From 951474c7fcd1b28d3178a6644d58958cb3bdf5a8 Mon Sep 17 00:00:00 2001
From: Yannick Heneault <yheneaul@matrox.com>
Date: Wed, 25 Aug 2010 15:16:27 +0000
Subject: modified G200SE conditionnal statement about revision register for products compatibility.

---
diff --git a/src/mga_driver.c b/src/mga_driver.c
index 5a1e9b4..83649ee 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -1081,7 +1081,7 @@ MGACountRam(ScrnInfoPtr pScrn)
 
 	if (pMga->is_G200SE)
 	    pMga->reg_1e24 = INREG(0x1e24); /* stash the model for later */
-	if (pMga->reg_1e24 == 0x01) {
+	if (pMga->reg_1e24 >= 0x01) {
 	    MGAUnmapMem(pScrn);
 	    ProbeSize = 16384;
 	    ProbeSizeOffset = 0x10000;
@@ -3253,7 +3253,7 @@ MGA_HAL(
     MGA_NOT_HAL(
 	if (pMga->is_G200SE) {
             OUTREG8(0x1FDE, 0x06);
-	    if (pMga->reg_1e24 == 0x01)
+	    if (pMga->reg_1e24 >= 0x01)
 		OUTREG8(0x1FDF, 0x03);
 	    else 
 		OUTREG8(0x1FDF, 0x14);
@@ -4326,7 +4326,7 @@ MGAValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
 	    return MODE_VIRTUAL_X;
 	if (mode->VDisplay > 1200)
 	    return MODE_VIRTUAL_Y;
-	if (pMga->reg_1e24 == 0x01 &&
+	if (pMga->reg_1e24 >= 0x01 &&
 	    xf86ModeBandwidth(mode, pScrn->bitsPerPixel) > 244)
 	    return MODE_BANDWIDTH;
     } else if (pMga->is_G200WB){
--
cgit v0.9.0.2-2-gbebe
From 0bd44fad450843b7f1c35c70ab356a2b250d107d Mon Sep 17 00:00:00 2001
From: Jesse Adkins <jesserayadkins@gmail.com>
Date: Tue, 28 Sep 2010 20:29:51 +0000
Subject: Purge cvs tags.

Signed-off-by: Jesse Adkins <jesserayadkins@gmail.com>
Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
---
diff --git a/man/mga.man b/man/mga.man
index 3a7a9f8..e1e674f 100644
--- a/man/mga.man
+++ b/man/mga.man
@@ -1,4 +1,3 @@
-.\" $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/mga.man,v 1.7 2003/04/03 07:11:03 herrb Exp $ 
 .\" shorthand for double quote that works everywhere.
 .ds q \N'34'
 .TH mga __drivermansuffix__ __vendorversion__
diff --git a/src/binding.h b/src/binding.h
index 6dcd1e9..57e9b92 100644
--- a/src/binding.h
+++ b/src/binding.h
@@ -13,7 +13,6 @@
  @end
 
 ***************************************************************************************/
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/HALlib/binding.h,v 1.3 2000/10/24 22:45:08 dawes Exp $ */
 
 #ifndef _BINDING
 #define _BINDING
diff --git a/src/mga.h b/src/mga.h
index 2cb3d88..7725b56 100644
--- a/src/mga.h
+++ b/src/mga.h
@@ -1,4 +1,3 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/mga.h,v 1.87tsi Exp $ */
 /*
  * MGA Millennium (MGA2064W) functions
  *
diff --git a/src/mga_common.h b/src/mga_common.h
index 90f6b37..81be2bc 100644
--- a/src/mga_common.h
+++ b/src/mga_common.h
@@ -25,8 +25,6 @@
  * Converted to common header format:
  *   Jens Owen <jens@tungstengraphics.com>
  *
- * $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/mga_common.h,v 1.2 2002/12/16 16:19:18 dawes Exp $
- *
  */
 
 #ifndef _MGA_COMMON_H_
diff --git a/src/mga_dri.h b/src/mga_dri.h
index f1afb5d..1984b9c 100644
--- a/src/mga_dri.h
+++ b/src/mga_dri.h
@@ -1,5 +1,3 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/mga_dri.h,v 1.6 2001/04/10 16:08:01 dawes Exp $ */
-
 /*
  * Copyright 2000 VA Linux Systems Inc., Fremont, California.
  * All Rights Reserved.
diff --git a/src/mga_dripriv.h b/src/mga_dripriv.h
index 3ddd133..feca134 100644
--- a/src/mga_dripriv.h
+++ b/src/mga_dripriv.h
@@ -1,5 +1,3 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/mga_dripriv.h,v 1.4 2001/04/10 16:08:01 dawes Exp $ */
-
 /*
  * Copyright 2000 VA Linux Systems Inc., Fremont, California.
  * All Rights Reserved.
diff --git a/src/mga_driver.c b/src/mga_driver.c
index 83649ee..72e7acc 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -1,4 +1,3 @@
-/* $XConsortium: mga_driver.c /main/12 1996/10/28 05:13:26 kaleb $ */
 /*
  * MGA Millennium (MGA2064W) with Ti3026 RAMDAC driver v.1.1
  *
diff --git a/src/mga_macros.h b/src/mga_macros.h
index 69dc8e3..bffd063 100644
--- a/src/mga_macros.h
+++ b/src/mga_macros.h
@@ -1,5 +1,3 @@
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/mga_macros.h,v 1.21 2001/09/26 12:59:17 alanh Exp $ */
-
 #ifndef _MGA_MACROS_H_
 #define _MGA_MACROS_H_
 
diff --git a/src/mga_reg.h b/src/mga_reg.h
index 6251976..ffe4723 100644
--- a/src/mga_reg.h
+++ b/src/mga_reg.h
@@ -1,11 +1,3 @@
-/* $XConsortium: mgareg.h /main/2 1996/10/25 10:33:21 kaleb $ */
-
-
-
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/mga_reg.h,v 1.18 2001/09/26 12:59:18 alanh Exp $ */
-
-
-
 /*
  * MGA Millennium (MGA2064W) functions
  * MGA Mystique (MGA1064SG) functions
diff --git a/src/mga_sarea.h b/src/mga_sarea.h
index c5ffbbc..16fc9ce 100644
--- a/src/mga_sarea.h
+++ b/src/mga_sarea.h
@@ -1,5 +1,3 @@
-/* $XFree86$ */
-
 /*
  * Copyright 2000 Gareth Hughes
  * All Rights Reserved.
diff --git a/src/mgareg_flags.h b/src/mgareg_flags.h
index 69050fc..548af86 100644
--- a/src/mgareg_flags.h
+++ b/src/mgareg_flags.h
@@ -19,7 +19,6 @@
  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE 
  * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  */
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/mgareg_flags.h,v 1.2 2003/01/12 03:55:47 tsi Exp $ */
 
 #ifndef _MGAREGS_H_
 #define _MGAREGS_H_
diff --git a/util/stormdwg.c b/util/stormdwg.c
index 99f76cc..b43cc32 100644
--- a/util/stormdwg.c
+++ b/util/stormdwg.c
@@ -1,8 +1,3 @@
-/* $XConsortium: dwg.c /main/2 1996/10/28 06:57:55 kaleb $ */
-
-
-
-/* $XFree86: xc/programs/Xserver/hw/xfree86/drivers/mga/util/stormdwg.c,v 1.1 1997/04/12 14:11:29 hohndel Exp $ */
 
 #include <stdio.h>
 #include <stdlib.h>
--
cgit v0.9.0.2-2-gbebe
From 636c3c88e7e9cb30010fe1731cd7356849f3f172 Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Thu, 14 Oct 2010 18:36:06 +0000
Subject: Don't allow the config file to override BIOS location

Signed-off-by: Adam Jackson <ajax@redhat.com>
---
diff --git a/src/mga_driver.c b/src/mga_driver.c
index 72e7acc..37bf847 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -1779,23 +1779,16 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 #ifndef XSERVER_LIBPCIACCESS
     /*
      * Find the BIOS base.  Get it from the PCI config if possible.  Otherwise
-     * use the VGA default.  Allow the config file to override this.
+     * use the VGA default.
      */
 
-    pMga->BiosFrom = X_NONE;
-    if (pMga->device->BiosBase != 0) {
-	/* XXX This isn't used */
-	pMga->BiosAddress = pMga->device->BiosBase;
-	pMga->BiosFrom = X_CONFIG;
-    } else {
-	/* details: rombase sdk pp 4-15 */
-	if (pMga->PciInfo->biosBase != 0) {
-	    pMga->BiosAddress = pMga->PciInfo->biosBase & 0xffff0000;
-	    pMga->BiosFrom = X_PROBED;
-	} else if (pMga->Primary) {
-	    pMga->BiosAddress = 0xc0000;
-	    pMga->BiosFrom = X_DEFAULT;
-	}
+    /* details: rombase sdk pp 4-15 */
+    if (pMga->PciInfo->biosBase != 0) {
+	pMga->BiosAddress = pMga->PciInfo->biosBase & 0xffff0000;
+	pMga->BiosFrom = X_PROBED;
+    } else if (pMga->Primary) {
+	pMga->BiosAddress = 0xc0000;
+	pMga->BiosFrom = X_DEFAULT;
     }
     if (pMga->BiosAddress) {
 	xf86DrvMsg(pScrn->scrnIndex, pMga->BiosFrom, "BIOS at 0x%lX\n",
--
cgit v0.9.0.2-2-gbebe
From f7a2ef60e18e2cc464f69c1cad4681096c645651 Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Sat, 30 Oct 2010 16:38:31 +0000
Subject: Sun's copyrights now belong to Oracle

Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
---
diff --git a/man/Makefile.am b/man/Makefile.am
index b3688ce..1ea26b3 100644
--- a/man/Makefile.am
+++ b/man/Makefile.am
@@ -1,5 +1,5 @@
 #
-# Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
+# Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
 #
 # Permission is hereby granted, free of charge, to any person obtaining a
 # copy of this software and associated documentation files (the "Software"),
@@ -19,7 +19,7 @@
 # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 # DEALINGS IN THE SOFTWARE.
-# 
+#
 
 drivermandir = $(DRIVER_MAN_DIR)
 
--
cgit v0.9.0.2-2-gbebe
From 5f1b04e86e79938c8158055a777280a649f95510 Mon Sep 17 00:00:00 2001
From: Yannick Heneault <yheneaul@matrox.com>
Date: Fri, 17 Dec 2010 14:00:46 +0000
Subject: added support for G200ER.

---
diff --git a/src/mga.h b/src/mga.h
index 7725b56..c520e86 100644
--- a/src/mga.h
+++ b/src/mga.h
@@ -136,6 +136,10 @@ void MGAdbg_outreg32(ScrnInfoPtr, int,int, char*);
 #define PCI_CHIP_MGAG200_EH_PCI 0x0533
 #endif
 
+#ifndef PCI_CHIP_MGAG200_ER_PCI
+#define PCI_CHIP_MGAG200_ER_PCI 0x0534
+#endif
+
 /*
  * Read/write to the DAC via MMIO 
  */
@@ -199,7 +203,9 @@ void MGAdbg_outreg32(ScrnInfoPtr, int,int, char*);
 typedef struct {
     unsigned char	ExtVga[6];
     unsigned char 	DacClk[6];
-    unsigned char *     DacRegs;
+    unsigned char	ExtVga_Index24;
+    unsigned char	Dac_Index90;
+    unsigned char * DacRegs;
     unsigned long	crtc2[0x58];
     unsigned char	dac2[0x21];
     CARD32		Option;
@@ -478,6 +484,7 @@ typedef struct {
     int is_G200WB:1;
     int is_G200EV:1;
     int is_G200EH:1;
+    int is_G200ER:1;
 
     int KVM;
 
diff --git a/src/mga_dacG.c b/src/mga_dacG.c
index df00765..fca1031 100644
--- a/src/mga_dacG.c
+++ b/src/mga_dacG.c
@@ -444,6 +444,116 @@ MGAG200WBPIXPLLSET(ScrnInfoPtr pScrn, MGARegPtr mgaReg)
     outMGAdac(MGA1064_REMHEADCTL, ucTempByte);
 }
 
+#define G200ER_PLLREF 48000
+#define G200ER_VCOMIN 1056000
+#define G200ER_VCOMAX 1488000
+
+static void MGAG200ERComputePLLParam(ScrnInfoPtr pScrn, long lFo, int *piM, int *piN, int *piP)
+{
+
+    int  ulM;
+    int  ulN;
+    int  ulO;
+    int  ulR;
+
+    CARD32 ulComputedFo;
+    CARD32 ulVco;
+    CARD32 ulFDelta;
+    CARD32 ulFTmpDelta;
+
+    CARD32 aulMDivValue[] = {1, 2, 4, 8};
+
+    CARD32 ulFo   = lFo;
+
+    ulFDelta = 0xFFFFFFFF;
+
+    for (ulR = 0; ulR < 4;  ulR++)
+    {
+    	if(ulFDelta==0) break;
+        for (ulN = 5; (ulN <= 128) ; ulN++)
+        {
+            if(ulFDelta==0) break;
+            for (ulM = 3; ulM >= 0; ulM--)
+            {
+            	if(ulFDelta==0) break;
+                for (ulO = 5; ulO <= 32; ulO++)
+                {
+                	ulVco = (G200ER_PLLREF * (ulN+1)) / (ulR+1);
+                	// Validate vco
+                    if (ulVco < G200ER_VCOMIN) continue;
+					if (ulVco > G200ER_VCOMAX) continue;
+                	ulComputedFo = ulVco / (aulMDivValue[ulM] * (ulO+1));
+
+                    if (ulComputedFo > ulFo)
+                    {
+                        ulFTmpDelta = ulComputedFo - ulFo;
+                    }
+                    else
+                    {
+                        ulFTmpDelta = ulFo - ulComputedFo;
+                    }
+
+                    if (ulFTmpDelta < ulFDelta)
+                    {
+                        ulFDelta = ulFTmpDelta;
+                        // XG200ERPIXPLLCM M<1:0> O<7:3>
+                        *piM = (CARD8)ulM | (CARD8)(ulO<<3);
+                        //
+                        // XG200ERPIXPLLCN N<6:0>
+                        *piN = (CARD8)ulN;
+                        //
+                        // XG200ERPIXPLLCP R<1:0> cg<7:4> (Use R value)
+                        *piP = (CARD8)ulR | (CARD8)(ulR<<3);
+
+                        // Test
+                        int ftest = (G200ER_PLLREF * (ulN+1)) / ((ulR+1) * aulMDivValue[ulM] * (ulO+1));
+                        ftest=ftest;
+                    }
+                } // End O Loop
+            } // End M Loop
+        } // End N Loop
+    } // End R Loop
+}
+
+static void
+MGAG200ERPIXPLLSET(ScrnInfoPtr pScrn, MGARegPtr mgaReg)
+{
+    //TODO  G200ER Validate sequence 
+    CARD8 ucPixCtrl, ucTempByte;
+    MGAPtr pMga = MGAPTR(pScrn);
+
+
+    // Set pixclkdis to 1
+    ucPixCtrl = inMGAdac(MGA1064_PIX_CLK_CTL);
+    ucPixCtrl |= MGA1064_PIX_CLK_CTL_CLK_DIS;
+    outMGAdac(MGA1064_PIX_CLK_CTL, ucPixCtrl);
+
+    ucTempByte = inMGAdac(MGA1064_REMHEADCTL);
+    ucTempByte |= MGA1064_REMHEADCTL_CLKDIS;
+    outMGAdac(MGA1064_REMHEADCTL, ucTempByte);
+
+    // Select PLL Set C
+    ucTempByte = INREG8(MGAREG_MEM_MISC_READ);
+    ucTempByte |= (0x3<<2) | 0xc0; //select MGA pixel clock
+    OUTREG8(MGAREG_MEM_MISC_WRITE, ucTempByte);
+
+    ucPixCtrl &= ~MGA1064_PIX_CLK_CTL_CLK_DIS;
+    ucPixCtrl |= MGA1064_PIX_CLK_CTL_CLK_POW_DOWN;
+    outMGAdac(MGA1064_PIX_CLK_CTL, ucPixCtrl);
+
+    // Wait 500 us
+    usleep(500);
+
+    // Program the Pixel PLL Register
+    outMGAdac(MGA1064_ER_PIX_PLLC_N, mgaReg->PllN);
+    outMGAdac(MGA1064_ER_PIX_PLLC_M, mgaReg->PllM);
+    outMGAdac(MGA1064_ER_PIX_PLLC_P, mgaReg->PllP);
+
+        // Wait 50 us
+    usleep(50);
+
+}
+
 static void
 MGAG200WBPrepareForModeSwitch(ScrnInfoPtr pScrn)
 {
@@ -768,8 +878,13 @@ MGAGSetPCLK( ScrnInfoPtr pScrn, long f_out )
 
 	    pReg->PllM = m;
 	    pReg->PllN = n;
-	    pReg->PllP = p;
-        } else {
+	    pReg->PllP = p;		
+	} else if (pMga->is_G200ER) {
+	    MGAG200ERComputePLLParam(pScrn, f_out, &m, &n, &p);
+	    pReg->PllM = m;
+	    pReg->PllN = n;
+	    pReg->PllP = p;		
+    } else {
 	    /* Do the calculations for m, n, p and s */
 	    MGAGCalcClock( pScrn, f_out, &m, &n, &p, &s );
 
@@ -966,6 +1081,10 @@ MGAGInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
                 pReg->Option2 = 0x0000b000;
                 break;
 
+		case PCI_CHIP_MGAG200_ER_PCI:
+			pReg->Dac_Index90 = 0;
+			break;
+
         case PCI_CHIP_MGAG200_EH_PCI:
                 pReg->DacRegs[MGA1064_MISC_CTL] =
                     MGA1064_MISC_CTL_VGA8 |
@@ -1088,6 +1207,7 @@ MGAGInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
         if (pMga->is_G200WB){
             pReg->ExtVga[1] |= 0x88;
         }
+	pReg->ExtVga_Index24 = 0x05;
 		
 	pVga->CRTC[0]	= ht - 4;
 	pVga->CRTC[1]	= hd;
@@ -1327,10 +1447,15 @@ MGA_NOT_HAL(
 	      if ( (pMga->is_G200EV || pMga->is_G200WB || pMga->is_G200EH) &&
 		   (i >= 0x44) && (i <= 0x4E))
 	         continue;
-
+			 
 	      outMGAdac(i, mgaReg->DacRegs[i]);
 	   }
 	   
+		if (pMga->is_G200ER)
+        {
+			outMGAdac(0x90, mgaReg->Dac_Index90);
+        }
+   
 	   if (!MGAISGx50(pMga)) {
 	       /* restore pci_option register */
 #ifdef XSERVER_LIBPCIACCESS
@@ -1361,7 +1486,9 @@ MGA_NOT_HAL(
 #endif
 	   }
 
-           if (pMga->is_G200EV) {
+           if (pMga->is_G200ER) {
+               MGAG200ERPIXPLLSET(pScrn, mgaReg);               
+           } else  if (pMga->is_G200EV) {
                MGAG200EVPIXPLLSET(pScrn, mgaReg);
            } else if (pMga->is_G200WB) {
                MGAG200WBPIXPLLSET(pScrn, mgaReg);
@@ -1388,6 +1515,11 @@ MGA_NOT_HAL(
            for (i = 0; i < 6; i++)
 	      OUTREG16(MGAREG_CRTCEXT_INDEX, (mgaReg->ExtVga[i] << 8) | i);
 
+           if (pMga->is_G200ER) {
+               OUTREG8(MGAREG_CRTCEXT_INDEX, 0x24);
+               OUTREG8(MGAREG_CRTCEXT_DATA,  mgaReg->ExtVga_Index24);			   
+           }
+
 	   /* This handles restoring the generic VGA registers. */
 	   if (pMga->is_G200SE) {
  	      MGAG200SERestoreMode(pScrn, vgaReg);
@@ -1404,7 +1536,7 @@ MGA_NOT_HAL(
                OUTREG16(MGAREG_CRTCEXT_INDEX, 6);
                OUTREG16(MGAREG_CRTCEXT_DATA, 0);
            }
-
+		   
 	   /*
 	    * this is needed to properly restore start address
 	    */
@@ -1555,6 +1687,11 @@ MGAGSave(ScrnInfoPtr pScrn, vgaRegPtr vgaReg, MGARegPtr mgaReg,
             mgaReg->PllM = inMGAdac(MGA1064_EH_PIX_PLLC_M);
             mgaReg->PllN = inMGAdac(MGA1064_EH_PIX_PLLC_N);
             mgaReg->PllP = inMGAdac(MGA1064_EH_PIX_PLLC_P);
+        } else if (pMga->is_G200ER) {
+            mgaReg->PllM = inMGAdac(MGA1064_ER_PIX_PLLC_M);
+            mgaReg->PllN = inMGAdac(MGA1064_ER_PIX_PLLC_N);
+            mgaReg->PllP = inMGAdac(MGA1064_ER_PIX_PLLC_P);
+            mgaReg->Dac_Index90 = inMGAdac(0x90);
         }
 
         mgaReg->PIXPLLCSaved = TRUE;
@@ -1583,6 +1720,11 @@ MGAGSave(ScrnInfoPtr pScrn, vgaRegPtr vgaReg, MGARegPtr mgaReg,
 		OUTREG8(MGAREG_CRTCEXT_INDEX, i);
 		mgaReg->ExtVga[i] = INREG8(MGAREG_CRTCEXT_DATA);
 	}
+	if (pMga->is_G200ER)
+	{
+		OUTREG8(MGAREG_CRTCEXT_INDEX, 0x24);
+		mgaReg->ExtVga_Index24 = INREG8(MGAREG_CRTCEXT_DATA);
+	}
 
 #ifdef DEBUG		
 	ErrorF("Saved values:\nDAC:");
@@ -1737,7 +1879,7 @@ static const struct mgag_i2c_private {
     { (1 << 0), (1 << 2) },
     { (1 << 4), (1 << 5) },
     { (1 << 0), (1 << 1) },  /* G200SE, G200EV and G200WB I2C bits */
-    { (1 << 1), (1 << 0) },  /* G200EH I2C bits */
+    { (1 << 1), (1 << 0) },  /* G200EH, G200ER I2C bits */
 };
 
 
@@ -1750,7 +1892,7 @@ MGAG_ddc1Read(ScrnInfoPtr pScrn)
 
   if (pMga->is_G200SE || pMga->is_G200WB || pMga->is_G200EV)
     i2c_index = 3;
-  else if (pMga->is_G200EH)
+  else if (pMga->is_G200EH || pMga->is_G200ER)
     i2c_index = 4;
   else
     i2c_index = 0;
@@ -1851,7 +1993,7 @@ MGAG_i2cInit(ScrnInfoPtr pScrn)
 
         if (pMga->is_G200SE || pMga->is_G200WB || pMga->is_G200EV)
             i2c_index = 3;
-        else if (pMga->is_G200EH)
+        else if (pMga->is_G200EH || pMga->is_G200ER)
             i2c_index = 4;
         else
             i2c_index = 0;
@@ -1976,7 +2118,7 @@ void MGAGSetupFuncs(ScrnInfoPtr pScrn)
     pMga->Save = MGAGSave;
     pMga->Restore = MGAGRestore;
     pMga->ModeInit = MGAGInit;
-    if (!pMga->is_G200WB){
+    if ((!pMga->is_G200WB) && (!pMga->is_G200ER)) {
         pMga->ddc1Read = MGAG_ddc1Read;
         /* vgaHWddc1SetSpeed will only work if the card is in VGA mode */
         pMga->DDC1SetSpeed = vgaHWddc1SetSpeedWeak();
diff --git a/src/mga_driver.c b/src/mga_driver.c
index 37bf847..7232c73 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -403,6 +403,21 @@ static const struct mga_device_attributes attribs[] = {
 	8192, 0x4000,          /* Memory probe size & offset values */
     },
 
+    /* G200ER */
+    [15] = { 0, 1, 0, 0, 1, 0, 0, 0, new_BARs,
+            (TRANSC_SOLID_FILL | TWO_PASS_COLOR_EXPAND | USE_LINEAR_EXPANSION),
+	{
+	    { 50000, 230000 }, /* System VCO frequencies */
+	    { 50000, 203400 }, /* Pixel VCO frequencies */
+	    { 0, 0 },          /* Video VCO frequencies */
+	    45000,            /* Memory clock */
+	    27050,             /* PLL reference frequency */
+	    0,                 /* Supports fast bitblt? */
+	    MGA_HOST_PCI       /* Host interface */
+	},
+
+	16384, 0x4000,          /* Memory probe size & offset values */
+    }
 };
 
 #ifdef XSERVER_LIBPCIACCESS
@@ -432,6 +447,8 @@ static const struct pci_id_match mga_device_match[] = {
 
     MGA_DEVICE_MATCH( PCI_CHIP_MGAG200_EH_PCI, 14 ),
 
+	MGA_DEVICE_MATCH(PCI_CHIP_MGAG200_ER_PCI, 15 ),
+
     { 0, 0, 0 },
 };
 #endif
@@ -449,6 +466,7 @@ static SymTabRec MGAChipsets[] = {
     { PCI_CHIP_MGAG200_SE_A_PCI,	"mgag200 SE A PCI" },
     { PCI_CHIP_MGAG200_SE_B_PCI,	"mgag200 SE B PCI" },
     { PCI_CHIP_MGAG200_EV_PCI,	"mgag200 EV Maxim" },
+    { PCI_CHIP_MGAG200_ER_PCI,	"mgag200 ER SH7757" },	
     { PCI_CHIP_MGAG200_WINBOND_PCI,	"mgag200 eW Nuvoton" },
     { PCI_CHIP_MGAG200_EH_PCI,	"mgag200eH" },
     { PCI_CHIP_MGAG400,		"mgag400" },
@@ -471,6 +489,8 @@ static PciChipsets MGAPciChipsets[] = {
 	RES_SHARED_VGA },
     { PCI_CHIP_MGAG200_EV_PCI, PCI_CHIP_MGAG200_EV_PCI,
 	RES_SHARED_VGA },
+    { PCI_CHIP_MGAG200_ER_PCI, PCI_CHIP_MGAG200_ER_PCI,
+	RES_SHARED_VGA },
     { PCI_CHIP_MGAG200_WINBOND_PCI, PCI_CHIP_MGAG200_WINBOND_PCI,
 	RES_SHARED_VGA },
     { PCI_CHIP_MGAG200_EH_PCI, PCI_CHIP_MGAG200_EH_PCI,
@@ -912,6 +932,11 @@ MGAProbe(DriverPtr drv, int flags)
             case PCI_CHIP_MGAG200_EH_PCI:
                 attrib_no = 14;
                 break;
+				
+            case PCI_CHIP_MGAG200_ER_PCI:
+                attrib_no = 15;
+                break;
+				
 
 	    default:
 		return FALSE;
@@ -1285,6 +1310,11 @@ MGAdoDDC(ScrnInfoPtr pScrn)
     MGASave(pScrn);
 
     /* It is now safe to talk to the card */
+    /* Allow access to DDC */
+    if (pMga->is_G200ER) {
+	 CARD8 ucData = inMGAdac(MGA1064_GEN_IO_CTL2);
+     outMGAdac(MGA1064_GEN_IO_CTL2, ucData | 1);        
+    }
 
     /* Initialize I2C buses - used by DDC if available */
     if (pMga->i2cInit) {
@@ -1326,6 +1356,12 @@ MGAdoDDC(ScrnInfoPtr pScrn)
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO, "end of monitor info\n");
     }
 
+    /* Remove access to DDC */
+    if (pMga->is_G200ER) {
+	  CARD8 ucData = inMGAdac(MGA1064_GEN_IO_CTL2);
+      outMGAdac(MGA1064_GEN_IO_CTL2, ucData & ~1);        
+    }
+
     /* Restore previous state and unmap MGA memory and MMIO areas */
     MGARestore(pScrn);
     MGAUnmapMem(pScrn);
@@ -1619,6 +1655,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
     pMga->is_G200EV = (pMga->Chipset == PCI_CHIP_MGAG200_EV_PCI);
     pMga->is_G200WB = (pMga->Chipset == PCI_CHIP_MGAG200_WINBOND_PCI);
     pMga->is_G200EH = (pMga->Chipset == PCI_CHIP_MGAG200_EH_PCI);
+    pMga->is_G200ER = (pMga->Chipset == PCI_CHIP_MGAG200_ER_PCI);
 
 #ifdef USEMGAHAL
     if (pMga->chip_attribs->HAL_chipset) {
@@ -1782,14 +1819,14 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
      * use the VGA default.
      */
 
-    /* details: rombase sdk pp 4-15 */
-    if (pMga->PciInfo->biosBase != 0) {
-	pMga->BiosAddress = pMga->PciInfo->biosBase & 0xffff0000;
-	pMga->BiosFrom = X_PROBED;
-    } else if (pMga->Primary) {
-	pMga->BiosAddress = 0xc0000;
-	pMga->BiosFrom = X_DEFAULT;
-    }
+	/* details: rombase sdk pp 4-15 */
+	if (pMga->PciInfo->biosBase != 0) {
+	    pMga->BiosAddress = pMga->PciInfo->biosBase & 0xffff0000;
+	    pMga->BiosFrom = X_PROBED;
+	} else if (pMga->Primary) {
+	    pMga->BiosAddress = 0xc0000;
+	    pMga->BiosFrom = X_DEFAULT;
+	}
     if (pMga->BiosAddress) {
 	xf86DrvMsg(pScrn->scrnIndex, pMga->BiosFrom, "BIOS at 0x%lX\n",
 		   (unsigned long)pMga->BiosAddress);
@@ -2134,6 +2171,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
     case PCI_CHIP_MGAG200_WINBOND_PCI:
     case PCI_CHIP_MGAG200_EV_PCI:
     case PCI_CHIP_MGAG200_EH_PCI:
+    case PCI_CHIP_MGAG200_ER_PCI:	
     case PCI_CHIP_MGAG400:
     case PCI_CHIP_MGAG550:
 	MGAGSetupFuncs(pScrn);
@@ -2247,6 +2285,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
           case PCI_CHIP_MGAG200_WINBOND_PCI:
 	  case PCI_CHIP_MGAG200_EV_PCI:
       case PCI_CHIP_MGAG200_EH_PCI:
+	  case PCI_CHIP_MGAG200_ER_PCI:	  
 	    pMga->SrcOrg = 0;
 	    pMga->DstOrg = 0;
 	    break;
@@ -2424,16 +2463,17 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 	   maxPitch = 2048;
 	   break;
 	case PCI_CHIP_MGAG200_SE_A_PCI:
-	   if (pScrn->videoRam < 2048){
+           if (pScrn->videoRam < 2048){
                maxPitch = 1280;
-	   }
-	   break;
+           }
+           break;
 	case PCI_CHIP_MGAG200:
 	case PCI_CHIP_MGAG200_PCI:
 	case PCI_CHIP_MGAG200_SE_B_PCI:
         case PCI_CHIP_MGAG200_WINBOND_PCI:
 	case PCI_CHIP_MGAG200_EV_PCI:
     case PCI_CHIP_MGAG200_EH_PCI:
+	case PCI_CHIP_MGAG200_ER_PCI:	
 	case PCI_CHIP_MGAG400:
 	case PCI_CHIP_MGAG550:
 	   maxPitch = 4096;
@@ -4332,10 +4372,13 @@ MGAValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
 	    return MODE_BANDWIDTH;
     } else if (pMga->is_G200EV
 	       && (xf86ModeBandwidth(mode, pScrn->bitsPerPixel) > 327)) {
-        return MODE_BANDWIDTH;
+	return MODE_BANDWIDTH;
     } else if (pMga->is_G200EH
                && (xf86ModeBandwidth(mode, pScrn->bitsPerPixel) > 375)) {
         return MODE_BANDWIDTH;
+    } else if (pMga->is_G200ER
+               && (xf86ModeBandwidth(mode, pScrn->bitsPerPixel) > 550)) {
+        return MODE_BANDWIDTH;
     }
 
     lace = 1 + ((mode->Flags & V_INTERLACE) != 0);
diff --git a/src/mga_merge.c b/src/mga_merge.c
index 753f752..1fd0572 100644
--- a/src/mga_merge.c
+++ b/src/mga_merge.c
@@ -363,6 +363,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
     case PCI_CHIP_MGAG200_WINBOND_PCI:
     case PCI_CHIP_MGAG200_EV_PCI:
     case PCI_CHIP_MGAG200_EH_PCI:
+	case PCI_CHIP_MGAG200_ER_PCI:
     case PCI_CHIP_MGAG400:
     case PCI_CHIP_MGAG550:
 	MGAGSetupFuncs(pScrn);
@@ -518,6 +519,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
         case PCI_CHIP_MGAG200_WINBOND_PCI:
         case PCI_CHIP_MGAG200_EV_PCI:
         case PCI_CHIP_MGAG200_EH_PCI:
+	case PCI_CHIP_MGAG200_ER_PCI:		
 	case PCI_CHIP_MGAG400:
 	case PCI_CHIP_MGAG550:
 	   maxPitch = 4096;
diff --git a/src/mga_reg.h b/src/mga_reg.h
index ffe4723..5a37db6 100644
--- a/src/mga_reg.h
+++ b/src/mga_reg.h
@@ -369,6 +369,7 @@
 #define MGA1064_MISC_CTL_VGA8   		( 0x01 << 3 )
 #define MGA1064_MISC_CTL_DAC_RAM_CS   		( 0x01 << 4 )
 
+#define MGA1064_GEN_IO_CTL2	0x29
 #define MGA1064_GEN_IO_CTL	0x2a
 #define MGA1064_GEN_IO_DATA	0x2b
 #define MGA1064_SYS_PLL_M	0x2c
@@ -429,6 +430,10 @@
 #define MGA1064_EH_PIX_PLLC_N   0xb7
 #define MGA1064_EH_PIX_PLLC_P   0xb8
 
+/* Modified PLL for G200 Maxim (G200ER) */
+#define MGA1064_ER_PIX_PLLC_M	0xb7
+#define MGA1064_ER_PIX_PLLC_N	0xb6
+#define MGA1064_ER_PIX_PLLC_P	0xb8
 
 #define MGA1064_DISP_CTL        0x8a
 #define MGA1064_DISP_CTL_DAC1OUTSEL_MASK       0x01
diff --git a/src/mga_storm.c b/src/mga_storm.c
index 87473c8..db7fae7 100644
--- a/src/mga_storm.c
+++ b/src/mga_storm.c
@@ -1131,6 +1131,7 @@ void MGAStormEngineInit( ScrnInfoPtr pScrn )
     case PCI_CHIP_MGAG200_WINBOND_PCI:
     case PCI_CHIP_MGAG200_EV_PCI:
     case PCI_CHIP_MGAG200_EH_PCI:
+    case PCI_CHIP_MGAG200_ER_PCI:	
 	pMga->SrcOrg = 0;
 	OUTREG(MGAREG_SRCORG, pMga->realSrcOrg);
 	OUTREG(MGAREG_DSTORG, pMga->DstOrg);
--
cgit v0.9.0.2-2-gbebe
From 43280e6521815582f219d42821d896093c9c0d5f Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Wed, 22 Jun 2011 21:02:29 +0000
Subject: Don't include xf86Priv.h

Signed-off-by: Adam Jackson <ajax@redhat.com>
---
diff --git a/src/mga_dri.c b/src/mga_dri.c
index 3fda623..14f342f 100644
--- a/src/mga_dri.c
+++ b/src/mga_dri.c
@@ -32,7 +32,6 @@
 
 #include "xf86.h"
 #include "xf86_OSproc.h"
-#include "xf86Priv.h"
 
 #include "xf86PciInfo.h"
 #include "xf86Pci.h"
--
cgit v0.9.0.2-2-gbebe
From c083bf0a66bef9a4345847f39be5fb895c211f79 Mon Sep 17 00:00:00 2001
From: Christian Toutant <ctoutant@matrox.com>
Date: Wed, 03 Aug 2011 13:45:13 +0000
Subject: Added support for G200SE Pilot3

Optimize use of bandwidth and increase maximum resolution to 1920x1200

Signed-off-by: Christian Toutant <ctoutant@matrox.com>
---
diff --git a/src/mga_driver.c b/src/mga_driver.c
index 7232c73..b140013 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -3282,15 +3282,71 @@ MGA_HAL(
 	    outb(0xfac, 0x02);
     }
 
-    MGA_NOT_HAL(
-	if (pMga->is_G200SE) {
+    /* 
+     This function optimize the Priority Request control
+     Higher HiPriLvl will reduce drawing performance
+     We need to give enough bandwith to crtc to avoid visual artifact
+    */
+	if (pMga->is_G200SE) 
+    {
+        if (pMga->reg_1e24 >= 0x02)
+        {
+            /* Calulate CRTC Priority value */
+            CARD8  ucHiPriLvl;
+            CARD32 ulBitsPerPixel;
+            CARD32 ulMemoryBandwidth;
+
+            /* uiBitsPerPixel can only be 8,16 or32 */
+            if (pScrn->bitsPerPixel > 16)
+            {
+                ulBitsPerPixel = 32;
+            }
+            else if (pScrn->bitsPerPixel >  8) 
+            {
+                ulBitsPerPixel = 16;
+            }
+            else 
+            {
+                ulBitsPerPixel = 8;
+            }
+
+            
+            ulMemoryBandwidth = (mode->Clock * ulBitsPerPixel) / 1000;
+
+            if      (ulMemoryBandwidth    > 3100)  ucHiPriLvl = 0;
+            else if (ulMemoryBandwidth    > 2600)  ucHiPriLvl = 1;
+            else if (ulMemoryBandwidth    > 1900)  ucHiPriLvl = 2;
+            else if (ulMemoryBandwidth    > 1160)  ucHiPriLvl = 3;
+            else if (ulMemoryBandwidth    > 440)   ucHiPriLvl = 4;
+            else ucHiPriLvl = 5;
+
             OUTREG8(0x1FDE, 0x06);
-	    if (pMga->reg_1e24 >= 0x01)
-		OUTREG8(0x1FDF, 0x03);
-	    else 
-		OUTREG8(0x1FDF, 0x14);
+		    OUTREG8(0x1FDF, ucHiPriLvl);
+
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clock           == %d\n",   mode->Clock);
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "BitsPerPixel    == %d\n",   pScrn->bitsPerPixel);
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "MemoryBandwidth == %d\n",   ulMemoryBandwidth);
+            xf86DrvMsg(pScrn->scrnIndex, X_INFO, "HiPriLvl        == %02X\n", ucHiPriLvl);
         }
-    );
+        else
+        {
+            MGA_NOT_HAL(
+                xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Clock           == %d\n",   mode->Clock);
+                xf86DrvMsg(pScrn->scrnIndex, X_INFO, "BitsPerPixel    == %d\n",   pScrn->bitsPerPixel);
+                OUTREG8(0x1FDE, 0x06);
+	            if (pMga->reg_1e24 >= 0x01)
+                {
+		            OUTREG8(0x1FDF, 0x03);
+                    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "HiPriLvl        == 03\n");
+                }
+	            else 
+                {
+		            OUTREG8(0x1FDF, 0x14);
+                    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "HiPriLvl        == 14h\n");
+                }
+            );
+        }
+    }
 
     pMga->CurrentLayout.mode = mode;
 
@@ -4354,13 +4410,23 @@ MGAValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
     MGAPtr pMga = MGAPTR(pScrn);
 
     if (pMga->Chipset == PCI_CHIP_MGAG200_SE_A_PCI) {
-	if (mode->HDisplay > 1600)
-	    return MODE_VIRTUAL_X;
-	if (mode->VDisplay > 1200)
-	    return MODE_VIRTUAL_Y;
-	if (pMga->reg_1e24 >= 0x01 &&
-	    xf86ModeBandwidth(mode, pScrn->bitsPerPixel) > 244)
-	    return MODE_BANDWIDTH;
+    	if (pMga->reg_1e24 == 0x01) {
+	        if (mode->HDisplay > 1600)
+	            return MODE_VIRTUAL_X;
+	        if (mode->VDisplay > 1200)
+	            return MODE_VIRTUAL_Y;
+	        if (xf86ModeBandwidth(mode, pScrn->bitsPerPixel) > 244)
+	            return MODE_BANDWIDTH;
+        } else {
+            if (pMga->reg_1e24 >= 0x02) {
+	            if (mode->HDisplay > 1920)
+	                return MODE_VIRTUAL_X;
+	            if (mode->VDisplay > 1200)
+	                return MODE_VIRTUAL_Y;
+	            if (xf86ModeBandwidth(mode, pScrn->bitsPerPixel) > 301)
+	                return MODE_BANDWIDTH;
+            }
+        }
     } else if (pMga->is_G200WB){
         if (mode->Flags & V_DBLSCAN)
             return MODE_NO_DBLESCAN;
--
cgit v0.9.0.2-2-gbebe
From 01ca2186ea028b2549de509b51726aa08519fce0 Mon Sep 17 00:00:00 2001
From: Christian Toutant <ctoutant@matrox.com>
Date: Tue, 20 Sep 2011 17:07:16 +0000
Subject: Reset tagfifo for renesas.

For renesas, we need to reset tagfifo after a mode switch.

Signed-off-by: Christian Toutant <ctoutant@matrox.com>
---
diff --git a/src/mga_driver.c b/src/mga_driver.c
index b140013..58a1390 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -3282,6 +3282,28 @@ MGA_HAL(
 	    outb(0xfac, 0x02);
     }
 
+    /* Reset tagfifo*/ 
+	if (pMga->is_G200ER) 
+    {
+        CARD32 ulMemCtl = INREG(MGAREG_MEMCTL);
+        CARD8  ucSeq1;
+
+        xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Reset tagfifo\n");
+        /* Screen off */
+    	OUTREG8(MGAREG_SEQ_INDEX, 0x01);	/* Select SEQ1 */
+	    ucSeq1 = INREG8(MGAREG_SEQ_DATA) | 0x20;
+    	OUTREG8(MGAREG_SEQ_DATA, ucSeq1);
+
+        /* Reset tagfifo */
+        OUTREG(MGAREG_MEMCTL, ulMemCtl | 0x002000000);
+        usleep(1000); /* wait 1ms */
+        OUTREG(MGAREG_MEMCTL, ulMemCtl & ~0x002000000);
+
+        /* Screen on */
+    	OUTREG8(MGAREG_SEQ_DATA, ucSeq1 & ~0x20);
+
+    }
+
     /* 
      This function optimize the Priority Request control
      Higher HiPriLvl will reduce drawing performance
diff --git a/src/mga_reg.h b/src/mga_reg.h
index 5a37db6..ae0fe8c 100644
--- a/src/mga_reg.h
+++ b/src/mga_reg.h
@@ -119,6 +119,9 @@
 #define MGAREG_WACCEPTSEQ       0x1dd4
 #define MGAREG_WMISC            0x1e70
 
+
+#define MGAREG_MEMCTL           0x2E08
+
 /* OPMODE register additives */
 
 #define MGAOPM_DMA_GENERAL	(0x00 << 2)
--
cgit v0.9.0.2-2-gbebe
From ae90c47503bc1015a50e7ea6d22ec10e5e0d4113 Mon Sep 17 00:00:00 2001
From: Jamey Sharp <jamey@minilop.net>
Date: Tue, 13 Sep 2011 21:01:57 +0000
Subject: Nothing uses clientlx.c, so delete it.

Adam Jackson wrote:

	Hey, so, remember back in the dark ages when dualhead was this
	insanely wild differentiating feature?  Matrox thought it was so
	special, in fact, that they hid most of the implementation of it
	(and a bunch of other stuff) in a binary-only blob called the
	HALlib.  As you'd expect it was pretty much a cut-and-paste of
	the relevant Windows code, and then some open glue to keep it
	working; clientlx.c is that glue.

	I guess the theory was that if you don't tell people which
	registers to duplicate to implement a second pipe in their own
	hardware, they won't figure it out?  A pretty eyeroll-worthy
	idea even at the time, and definitely not something we should be
	condoning anymore.

	Kill it with fire ...

Signed-off-by: Jamey Sharp <jamey@minilop.net>
Reviewed-by: Jeremy Huddleston <jeremyhu@apple.com>
Reviewed-by: Adam Jackson <ajax@redhat.com>
---
diff --git a/src/Makefile.am b/src/Makefile.am
index 17211bb..44417de 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -32,7 +32,6 @@ mga_drv_la_LIBADD = $(noinst_LTLIBRARIES)
 mga_drv_la_SOURCES = \
          binding.h \
          client.h \
-         clientlx.c \
          mga_arc.c \
          mga_bios.c \
          mga_common.h \
diff --git a/src/binding.h b/src/binding.h
index 57e9b92..616aed7 100644
--- a/src/binding.h
+++ b/src/binding.h
@@ -37,37 +37,6 @@ typedef char            CHAR;
 typedef unsigned char   UCHAR;
 typedef unsigned char   FAR*LPUCHAR;
 
-typedef struct TAGCLIENTTABLE{
-    ULONG (DECL *ClientReadConfigSpaceByte       )(LPVOID , ULONG, LPVOID );        
-    ULONG (DECL *ClientReadConfigSpaceDword      )(LPVOID , ULONG, LPVOID );        
-    ULONG (DECL *ClientWriteConfigSpaceByte      )(LPVOID , ULONG, UCHAR);          
-    ULONG (DECL *ClientWriteConfigSpaceDword     )(LPVOID , ULONG, ULONG);          
-    ULONG (DECL *ClientOpenRegisterBase          )(LPVOID , ULONG, ULONG);          
-    ULONG (DECL *ClientCloseRegisterBase         )(LPVOID );                        
-    ULONG (DECL *ClientReadRegisterByte          )(LPVOID , ULONG, LPVOID );        
-    ULONG (DECL *ClientReadRegisterDword         )(LPVOID , ULONG, LPVOID );        
-    ULONG (DECL *ClientWriteRegisterByte         )(LPVOID , ULONG, UCHAR);          
-    ULONG (DECL *ClientWriteRegisterDword        )(LPVOID , ULONG, ULONG);          
-    ULONG (DECL *ClientOpenMemoryBase            )(LPVOID , ULONG, ULONG);          
-    ULONG (DECL *ClientCloseMemoryBase           )(LPVOID );                        
-    ULONG (DECL *ClientReadMemoryByte            )(LPVOID , ULONG, LPVOID );        
-    ULONG (DECL *ClientReadMemoryDword           )(LPVOID , ULONG, LPVOID );        
-    ULONG (DECL *ClientWriteMemoryByte           )(LPVOID , ULONG, UCHAR);          
-    ULONG (DECL *ClientWriteMemoryDword          )(LPVOID , ULONG, ULONG);          
-    ULONG (DECL *ClientOpenSystemDevice          )(LPVOID , ULONG, ULONG);          
-    ULONG (DECL *ClientCloseSystemDevice         )(LPVOID );                        
-    ULONG (DECL *ClientReadSystemDeviceByte      )(LPVOID , ULONG, LPVOID );        
-    ULONG (DECL *ClientReadSystemDeviceDword     )(LPVOID , ULONG, LPVOID );        
-    ULONG (DECL *ClientWriteSystemDeviceByte     )(LPVOID , ULONG, UCHAR);          
-    ULONG (DECL *ClientWriteSystemDeviceDword    )(LPVOID , ULONG, ULONG);          
-    ULONG (DECL *ClientWait                      )(LPVOID , ULONG);                 
-    ULONG (DECL *ClientGetBiosInfo               ) (LPVOID, LPVOID, LPVOID);        
-    ULONG (DECL *ClientReadDDCEdid               ) (LPVOID, LPVOID, ULONG);         
-#ifdef DEBUG
-    ULONG (DECL *ClientDebug                     ) (LPVOID, ULONG, LPVOID, ULONG, LPVOID);
-#endif
-} CLIENTTABLE, FAR *LPCLIENTTABLE;
-
 #endif /* _INTERNALBINDING */
 
 /***************************************************************************************************
diff --git a/src/client.h b/src/client.h
index 8348b64..59aca5d 100644
--- a/src/client.h
+++ b/src/client.h
@@ -17,46 +17,6 @@ typedef struct TAGCLIENTDATA
     pointer        pMga;
 } CLIENTDATA, *LPCLIENTDATA;
 
-extern ULONG DECL ClientReadConfigSpaceByte(LPBOARDHANDLE, ULONG, LPUCHAR);
-extern ULONG DECL ClientReadConfigSpaceDword(LPBOARDHANDLE , ULONG, LPULONG );
-extern ULONG DECL ClientWriteConfigSpaceByte (LPBOARDHANDLE , ULONG, UCHAR);
-extern ULONG DECL ClientWriteConfigSpaceDword(LPBOARDHANDLE , ULONG, ULONG);
-extern ULONG DECL ClientOpenRegisterBase(LPBOARDHANDLE , ULONG, ULONG);
-extern ULONG DECL ClientCloseRegisterBase (LPBOARDHANDLE );
-extern ULONG DECL ClientReadRegisterByte(LPBOARDHANDLE , ULONG, LPUCHAR );
-extern ULONG DECL ClientReadRegisterDword(LPBOARDHANDLE , ULONG, LPULONG );
-extern ULONG DECL ClientWriteRegisterByte (LPBOARDHANDLE , ULONG, UCHAR);
-extern ULONG DECL ClientWriteRegisterDword(LPBOARDHANDLE , ULONG, ULONG);
-extern ULONG DECL ClientOpenMemoryBase(LPBOARDHANDLE , ULONG, ULONG);
-extern ULONG DECL ClientCloseMemoryBase(LPBOARDHANDLE );
-extern ULONG DECL ClientReadMemoryByte(LPBOARDHANDLE , ULONG, LPUCHAR );
-extern ULONG DECL ClientReadMemoryDword (LPBOARDHANDLE , ULONG, LPULONG );
-extern ULONG DECL ClientWriteMemoryByte(LPBOARDHANDLE , ULONG, UCHAR);
-extern ULONG DECL ClientWriteMemoryDword (LPBOARDHANDLE , ULONG, ULONG);
-extern ULONG DECL ClientOpenSystemDevice (LPBOARDHANDLE , ULONG, ULONG);
-extern ULONG DECL ClientCloseSystemDevice (LPBOARDHANDLE );
-extern ULONG DECL ClientReadSystemDeviceByte(LPBOARDHANDLE , ULONG, LPUCHAR );
-extern ULONG DECL ClientReadSystemDeviceDword(LPBOARDHANDLE , ULONG, LPULONG );
-extern ULONG DECL ClientWriteSystemDeviceByte(LPBOARDHANDLE , ULONG, UCHAR);
-extern ULONG DECL ClientWriteSystemDeviceDword (LPBOARDHANDLE , ULONG, ULONG);
-extern ULONG DECL ClientWait (LPBOARDHANDLE , ULONG);
-extern ULONG DECL ClientLocateFirstTwisterOfQuad(ULONG);
-extern ULONG DECL ClientSearchDevNode(ULONG, UCHAR, UCHAR);
-extern ULONG DECL ClientGetBiosInfo(LPBOARDHANDLE, LPUCHAR, LPULONG );
-extern ULONG DECL ClientDebug (LPBOARDHANDLE , ULONG, LPUCHAR, ULONG, LPVOID);
-extern ULONG DECL ClientCallBiosInt10(LPBOARDHANDLE, LPBIOSREGS);
-extern ULONG DECL ClientReadDDCEdid(LPBOARDHANDLE, LPUCHAR, ULONG);
-extern ULONG DECL ClientCustomCall(LPBOARDHANDLE, ULONG, LPVOID, LPVOID);
-extern ULONG DECL ClientApplyEpromPatch(LPBOARDHANDLE);
-extern ULONG DECL ClientDetectHostInterface(LPBOARDHANDLE, LPULONG);
-extern ULONG DECL ClientHSLPatchFunction(LPBOARDHANDLE, ULONG, ULONG, LPUCHAR);
-extern ULONG DECL InitClientFunctions(LPBOARDHANDLE, ULONG);
-extern ULONG DECL ClientInitTimeBase(LPBOARDHANDLE);
-extern ULONG DECL ClientOpenDMABase(LPBOARDHANDLE, ULONG, ULONG);
-extern ULONG DECL ClientReadDMAByte(LPBOARDHANDLE, ULONG, LPUCHAR);
-extern ULONG DECL ClientReadBIOS(LPBOARDHANDLE, ULONG, ULONG, ULONG, ULONG, LPUCHAR);
-extern ULONG DECL ClientWriteBIOS(LPBOARDHANDLE, ULONG, ULONG, ULONG, ULONG);
-
 #if defined(__cplusplus)
     }
 #endif
diff --git a/src/clientlx.c b/src/clientlx.c
deleted file mode 100644
index 9c6ab50..0000000
--- a/src/clientlx.c
+++ b/dev/null
@@ -1,848 +0,0 @@
-/******************************************************************************\
-
-    clientlx.c
-
-    Copyright © 1997, Matrox Graphics Inc.
-
-    All Rights Reserved.
-
-\******************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include "xf86_OSproc.h"
-#include "xf86Pci.h"
-#include "client.h"
-#include "mga.h"
-
-CLIENTTABLE ClientFunctions = {
-    (ULONG (DECL *)(LPVOID,ULONG,LPVOID))    ClientReadConfigSpaceByte,
-    (ULONG (DECL *)(LPVOID,ULONG,LPVOID))    ClientReadConfigSpaceDword,
-    (ULONG (DECL *)(LPVOID,ULONG,UCHAR))     ClientWriteConfigSpaceByte,
-    (ULONG (DECL *)(LPVOID,ULONG,ULONG))     ClientWriteConfigSpaceDword,
-    (ULONG (DECL *)(LPVOID,ULONG,ULONG))     ClientOpenRegisterBase,
-    (ULONG (DECL *)(LPVOID))                 ClientCloseRegisterBase,
-    (ULONG (DECL *)(LPVOID,ULONG,LPVOID))    ClientReadRegisterByte,
-    (ULONG (DECL *)(LPVOID,ULONG,LPVOID))    ClientReadRegisterDword,
-    (ULONG (DECL *)(LPVOID,ULONG,UCHAR))     ClientWriteRegisterByte,
-    (ULONG (DECL *)(LPVOID,ULONG,ULONG))     ClientWriteRegisterDword,
-    (ULONG (DECL *)(LPVOID,ULONG,ULONG))     ClientOpenMemoryBase,
-    (ULONG (DECL *)(LPVOID))                 ClientCloseMemoryBase,
-    (ULONG (DECL *)(LPVOID,ULONG,LPVOID))    ClientReadMemoryByte,
-    (ULONG (DECL *)(LPVOID,ULONG,LPVOID))    ClientReadMemoryDword,
-    (ULONG (DECL *)(LPVOID,ULONG,UCHAR))     ClientWriteMemoryByte,
-    (ULONG (DECL *)(LPVOID,ULONG,ULONG))     ClientWriteMemoryDword,
-    (ULONG (DECL *)(LPVOID,ULONG,ULONG))     ClientOpenSystemDevice,
-    (ULONG (DECL *)(LPVOID))                 ClientCloseSystemDevice,
-    (ULONG (DECL *)(LPVOID,ULONG,LPVOID))    ClientReadSystemDeviceByte,
-    (ULONG (DECL *)(LPVOID,ULONG,LPVOID))    ClientReadSystemDeviceDword,
-    (ULONG (DECL *)(LPVOID,ULONG,UCHAR))     ClientWriteSystemDeviceByte,
-    (ULONG (DECL *)(LPVOID,ULONG,ULONG))     ClientWriteSystemDeviceDword,
-    (ULONG (DECL *)(LPVOID,ULONG))           ClientWait,
-    (ULONG (DECL *)(LPVOID,LPVOID,LPVOID))   ClientGetBiosInfo,
-    (ULONG (DECL *)(LPVOID,LPVOID,ULONG))    ClientReadDDCEdid
-};
-
-/******************************************************************************\
-
-    Function      : ClientReadConfigSpaceByte
-
-    Description   : Read a Byte from the configuration space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specifib board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    UCHAR *pucByte | pointer to a byte that will receive
-                    the data
-
-    Return Val : ULONG
-
-\******************************************************************************/
-ULONG ClientReadConfigSpaceByte(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                                UCHAR *pucByte)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-    MGAPtr pMga = (MGAPtr)pClientStruct->pMga;
-
-    ASSERT_HANDLER(pBoard);
-
-#ifdef XSERVER_LIBPCIACCESS
-    pci_device_cfg_read_u8(pMga->PciInfo, pucByte, ulOffset);
-#else
-    *pucByte = pciReadByte(pMga->PciTag,ulOffset);
-#endif
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientReadConfigSpaceDword
-
-    Description   : Read a Dword from the configuration space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset  | Offset of the Byte to be read.
-                    ULONG *pulDword | Dword to receive the data
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientReadConfigSpaceDword(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                                 ULONG *pulDword)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-    MGAPtr pMga = (MGAPtr)pClientStruct->pMga;
-
-    ASSERT_HANDLER(pBoard);
-
-#ifdef XSERVER_LIBPCIACCESS
-    pci_device_cfg_read_u32(pMga->PciInfo, (uint32_t *) pulDword, ulOffset);
-#else
-    *pulDword = pciReadLong(pMga->PciTag,ulOffset);
-#endif
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientWriteConfigSpaceByte
-
-    Description   : Write a Byte from the configuration space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    UCHAR ucByte   | Byte to receive the data
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientWriteConfigSpaceByte(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                                 UCHAR ucByte)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-    MGAPtr pMga = (MGAPtr)pClientStruct->pMga;
-
-    ASSERT_HANDLER(pBoard);
-
-#ifdef XSERVER_LIBPCIACCESS
-    pci_device_cfg_write_u8(pMga->PciInfo, ucByte, ulOffset);
-#else
-    pciWriteByte(pMga->PciTag,ulOffset, ucByte);
-#endif
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientWriteConfigSpaceDword
-
-    Description   : Write a Dword from the configuration space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard     | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    ULONG ulDword  | Dword containing the data to  be written
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientWriteConfigSpaceDword(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                                  ULONG ulDword)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-    MGAPtr pMga = (MGAPtr)pClientStruct->pMga;
-
-    ASSERT_HANDLER(pBoard);
-
-#ifdef XSERVER_LIBPCIACCESS
-    pci_device_cfg_write_u32(pMga->PciInfo, (uint32_t) ulDword, ulOffset);
-#else
-    pciWriteLong(pMga->PciTag,ulOffset, ulDword);
-#endif
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientOpenRegisterBase
-
-    Description   : Map the register base for future call to ClientReadRegisterX
-                    and ClientWriteRegisterX.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulAddress | Physical address of the Register aperture
-                    ULONG ulSize    | Size in Byte of the Register Aperture
-
-    Return Val : ULONG
-
-\******************************************************************************/
-ULONG ClientOpenRegisterBase(LPBOARDHANDLE pBoard, ULONG ulAddress, ULONG ulSize)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-    MGAPtr pMga = (MGAPtr)pClientStruct->pMga;
-
-    ASSERT_HANDLER(pBoard);
-
-    pClientStruct->ulRegisterBase = (ULONG) pMga->IOBase;
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientCloseRegisterBase
-
-    Description   : Unmap the register base address and free resources needed
-                    to address it.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-
-    Return Val : ULONG
-
-\******************************************************************************/
-ULONG ClientCloseRegisterBase(LPBOARDHANDLE pBoard)
-{
-    ASSERT_HANDLER(pBoard);
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientReadRegisterByte
-
-    Description   : Read a byte from the Register space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure.
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    UCHAR *pucByte | pointer to the byte that will receive
-                    the data.
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientReadRegisterByte(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                             UCHAR *pucByte)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-
-    ASSERT_HANDLER(pBoard);
-
-    *pucByte = *((UCHAR *)(pClientStruct->ulRegisterBase + ulOffset));
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientReadRegisterDword
-
-    Description   : Read a Dword from the Register space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset  | Offset of the Byte to be read.
-                    ULONG *pulDword | pointer to the dword that will receive
-                    the data.
-
-    Return Val : ULONG
-
-\******************************************************************************/
-ULONG ClientReadRegisterDword(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                              ULONG *pulDword)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-
-    ASSERT_HANDLER(pBoard);
-
-    *pulDword = *((ULONG *)(pClientStruct->ulRegisterBase + ulOffset));
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientWriteRegisterByte
-
-    Description   : Write a Byte from the Register space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    UCHAR ucByte   | CHAR to receive the data.
-
-    Return Val : ULONG
-
-\******************************************************************************/
-ULONG ClientWriteRegisterByte(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                              UCHAR ucByte)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-
-    ASSERT_HANDLER(pBoard);
-
-    *((UCHAR *)(pClientStruct->ulRegisterBase + ulOffset)) = ucByte;
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientWriteRegisterSpaceDword
-
-    Description   : Write a Dword from the Register space.
-
-    I/O Desc.     : LPBOARDHANDLE *| pBoard  | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    ULONG ulDword  | Dword to receive the data
-
-    Return Val : ULONG
-
-\******************************************************************************/
-ULONG ClientWriteRegisterDword(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                               ULONG ulDword)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-
-    ASSERT_HANDLER(pBoard);
-
-    *((ULONG *)(pClientStruct->ulRegisterBase + ulOffset)) = ulDword;
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientOpenMemoryBase
-
-    Description   : Map the Memory base for future call to ClientReadMemoryX
-                    and ClientWriteMemoryX.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulAddress | Physical address of the Register aperture
-                    ULONG ulSize    | Size in Byte of the Register Aperture
-    Return Val : ULONG
-
-\******************************************************************************/
-ULONG ClientOpenMemoryBase(LPBOARDHANDLE pBoard, ULONG ulAddress, ULONG ulSize)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-    MGAPtr pMga = (MGAPtr) pClientStruct->pMga;
-
-    ASSERT_HANDLER(pBoard);
-
-    pClientStruct->ulFrameBufferBase = (ULONG) pMga->FbBase;
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientCloseMemoryBase
-
-    Description   : Unmap the Frame Buffer aperture and free resources
-                    needed to address it.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientCloseMemoryBase(LPBOARDHANDLE pBoard)
-{
-    ASSERT_HANDLER(pBoard);
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientReadMemoryByte
-
-    Description   : Read a Byte from the Frame Buffer space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    UCHAR *ucByte  | CHAR to receive the data
-
-    Return Val : ULONG
-\******************************************************************************/
-ULONG ClientReadMemoryByte(LPBOARDHANDLE pBoard, ULONG ulOffset, UCHAR *pucByte)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-
-    ASSERT_HANDLER(pBoard);
-
-    *pucByte = *((UCHAR *)(pClientStruct->ulFrameBufferBase + ulOffset));
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientReadMemoryDword
-
-    Description   : Read a Dword from the Frame Buffer Space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    ULONG *uDword  | Dword to receive the data
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientReadMemoryDword(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                            ULONG *pulDword)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-
-    ASSERT_HANDLER(pBoard);
-
-    *pulDword = *((ULONG *)(pClientStruct->ulFrameBufferBase + ulOffset));
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-   Function      : ClientWriteMemoryByte
-
-   Description   : Write a Byte from the Frame Buffer space.
-
-   I/O Desc.     : LPBOARDHANDLE pBoard     | Handle to the board structure
-                   containing all the information about a specific board.
-                   ULONG ulOffset | Offset of the Byte to be read.
-                   UCHAR ucByte   | CHAR to receive the data
-
-   Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientWriteMemoryByte(LPBOARDHANDLE pBoard, ULONG ulOffset, UCHAR ucByte)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-
-    ASSERT_HANDLER(pBoard);
-
-    *((UCHAR *)(pClientStruct->ulFrameBufferBase + ulOffset)) = ucByte;
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientWriteMemoryDword
-
-    Description   : Write a Dword from the Frame Buffer space.
-
-    I/O desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    ULONG ulDword  | Dword to receive the data
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientWriteMemoryDword(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                            ULONG ulDword)
-{
-    LPCLIENTDATA pClientStruct = MGAGetClientPointer(pBoard);
-
-    ASSERT_HANDLER(pBoard);
-
-    *((ULONG *)(pClientStruct->ulFrameBufferBase + ulOffset)) = ulDword;
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientOpenSystemDevice
-
-    Description   : Map a System device aperture for future call to
-                    ClientReadSystemDeviceX and ClientWriteSystemDeviceX.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulAddress | Physical address of the Register aperture
-                    ULONG ulSize    | Size in Byte of the Register Aperture
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientOpenSystemDevice(LPBOARDHANDLE pBoard, ULONG ulAddress,
-                                    ULONG ulSize)
-{
-    return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientCloseSystemDevice
-
-    Description   : Unmap the System Device aperture address and free
-                    resources needed to address it.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientCloseSystemDevice (LPBOARDHANDLE pBoard)
-{
-    return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientReadSystemDeviceByte
-
-    Description   : Read a Byte from the device Space.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    ULONG pucByte  | Byte to read the data
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientReadSystemDeviceByte(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                                 UCHAR *pucByte)
-{
-    return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientReadSystemDeviceDword
-
-    Description   : Read a Dword from the Frame Buffer Space
-
-    I/O Desc.     : LPBOARDHANDLE pBoard     | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    ULONG ulDword  | Dword to Read the data
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientReadSystemDeviceDword(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                                  ULONG *pulDword)
-{
-    return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientWriteSystemByte
-
-    Description   : Write a Byte from the System Device Aperture
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    UCHAR ucByte   | Byte to receive the data
-    Return Val : ULONG
-
-\******************************************************************************/
-ULONG ClientWriteSystemDeviceByte(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                                  UCHAR ucByte)
-{
-    return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientWriteSystemDword
-
-    Description   : Write a Dword from the System Device Aperture.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard     | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulOffset | Offset of the Byte to be read.
-                    ULONG uDword   | Dword to receive the data
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientWriteSystemDeviceDword(LPBOARDHANDLE pBoard, ULONG ulOffset,
-                                   ULONG ulDword)
-{
-    return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientWait
-
-    Description   : Wait for ulDelayus micro-seconds.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    ULONG ulDelayus | Delay in uSec
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientWait (LPBOARDHANDLE pBoard, ULONG ulDelayus)
-{
-    int i;
-    ULONG ulTmp;
-
-    ASSERT_HANDLER(pBoard);
-
-    for(i = 0; i < ulDelayus * 3; i++)
-    {
-        ClientReadRegisterDword(pBoard,0x1e14,&ulTmp);
-    }
-
-    return 0;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientGetBiosInfo
-
-    Description   : This function will be call if no PINS can be found
-                    in physical EEPROM.
-
-    I/O Desc.     :  LPBOARDHANDLE pBoard | Handle to the board structure
-                     containing all the information about a specific board.
-                     LPUCHAR    | Buffer where we copy bios pins.
-                     ULONG      | Bios version
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientGetBiosInfo(LPBOARDHANDLE pBoard, LPUCHAR pucPins,LPULONG pulBIOSVersion)
-{
-    Bool bNotFound = TRUE;
-    UCHAR ucBIOS[32768];
-    UCHAR ucTmpByte;
-    UCHAR ucCheckSum;
-    UCHAR ucPinsIndex;
-    UCHAR ucPinsSize;
-    ULONG ulTmpDword;
-    ULONG ulPinsOffset = 0;
-    ULONG ulPCIINFOffset;
-
-    ASSERT_HANDLER(pBoard);
-
-    xf86ReadBIOS(0xc0000,0,ucBIOS,32768);
-
-    if(ucBIOS[0] == 0x55)
-    {
-        if(ucBIOS[1] == 0xaa)
-        {
-            while((ulPinsOffset < 0x10000) && bNotFound)
-            {
-                ulTmpDword = *(ULONG *)(ucBIOS + ulPinsOffset);
-                ucPinsSize = (UCHAR) (ulTmpDword >> 16);
-                if(((ulTmpDword & 0x0000ffff) == 0x0000412e)
-                    && ucPinsSize <= 128)
-                {
-                    ucCheckSum = 0;
-                    for(ucPinsIndex = 0;ucPinsIndex < ucPinsSize; ucPinsIndex++)
-                    {
-                        pucPins[ucPinsIndex] = ucBIOS[ulPinsOffset +
-                                               ucPinsIndex];
-                        ucCheckSum += pucPins[ucPinsIndex];
-                    }
-                    if(ucCheckSum == 0)
-                    {
-                        bNotFound = FALSE;
-                    }
-                }
-                ulPinsOffset++;
-            }
-
-            if(bNotFound)
-            {
-                return 1;
-            }
-
-            ulPCIINFOffset = *(ULONG *)(ucBIOS + 0x18);
-            ulPCIINFOffset &= 0x0000ffff;
-            ulTmpDword = *(ULONG *)(ucBIOS + ulPCIINFOffset);
-
-            if(ulTmpDword == 0x52494350)  /* "PCIR" */
-            {
-                ulPCIINFOffset += 0x12;
-                ulTmpDword = *(ULONG *)(ucBIOS + ulPCIINFOffset);
-                *pulBIOSVersion = ((ULONG) ((ulTmpDword & 0xf0) >> 4) << 16) |
-                                  ((ulTmpDword &0xf) << 12) | ((ulTmpDword >> 8)
-                                  & 0xff);
-            }
-            else
-            {
-                return 1;
-            }
-        }
-        else
-        {
-           return 1;
-        }
-    }
-    else
-    {
-        return 1;
-    }
-
-    if(!*pulBIOSVersion)
-    {
-        ucTmpByte = ucBIOS[5];
-        *pulBIOSVersion = ((ULONG) (ucTmpByte >> 4) << 16) | ((ULONG)
-                          (ucTmpByte & 0x0f) << 12);
-    }
-
-    return 0;
-}
-
-/******************************************************************************\
-
-    Function      : ClientCallBiosInt10
-
-    Description   : Call the BIOS Int10h with specified parameters.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    LPBIOSREGS pBiosRegs | Pointor to the Bios register
-                    structure.
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientCallBiosInt10(LPBOARDHANDLE pBoard, LPBIOSREGS pBiosRegs)
-{
-   ASSERT_HANDLER(pBoard);
-
-   return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientReadDDCEdid
-
-    Description   : Not implemented.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    LPBIOSREGS pBiosRegs | Pointor to the Bios register
-                    structure.
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientReadDDCEdid(LPBOARDHANDLE pBoard, LPUCHAR pEdid,
-                               ULONG ulMonitorIndex)
-{
-   ASSERT_HANDLER(pBoard);
-
-   return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientCustomCall
-
-    Description   : Not implemented.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    LPBIOSREGS pBiosRegs | Pointor to the Bios register
-                    structure.
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientCustomCall(LPBOARDHANDLE pBoard, ULONG ulServiceNumber,
-                       LPVOID pInData, LPVOID pOutData)
-{
-   ASSERT_HANDLER(pBoard);
-
-   return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientApplyEpromPatch
-
-    Description   : Not implemented.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    LPBIOSREGS pBiosRegs | Pointor to the Bios register
-                    structure.
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientApplyEpromPatch(LPBOARDHANDLE pBoard)
-{
-   ASSERT_HANDLER(pBoard);
-
-   return 1;
-}
-
-
-/******************************************************************************\
-
-    Function      : ClientDetectHostInterface
-
-    Description   : Not implemented.
-
-    I/O Desc.     : LPBOARDHANDLE pBoard | Handle to the board structure
-                    containing all the information about a specific board.
-                    LPBIOSREGS pBiosRegs | Pointor to the Bios register
-                    structure.
-
-    Return Val    : ULONG
-
-\******************************************************************************/
-ULONG ClientDetectHostInterface(LPBOARDHANDLE pBoard, LPULONG pulData)
-{
-   ASSERT_HANDLER(pBoard);
-
-   return 1;
-}
-
--
cgit v0.9.0.2-2-gbebe
From 94bbeb132c7eda912d1b402a1a91ca7cbbf5e6a1 Mon Sep 17 00:00:00 2001
From: Jamey Sharp <jamey@minilop.net>
Date: Thu, 15 Sep 2011 15:29:11 +0000
Subject: Delete support for MGA's proprietary HAL: unifdef USEMGAHAL.

This patch produced with:
	for f in `git grep -Fwl USEMGAHAL`; do
		unifdef -B -UUSEMGAHAL $f | sponge $f
	done

Adam Jackson wrote:

	Hey, so, remember back in the dark ages when dualhead was this
	insanely wild differentiating feature?  Matrox thought it was so
	special, in fact, that they hid most of the implementation of it
	(and a bunch of other stuff) in a binary-only blob called the
	HALlib.  As you'd expect it was pretty much a cut-and-paste of
	the relevant Windows code, and then some open glue to keep it
	working; clientlx.c is that glue.

	I guess the theory was that if you don't tell people which
	registers to duplicate to implement a second pipe in their own
	hardware, they won't figure it out?  A pretty eyeroll-worthy
	idea even at the time, and definitely not something we should be
	condoning anymore.

	Kill it with fire, but while you're at it, untangle the hideous
	mess of MGA_HAL() macros too.

Signed-off-by: Jamey Sharp <jamey@minilop.net>
Cc: Adam Jackson <ajax@redhat.com>
---
diff --git a/src/mga.h b/src/mga.h
index c520e86..fced6aa 100644
--- a/src/mga.h
+++ b/src/mga.h
@@ -42,10 +42,6 @@
 #include "mga_dri.h"
 #endif
 
-#ifdef USEMGAHAL
-#include "client.h"
-#endif
-
 typedef enum {
     OPTION_SW_CURSOR,
     OPTION_HW_CURSOR,
@@ -329,11 +325,6 @@ typedef enum {
 
 typedef struct {
     int			lastInstance;
-#ifdef USEMGAHAL
-    LPCLIENTDATA	pClientStruct;
-    LPBOARDHANDLE	pBoard;
-    LPMGAHWINFO		pMgaHwInfo;
-#endif
     int			refCount;
     CARD32		masterFbAddress;
     long		masterFbMapSize;
@@ -459,12 +450,6 @@ struct mga_device_attributes {
 };
 
 typedef struct {
-#ifdef USEMGAHAL
-    LPCLIENTDATA	pClientStruct;
-    LPBOARDHANDLE	pBoard;
-    LPMGAMODEINFO	pMgaModeInfo;
-    LPMGAHWINFO		pMgaHwInfo;
-#endif
     EntityInfoPtr	pEnt;
     struct mga_bios_values bios;
     CARD8               BiosOutputMode;
@@ -650,9 +635,6 @@ typedef struct {
     MGAPaletteInfo	palinfo[256];  /* G400 hardware bug workaround */
     FBLinearPtr		LinearScratch;
     Bool                softbooted;
-#ifdef USEMGAHAL
-    Bool                HALLoaded;
-#endif
     OptionInfoPtr	Options;
 
     /* Exa */
@@ -810,26 +792,6 @@ void MGAG200SESaveMode(ScrnInfoPtr, vgaRegPtr);
 void MGAG200SERestoreMode(ScrnInfoPtr, vgaRegPtr);
 void MGAG200SEHWProtect(ScrnInfoPtr, Bool);
 
-#ifdef USEMGAHAL
-/************ ESC Call Definition ***************/
-typedef struct {
-    char *function;
-    void (*funcptr)(ScrnInfoPtr pScrn, unsigned long *param, char *out, DisplayModePtr pMode);
-} MGAEscFuncRec, *MGAEscFuncPtr;
-
-typedef struct {
-    char function[32];
-    unsigned long parameters[32];
-} EscCmdStruct;
-
-extern LPMGAMODEINFO pMgaModeInfo[2];
-extern MGAMODEINFO   TmpMgaModeInfo[2];
-
-extern void MGAExecuteEscCmd(ScrnInfoPtr pScrn, char *cmdline , char *sResult, DisplayModePtr pMode);
-void MGAFillDisplayModeStruct(DisplayModePtr pMode, LPMGAMODEINFO pModeInfo);
-/************************************************/
-#endif
-
 static __inline__ void
 MGA_MARK_SYNC(MGAPtr pMga, ScrnInfoPtr pScrn)
 {
diff --git a/src/mga_dacG.c b/src/mga_dacG.c
index fca1031..b489dea 100644
--- a/src/mga_dacG.c
+++ b/src/mga_dacG.c
@@ -1001,9 +1001,6 @@ MGAGInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 		break;
 	case PCI_CHIP_MGAG400:
 	case PCI_CHIP_MGAG550:
-#ifdef USEMGAHAL
-	       MGA_HAL(break;);
-#endif
 	       if (MGAISGx50(pMga))
 		       break;
 
@@ -1046,9 +1043,6 @@ MGAGInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 		break;
 	case PCI_CHIP_MGAG200_SE_A_PCI:
 	case PCI_CHIP_MGAG200_SE_B_PCI:
-#ifdef USEMGAHAL
-		MGA_HAL(break;);
-#endif
         pReg->DacRegs[ MGA1064_VREF_CTL ] = 0x03;
                 pReg->DacRegs[MGA1064_PIX_CLK_CTL] =
                     MGA1064_PIX_CLK_CTL_SEL_PLL;
@@ -1097,9 +1091,6 @@ MGAGInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	case PCI_CHIP_MGAG200:
 	case PCI_CHIP_MGAG200_PCI:
 	default:
-#ifdef USEMGAHAL
-		MGA_HAL(break;);
-#endif
 		if(pMga->OverclockMem) {
                      /* 143 Mhz */
 		    pReg->DacRegs[ MGA1064_SYS_PLL_M ] = 0x06;
@@ -1496,21 +1487,6 @@ MGA_NOT_HAL(
                MGAG200EHPIXPLLSET(pScrn, mgaReg);
            }
 );	/* MGA_NOT_HAL */
-#ifdef USEMGAHAL
-          /* 
-	   * Work around another bug in HALlib: it doesn't restore the
-	   * DAC width register correctly. MATROX: hint, hint.
-	   */
-           MGA_HAL(	 
-    	       outMGAdac(MGA1064_MUL_CTL,mgaReg->DacRegs[0]);
-  	       outMGAdac(MGA1064_MISC_CTL,mgaReg->DacRegs[1]); 
-	       if (!MGAISGx50(pMga)) {
-		   outMGAdac(MGA1064_PIX_PLLC_M,mgaReg->DacRegs[2]);
-		   outMGAdac(MGA1064_PIX_PLLC_N,mgaReg->DacRegs[3]);
-		   outMGAdac(MGA1064_PIX_PLLC_P,mgaReg->DacRegs[4]);
-	       } 
-	       ); 
-#endif
 	   /* restore CRTCEXT regs */
            for (i = 0; i < 6; i++)
 	      OUTREG16(MGAREG_CRTCEXT_INDEX, (mgaReg->ExtVga[i] << 8) | i);
@@ -1650,24 +1626,6 @@ MGAGSave(ScrnInfoPtr pScrn, vgaRegPtr vgaReg, MGARegPtr mgaReg,
 	 * DAC width register correctly.
 	 */
 
-#ifdef USEMGAHAL
-	/* 
-	 * Work around another bug in HALlib: it doesn't restore the
-	 * DAC width register correctly (s.o.). MATROX: hint, hint.
-	 */
-  	MGA_HAL(
-  	    if (mgaReg->DacRegs == NULL) {
-  		mgaReg->DacRegs = xnfcalloc(MGAISGx50(pMga) ? 2 : 5, 1);
-  	    }
-    	    mgaReg->DacRegs[0] = inMGAdac(MGA1064_MUL_CTL);
-  	    mgaReg->DacRegs[1] = inMGAdac(MGA1064_MISC_CTL);
-	    if (!MGAISGx50(pMga)) {
-		mgaReg->DacRegs[2] = inMGAdac(MGA1064_PIX_PLLC_M);
-		mgaReg->DacRegs[3] = inMGAdac(MGA1064_PIX_PLLC_N);
-		mgaReg->DacRegs[4] = inMGAdac(MGA1064_PIX_PLLC_P);
-	    } 
-  	);
-#endif
 	MGA_NOT_HAL(
 	/*
 	 * The port I/O code necessary to read in the extended registers.
@@ -1793,12 +1751,6 @@ MGAGSetCursorPosition(ScrnInfoPtr pScrn, int x, int y)
     x += 64;
     y += 64;
 
-#ifdef USEMGAHAL
-    MGA_HAL(
-	    x += pMga->HALGranularityOffX;
-	    y += pMga->HALGranularityOffY;
-    );
-#endif
     /* cursor update must never occurs during a retrace period (pp 4-160) */
     while( INREG( MGAREG_Status ) & 0x08 );
     
diff --git a/src/mga_driver.c b/src/mga_driver.c
index 58a1390..d770031 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -1509,10 +1509,6 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
     int flags24;
     MGAEntPtr pMgaEnt = NULL;
     Bool Default;
-#ifdef USEMGAHAL
-    ULONG status;
-    CARD8 MiscCtlReg;
-#endif
 
     /*
      * Note: This function is only called once at server startup, and
@@ -1657,37 +1653,9 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
     pMga->is_G200EH = (pMga->Chipset == PCI_CHIP_MGAG200_EH_PCI);
     pMga->is_G200ER = (pMga->Chipset == PCI_CHIP_MGAG200_ER_PCI);
 
-#ifdef USEMGAHAL
-    if (pMga->chip_attribs->HAL_chipset) {
-	Bool loadHal = TRUE;
-	
-	from = X_DEFAULT;
-	if (xf86FindOption(pMga->device->options, "NoHal")) {
-	    loadHal = !xf86SetBoolOption(pMga->device->options,
-					 "NoHal", !loadHal);
-	    from = X_CONFIG;
-	} else if (xf86FindOption(pMga->device->options, "Hal")) {
-	    loadHal = xf86SetBoolOption(pMga->device->options,
-					"Hal", loadHal);
-	    from = X_CONFIG;
-	}
-        if (loadHal && xf86LoadSubModule(pScrn, "mga_hal")) {
-	  xf86DrvMsg(pScrn->scrnIndex, from,"Matrox HAL module used\n");
-	  pMga->HALLoaded = TRUE;
-	} else {
-	  xf86DrvMsg(pScrn->scrnIndex, from, "Matrox HAL module not loaded "
-		     "- using builtin mode setup instead\n");
-	  pMga->HALLoaded = FALSE;
-	}
-    }
-#endif
-
     pMga->DualHeadEnabled = FALSE;
     if (xf86IsEntityShared(pScrn->entityList[0])) {/* dual-head mode requested*/
 	if (
-#ifdef USEMGAHAL
-	    pMga->HALLoaded ||
-#endif
 	    !MGA_DH_NEEDS_HAL(pMga)) {
 	    pMga->DualHeadEnabled = TRUE;
 	} else if (xf86IsPrimInitDone(pScrn->entityList[0])) {
@@ -2088,30 +2056,6 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
             xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                 "\"Merged Framebuffer\" mode only supported on G450 and G550 boards.\n");
         } else { 
-#ifdef USEMGAHAL
-            if(pMga->HALLoaded)
-            { 
-                pMga->MergedFB = TRUE;
-                xf86DrvMsg(pScrn->scrnIndex, X_CONFIG,
-                        "Using \"Merged Framebuffer\" mode.\n");
-                /*
-                * a few options that won't work well together
-                */
-                if(pMga->HWCursor) /*Should we give the choice? */
-                    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                        " -- Hardware Cursor disabled.\n");
-                pMga->HWCursor = FALSE; 
-                if(pMga->ShadowFB) 
-                    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                        " -- Shadow Framebuffer disabled.\n");
-                pMga->ShadowFB = FALSE;
-                if(pMga->FBDev) 
-                    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                        " -- Framebuffer device disabled.\n");
-                pMga->FBDev = FALSE;
-            } /* MGA_HAL */
-            else
-#endif
             { 
                 xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
                     "HALLib not loaded! NOT using \"Merged Framebuffer\" mode.\n");
@@ -2404,10 +2348,6 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
     clockRanges->clockIndex = -1;		/* programmable */
     clockRanges->interlaceAllowed = TRUE;
     clockRanges->doubleScanAllowed = TRUE;
-#ifdef USEMGAHAL
-    MGA_HAL(clockRanges->interlaceAllowed = FALSE);
-    MGA_HAL(clockRanges->doubleScanAllowed = FALSE);
-#endif
     if (pMga->SecondCrtc == TRUE) 
 	clockRanges->interlaceAllowed = FALSE;
 
@@ -2513,80 +2453,6 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 	MGAFreeRec(pScrn);
 	return FALSE;
     }
-#ifdef USEMGAHAL
-    MGA_HAL(
-
-    if(pMga->SecondCrtc == FALSE) {
-	
-        pMga->pBoard = xalloc(sizeof(CLIENTDATA) + MGAGetBOARDHANDLESize());
-        pMga->pClientStruct = xalloc(sizeof(CLIENTDATA));
-        pMga->pClientStruct->pMga = (MGAPtr) pMga;
-
-        MGAMapMem(pScrn);
-	/* 
-	 * For some reason the MGAOPM_DMA_BLIT bit needs to be set
-	 * on G200 before opening the HALlib. I don't know why.
-	 * MATROX: hint, hint.
-	 */
-	/*if (pMga->Chipset == PCI_CHIP_MGAG200 ||
-	  pMga->Chipset == PCI_CHIP_MGAG200_PCI) */{
-	    CARD32 opmode;
-	    opmode = INREG(MGAREG_OPMODE);
-	    OUTREG(MGAREG_OPMODE,  MGAOPM_DMA_BLIT | opmode);
-	}
-	/* wrapping OpenLibrary to fix broken registers. MATROX: hint, hint. */
-	MiscCtlReg = inMGAdac(MGA1064_MISC_CTL);
-        MGAOpenLibrary(pMga->pBoard,pMga->pClientStruct,sizeof(CLIENTDATA));
-	outMGAdac(MGA1064_MISC_CTL,MiscCtlReg);
-        MGAUnmapMem(pScrn);
-        pMga->pMgaHwInfo = xalloc(sizeof(MGAHWINFO));
-        MGAGetHardwareInfo(pMga->pBoard,pMga->pMgaHwInfo);
-
-        /* copy the board handles */
-        if (pMga->DualHeadEnabled) {
-            pMgaEnt->pClientStruct = pMga->pClientStruct;
-            pMgaEnt->pBoard = pMga->pBoard;
-            pMgaEnt->pMgaHwInfo = pMga->pMgaHwInfo;
-        }
-
-    } else { /* Second CRTC && entity is shared */ 
-        pMga->pBoard = pMgaEnt->pBoard;
-        pMga->pClientStruct = pMgaEnt->pClientStruct;
-        pMga->pMgaHwInfo = pMgaEnt->pMgaHwInfo;
-
-    }
-
-    MGAFillModeInfoStruct(pScrn,NULL);
-    /* Fields usually handled by MGAFillModeInfoStruct, but are unavailable
-     * because no mode is given
-     */
-    pMga->pMgaModeInfo->ulDispWidth = pScrn->virtualX;
-    pMga->pMgaModeInfo->ulDispHeight = pScrn->virtualY;
-
-    
-    if (ISDIGITAL1(pMga)) 
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                    "Digital screen detected on first head.\n");
-    if (ISTV1(pMga)) 
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                    "TV detected on first head.\n");
-    if (ISDIGITAL2(pMga)) 
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                    "Digital screen detected on second head.\n");
-    if (ISTV2(pMga))
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                    "TV detected on second head.\n");
-
-    
-    if((status = MGAValidateMode(pMga->pBoard,pMga->pMgaModeInfo)) != 0) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		   "MGAValidateMode from HALlib found the mode to be invalid.\n"
-		   "\tError: 0x%lx\n", status);
-        return FALSE;
-    }
-    pScrn->displayWidth = pMga->pMgaModeInfo->ulFBPitch;
-    );	/* MGA_HAL */
-#endif
 
     /* If the Device section explicitly set HasSDRAM, don't bother checking.
      */
@@ -2620,9 +2486,6 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
      * driver and if the driver doesn't provide code to set them.  They
      * are not pre-initialised at all.
      */
-#ifdef USEMGAHAL
-    MGA_HAL(xf86SetCrtcForModes(pScrn, 0));
-#endif
     MGA_NOT_HAL(xf86SetCrtcForModes(pScrn, INTERLACE_HALVE_V));
 
     /* Set the current mode to the first in the list */
@@ -2790,46 +2653,6 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
     };
 
     
-#ifdef USEMGAHAL
-    MGA_HAL(
-    /* Close the library after preinit */
-    /* This needs to only happen after this board has completed preinit
-     * both times
-     */
-
-      if(pMga->DualHeadEnabled) {
-	  /* Entity is shared make sure refcount == 2 */
-	  /* If ref count is 2 then reset it to 0 */
-	  if(pMgaEnt->refCount == 2) {
-	      /* Both boards have done there initialization */
-	      MGACloseLibrary(pMga->pBoard);
-
-	      if (pMga->pBoard)
-	        xfree(pMga->pBoard);
-	      if (pMga->pClientStruct)
-	        xfree(pMga->pClientStruct);
-	      if (pMga->pMgaModeInfo)
-	        xfree(pMga->pMgaModeInfo);
-	      if (pMga->pMgaHwInfo)
-	        xfree(pMga->pMgaHwInfo);
-	      pMgaEnt->refCount = 0;
-	  }
-      } else {
-	  MGACloseLibrary(pMga->pBoard);
-
-	  if (pMga->pBoard)
-	    xfree(pMga->pBoard);
-	  if (pMga->pClientStruct)
-	    xfree(pMga->pClientStruct);
-	  if (pMga->pMgaModeInfo)
-	    xfree(pMga->pMgaModeInfo);
-	  if (pMga->pMgaHwInfo)
-	    xfree(pMga->pMgaHwInfo);
-      }
-
-    );	/* MGA_HAL */
-#endif
-
     xf86SetPrimInitDone(pScrn->entityList[0]);
     
     return TRUE;
@@ -2995,9 +2818,6 @@ MGASave(ScrnInfoPtr pScrn)
     MGARegPtr mgaReg = &pMga->SavedReg;
 
     if(pMga->SecondCrtc == TRUE) return;
-#ifdef USEMGAHAL
-    MGA_HAL(if (pMga->pBoard != NULL) MGASaveVgaState(pMga->pBoard));
-#endif
 
     /* I need to save the registers for the second head also */
     /* Save the register for 0x80 to 0xa0 */
@@ -3007,135 +2827,6 @@ MGASave(ScrnInfoPtr pScrn)
     (*pMga->Save)(pScrn, vgaReg, mgaReg, pMga->Primary);
 }
 
-#ifdef USEMGAHAL
-/* Convert DisplayModeRec parameters in MGAMODEINFO parameters.
-*  mode parameter optionnal. */
-void
-MGAFillModeInfoStruct(ScrnInfoPtr pScrn, DisplayModePtr mode)
-{
-     const char *s;
-    MGAPtr pMga = MGAPTR(pScrn);
-
-    Bool digital1 = FALSE;
-    Bool digital2 = FALSE;
-    Bool tv1 = FALSE;
-    Bool tv2 = FALSE;
-    Bool swap_head
-      = xf86ReturnOptValBool(pMga->Options, OPTION_SWAPPED_HEAD, FALSE);
-        
-    if(pMga->MergedFB && mode && mode->Private && (mode->PrivSize == 0)) {
-        mode = pMga->SecondCrtc ? 
-             ((MergedDisplayModePtr)mode->Private)->Monitor2
-            : ((MergedDisplayModePtr)mode->Private)->Monitor1;
-    }
-    
-    
-    if (pMga->pMgaHwInfo)
-    {
-	digital1 = ISDIGITAL1(pMga);
-	digital2 = ISDIGITAL2(pMga);
-	tv1 = ISTV1(pMga);
-	tv2 = ISTV2(pMga);
-    }
-
-    /*FIXME: causes segfault elsewhere if not commented*/
-    /*if(!pMga->pMgaModeInfo)*/ pMga->pMgaModeInfo = xalloc(sizeof(MGAMODEINFO));
-    pMga->pMgaModeInfo->flOutput = 0;
-    pMga->pMgaModeInfo->ulDeskWidth = pScrn->virtualX;
-    pMga->pMgaModeInfo->ulDeskHeight = pScrn->virtualY;
-    pMga->pMgaModeInfo->ulFBPitch = 0;
-    pMga->pMgaModeInfo->ulBpp = pScrn->bitsPerPixel;
-    pMga->pMgaModeInfo->ulZoom = 1;
-    pMga->pMgaModeInfo->flSignalMode = 0x10;
-
-    /* Set TV standard */
-    if ((s = xf86GetOptValString(pMga->Options, OPTION_TVSTANDARD))) {
-    	if (!xf86NameCmp(s, "PAL")) {
-    		pMga->pMgaModeInfo->flSignalMode = 0x00;
-    		pMga->pMgaModeInfo->ulRefreshRate = 50;
-    		pMga->pMgaModeInfo->ulTVStandard = TV_PAL;
-    	} else {
-    		pMga->pMgaModeInfo->ulRefreshRate = 60;
-    		pMga->pMgaModeInfo->ulTVStandard = TV_NTSC;
-    	}
-    } else {
-    	pMga->pMgaModeInfo->ulRefreshRate = 0;
-    	pMga->pMgaModeInfo->ulTVStandard = TV_NTSC;
-    }
-
-    /* Set Cable Type */
-    if ((s = xf86GetOptValString(pMga->Options, OPTION_CABLETYPE))) {
-    	if (!xf86NameCmp(s, "SCART_RGB")) {
-    		pMga->pMgaModeInfo->ulCableType = TV_SCART_RGB;
-    	} else if (!xf86NameCmp(s, "SCART_COMPOSITE")) {
-    		pMga->pMgaModeInfo->ulCableType = TV_SCART_COMPOSITE;
-    	} else if (!xf86NameCmp(s, "SCART_TYPE2")) {
-    		pMga->pMgaModeInfo->ulCableType = TV_SCART_TYPE2;
-    	} else {
-    		pMga->pMgaModeInfo->ulCableType = TV_YC_COMPOSITE;
-    	}
-    } else {
-    	pMga->pMgaModeInfo->ulCableType = TV_YC_COMPOSITE;
-    }
-
-    if(mode) {
-        pMga->pMgaModeInfo->ulHorizRate = 0;
-        pMga->pMgaModeInfo->ulDispWidth = mode->HDisplay;
-        pMga->pMgaModeInfo->ulDispHeight = mode->VDisplay;
-        pMga->pMgaModeInfo->ulPixClock = mode->Clock;
-        pMga->pMgaModeInfo->ulHFPorch = mode->HSyncStart - mode->HDisplay;
-        pMga->pMgaModeInfo->ulHSync = mode->HSyncEnd - mode->HSyncStart;
-        pMga->pMgaModeInfo->ulHBPorch = mode->HTotal - mode->HSyncEnd;
-        pMga->pMgaModeInfo->ulVFPorch = mode->VSyncStart - mode->VDisplay;
-        pMga->pMgaModeInfo->ulVSync = mode->VSyncEnd - mode->VSyncStart;
-        pMga->pMgaModeInfo->ulVBPorch = mode->VTotal - mode->VSyncEnd;
-    }
-    /* Use DstOrg directly */
-    /* This is an offset in pixels not memory */
-    pMga->pMgaModeInfo->ulDstOrg = pMga->DstOrg / (pScrn->bitsPerPixel / 8);
-    pMga->pMgaModeInfo->ulDisplayOrg = pMga->DstOrg / (pScrn->bitsPerPixel / 8);
-    pMga->pMgaModeInfo->ulPanXGran = 0;
-    pMga->pMgaModeInfo->ulPanYGran = 0;
-
-    if(pMga->SecondCrtc == TRUE) {
-	pMga->pMgaModeInfo->flOutput = MGAMODEINFO_SECOND_CRTC |
-				       MGAMODEINFO_FORCE_PITCH |
-				       MGAMODEINFO_FORCE_DISPLAYORG;
-	if (digital2) {
-	    pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_DIGITAL2;
-	} else if (tv2) {
-	    pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_TV;
-	} else {
-            if (!swap_head) {
-	      pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_ANALOG2;
-            } else {
-              pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_ANALOG1;
-            }
-	}
-    } else { 
-	pMga->pMgaModeInfo->flOutput = MGAMODEINFO_FORCE_PITCH;
-        if (digital1) {
-	    if ((pMga->Chipset == PCI_CHIP_MGAG200) ||
-		(pMga->Chipset == PCI_CHIP_MGAG200_PCI)) {
-		pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_FLATPANEL1;
-		pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_DIGITAL2;
-	    } else {
-		pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_DIGITAL1;
-	    }
-        } else if (tv1) {
-	    pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_TV;
-       	} else {
-            if (!swap_head) {
-	        pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_ANALOG1;
-            } else {
-                pMga->pMgaModeInfo->flOutput |= MGAMODEINFO_ANALOG2;
-            }
-        }
-    }
-    pMga->pMgaModeInfo->ulFBPitch = pScrn->displayWidth;
-}
-#endif
-
 /*
  * Initialise a new mode.  This is currently still using the old
  * "initialise struct, restore/write struct to HW" model.  That could
@@ -3150,9 +2841,6 @@ MGAModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
     MGAPtr pMga = MGAPTR(pScrn);
     MGARegPtr mgaReg;
 
-#ifdef USEMGAHAL
-   ULONG status;
-#endif
     vgaHWUnlock(hwp);
 
 /*    if(pMga->MergedFB && mode && mode->Private && (mode->PrivSize == 0)) {
@@ -3175,56 +2863,6 @@ MGAModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
     }
     vgaReg = &hwp->ModeReg;
     mgaReg = &pMga->ModeReg;
-#ifdef USEMGAHAL
-    MGA_HAL( 
-        MGAFillModeInfoStruct(pScrn,mode);
-                    
-        /* Validate the parameters */
-        if ((status = MGAValidateMode(pMga->pBoard, pMga->pMgaModeInfo)) != 0) {
-            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                    "MGAValidateMode from HALlib found the mode to be invalid.\n"
-                    "\tError: %lx\n", status);
-            return FALSE;
-        }
-
-        /*
-         * Find mode for second head. 
-         */
-        if(pMga->MergedFB) {
-    
-            MGAFillModeInfoStruct(pMga->pScrn2,mode);
-            /* Validates the Video parameters */
-            if ((status = MGAValidateVideoParameters(pMga->pBoard, MGAPTR(pMga->pScrn2)->pMgaModeInfo))
-                != 0) {
-                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                        "MGAValidateVideoParameters from HALlib found the mode to be invalid.\n\tError: %lx\n", status);
-                return FALSE;
-            }
-        }
-    );	 /*MGA_HAL */
-    
-#endif
-
-#ifdef USEMGAHAL
-MGA_HAL(
-
-    /*************************** ESC *****************************/
-    TmpMgaModeInfo[0] =  *pMga->pMgaModeInfo;
-	
-    if(pMga->SecondCrtc == TRUE)
-        pMgaModeInfo[1] = pMga->pMgaModeInfo;
-    else
-        pMgaModeInfo[0] = pMga->pMgaModeInfo;
-    
-	TmpMgaModeInfo[0].ulDispWidth = 0;
-    
-    if(!pMga->MergedFB) /* FIXME: Must deal with this once PowerDesk & MergedFB 
-                           compatibility will exist */
-        MGAFillDisplayModeStruct(mode, pMga->pMgaModeInfo);  
-    /*************************************************************/
-
-);	/* MGA_HAL */
-#endif
 
 #ifdef XF86DRI
    if (pMga->directRenderingEnabled) {
@@ -3232,38 +2870,6 @@ MGA_HAL(
    }
 #endif
 
-#ifdef USEMGAHAL
-    MGA_HAL(
-    /* Initialize the board */
-    if(MGASetMode(pMga->pBoard,pMga->pMgaModeInfo) != 0) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		"MGASetMode returned an error."
-		"  Make sure to validate the mode before.\n");
-	return FALSE;
-    }
-    if(pMga->MergedFB
-       && MGASetMode(pMga->pBoard,MGAPTR(pMga->pScrn2)->pMgaModeInfo) != 0) {
-  	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		   "MGASetMode returned an error."
-		   "  Make sure to validate the mode before.\n");
-    }
-
-    );	/* MGA_HAL */
-
-    /* getting around bugs in the HAL lib. MATROX: hint, hint. */
-    MGA_HAL(
-	    if (pMga->chip_attribs->hwcursor_1064) {
-		if(pMga->SecondCrtc == FALSE && pMga->HWCursor == TRUE) {
-		outMGAdac(MGA1064_CURSOR_BASE_ADR_LOW, 
-			  pMga->FbCursorOffset >> 10);
-		outMGAdac(MGA1064_CURSOR_BASE_ADR_HI, 
-			  pMga->FbCursorOffset >> 18);
-		outMGAdac(MGA1064_CURSOR_CTL, 0x00);
-	      }
-	    }
-    );	/* MGA_HAL */
-#endif
-
     MGA_NOT_HAL((*pMga->Restore)(pScrn, vgaReg, mgaReg, FALSE));
 
     MGAStormSync(pScrn);
@@ -3472,14 +3078,6 @@ MGARestore(ScrnInfoPtr pScrn)
 	vgaHWProtect(pScrn, TRUE);
     }
     if (pMga->Primary) {
-#ifdef USEMGAHAL
-	MGA_HAL(
-	    if(pMga->pBoard != NULL) {
-		MGASetVgaMode(pMga->pBoard);
-		MGARestoreVgaState(pMga->pBoard);
-	    }
-	    );	/* MGA_HAL */
-#endif
         (*pMga->Restore)(pScrn, vgaReg, mgaReg, TRUE);
     } else {
         vgaHWRestore(pScrn, vgaReg, VGA_SR_MODE);
@@ -3588,81 +3186,12 @@ MGAScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
        pPriv = xf86GetEntityPrivate(pScrn->entityList[0], MGAEntityIndex);
        pMgaEnt = pPriv->ptr;
        pMgaEnt->refCount++;
-#ifdef USEMGAHAL
-       MGA_HAL(
-       if(pMgaEnt->refCount == 1) {
-	   CARD8 MiscCtlReg;
-	  pMga->pBoard = xalloc(sizeof(CLIENTDATA) + MGAGetBOARDHANDLESize());
-	  pMga->pClientStruct = xalloc(sizeof(CLIENTDATA));
-	  pMga->pClientStruct->pMga = (MGAPtr) pMga;
-	  
-	  /* wrapping OpenLibrary to fix broken registers. MATROX: hint,hint.*/
-          MiscCtlReg = inMGAdac(MGA1064_MISC_CTL);
-	  MGAOpenLibrary(pMga->pBoard,pMga->pClientStruct,sizeof(CLIENTDATA));
-	  outMGAdac(MGA1064_MISC_CTL,MiscCtlReg);
-	  pMga->pMgaHwInfo = xalloc(sizeof(MGAHWINFO));
-	  MGAGetHardwareInfo(pMga->pBoard,pMga->pMgaHwInfo);
-
-	  /* Detecting for type of display */
-	  if (pMga->pMgaHwInfo->ulCapsSecondOutput & MGAHWINFOCAPS_OUTPUT_TV) {
-	  	xf86DrvMsg(pScrn->scrnIndex, X_PROBED, "TV detected\n");
-	  }
-	  if (pMga->pMgaHwInfo->ulCapsFirstOutput &
-			MGAHWINFOCAPS_OUTPUT_DIGITAL) {
-	  	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				"Digital Screen detected\n");
-	  }
-	  if (pMga->pMgaHwInfo->ulCapsSecondOutput &
-			MGAHWINFOCAPS_OUTPUT_DIGITAL) {
-	  	xf86DrvMsg(pScrn->scrnIndex, X_PROBED,
-				"Digital Screen detected\n");
-	  }
-
-	  /* Now copy these to the entitystructure */
-	  pMgaEnt->pClientStruct = pMga->pClientStruct;
-	  pMgaEnt->pBoard = pMga->pBoard;
-	  pMgaEnt->pMgaHwInfo = pMga->pMgaHwInfo;
-       } else { /* Ref count is 2 */
-	  pMga->pClientStruct = pMgaEnt->pClientStruct;
-	  pMga->pBoard = pMgaEnt->pBoard;
-	  pMga->pMgaHwInfo = pMgaEnt->pMgaHwInfo;
-       }
-       );	/* MGA_HAL */
-#endif
     } else {
-#ifdef USEMGAHAL
-	CARD8 MiscCtlReg;
-
-	  MGA_HAL(
-	  pMga->pBoard = xalloc(sizeof(CLIENTDATA) + MGAGetBOARDHANDLESize());
-	  pMga->pClientStruct = xalloc(sizeof(CLIENTDATA));
-	  pMga->pClientStruct->pMga = (MGAPtr) pMga;
-
-	  MiscCtlReg = inMGAdac(MGA1064_MISC_CTL);
-	  /* wrapping OpenLibrary to fix broken registers. MATROX: hint,hint.*/
-	  MGAOpenLibrary(pMga->pBoard,pMga->pClientStruct,sizeof(CLIENTDATA));
-	  outMGAdac(MGA1064_MISC_CTL,MiscCtlReg);
-	  pMga->pMgaHwInfo = xalloc(sizeof(MGAHWINFO));
-	  MGAGetHardwareInfo(pMga->pBoard,pMga->pMgaHwInfo);
-	  );	/* MGA_HAL */
-#endif
     }
     if (pMga->is_G200SE) {
 	pScrn->videoRam = VRTemp;
 	pMga->FbMapSize = FBTemp;
     }
-#ifdef USEMGAHAL
-    MGA_HAL(
-	/* There is a problem in the HALlib: set soft reset bit */
-	/* MATROX: hint, hint. */
-	if (!pMga->Primary && !pMga->FBDev &&
-	    (SUBSYS_ID(pMga->PciInfo) == PCI_CARD_MILL_G200_SG)) {
-	    OUTREG(MGAREG_Reset, 1);
-	    usleep(200);
-	    OUTREG(MGAREG_Reset, 0);
-	}
-    );	/* MGA_HAL */
-#endif
 
     /* Initialise the MMIO vgahw functions */
     vgaHWSetMmioFuncs(hwp, pMga->IOBase, PORT_OFFSET);
@@ -3969,66 +3498,8 @@ MGAScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 Bool
 MGASwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
 {
-#ifdef USEMGAHAL
-    char sCmdIn[256];
-    char sCmdOut[256];
-    FILE* fdIn;
-# ifdef MATROX_WRITEBACK
-    FILE* fdOut;
-# endif
-#endif
  
     if  (mode->Flags & 0x80000000) {
-#ifdef USEMGAHAL
-
-# ifdef MATROX_WRITEBACK
-#  define MWB(x) { x; }
-#  define MWB_COND(x) x
-# else
-#  define MWB(x)
-#  define MWB_COND(x) 1
-# endif
-	ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-
-	MGA_HAL(
-	fdIn = fopen("/tmp/mgaDriverIn", "rt");
-	MWB(fdOut = fopen("/tmp/mgaDriverOut", "wt"))
-
-	if(fdIn && MWB_COND(fdOut))
-	{
- 
-	    fgets(sCmdIn, 255, fdIn);
- 
-	    if(sCmdIn)
-	    {
- 
-		MGAExecuteEscCmd(xf86Screens[scrnIndex], sCmdIn, sCmdOut, mode);
- 
-		/* Remove file and close file descriptor */
-		remove("/tmp/mgaDriverIn");
-		fclose(fdIn);
-		MWB(
-		    /* Write output data to output file for
-		       calling application */
-		    fputs(sCmdOut, fdOut);
-		    fclose(fdOut);
-		    )
-		mode->Flags &= 0x7FFFFFFF;
-		return TRUE;
-	    }
-	    else
-	    {
-		mode->Flags &= 0x7FFFFFFF;
-		return FALSE;
-	    }
-	}
-	else
-	{
-	    mode->Flags &= 0x7FFFFFFF;
-	    return FALSE;
-	}
-   )
-#endif
  	return FALSE; 
     }   else
 	return MGAModeInit(xf86Screens[scrnIndex], mode);
@@ -4040,28 +3511,6 @@ MGASwitchMode(int scrnIndex, DisplayModePtr mode, int flags)
 void
 MGAAdjustGranularity(ScrnInfoPtr pScrn, int* x, int* y)
 {
-#ifdef USEMGAHAL
-    MGA_HAL(
-	MGAPtr pMga = MGAPTR(pScrn);
-	MGAPtr pMga2;
-	int xg = 1;
-	int yg = 1;
-	if(pMga->pMgaModeInfo && pMga->pMgaModeInfo->ulPanXGran && pMga->pMgaModeInfo->ulPanYGran) {
-	    xg = pMga->pMgaModeInfo->ulPanXGran;
-	    yg = pMga->pMgaModeInfo->ulPanYGran;
-	}
-	if(pMga->pScrn2 && (pMga2 = MGAPTR(pMga->pScrn2)) ) {
-
-	    if(pMga2->pMgaModeInfo && pMga2->pMgaModeInfo->ulPanXGran && pMga2->pMgaModeInfo->ulPanYGran) {
-		xg = max(xg,pMga2->pMgaModeInfo->ulPanXGran);
-		yg = max(yg,pMga2->pMgaModeInfo->ulPanYGran);
-	    }
-	}
-	xg=16; /*ncoder: temporary */ 
-	*x -= *x % xg;
-	*y -= *y % yg;
-	); 
-#endif
 }
 
 
@@ -4087,16 +3536,6 @@ MGAAdjustFrame(int scrnIndex, int x, int y, int flags)
         /* wanted to improve panning granularity problems without risking
          * compatibility issues. Existing code looked hardware dependent.
          */
-#ifdef USEMGAHAL
-    MGA_HAL(
-	    pMga->HALGranularityOffX = x;
-	    pMga->HALGranularityOffY = y;
-        MGAAdjustGranularity(pScrn,&x,&y);
-	    pMga->HALGranularityOffX = pMga->HALGranularityOffX - x;
-	    pMga->HALGranularityOffY = pMga->HALGranularityOffY - y;
-        HALSetDisplayStart(pMga->pBoard,x,y,0);
-    );
-#endif
     MGA_NOT_HAL(
         if(pMga->ShowCache && y && pScrn->vtSema)
             y += pScrn->virtualY - 1;
@@ -4139,12 +3578,6 @@ MGAAdjustFrameCrtc2(int scrnIndex, int x, int y, int flags)
     pScrn = xf86Screens[scrnIndex];
     pMga = MGAPTR(pScrn);
     pLayout = &pMga->CurrentLayout;
-#ifdef USEMGAHAL
-    MGA_HAL(
-        MGAAdjustGranularity(pScrn,&x,&y);
-        HALSetDisplayStart(pMga->pBoard,x,y,1);
-    );
-#endif
     MGA_NOT_HAL(
         if(pMga->ShowCache && y && pScrn->vtSema)
             y += pScrn->virtualY - 1;
@@ -4258,9 +3691,6 @@ MGALeaveVT(int scrnIndex, int flags)
         DRILock(pScreen, 0);
     }
 #endif
-#ifdef USEMGAHAL
-    MGA_HAL( RESTORE_TEXTMODE_ON_DVI(pMga); );
-#endif
 }
 
 
@@ -4280,9 +3710,6 @@ MGACloseScreen(int scrnIndex, ScreenPtr pScreen)
     MGAPtr pMga = MGAPTR(pScrn);
     MGAEntPtr pMgaEnt = NULL;
 
-#ifdef USEMGAHAL    
-    MGA_HAL( RESTORE_TEXTMODE_ON_DVI(pMga); );
-#endif
     if (pMga->MergedFB)
          MGACloseScreenMerged(scrnIndex, pScreen);
 
@@ -4311,37 +3738,6 @@ MGACloseScreen(int scrnIndex, ScreenPtr pScreen)
        pMgaEnt->refCount--;
    }
 
-#ifdef USEMGAHAL
-   MGA_HAL(
-   if(pMga->DualHeadEnabled) {
-      if(pMgaEnt->refCount == 0) {
-	 /* Both boards have closed there screen */
-	 MGACloseLibrary(pMga->pBoard);
-
-	 if (pMga->pBoard)
-	   xfree(pMga->pBoard);
-	 if (pMga->pClientStruct)
-	   xfree(pMga->pClientStruct);
-	 if (pMga->pMgaModeInfo)
-	   xfree(pMga->pMgaModeInfo);
-	 if (pMga->pMgaHwInfo)
-	   xfree(pMga->pMgaHwInfo);
-      }
-   } else {
-      MGACloseLibrary(pMga->pBoard);
-
-      if (pMga->pBoard)
-	xfree(pMga->pBoard);
-      if (pMga->pClientStruct)
-	xfree(pMga->pClientStruct);
-      if (pMga->pMgaModeInfo)
-	xfree(pMga->pMgaModeInfo);
-      if (pMga->pMgaHwInfo)
-	xfree(pMga->pMgaHwInfo);
-   }
-   );	/* MGA_HAL */
-#endif
-
 #ifdef USE_XAA
     if (pMga->AccelInfoRec)
 	XAADestroyInfoRec(pMga->AccelInfoRec);
diff --git a/src/mga_esc.c b/src/mga_esc.c
index e811712..41b734a 100644
--- a/src/mga_esc.c
+++ b/src/mga_esc.c
@@ -10,782 +10,4 @@
 #include "config.h"
 #endif
 
-#ifdef USEMGAHAL
-
-/* All drivers should typically include these */
-#include "xf86.h"
-#include "xf86_OSproc.h"
-
-/* All drivers need this */
-
-#include "compiler.h"
-
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
-/* Drivers that need to access the PCI config space directly need this */
-#include "xf86Pci.h"
-
-/* All drivers initialising the SW cursor need this */
-#include "mipointer.h"
-
-/* All drivers implementing backing store need this */
-#include "mibstore.h"
-
-#include "micmap.h"
-
-#include "xf86DDC.h"
-#include "vbe.h"
-
-#include "fb.h"
-#include "dixstruct.h"
-
-#include "mga_reg.h"
-#include "mga.h"
-#include "mga_macros.h"
-
-/* ESC */
-LPMGAMODEINFO pMgaModeInfo[2] = {NULL};
-MGAMODEINFO   TmpMgaModeInfo[2] = {{0}};
-
-/* ESC Implementation */
-static void EscHLeft(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscHRight(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscVUp(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscVDown(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscHLarger(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscHSmaller(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscVTaller(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscVSmaller(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscRefresh(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscRestoreVidParm(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscRead(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscWrite(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscHal(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscTest(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-static void EscMerged(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode);
-
-static LPMGAMODEINFO  GetModeInfoPtr(ULONG ulScreen);
-static void GetVideoParameterStr(LPMGAMODEINFO pModeInfo, char *sResult);
-static Bool convertNumber(unsigned long *pulNumber, char *sNumber);
-
-
-static MGAEscFuncRec FunctionTable[] = {
-    {"hal",  EscHal},
-    {"test",  EscTest},
-    {"read",  EscRead},
-	{"write", EscWrite},
-    {"left",  EscHLeft},
-    {"right", EscHRight},
-    {"down",  EscVDown},
-    {"up",    EscVUp},
-    {"h+",    EscHLarger},
-    {"h-",    EscHSmaller},
-    {"v+",    EscVTaller},
-    {"v-",    EscVSmaller},
-    {"refresh", EscRefresh},
-    {"undo",  EscRestoreVidParm},
-    {"merged", EscMerged},
-    {NULL,NULL}
-};
-
-
-void MGAFillDisplayModeStruct(DisplayModePtr pMode, LPMGAMODEINFO pModeInfo)
-{
-   pMode->Clock = pModeInfo->ulPixClock;
-
-   pMode->HDisplay = pModeInfo->ulDispWidth;
-   pMode->HSyncStart =  pModeInfo->ulDispWidth
-                       + pModeInfo->ulHFPorch;
-   pMode->HSyncEnd = pModeInfo->ulDispWidth
-                       + pModeInfo->ulHFPorch
-                        + pModeInfo->ulHSync;
-   pMode->HTotal = pModeInfo->ulDispWidth
-                       + pModeInfo->ulHFPorch
-                       + pModeInfo->ulHSync
-                       + pModeInfo->ulHBPorch;
-
-   pMode->VDisplay = pModeInfo->ulDispHeight;
-   pMode->VSyncStart =  pModeInfo->ulDispHeight
-                       + pModeInfo->ulVFPorch;
-   pMode->VSyncEnd = pModeInfo->ulDispHeight
-                       + pModeInfo->ulVFPorch
-                       + pModeInfo->ulVSync;
-   pMode->VTotal = pModeInfo->ulDispHeight
-                       + pModeInfo->ulVFPorch
-                       + pModeInfo->ulVSync
-                       + pModeInfo->ulVBPorch;
-
-   pMode->VRefresh = pModeInfo->ulRefreshRate;
-}
-
-static LPMGAMODEINFO  GetModeInfoPtr(ULONG ulScreen)
-{
-
-    if ( !TmpMgaModeInfo[ulScreen].ulDispWidth )
-    {
-        TmpMgaModeInfo[ulScreen] = *pMgaModeInfo[ulScreen];
-    }
-
-    return &TmpMgaModeInfo[ulScreen];
-}
-
-
-static void GetVideoParameterStr(LPMGAMODEINFO pModeInfo, char *sResult)
-{
-    sprintf(sResult, "%d %d %d %d %d %d %d %d %d %d %d",
-            pModeInfo->ulDispWidth,
-            pModeInfo->ulDispHeight,
-            pModeInfo->ulBpp,
-            pModeInfo->ulPixClock,
-            pModeInfo->ulHFPorch,
-            pModeInfo->ulHSync,
-            pModeInfo->ulHBPorch,
-            pModeInfo->ulVFPorch,
-            pModeInfo->ulVSync,
-            pModeInfo->ulVBPorch,
-            pModeInfo->flSignalMode);
-}
-
-
-static float  GetVRefresh(LPMGAMODEINFO pModeInfo)
-{
-    ULONG ulHTotal;
-    ULONG ulVTotal;
-
-    ulHTotal =
-        pModeInfo->ulDispWidth +
-        pModeInfo->ulHFPorch +
-        pModeInfo->ulHSync +
-        pModeInfo->ulHBPorch;
-
-    ulVTotal =
-        pModeInfo->ulDispHeight +
-        pModeInfo->ulVFPorch    +
-        pModeInfo->ulVSync      +
-        pModeInfo->ulVBPorch;
-
-    return ((float)pModeInfo->ulPixClock * 1000.0) / (ulHTotal * ulVTotal);
-}
-
-static void EscHal(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-	MGAPtr pMGA = MGAPTR(pScrn);
-
-	if(pMGA->HALLoaded)
-		strcpy(sResult, "YES");
-	else
-		strcpy(sResult, "NO");
-
-}
-
-static void EscTest(ScrnInfoPtr pScrn, unsigned long *param, char
-*sResult, DisplayModePtr pMode)
-{
-	strcpy(sResult, "YES");
-}
-
-static void EscMerged(ScrnInfoPtr pScrn, unsigned long *param, char
-*sResult, DisplayModePtr pMode)
-{
-	strcpy(sResult, "YES");
-}
-
-static void  EscRead(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    ULONG  ulSource, ulAddr, ulData;
-    UCHAR  ucIndex;
-
-    if ( (param[0] & 0xffff) < 2 )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-
-    ulSource = param[1] >> 16;
-    ulAddr = param[1] & 0xffff;
-
-
-    switch( ulSource )
-    {
-    case 0:
-        ulData = INREG(ulAddr);
-        sprintf(sResult, "MGA[%04X] = 0x%08X", ulAddr, ulData);
-        break;
-    case 1:
-        ucIndex = INREG8(0x3c00);
-        OUTREG8(0x3c00, (UCHAR)ulAddr);
-        ulData = (ULONG)INREG8(0x3c0a);
-        OUTREG8(0x3c00, ucIndex);
-        sprintf(sResult, "DAC[%02X] = 0x%02X", ulAddr, ulData);
-        break;
-    case 2:
-        ucIndex = INREG8(0x1fd4);
-        OUTREG8(0x1fd4, (UCHAR)ulAddr);
-        ulData = (ULONG)INREG8(0x1fd5);
-        OUTREG8(0x1fd4, ucIndex);
-        sprintf(sResult, "CRTC[%02X] = 0x%02X", ulAddr, ulData);
-        break;
-    case 3:
-        ucIndex = INREG8(0x1fde);
-        OUTREG8(0x1fde, (UCHAR)ulAddr);
-        ulData = (ULONG)INREG8(0x1fdf);
-        OUTREG8(0x1fde, ucIndex);
-        sprintf(sResult, "CRTCEXT[%02X] = 0x%02X", ulAddr, ulData);
-        break;
-    default:
-        strcpy(sResult, "ERROR# 2");
-        break;
-    }
-}
-
-static void  EscWrite(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    ULONG  ulSource, ulAddr, ulData;
-    UCHAR  ucIndex;
-
-    if ( (param[0] & 0xffff) < 3 )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    ulSource = param[1] >> 16;
-    ulAddr = param[1] & 0xffff;
-    ulData = param[2];
-
-
-    switch( ulSource )
-    {
-    case 0:
-        OUTREG(ulAddr, ulData);
-        strcpy(sResult, "OK");
-        break;
-    case 1:
-        ucIndex = INREG8(0x3c00);
-        OUTREG8(0x3c00, (UCHAR)ulAddr);
-        OUTREG8(0x3c0a, (UCHAR)ulData);
-        OUTREG8(0x3c00, ucIndex);
-        strcpy(sResult, "OK");
-        break;
-    case 2:
-        ucIndex = INREG8(0x1fd4);
-        OUTREG8(0x1fd4, (UCHAR)ulAddr);
-        OUTREG8(0x1fd5, (UCHAR)ulData);
-        OUTREG8(0x1fd4, ucIndex);
-        strcpy(sResult, "OK");
-        break;
-    case 3:
-        ucIndex = INREG8(0x1fde);
-        OUTREG8(0x1fde, (UCHAR)ulAddr);
-        OUTREG8(0x1fdf, (UCHAR)ulData);
-        OUTREG8(0x1fde, ucIndex);
-        strcpy(sResult, "OK");
-        break;
-    default:
-        strcpy(sResult, "ERROR# 2");
-        break;
-    }
-}
-
-static void  EscHLeft(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    LPMGAMODEINFO pModeInfo;
-
-    pModeInfo = GetModeInfoPtr(param[0] >> 16);
-
-    if ( !pMgaModeInfo )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-
-    if (pModeInfo->ulHBPorch > (8 * param[1]) )
-    {
-        pModeInfo->ulHBPorch -=8 * param[1];
-        pModeInfo->ulHFPorch +=8 * param[1];
-        MGASetMode(pMga->pBoard, pModeInfo);
-    }
-
-    MGAFillDisplayModeStruct(pMode, pModeInfo);
-
-    GetVideoParameterStr(pModeInfo, sResult);
-}
-
-
-static void  EscHRight(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    LPMGAMODEINFO pModeInfo;
-
-    pModeInfo = GetModeInfoPtr(param[0] >> 16);
-
-    if ( !pMgaModeInfo )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    if (pModeInfo->ulHFPorch > (8 * param[1]) )
-    {
-        pModeInfo->ulHFPorch -=8 * param[1];
-        pModeInfo->ulHBPorch +=8 * param[1];
-        MGASetMode(pMga->pBoard, pModeInfo);
-    }
-
-    MGAFillDisplayModeStruct(pMode, pModeInfo);
-
-    GetVideoParameterStr(pModeInfo, sResult);
-}
-
-
-
-static void  EscVUp(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    LPMGAMODEINFO pModeInfo;
-
-    pModeInfo = GetModeInfoPtr(param[0] >> 16);
-
-    if ( !pMgaModeInfo )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    if (pModeInfo->ulVBPorch > (param[1]) )
-    {
-        pModeInfo->ulVBPorch -= param[1];
-        pModeInfo->ulVFPorch += param[1];
-        MGASetMode(pMga->pBoard, pModeInfo);
-    }
-
-    MGAFillDisplayModeStruct(pMode, pModeInfo);
-
-    GetVideoParameterStr(pModeInfo, sResult);
-}
-
-
-static void  EscVDown(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    LPMGAMODEINFO pModeInfo;
-
-    pModeInfo = GetModeInfoPtr(param[0] >> 16);
-
-    if ( !pMgaModeInfo )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    if (pModeInfo->ulVFPorch >= (param[1]) )
-    {
-        pModeInfo->ulVFPorch -= param[1];
-        pModeInfo->ulVBPorch += param[1];
-        MGASetMode(pMga->pBoard, pModeInfo);
-    }
-
-    MGAFillDisplayModeStruct(pMode, pModeInfo);
-
-    GetVideoParameterStr(pModeInfo, sResult);
-}
-
-
-static void EscHLarger(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    LPMGAMODEINFO pModeInfo;
-    float fRefresh, fPixelClock;
-    ULONG ulStep;
-
-    pModeInfo = GetModeInfoPtr(param[0] >> 16);
-
-    if ( !pMgaModeInfo )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    if ((param[0] & 0xffff) > 1)
-    {
-
-        ulStep = param[1] * 8;
-    }
-    else
-    {
-
-        ulStep = 8;
-    }
-
-    fRefresh = GetVRefresh(pModeInfo);
-    fPixelClock = (float)pModeInfo->ulPixClock;
-    if (pModeInfo->ulHBPorch >= ulStep )
-    {
-        pModeInfo->ulHBPorch -= ulStep;
-    }
-    else
-    {
-        pModeInfo->ulHBPorch = 0;
-    }
-    pModeInfo->ulPixClock = (ULONG)( (fRefresh * fPixelClock) / GetVRefresh(pModeInfo));
-    MGASetMode(pMga->pBoard, pModeInfo);
-
-    MGAFillDisplayModeStruct(pMode, pModeInfo);
-
-    GetVideoParameterStr(pModeInfo, sResult);
-}
-
-
-static void EscHSmaller(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    LPMGAMODEINFO pModeInfo;
-    float fRefresh, fPixelClock;
-    ULONG ulStep;
-
-    pModeInfo = GetModeInfoPtr(param[0] >> 16);
-
-    if ( !pMgaModeInfo )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    if ((param[0] & 0xffff) > 1)
-    {
-
-        ulStep = param[1] * 8;
-    }
-    else
-    {
-
-        ulStep = 8;
-    }
-
-
-    fRefresh = GetVRefresh(pModeInfo);
-    fPixelClock = (float)pModeInfo->ulPixClock;
-    pModeInfo->ulHBPorch += ulStep;
-    pModeInfo->ulPixClock = (ULONG)( (fRefresh * fPixelClock) / GetVRefresh(pModeInfo));
-
-    MGASetMode(pMga->pBoard, pModeInfo);
-
-    MGAFillDisplayModeStruct(pMode, pModeInfo);
-
-    GetVideoParameterStr(pModeInfo, sResult);
-}
-
-static void EscVTaller(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    LPMGAMODEINFO pModeInfo;
-    float fRefresh, fPixelClock;
-    ULONG ulStep;
-
-    pModeInfo = GetModeInfoPtr(param[0] >> 16);
-
-    if ( !pMgaModeInfo )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    if ((param[0] & 0xffff) > 1)
-    {
-
-        ulStep = param[1];
-    }
-    else
-    {
-
-        ulStep = 1;
-    }
-
-    fRefresh = GetVRefresh(pModeInfo);
-    fPixelClock = (float)pModeInfo->ulPixClock;
-
-    if (pModeInfo->ulVBPorch >= ulStep )
-    {
-        pModeInfo->ulVBPorch -= ulStep;
-    }
-    else
-    {
-        pModeInfo->ulVBPorch = 0;
-    }
-
-    pModeInfo->ulPixClock = (ULONG)( (fRefresh * fPixelClock) / GetVRefresh(pModeInfo));
-    MGASetMode(pMga->pBoard, pModeInfo);
-
-    MGAFillDisplayModeStruct(pMode, pModeInfo);
-
-    GetVideoParameterStr(pModeInfo, sResult);
-}
-
-static void EscVSmaller(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    LPMGAMODEINFO pModeInfo;
-    float fRefresh, fPixelClock;
-    ULONG ulStep;
-
-    pModeInfo = GetModeInfoPtr(param[0] >> 16);
-
-    if ( !pMgaModeInfo )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    if ((param[0] & 0xffff) > 1)
-    {
-
-        ulStep = param[1];
-    }
-    else
-    {
-
-        ulStep = 1;
-    }
-
-
-    fRefresh = GetVRefresh(pModeInfo);
-    fPixelClock = (float)pModeInfo->ulPixClock;
-    pModeInfo->ulVFPorch += ulStep;
-    pModeInfo->ulPixClock = (ULONG)( (fRefresh * fPixelClock) / GetVRefresh(pModeInfo));
-    MGASetMode(pMga->pBoard, pModeInfo);
-
-    MGAFillDisplayModeStruct(pMode, pModeInfo);
-
-    GetVideoParameterStr(pModeInfo, sResult);
-}
-
-
-static void EscRefresh(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-    LPMGAMODEINFO pModeInfo;
-    float fRefresh, fPixelClock;
-
-    pModeInfo = GetModeInfoPtr(param[0] >> 16);
-
-    if ( !pMgaModeInfo )
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    if ((param[0] & 0xffff) < 2)
-    {
-        strcpy(sResult, "#error 1");
-        return;
-    }
-
-    fRefresh = GetVRefresh(pModeInfo);
-
-    fPixelClock = (float)pModeInfo->ulPixClock;
-    pModeInfo->ulPixClock = (ULONG)( ((float)param[1] * fPixelClock) / fRefresh);
-
-    pModeInfo->ulRefreshRate = param[1];
-
-    MGASetMode(pMga->pBoard, pModeInfo);
-
-    MGAFillDisplayModeStruct(pMode, pModeInfo);
-
-    GetVideoParameterStr(pModeInfo, sResult);
-}
-
-static void EscRestoreVidParm(ScrnInfoPtr pScrn, unsigned long *param, char *sResult, DisplayModePtr pMode)
-{
-    MGAPtr pMga = MGAPTR(pScrn);
-
-    TmpMgaModeInfo[param[0] >> 16].ulDispWidth = 0;
-    MGASetMode(pMga->pBoard, pMgaModeInfo[param[0] >> 16]);
-
-    MGAFillDisplayModeStruct(pMode, pMgaModeInfo[param[0] >> 16]);
-
-    GetVideoParameterStr(pMgaModeInfo[param[0] >> 16], sResult);
-}
-
-static Bool convertNumber(unsigned long *pulNumber, char *sNumber)
-{
-    unsigned long i, ulDigit, shiftHex;
-    Bool bResult = TRUE;
-
-    if (sNumber == NULL)
-    {
-        return FALSE;
-    }
-
-
-    /* Convert number */
-    if ( (sNumber[0] == '0') && (sNumber[1] == 'x') )
-    {
-        shiftHex = 0;
-        *pulNumber = 0;
-
-        for (i = strlen(sNumber) - 1; i > 1; i--)
-        {
-            if (shiftHex > 28)
-            {
-                bResult = FALSE;
-                break;
-            }
-
-            if ( !isxdigit(sNumber[i]) )
-            {
-                bResult = FALSE;
-                break;
-            }
-
-            ulDigit = toupper(sNumber[i]) - '0';
-            if (ulDigit > 9)
-            {
-                ulDigit -= 7;
-            }
-            *pulNumber += ulDigit << shiftHex;
-            shiftHex += 4;
-        }
-    }
-    else
-    {
-        for (i = 0; i < strlen(sNumber); i++)
-        {
-            if ( !isdigit(sNumber[i]) )
-            {
-                bResult = FALSE;
-                break;
-            }
-        }
-        *pulNumber = atoi(sNumber);
-    }
-
-    return bResult;
-}
-
-static Bool GetEscCommand(char *cmdline, EscCmdStruct *escCmd)
-{
-    unsigned long i, paramIndex, ulHI;
-    Bool bResult;
-    char *pParameter, *function;
-
-    bResult = TRUE; /* success */
-
-    function = strtok(cmdline, " \t\n,");
-
-
-    escCmd->parameters[0] = 0;
-    if (function)
-    {
-        /* Find Screen */
-        if (function[1] == ':' )
-        {
-            escCmd->parameters[0] = (unsigned long)(function[0] - '0') << 16;
-            strncpy(escCmd->function, function+2, 32);
-        }
-        else
-        {
-            strncpy(escCmd->function, function, 32);
-        }
-
-    }
-    else
-    {
-        strcpy(escCmd->function, "#ERROR -1");
-        escCmd->parameters[0] = 0;
-        return FALSE;
-    }
-
-    paramIndex = 1;
-    while ( (pParameter = strtok(NULL, " \t\n,")) != NULL )
-    {
-        if (paramIndex > 31)
-        {
-            /* 32 parameters supported */
-            break;
-        }
-
-        i = 0;
-        while(pParameter[i] && pParameter[i] != ':')
-        {
-            i++;
-        }
-
-        if ( pParameter[i] )
-        {
-            pParameter[i] = '\0';
-            bResult  = convertNumber(&escCmd->parameters[paramIndex], &pParameter[i+1]);
-            bResult |= convertNumber(&ulHI, pParameter);
-            escCmd->parameters[paramIndex] &= 0xffff;
-            escCmd->parameters[paramIndex] += ulHI << 16;
-            pParameter[i] = ':';
-        }
-        else
-        {
-            bResult = convertNumber(&escCmd->parameters[paramIndex], pParameter);
-        }
-
-
-        if (!bResult)
-        {
-            break;
-        }
-        paramIndex++;
-    }
-
-    escCmd->parameters[0] += paramIndex;
-    return bResult;
-
-}
-
-void MGAExecuteEscCmd(ScrnInfoPtr pScrn, char *cmdline , char *sResult, DisplayModePtr pMode)
-{
-    int i = 0;
-    int ulScreen = 0;
-    MGAPtr pMga = MGAPTR(pScrn);
-    EscCmdStruct EscCmd;
-
-    if (pMga->SecondCrtc)
-    {
-	ulScreen = 1;
-    }
-    else
-    {
-	ulScreen = 0;
-    }
-
-
-    if (FunctionTable[0].function &&  GetEscCommand(cmdline,  &EscCmd) )
-    {
-        i = 0;
-
-        while ( FunctionTable[i].function && strcmp(FunctionTable[i].function, EscCmd.function) )
-        {
-            i++;
-        }
-
-        if (FunctionTable[i].function)
-        {
-	    EscCmd.parameters[0] &= 0xffff;
-	    EscCmd.parameters[0] |= ulScreen << 16;
-
-            FunctionTable[i].funcptr(pScrn, EscCmd.parameters, sResult, pMode);
-        }
-        else
-        {
-            strcpy(sResult, "error# -1");
-        }
-    }
-    else
-    {
-        strcpy(sResult, "error# -1");
-    }
-}
-#else
 int mga_foo;
-#endif
diff --git a/src/mga_macros.h b/src/mga_macros.h
index bffd063..130651d 100644
--- a/src/mga_macros.h
+++ b/src/mga_macros.h
@@ -74,18 +74,7 @@ while(INREG(MGAREG_DWGSYNC) != MGA_SYNC_XTAG) ; \
 #define CHECK_DMA_QUIESCENT(pMGA, pScrn)
 #endif
 
-#ifdef USEMGAHAL
-#define MGA_HAL(x) { \
-	MGAPtr pMga = MGAPTR(pScrn); \
-	if (pMga->HALLoaded && pMga->chip_attribs->HAL_chipset) { x; } \
-}
-#define MGA_NOT_HAL(x) { \
-	MGAPtr pMga = MGAPTR(pScrn); \
-	if (!pMga->HALLoaded || !pMga->chip_attribs->HAL_chipset) { x; } \
-}
-#else
 #define MGA_NOT_HAL(x) { x; }
-#endif
 
 #define MGAISGx50(x) ((x)->is_Gx50)
 
diff --git a/src/mga_merge.c b/src/mga_merge.c
index 1fd0572..2affe3b 100644
--- a/src/mga_merge.c
+++ b/src/mga_merge.c
@@ -236,9 +236,6 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
     int i;
     char* s;
     ClockRangePtr clockRanges;
-#ifdef USEMGAHAL
-    ULONG status;
-#endif
     MgaScrn2Rel Monitor2Pos;
 
     xf86DrvMsg(pScrn1->scrnIndex, X_INFO, "==== Start of second screen initialization ====\n");
@@ -252,9 +249,6 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
     }
 
     pMga = MGAPTR(pScrn);
-#ifdef USEMGAHAL
-    pMga->pMgaModeInfo = NULL; /*will be allocated later if NULL*/ 
-#endif
     pMga1 = MGAPTR(pScrn1);
     pMga1->pScrn2 = pScrn;
   
@@ -456,10 +450,6 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
     clockRanges->clockIndex = -1;		/* programmable */
     clockRanges->interlaceAllowed = TRUE;
     clockRanges->doubleScanAllowed = TRUE;
-#ifdef USEMGAHAL
-    MGA_HAL(clockRanges->interlaceAllowed = FALSE);
-    MGA_HAL(clockRanges->doubleScanAllowed = FALSE);
-#endif
     clockRanges->interlaceAllowed = FALSE; /*no interlace on CRTC2 */
 
     clockRanges->ClockMulFactor = 1;
@@ -562,30 +552,6 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
 	MGAFreeRec(pScrn);
 	return FALSE;
     }
-#ifdef USEMGAHAL
-    MGA_HAL(
-
-    pMga->pBoard = pMga1->pBoard;
-    pMga->pClientStruct = pMga1->pClientStruct;
-    pMga->pMgaHwInfo = pMga1->pMgaHwInfo;
-
-
-    MGAFillModeInfoStruct(pScrn,NULL);
-    /* Fields usually handled by MGAFillModeInfoStruct, but are unavailable
-     * because no mode is given
-     */
-    pMga->pMgaModeInfo->ulDispWidth = pScrn->virtualX;
-    pMga->pMgaModeInfo->ulDispHeight = pScrn->virtualY;
-    
-    if((status = MGAValidateMode(pMga->pBoard,pMga->pMgaModeInfo)) != 0) {
-	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		   "MGAValidateMode from HALlib found the mode to be invalid.\n"
-		   "\tError: 0x%lx\n", status);
-        return FALSE;
-    }
-    pScrn->displayWidth = pMga->pMgaModeInfo->ulFBPitch;
-    );	/* MGA_HAL */
-#endif
 
     /*
      * Set the CRTC parameters for all of the modes based on the type
@@ -595,9 +561,6 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
      * driver and if the driver doesn't provide code to set them.  They
      * are not pre-initialised at all.
      */
-#ifdef USEMGAHAL
-    MGA_HAL(xf86SetCrtcForModes(pScrn, 0));
-#endif
     MGA_NOT_HAL(xf86SetCrtcForModes(pScrn, INTERLACE_HALVE_V));
 
     /* Set the current mode to the first in the list */
--
cgit v0.9.0.2-2-gbebe
From ee09a9a340f8946f2d4a71a431b64189dbb5c256 Mon Sep 17 00:00:00 2001
From: Matt Turner <mattst88@gmail.com>
Date: Tue, 27 Sep 2011 02:22:09 +0000
Subject: Remove xalloc/xcalloc/xrealloc/xfree

Reviewed-by: Jamey Sharp <jamey@minilop.net>
Signed-off-by: Matt Turner <mattst88@gmail.com>
---
diff --git a/src/mga_dga.c b/src/mga_dga.c
index d43b96d..224e4ba 100644
--- a/src/mga_dga.c
+++ b/src/mga_dga.c
@@ -111,7 +111,7 @@ SECOND_PASS:
 	    if(secondPitch)
 		pitch = secondPitch; 
 
-	    if(!(newmodes = xrealloc(modes, (*num + 1) * sizeof(DGAModeRec))))
+	    if(!(newmodes = realloc(modes, (*num + 1) * sizeof(DGAModeRec))))
 		break;
 
 	    modes = newmodes;
diff --git a/src/mga_dri.c b/src/mga_dri.c
index 14f342f..957c6df 100644
--- a/src/mga_dri.c
+++ b/src/mga_dri.c
@@ -91,24 +91,24 @@ static Bool MGAInitVisualConfigs( ScreenPtr pScreen )
    case 16:
       numConfigs = 8;
 
-      pConfigs = (__GLXvisualConfig*)xcalloc( sizeof(__GLXvisualConfig),
+      pConfigs = (__GLXvisualConfig*)calloc( sizeof(__GLXvisualConfig),
 						numConfigs );
       if ( !pConfigs ) {
 	 return FALSE;
       }
 
-      pMGAConfigs = (MGAConfigPrivPtr)xcalloc( sizeof(MGAConfigPrivRec),
+      pMGAConfigs = (MGAConfigPrivPtr)calloc( sizeof(MGAConfigPrivRec),
 						 numConfigs );
       if ( !pMGAConfigs ) {
-	 xfree( pConfigs );
+	 free(pConfigs);
 	 return FALSE;
       }
 
-      pMGAConfigPtrs = (MGAConfigPrivPtr*)xcalloc( sizeof(MGAConfigPrivPtr),
+      pMGAConfigPtrs = (MGAConfigPrivPtr*)calloc( sizeof(MGAConfigPrivPtr),
 						     numConfigs );
       if ( !pMGAConfigPtrs ) {
-	 xfree( pConfigs );
-	 xfree( pMGAConfigs );
+	 free(pConfigs);
+	 free(pMGAConfigs);
 	 return FALSE;
       }
 
@@ -182,24 +182,24 @@ static Bool MGAInitVisualConfigs( ScreenPtr pScreen )
    case 32:
       numConfigs = 8;
 
-      pConfigs = (__GLXvisualConfig*)xcalloc( sizeof(__GLXvisualConfig),
+      pConfigs = (__GLXvisualConfig*)calloc( sizeof(__GLXvisualConfig),
 						numConfigs );
       if ( !pConfigs ) {
 	 return FALSE;
       }
 
-      pMGAConfigs = (MGAConfigPrivPtr)xcalloc( sizeof(MGAConfigPrivRec),
+      pMGAConfigs = (MGAConfigPrivPtr)calloc( sizeof(MGAConfigPrivRec),
 						 numConfigs );
       if ( !pMGAConfigs ) {
-	 xfree( pConfigs );
+	 free(pConfigs);
 	 return FALSE;
       }
 
-      pMGAConfigPtrs = (MGAConfigPrivPtr*)xcalloc( sizeof(MGAConfigPrivPtr),
+      pMGAConfigPtrs = (MGAConfigPrivPtr*)calloc( sizeof(MGAConfigPrivPtr),
 						     numConfigs );
       if ( !pMGAConfigPtrs ) {
-	 xfree( pConfigs );
-	 xfree( pMGAConfigs );
+	 free(pConfigs);
+	 free(pMGAConfigs);
 	 return FALSE;
       }
 
@@ -973,11 +973,11 @@ static void MGADRIMoveBuffersXAA(WindowPtr pParent, DDXPointRec ptOldOrg,
 
         if (nbox>1) {
 	    /* Keep ordering in each band, reverse order of bands */
-	    pboxNew1 = (BoxPtr)xalloc(sizeof(BoxRec)*nbox);
+	    pboxNew1 = (BoxPtr)malloc(sizeof(BoxRec)*nbox);
 	    if (!pboxNew1) return;
-	    pptNew1 = (DDXPointPtr)xalloc(sizeof(DDXPointRec)*nbox);
+	    pptNew1 = (DDXPointPtr)malloc(sizeof(DDXPointRec)*nbox);
 	    if (!pptNew1) {
-	        xfree(pboxNew1);
+	        free(pboxNew1);
 	        return;
 	    }
 	    pboxBase = pboxNext = pbox+nbox-1;
@@ -1008,14 +1008,14 @@ static void MGADRIMoveBuffersXAA(WindowPtr pParent, DDXPointRec ptOldOrg,
 
         if (nbox > 1) {
 	    /*reverse orderof rects in each band */
-	    pboxNew2 = (BoxPtr)xalloc(sizeof(BoxRec)*nbox);
-	    pptNew2 = (DDXPointPtr)xalloc(sizeof(DDXPointRec)*nbox);
+	    pboxNew2 = (BoxPtr)malloc(sizeof(BoxRec)*nbox);
+	    pptNew2 = (DDXPointPtr)malloc(sizeof(DDXPointRec)*nbox);
 	    if (!pboxNew2 || !pptNew2) {
-	        if (pptNew2) xfree(pptNew2);
-	        if (pboxNew2) xfree(pboxNew2);
+	        if (pptNew2) free(pptNew2);
+	        if (pboxNew2) free(pboxNew2);
 	        if (pboxNew1) {
-		    xfree(pptNew1);
-		    xfree(pboxNew1);
+		    free(pptNew1);
+		    free(pboxNew1);
 		}
 	       return;
 	    }
@@ -1066,12 +1066,12 @@ static void MGADRIMoveBuffersXAA(WindowPtr pParent, DDXPointRec ptOldOrg,
     MGASelectBuffer(pScrn, MGA_FRONT);
 
     if (pboxNew2) {
-        xfree(pptNew2);
-        xfree(pboxNew2);
+        free(pptNew2);
+        free(pboxNew2);
     }
     if (pboxNew1) {
-        xfree(pptNew1);
-        xfree(pboxNew1);
+        free(pptNew1);
+        free(pboxNew1);
     }
 
     pMga->AccelInfoRec->NeedToSync = TRUE;
@@ -1150,7 +1150,7 @@ Bool MGADRIScreenInit( ScreenPtr pScreen )
    if (xf86LoaderCheckSymbol("DRICreatePCIBusID")) {
       pDRIInfo->busIdString = DRICreatePCIBusID(pMga->PciInfo);
    } else {
-      pDRIInfo->busIdString = xalloc(64);
+      pDRIInfo->busIdString = malloc(64);
       sprintf( pDRIInfo->busIdString, "PCI:%d:%d:%d",
 #ifdef XSERVER_LIBPCIACCESS
 	       ((pMga->PciInfo->domain << 8) | pMga->PciInfo->bus),
@@ -1198,7 +1198,7 @@ Bool MGADRIScreenInit( ScreenPtr pScreen )
 
    pDRIInfo->SAREASize = SAREA_MAX;
 
-   pMGADRI = (MGADRIPtr)xcalloc( sizeof(MGADRIRec), 1 );
+   pMGADRI = (MGADRIPtr)calloc( sizeof(MGADRIRec), 1 );
    if ( !pMGADRI ) {
       DRIDestroyInfoRec( pMga->pDRIInfo );
       pMga->pDRIInfo = 0;
@@ -1208,9 +1208,9 @@ Bool MGADRIScreenInit( ScreenPtr pScreen )
    }
 
    pMGADRIServer = (MGADRIServerPrivatePtr)
-      xcalloc( sizeof(MGADRIServerPrivateRec), 1 );
+      calloc( sizeof(MGADRIServerPrivateRec), 1 );
    if ( !pMGADRIServer ) {
-      xfree( pMGADRI );
+      free( pMGADRI );
       DRIDestroyInfoRec( pMga->pDRIInfo );
       pMga->pDRIInfo = 0;
       xf86DrvMsg( pScrn->scrnIndex, X_ERROR,
@@ -1249,9 +1249,9 @@ Bool MGADRIScreenInit( ScreenPtr pScreen )
    pDRIInfo->bufferRequests = DRI_ALL_WINDOWS;
 
    if ( !DRIScreenInit( pScreen, pDRIInfo, &pMga->drmFD ) ) {
-      xfree( pMGADRIServer );
+      free( pMGADRIServer );
       pMga->DRIServerInfo = 0;
-      xfree( pDRIInfo->devPrivate );
+      free( pDRIInfo->devPrivate );
       pDRIInfo->devPrivate = 0;
       DRIDestroyInfoRec( pMga->pDRIInfo );
       pMga->pDRIInfo = 0;
@@ -1495,20 +1495,20 @@ void MGADRICloseScreen( ScreenPtr pScreen )
 
    if ( pMga->pDRIInfo ) {
       if ( pMga->pDRIInfo->devPrivate ) {
-	 xfree( pMga->pDRIInfo->devPrivate );
+	 free( pMga->pDRIInfo->devPrivate );
 	 pMga->pDRIInfo->devPrivate = 0;
       }
       DRIDestroyInfoRec( pMga->pDRIInfo );
       pMga->pDRIInfo = 0;
    }
    if ( pMga->DRIServerInfo ) {
-      xfree( pMga->DRIServerInfo );
+      free(pMga->DRIServerInfo);
       pMga->DRIServerInfo = 0;
    }
    if ( pMga->pVisualConfigs ) {
-      xfree( pMga->pVisualConfigs );
+      free(pMga->pVisualConfigs);
    }
    if ( pMga->pVisualConfigsPriv ) {
-      xfree( pMga->pVisualConfigsPriv );
+      free( pMga->pVisualConfigsPriv );
    }
 }
diff --git a/src/mga_driver.c b/src/mga_driver.c
index d770031..d4ae346 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -646,7 +646,7 @@ MGAFreeRec(ScrnInfoPtr pScrn)
 {
     if (pScrn->driverPrivate == NULL)
 	return;
-    xfree(pScrn->driverPrivate);
+    free(pScrn->driverPrivate);
     pScrn->driverPrivate = NULL;
 }
 
@@ -813,7 +813,7 @@ MGAProbe(DriverPtr drv, int flags)
 			            MGAChipsets, MGAPciChipsets, devSections,
 			            numDevSections, drv, &usedChips);
     /* Free it since we don't need that list after this */
-    xfree(devSections);
+    free(devSections);
     if (numUsed <= 0)
 	return FALSE;
 
@@ -971,7 +971,7 @@ MGAProbe(DriverPtr drv, int flags)
 	    }
         }
     }
-    xfree(usedChips);
+    free(usedChips);
 
     return foundScreen;
 }
@@ -1715,7 +1715,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 #endif
     }
 
-    if (!(pMga->Options = xalloc(sizeof(MGAOptions))))
+    if (!(pMga->Options = malloc(sizeof(MGAOptions))))
 	return FALSE;
     memcpy(pMga->Options, MGAOptions, sizeof(MGAOptions));
 
@@ -2384,7 +2384,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
         switch(pMga->Chipset) {
 	case PCI_CHIP_MGA2064:
 	   if (!pMga->NoAccel) {
-		linePitches = xalloc(sizeof(Pitches1));
+		linePitches = malloc(sizeof(Pitches1));
 		memcpy(linePitches, Pitches1, sizeof(Pitches1));
 		minPitch = maxPitch = 0;
 	   }
@@ -2393,7 +2393,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 	case PCI_CHIP_MGA2164_AGP:
 	case PCI_CHIP_MGA1064:
 	   if (!pMga->NoAccel) {
-		linePitches = xalloc(sizeof(Pitches2));
+		linePitches = malloc(sizeof(Pitches2));
 		memcpy(linePitches, Pitches2, sizeof(Pitches2));
 		minPitch = maxPitch = 0;
 	   }
@@ -2431,7 +2431,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 			      LOOKUP_BEST_REFRESH);
       
 	if (linePitches)
-	   xfree(linePitches);
+	   free(linePitches);
     }
 
     if (i < 1 && pMga->FBDev) {
@@ -3294,7 +3294,7 @@ MGAScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 
     if(pMga->ShadowFB) {
  	pMga->ShadowPitch = BitmapBytePad(pScrn->bitsPerPixel * width);
-	pMga->ShadowPtr = xalloc(pMga->ShadowPitch * height);
+	pMga->ShadowPtr = malloc(pMga->ShadowPitch * height);
 	displayWidth = pMga->ShadowPitch / (pScrn->bitsPerPixel >> 3);
         FBStart = pMga->ShadowPtr;
     } else {
@@ -3745,21 +3745,21 @@ MGACloseScreen(int scrnIndex, ScreenPtr pScreen)
 #ifdef USE_EXA
     if (pMga->ExaDriver) {
 	exaDriverFini(pScreen);
-	xfree(pMga->ExaDriver);
+	free(pMga->ExaDriver);
     }
 #endif
     if (pMga->CursorInfoRec)
     	xf86DestroyCursorInfoRec(pMga->CursorInfoRec);
     if (pMga->ShadowPtr)
-	xfree(pMga->ShadowPtr);
+	free(pMga->ShadowPtr);
     if (pMga->DGAModes)
-	xfree(pMga->DGAModes);
+	free(pMga->DGAModes);
     if (pMga->adaptor)
-	xfree(pMga->adaptor);
+	free(pMga->adaptor);
     if (pMga->portPrivate)
-	xfree(pMga->portPrivate);
+	free(pMga->portPrivate);
     if (pMga->ScratchBuffer)
-	xfree(pMga->ScratchBuffer);
+	free(pMga->ScratchBuffer);
 
     pScrn->vtSema = FALSE;
 
diff --git a/src/mga_merge.c b/src/mga_merge.c
index 2affe3b..e3216c9 100644
--- a/src/mga_merge.c
+++ b/src/mga_merge.c
@@ -70,9 +70,9 @@ CopyModeNLink(ScrnInfoPtr pScrn, DisplayModePtr dest, DisplayModePtr i, DisplayM
     DisplayModePtr mode;
     int dx = 0,dy = 0;
     /* start with first node */
-    mode = xalloc(sizeof(DisplayModeRec));
+    mode = malloc(sizeof(DisplayModeRec));
     memcpy(mode,i, sizeof(DisplayModeRec));
-    mode->Private = xalloc(sizeof(MergedDisplayModeRec));
+    mode->Private = malloc(sizeof(MergedDisplayModeRec));
     ((MergedDisplayModePtr)mode->Private)->Monitor1 = i;
     ((MergedDisplayModePtr)mode->Private)->Monitor2 = j;
     ((MergedDisplayModePtr)mode->Private)->Monitor2Pos = srel;
@@ -239,7 +239,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
     MgaScrn2Rel Monitor2Pos;
 
     xf86DrvMsg(pScrn1->scrnIndex, X_INFO, "==== Start of second screen initialization ====\n");
-    pScrn = xalloc(sizeof(ScrnInfoRec));
+    pScrn = malloc(sizeof(ScrnInfoRec));
     memcpy(pScrn,pScrn1,sizeof(ScrnInfoRec));
    
     pScrn->driverPrivate = NULL; 
@@ -270,7 +270,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
 
     /* Set pScrn->monitor */
     {
-        pScrn->monitor = xalloc(sizeof(MonRec));
+        pScrn->monitor = malloc(sizeof(MonRec));
         /* copy everything we don't care about */
         memcpy(pScrn->monitor,pScrn1->monitor,sizeof(MonRec));
         pScrn->monitor->DDC = NULL;   /*FIXME:have to try this */ 
@@ -484,7 +484,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
         switch(pMga->Chipset) {
 	case PCI_CHIP_MGA2064:
 	   if (!pMga->NoAccel) {
-		linePitches = xalloc(sizeof(Pitches1));
+		linePitches = malloc(sizeof(Pitches1));
 		memcpy(linePitches, Pitches1, sizeof(Pitches1));
 		minPitch = maxPitch = 0;
 	   }
@@ -493,7 +493,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
 	case PCI_CHIP_MGA2164_AGP:
 	case PCI_CHIP_MGA1064:
 	   if (!pMga->NoAccel) {
-		linePitches = xalloc(sizeof(Pitches2));
+		linePitches = malloc(sizeof(Pitches2));
 		memcpy(linePitches, Pitches2, sizeof(Pitches2));
 		minPitch = maxPitch = 0;
 	   }
@@ -529,7 +529,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
 			      LOOKUP_BEST_REFRESH);
         
 	if (linePitches)
-	   xfree(linePitches);
+	   free(linePitches);
     }
 
 
@@ -881,10 +881,10 @@ MGACloseScreenMerged(int scrnIndex, ScreenPtr pScreen) {
     ScrnInfoPtr pScrn2 = pMga->pScrn2;
 
     if(pScrn2) {
-        xfree(pScrn2->monitor);
+        free(pScrn2->monitor);
         pScrn2->monitor = NULL;
 
-        xfree(pScrn2);
+        free(pScrn2);
         pMga->pScrn2 = NULL;
     }
 
@@ -893,8 +893,8 @@ MGACloseScreenMerged(int scrnIndex, ScreenPtr pScreen) {
         do {
             DisplayModePtr p = pScrn1->currentMode->next; 
             if(pScrn1->currentMode->Private) 
-                xfree(pScrn1->currentMode->Private);
-            xfree(pScrn1->currentMode);
+                free(pScrn1->currentMode->Private);
+            free(pScrn1->currentMode);
             pScrn1->currentMode = p;
         }while( pScrn1->currentMode != pScrn1->modes);
     }
diff --git a/src/mga_storm.c b/src/mga_storm.c
index db7fae7..f0e6194 100644
--- a/src/mga_storm.c
+++ b/src/mga_storm.c
@@ -583,7 +583,7 @@ Bool mgaAccelInit( ScreenPtr pScreen )
     BoxRec AvailFBArea;
     int i;
 
-    pMga->ScratchBuffer = xalloc(((pScrn->displayWidth * pMga->CurrentLayout.bitsPerPixel) + 127) >> 3);
+    pMga->ScratchBuffer = malloc(((pScrn->displayWidth * pMga->CurrentLayout.bitsPerPixel) + 127) >> 3);
     if(!pMga->ScratchBuffer) return FALSE;
 
     pMga->AccelInfoRec = infoPtr = XAACreateInfoRec();
diff --git a/src/mga_vga.c b/src/mga_vga.c
index 9f00b3d..0ac8bf7 100644
--- a/src/mga_vga.c
+++ b/src/mga_vga.c
@@ -197,17 +197,17 @@ MGAG200SESaveFonts(ScrnInfoPtr scrninfp, vgaRegPtr save)
     hwp->writeSeq(hwp, 0x04, 0x06); /* enable plane graphics */
     hwp->writeGr(hwp, 0x05, 0x00);  /* write mode 0, read mode 0 */
     hwp->writeGr(hwp, 0x06, 0x05);  /* set graphics */
-    if (hwp->FontInfo1 || (hwp->FontInfo1 = xalloc(FONT_AMOUNT))) {
+    if (hwp->FontInfo1 || (hwp->FontInfo1 = malloc(FONT_AMOUNT))) {
 	hwp->writeSeq(hwp, 0x02, 0x04); /* write to plane 2 */
 	hwp->writeGr(hwp, 0x04, 0x02);  /* read plane 2 */
 	slowbcopy_frombus(hwp->Base, hwp->FontInfo1, FONT_AMOUNT);
     }
-    if (hwp->FontInfo2 || (hwp->FontInfo2 = xalloc(FONT_AMOUNT))) {
+    if (hwp->FontInfo2 || (hwp->FontInfo2 = malloc(FONT_AMOUNT))) {
 	hwp->writeSeq(hwp, 0x02, 0x08); /* write to plane 3 */
 	hwp->writeGr(hwp, 0x04, 0x03);  /* read plane 3 */
 	slowbcopy_frombus(hwp->Base, hwp->FontInfo2, FONT_AMOUNT);
     }
-    if (hwp->TextInfo || (hwp->TextInfo = xalloc(2 * TEXT_AMOUNT))) {
+    if (hwp->TextInfo || (hwp->TextInfo = malloc(2 * TEXT_AMOUNT))) {
 	hwp->writeSeq(hwp, 0x02, 0x01); /* write to plane 0 */
 	hwp->writeGr(hwp, 0x04, 0x00);  /* read plane 0 */
 	slowbcopy_frombus(hwp->Base, hwp->TextInfo, TEXT_AMOUNT);
diff --git a/src/mga_video.c b/src/mga_video.c
index a69c973..beb5a3c 100644
--- a/src/mga_video.c
+++ b/src/mga_video.c
@@ -131,8 +131,8 @@ void MGAInitVideo(ScreenPtr pScreen)
 	    num_adaptors = 1;
 	    adaptors = &newAdaptor;
 	} else {
-	    newAdaptors =  /* need to free this someplace */
-		xalloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr*));
+	    /* need to free this someplace */
+	    newAdaptors = malloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr *));
 	    if(newAdaptors) {
 		memcpy(newAdaptors, adaptors, num_adaptors * 
 					sizeof(XF86VideoAdaptorPtr));
@@ -147,7 +147,7 @@ void MGAInitVideo(ScreenPtr pScreen)
         xf86XVScreenInit(pScreen, adaptors, num_adaptors);
 
     if(newAdaptors)
-	xfree(newAdaptors);
+	free(newAdaptors);
 }
 
 /* client libraries expect an encoding */
@@ -231,10 +231,10 @@ MGAAllocAdaptor(ScrnInfoPtr pScrn, Bool doublebuffer)
     if(!(adapt = xf86XVAllocateVideoAdaptorRec(pScrn)))
 	return NULL;
 
-    if(!(pPriv = xcalloc(1, sizeof(MGAPortPrivRec) + 
+    if(!(pPriv = calloc(1, sizeof(MGAPortPrivRec) +
 			(sizeof(DevUnion) * MGA_MAX_PORTS)))) 
     {
-	xfree(adapt);
+	free(adapt);
 	return NULL;
     }
 
@@ -1082,18 +1082,18 @@ MGAAllocateSurface(
     surface->width = w;
     surface->height = h;
 
-    if(!(surface->pitches = xalloc(sizeof(int)))) {
+    if(!(surface->pitches = malloc(sizeof(int)))) {
         MGAFreeMemory(pScrn, surface_memory);
 	return BadAlloc;
     }
-    if(!(surface->offsets = xalloc(sizeof(int)))) {
-	xfree(surface->pitches);
+    if(!(surface->offsets = malloc(sizeof(int)))) {
+	free(surface->pitches);
         MGAFreeMemory(pScrn, surface_memory);
 	return BadAlloc;
     }
-    if(!(pPriv = xalloc(sizeof(OffscreenPrivRec)))) {
-	xfree(surface->pitches);
-	xfree(surface->offsets);
+    if(!(pPriv = malloc(sizeof(OffscreenPrivRec)))) {
+	free(surface->pitches);
+	free(surface->offsets);
         MGAFreeMemory(pScrn, surface_memory);
 	return BadAlloc;
     }
@@ -1137,9 +1137,9 @@ MGAFreeSurface(
     if(pPriv->isOn)
 	MGAStopSurface(surface);
     MGAFreeMemory(pScrn, pPriv->surface_memory);
-    xfree(surface->pitches);
-    xfree(surface->offsets);
-    xfree(surface->devPrivate.ptr);
+    free(surface->pitches);
+    free(surface->offsets);
+    free(surface->devPrivate.ptr);
 
     return Success;
 }
@@ -1231,7 +1231,7 @@ MGAInitOffscreenImages(ScreenPtr pScreen)
     XF86OffscreenImagePtr offscreenImages;
 
     /* need to free this someplace */
-    if(!(offscreenImages = xalloc(num * sizeof(XF86OffscreenImageRec))))
+    if(!(offscreenImages = malloc(num * sizeof(XF86OffscreenImageRec))))
 	return;
 
     offscreenImages[0].image = &Images[0];
--
cgit v0.9.0.2-2-gbebe
From 1036e32e006d496023553ea566cb13ae93933719 Mon Sep 17 00:00:00 2001
From: Matt Turner <mattst88@gmail.com>
Date: Tue, 27 Sep 2011 02:35:48 +0000
Subject: Remove if(E != NULL) checks around free(E)

Reviewed-by: Jamey Sharp <jamey@minilop.net>
Signed-off-by: Matt Turner <mattst88@gmail.com>
---
diff --git a/src/mga_dri.c b/src/mga_dri.c
index 957c6df..1454994 100644
--- a/src/mga_dri.c
+++ b/src/mga_dri.c
@@ -1011,8 +1011,8 @@ static void MGADRIMoveBuffersXAA(WindowPtr pParent, DDXPointRec ptOldOrg,
 	    pboxNew2 = (BoxPtr)malloc(sizeof(BoxRec)*nbox);
 	    pptNew2 = (DDXPointPtr)malloc(sizeof(DDXPointRec)*nbox);
 	    if (!pboxNew2 || !pptNew2) {
-	        if (pptNew2) free(pptNew2);
-	        if (pboxNew2) free(pboxNew2);
+	        free(pptNew2);
+	        free(pboxNew2);
 	        if (pboxNew1) {
 		    free(pptNew1);
 		    free(pboxNew1);
@@ -1494,21 +1494,13 @@ void MGADRICloseScreen( ScreenPtr pScreen )
    DRICloseScreen( pScreen );
 
    if ( pMga->pDRIInfo ) {
-      if ( pMga->pDRIInfo->devPrivate ) {
-	 free( pMga->pDRIInfo->devPrivate );
-	 pMga->pDRIInfo->devPrivate = 0;
-      }
+      free(pMga->pDRIInfo->devPrivate);
+      pMga->pDRIInfo->devPrivate = 0;
       DRIDestroyInfoRec( pMga->pDRIInfo );
       pMga->pDRIInfo = 0;
    }
-   if ( pMga->DRIServerInfo ) {
-      free(pMga->DRIServerInfo);
-      pMga->DRIServerInfo = 0;
-   }
-   if ( pMga->pVisualConfigs ) {
-      free(pMga->pVisualConfigs);
-   }
-   if ( pMga->pVisualConfigsPriv ) {
-      free( pMga->pVisualConfigsPriv );
-   }
+   free(pMga->DRIServerInfo);
+   pMga->DRIServerInfo = 0;
+   free(pMga->pVisualConfigs);
+   free(pMga->pVisualConfigsPriv);
 }
diff --git a/src/mga_driver.c b/src/mga_driver.c
index d4ae346..dcbfabf 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -644,8 +644,6 @@ MGAGetRec(ScrnInfoPtr pScrn)
 void
 MGAFreeRec(ScrnInfoPtr pScrn)
 {
-    if (pScrn->driverPrivate == NULL)
-	return;
     free(pScrn->driverPrivate);
     pScrn->driverPrivate = NULL;
 }
@@ -2430,8 +2428,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 			      pMga->FbMapSize,
 			      LOOKUP_BEST_REFRESH);
       
-	if (linePitches)
-	   free(linePitches);
+	free(linePitches);
     }
 
     if (i < 1 && pMga->FBDev) {
@@ -3750,16 +3747,11 @@ MGACloseScreen(int scrnIndex, ScreenPtr pScreen)
 #endif
     if (pMga->CursorInfoRec)
     	xf86DestroyCursorInfoRec(pMga->CursorInfoRec);
-    if (pMga->ShadowPtr)
-	free(pMga->ShadowPtr);
-    if (pMga->DGAModes)
-	free(pMga->DGAModes);
-    if (pMga->adaptor)
-	free(pMga->adaptor);
-    if (pMga->portPrivate)
-	free(pMga->portPrivate);
-    if (pMga->ScratchBuffer)
-	free(pMga->ScratchBuffer);
+    free(pMga->ShadowPtr);
+    free(pMga->DGAModes);
+    free(pMga->adaptor);
+    free(pMga->portPrivate);
+    free(pMga->ScratchBuffer);
 
     pScrn->vtSema = FALSE;
 
diff --git a/src/mga_merge.c b/src/mga_merge.c
index e3216c9..c1cf2eb 100644
--- a/src/mga_merge.c
+++ b/src/mga_merge.c
@@ -528,8 +528,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
 			      pMga->FbMapSize,
 			      LOOKUP_BEST_REFRESH);
         
-	if (linePitches)
-	   free(linePitches);
+	free(linePitches);
     }
 
 
@@ -892,8 +891,7 @@ MGACloseScreenMerged(int scrnIndex, ScreenPtr pScreen) {
         pScrn1->currentMode = pScrn1->modes;
         do {
             DisplayModePtr p = pScrn1->currentMode->next; 
-            if(pScrn1->currentMode->Private) 
-                free(pScrn1->currentMode->Private);
+            free(pScrn1->currentMode->Private);
             free(pScrn1->currentMode);
             pScrn1->currentMode = p;
         }while( pScrn1->currentMode != pScrn1->modes);
diff --git a/src/mga_video.c b/src/mga_video.c
index beb5a3c..784e7b1 100644
--- a/src/mga_video.c
+++ b/src/mga_video.c
@@ -146,8 +146,7 @@ void MGAInitVideo(ScreenPtr pScreen)
     if(num_adaptors)
         xf86XVScreenInit(pScreen, adaptors, num_adaptors);
 
-    if(newAdaptors)
-	free(newAdaptors);
+    free(newAdaptors);
 }
 
 /* client libraries expect an encoding */
--
cgit v0.9.0.2-2-gbebe
From 560967b4ffdb103f95121c43708dd5fc680a5045 Mon Sep 17 00:00:00 2001
From: Matt Turner <mattst88@gmail.com>
Date: Tue, 27 Sep 2011 02:37:04 +0000
Subject: Fix printf format specifier warning

Signed-off-by: Matt Turner <mattst88@gmail.com>
---
diff --git a/src/mga_exa.c b/src/mga_exa.c
index f292327..e5eaa92 100644
--- a/src/mga_exa.c
+++ b/src/mga_exa.c
@@ -865,7 +865,7 @@ mgaExaInit(ScreenPtr pScreen)
 
     xf86DrvMsg(pScrn->scrnIndex, X_INFO, "X %d Y %d bpp %d\n",
                pScrn->virtualX, pScrn->virtualY, pScrn->bitsPerPixel);
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Start at %p, size %x, osb %x\n",
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO, "Start at %p, size %lx, osb %lx\n",
                pExa->memoryBase, pExa->memorySize, pExa->offScreenBase);
 
     /* In PW24 mode, we need to align to "3 64-bytes" */
--
cgit v0.9.0.2-2-gbebe
From 07792ef41f33aa5419168263637e34ee614f26e2 Mon Sep 17 00:00:00 2001
From: Matt Turner <mattst88@gmail.com>
Date: Tue, 27 Sep 2011 02:38:17 +0000
Subject: Remove calls to xf86IsPc98()

Reviewed-by: Jamey Sharp <jamey@minilop.net>
Signed-off-by: Matt Turner <mattst88@gmail.com>
---
diff --git a/src/mga_driver.c b/src/mga_driver.c
index dcbfabf..4af36ca 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -2164,7 +2164,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
     /*
      * Reset card if it isn't primary one
      */
-    if ( (!pMga->Primary && !pMga->FBDev) || xf86IsPc98() )
+    if ( (!pMga->Primary && !pMga->FBDev) )
         MGASoftReset(pScrn);
 
     if (pScrn->videoRam == 0) {
@@ -2878,13 +2878,6 @@ MGAModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	vgaHWProtect(pScrn, FALSE);
     }
 
-    if (xf86IsPc98()) {
-	if (pMga->Chipset == PCI_CHIP_MGA2064)
-	    outb(0xfac, 0x01);
-	else
-	    outb(0xfac, 0x02);
-    }
-
     /* Reset tagfifo*/ 
 	if (pMga->is_G200ER) 
     {
@@ -3680,8 +3673,6 @@ MGALeaveVT(int scrnIndex, int flags)
     MGARestore(pScrn);
     vgaHWLock(hwp);
 
-    if (xf86IsPc98())
-	outb(0xfac, 0x00);
 #ifdef XF86DRI
     if (pMga->directRenderingEnabled) {
         pScreen = screenInfo.screens[scrnIndex];
@@ -3755,9 +3746,6 @@ MGACloseScreen(int scrnIndex, ScreenPtr pScreen)
 
     pScrn->vtSema = FALSE;
 
-    if (xf86IsPc98())
-	outb(0xfac, 0x00);
-
     xf86ClearPrimInitDone(pScrn->entityList[0]);
 
     if(pMga->BlockHandler)
diff --git a/src/mga_merge.c b/src/mga_merge.c
index c1cf2eb..aec3443 100644
--- a/src/mga_merge.c
+++ b/src/mga_merge.c
@@ -385,7 +385,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
     /*
      * Reset card if it isn't primary one
      */
-    if ( (!pMga->Primary && !pMga->FBDev) || xf86IsPc98() )
+    if ( (!pMga->Primary && !pMga->FBDev) )
         MGASoftReset(pScrn);
 
     
--
cgit v0.9.0.2-2-gbebe
From f9acf37be49844bea8165be9786afe37fd999229 Mon Sep 17 00:00:00 2001
From: Jeremy Huddleston <jeremyhu@apple.com>
Date: Sat, 29 Oct 2011 23:31:08 +0000
Subject: Include <unistd.h> for usleep

Signed-off-by: Jeremy Huddleston <jeremyhu@apple.com>
---
diff --git a/src/mga_vga.c b/src/mga_vga.c
index 0ac8bf7..8f52951 100644
--- a/src/mga_vga.c
+++ b/src/mga_vga.c
@@ -2,6 +2,8 @@
 #include "config.h"
 #endif
 
+#include <unistd.h>
+
 #include "misc.h"
 #include "xf86.h"
 #include "xf86_OSproc.h"
--
cgit v0.9.0.2-2-gbebe
From d9cf07a4f424b2beb844ea1b3ec5d468e79a747c Mon Sep 17 00:00:00 2001
From: Jeremy Huddleston <jeremyhu@apple.com>
Date: Sat, 29 Oct 2011 23:34:41 +0000
Subject: Include "xf86Modes.h" for xf86ModeBandwidth

Signed-off-by: Jeremy Huddleston <jeremyhu@apple.com>
---
diff --git a/src/mga_driver.c b/src/mga_driver.c
index 4af36ca..d9f6ea4 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -52,6 +52,10 @@
 #include "xf86.h"
 #include "xf86_OSproc.h"
 
+#ifdef HAVE_XF86MODEBANDWIDTH
+#include "xf86Modes.h"
+#endif
+
 #if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 6
 #include "xf86Resources.h"
 #include "xf86RAC.h"
--
cgit v0.9.0.2-2-gbebe
From 644ba5d11049e63ea61b5cc4fb889b0f840965ff Mon Sep 17 00:00:00 2001
From: Christian Toutant <ctoutant@matrox.com>
Date: Wed, 07 Dec 2011 20:42:39 +0000
Subject: Add support for Video Memory greater then 8M

Expand memory mapping of framebuffer from 8 to 16MB

Fix segfault on redhat distibution

Signed-off-by: Christian Toutant <ctoutant@matrox.com>
---
diff --git a/src/mga_driver.c b/src/mga_driver.c
index d9f6ea4..ae36378 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -2707,9 +2707,18 @@ MGAMapMem(ScrnInfoPtr pScrn)
 	if (pMga->IOBase == NULL)
 	    return FALSE;
 
-	pMga->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
-				     pMga->PciTag, pMga->FbAddress,
-				     pMga->FbMapSize);
+    if (pMga->is_G200ER)
+    {
+        pMga->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
+                         pMga->PciTag, pMga->FbAddress,
+                         pMga->FbMapSize);
+    }
+    else
+    {
+        pMga->FbBase = xf86MapPciMem(pScrn->scrnIndex, VIDMEM_FRAMEBUFFER,
+                         pMga->PciTag, pMga->FbAddress,
+                         pMga->FbMapSize);
+    }
 	if (pMga->FbBase == NULL)
 	    return FALSE;
 #endif
@@ -3139,11 +3148,19 @@ MGAScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     pMga = MGAPTR(pScrn);
     MGAdac = &pMga->Dac;
 
-    if (pMga->is_G200SE) {
-	VRTemp = pScrn->videoRam;
-	FBTemp = pMga->FbMapSize;
-	pScrn->videoRam = 8192;
-	pMga->FbMapSize = pScrn->videoRam * 1024;
+    if (pMga->is_G200SE)
+    {
+        VRTemp = pScrn->videoRam;
+        FBTemp = pMga->FbMapSize;
+        if (pMga->reg_1e24 >= 0x01)
+        {
+            pScrn->videoRam = 16384;
+        }
+        else
+        {
+            pScrn->videoRam = 8192;
+        }
+        pMga->FbMapSize = pScrn->videoRam * 1024;
     }
     
 
@@ -3701,10 +3718,26 @@ MGACloseScreen(int scrnIndex, ScreenPtr pScreen)
     vgaHWPtr hwp = VGAHWPTR(pScrn);
     MGAPtr pMga = MGAPTR(pScrn);
     MGAEntPtr pMgaEnt = NULL;
+    CARD32 VRTemp, FBTemp;
 
     if (pMga->MergedFB)
          MGACloseScreenMerged(scrnIndex, pScreen);
 
+    if (pMga->is_G200SE)
+    {
+        VRTemp = pScrn->videoRam;
+        FBTemp = pMga->FbMapSize;
+        if (pMga->reg_1e24 >= 0x01)
+        {
+            pScrn->videoRam = 16384;
+        }
+        else
+        {
+            pScrn->videoRam = 8192;
+        }
+        pMga->FbMapSize = pScrn->videoRam * 1024;
+    }
+
     if (pScrn->vtSema) {
 	if (pMga->FBDev) {
 	    fbdevHWRestore(pScrn);
@@ -3716,6 +3749,13 @@ MGACloseScreen(int scrnIndex, ScreenPtr pScreen)
 	    vgaHWUnmapMem(pScrn);
 	}
     }
+
+    if (pMga->is_G200SE)
+    {
+        pScrn->videoRam = VRTemp;
+        pMga->FbMapSize = FBTemp;
+    }
+
 #ifdef XF86DRI
    if (pMga->directRenderingEnabled) {
        MGADRICloseScreen(pScreen);
--
cgit v0.9.0.2-2-gbebe
From cc9d2e808de20723c9035952242d966455d583b7 Mon Sep 17 00:00:00 2001
From: Alan Coopersmith <alan.coopersmith@oracle.com>
Date: Thu, 29 Dec 2011 03:44:40 +0000
Subject: Check MGAAllocAdaptor() for memory allocation failure

If it couldn't allocate memory, don't attempt to write a bunch of values
to the NULL pointer before returning it, but just pass the NULL along
right away.

Resolves parfait warnings of the form:

Error: Null pointer dereference (CWE 476)
   Write to null pointer 'adapt'
        at line 322 of src/mga_video.c in function 'MGASetupImageVideoTexture'.
          Function 'MGAAllocAdaptor' may return constant 'NULL' at line 237, called at line 320.
          Null pointer introduced at line 237 in function 'MGAAllocAdaptor'.

repeated for every line writing to the adapt pointer in each function.

[ This bug was found by the Parfait 0.4.2 bug checking tool.
  For more information see http://labs.oracle.com/projects/parfait/ ]

Signed-off-by: Alan Coopersmith <alan.coopersmith@oracle.com>
Reviewed-by: Mark Kettenis <kettenis@openbsd.org>
---
diff --git a/src/mga_video.c b/src/mga_video.c
index 784e7b1..abce31f 100644
--- a/src/mga_video.c
+++ b/src/mga_video.c
@@ -269,6 +269,8 @@ MGASetupImageVideoOverlay(ScreenPtr pScreen)
     XF86VideoAdaptorPtr adapt;
 
     adapt = MGAAllocAdaptor(pScrn, TRUE);
+    if (adapt == NULL)
+	return NULL;
 
     adapt->type = XvWindowMask | XvInputMask | XvImageMask;
     adapt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
@@ -316,6 +318,8 @@ MGASetupImageVideoTexture(ScreenPtr pScreen)
     MGAPtr pMga = MGAPTR(pScrn);
 
     adapt = MGAAllocAdaptor(pScrn, FALSE);
+    if (adapt == NULL)
+	return NULL;
 
     adapt->type = XvWindowMask | XvInputMask | XvImageMask;
     adapt->flags = 0;
@@ -1298,6 +1302,8 @@ MGASetupImageVideoILOAD(ScreenPtr pScreen)
     MGAPtr pMga = MGAPTR(pScrn);
 
     adapt = MGAAllocAdaptor(pScrn, FALSE);
+    if (adapt == NULL)
+	return NULL;
 
     adapt->type = XvWindowMask | XvInputMask | XvImageMask;
     adapt->flags = 0;
--
cgit v0.9.0.2-2-gbebe
From 9223c44a731f48c66c226eb88dcb6f9d574cb599 Mon Sep 17 00:00:00 2001
From: Julien Cristau <jcristau@debian.org>
Date: Tue, 03 Jan 2012 22:35:18 +0000
Subject: When we can't load the xaa or exa modules, use shadowfb instead

Signed-off-by: Julien Cristau <jcristau@debian.org>
---
diff --git a/src/mga_driver.c b/src/mga_driver.c
index ae36378..00469e7 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -2101,6 +2101,31 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
         }
     }
 
+    /* Load XAA if needed */
+    if (!pMga->NoAccel) {
+#ifdef USE_EXA
+	if (pMga->Exa) {
+	    if (!xf86LoadSubModule(pScrn, "exa")) {
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		           "Falling back to shadowfb\n");
+		pMga->ShadowFB = TRUE;
+		pMga->NoAccel = TRUE;
+	    }
+	} else {
+#endif
+#ifdef USE_XAA
+	    if (!xf86LoadSubModule(pScrn, "xaa")) {
+		xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		           "Falling back to shadowfb\n");
+		pMga->ShadowFB = TRUE;
+		pMga->NoAccel = TRUE;
+	    }
+#endif
+#ifdef USE_EXA
+	}
+#endif
+    }
+
     switch (pMga->Chipset) {
     case PCI_CHIP_MGA2064:
     case PCI_CHIP_MGA2164:
@@ -2596,27 +2621,6 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 	return FALSE;
     }
 
-    /* Load XAA if needed */
-    if (!pMga->NoAccel) {
-#ifdef USE_EXA
-	if (pMga->Exa) {
-	    if (!xf86LoadSubModule(pScrn, "exa")) {
-		MGAFreeRec(pScrn);
-		return FALSE;
-	    }
-	} else {
-#endif
-#ifdef USE_XAA
-	    if (!xf86LoadSubModule(pScrn, "xaa")) {
-		MGAFreeRec(pScrn);
-		return FALSE;
-	    }
-#endif
-#ifdef USE_EXA
-	}
-#endif
-    }
-
     /* Load ramdac if needed */
     if (pMga->HWCursor) {
 	if (!xf86LoadSubModule(pScrn, "ramdac")) {
--
cgit v0.9.0.2-2-gbebe
From 4c4beaf628c9c5dd531605e40696ed31db0e97b8 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Wed, 04 Jan 2012 05:15:07 +0000
Subject: Untangle XF86DRI from the driver-specific DRI define

XF86DRI is defined by xorg-server.h, so --disable-dri in the driver
itself does exactly nothing other than not fill in the CFLAGS
and thus stop the driver from compiling.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
---
diff --git a/configure.ac b/configure.ac
index 540c390..840ff3c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -100,8 +100,8 @@ AC_MSG_RESULT([$DRI])
 AM_CONDITIONAL(DRI, test "x$DRI" = xyes)
 if test "x$DRI" = xyes; then
         PKG_CHECK_MODULES(DRI, [libdrm >= 2.0 xf86driproto])
-        AC_DEFINE(XF86DRI,1,[Enable DRI driver support])
-        AC_DEFINE(XF86DRI_DEVEL,1,[Enable developmental DRI driver support])
+        AC_DEFINE(MGADRI,1,[Enable DRI driver support])
+        AC_DEFINE(MGADRI_DEVEL,1,[Enable developmental DRI driver support])
 fi
 
 save_CFLAGS="$CFLAGS"
diff --git a/src/mga.h b/src/mga.h
index fced6aa..77406f1 100644
--- a/src/mga.h
+++ b/src/mga.h
@@ -28,7 +28,11 @@
 #include "xf86DDC.h"
 #include "xf86xv.h"
 
-#ifdef XF86DRI
+#ifndef XF86DRI
+#undef MGADRI
+#endif
+
+#ifdef MGADRI
 #include "xf86drm.h"
 
 #define _XF86DRI_SERVER_
@@ -589,7 +593,7 @@ typedef struct {
     int			expandRemaining;
     int			expandHeight;
     int			expandY;
-#ifdef XF86DRI
+#ifdef MGADRI
     Bool 		directRenderingEnabled;
     DRIInfoPtr 		pDRIInfo;
     int 		drmFD;
@@ -743,7 +747,7 @@ void MGAPointerMoved(int index, int x, int y);
 void MGAInitVideo(ScreenPtr pScreen);
 void MGAResetVideo(ScrnInfoPtr pScrn);
 
-#ifdef XF86DRI
+#ifdef MGADRI
 
 #define MGA_FRONT	0x1
 #define MGA_BACK	0x2
diff --git a/src/mga_driver.c b/src/mga_driver.c
index 00469e7..af005f1 100644
--- a/src/mga_driver.c
+++ b/src/mga_driver.c
@@ -101,7 +101,7 @@
 #include "shadowfb.h"
 #include "fbdevhw.h"
 
-#ifdef XF86DRI
+#ifdef MGADRI
 #include "dri.h"
 #endif
 
@@ -1532,7 +1532,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 
     pMga = MGAPTR(pScrn);
     /* Set here until dri is enabled */
-#ifdef XF86DRI
+#ifdef MGADRI
     pMga->haveQuiescense = 1;
 #endif
     /* Get the entity, and make sure it is PCI. */
@@ -1706,13 +1706,13 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
     }
 
     if (pMga->DualHeadEnabled) {
-#ifdef XF86DRI
+#ifdef MGADRI
         pMga->GetQuiescence = MGAGetQuiescenceShared;
 #endif
     } else {                                              /* single-head mode */
         pMga->SecondCrtc = FALSE;
         pMga->HWCursor = TRUE;
-#ifdef XF86DRI
+#ifdef MGADRI
         pMga->GetQuiescence = MGAGetQuiescence;
 #endif
     }
@@ -1942,7 +1942,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
     if (pScrn->depth == 8)
 	pScrn->rgbBits = 8;
 
-#ifdef XF86DRI
+#ifdef MGADRI
     from = X_DEFAULT;
     pMga->agpMode = MGA_DEFAULT_AGP_MODE;
 
@@ -2637,7 +2637,7 @@ MGAPreInit(ScrnInfoPtr pScrn, int flags)
 	}
     }
 
-#ifdef XF86DRI
+#ifdef MGADRI
     /* Load the dri module if requested. */
     if (xf86ReturnOptValBool(pMga->Options, OPTION_DRI, FALSE)) {
        xf86LoadSubModule(pScrn, "dri");
@@ -2878,7 +2878,7 @@ MGAModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
     vgaReg = &hwp->ModeReg;
     mgaReg = &pMga->ModeReg;
 
-#ifdef XF86DRI
+#ifdef MGADRI
    if (pMga->directRenderingEnabled) {
        DRILock(screenInfo.screens[pScrn->scrnIndex], 0);
    }
@@ -2989,7 +2989,7 @@ MGAModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode)
 	pMga->M1currentMode = (DisplayModePtr)mode->Private;
     }
 
-#ifdef XF86DRI
+#ifdef MGADRI
    if (pMga->directRenderingEnabled)
      DRIUnlock(screenInfo.screens[pScrn->scrnIndex]);
 #endif
@@ -3138,7 +3138,7 @@ MGAScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
     MGAEntPtr pMgaEnt = NULL;
     int f;
     CARD32 VRTemp, FBTemp;
-#ifdef XF86DRI
+#ifdef MGADRI
     MessageType driFrom = X_DEFAULT;
 #endif
     DPMSSetProcPtr mga_dpms_set_proc = NULL;
@@ -3317,7 +3317,7 @@ MGAScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 	FBStart = pMga->FbStart;
     }
 
-#ifdef XF86DRI
+#ifdef MGADRI
      /*
       * Setup DRI after visuals have been established.
       *
@@ -3473,7 +3473,7 @@ MGAScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
 
     MGAInitVideo(pScreen);
 
-#ifdef XF86DRI
+#ifdef MGADRI
     if (pMga->directRenderingEnabled) {
        /* Now that mi, drm and others have done their thing,
 	* complete the DRI setup.
@@ -3625,7 +3625,7 @@ MGAEnterVT(int scrnIndex, int flags)
 
     pMga = MGAPTR(pScrn);
 
-#ifdef XF86DRI
+#ifdef MGADRI
     if (pMga->directRenderingEnabled) {
 	if (pMga->irq) {
 	    /* Need to make sure interrupts are enabled */
@@ -3651,7 +3651,7 @@ static Bool
 MGAEnterVTFBDev(int scrnIndex, int flags)
 {
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-#ifdef XF86DRI
+#ifdef MGADRI
     ScreenPtr pScreen;
     MGAPtr pMga;
 
@@ -3690,7 +3690,7 @@ MGALeaveVT(int scrnIndex, int flags)
 {
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
     vgaHWPtr hwp = VGAHWPTR(pScrn);
-#ifdef XF86DRI
+#ifdef MGADRI
     MGAPtr pMga = MGAPTR(pScrn);
     ScreenPtr pScreen;
 #endif
@@ -3698,7 +3698,7 @@ MGALeaveVT(int scrnIndex, int flags)
     MGARestore(pScrn);
     vgaHWLock(hwp);
 
-#ifdef XF86DRI
+#ifdef MGADRI
     if (pMga->directRenderingEnabled) {
         pScreen = screenInfo.screens[scrnIndex];
         DRILock(pScreen, 0);
@@ -3760,7 +3760,7 @@ MGACloseScreen(int scrnIndex, ScreenPtr pScreen)
         pMga->FbMapSize = FBTemp;
     }
 
-#ifdef XF86DRI
+#ifdef MGADRI
    if (pMga->directRenderingEnabled) {
        MGADRICloseScreen(pScreen);
        pMga->directRenderingEnabled=FALSE;
diff --git a/src/mga_exa.c b/src/mga_exa.c
index e5eaa92..ced6452 100644
--- a/src/mga_exa.c
+++ b/src/mga_exa.c
@@ -41,7 +41,7 @@
 #include "mga_macros.h"
 
 #include "exa.h"
-#ifdef XF86DRI
+#ifdef MGADRI
 #include "mga_dri.h"
 #endif
 
@@ -763,7 +763,7 @@ mgaWaitMarker(ScreenPtr pScreen, int marker)
     while (INREG (MGAREG_Status) & 0x10000);
 }
 
-#ifdef XF86DRI
+#ifdef MGADRI
 static void
 init_dri(ScrnInfoPtr pScrn)
 {
@@ -837,7 +837,7 @@ init_dri(ScrnInfoPtr pScrn)
                        MGA_BUFFER_ALIGN) & ~MGA_BUFFER_ALIGN;
     dri->backPitch = widthBytes;
 }
-#endif /* XF86DRI */
+#endif /* MGADRI */
 
 Bool
 mgaExaInit(ScreenPtr pScreen)
@@ -898,7 +898,7 @@ mgaExaInit(ScreenPtr pScreen)
     pExa->UploadToScreen = mgaUploadToScreen;
     pExa->DownloadFromScreen = mgaDownloadFromScreen;
 
-#ifdef XF86DRI
+#ifdef MGADRI
     if (pMga->directRenderingEnabled)
         init_dri(pScrn);
 #endif
diff --git a/src/mga_macros.h b/src/mga_macros.h
index 130651d..d3b0d0e 100644
--- a/src/mga_macros.h
+++ b/src/mga_macros.h
@@ -17,7 +17,7 @@
 
 #define RGBEQUAL(c) (!((((c) >> 8) ^ (c)) & 0xffff))
 
-#ifdef XF86DRI
+#ifdef MGADRI
 #define MGA_SYNC_XTAG                 0x275f4200
 
 #define MGABUSYWAIT() do { \
@@ -64,7 +64,7 @@ while(INREG(MGAREG_DWGSYNC) != MGA_SYNC_XTAG) ; \
 	WAITFIFO(1); \
 	OUTREG(MGAREG_CXBNDRY, 0xFFFF0000); }
 
-#ifdef XF86DRI
+#ifdef MGADRI
 #define CHECK_DMA_QUIESCENT(pMGA, pScrn) {	\
    if (!pMGA->haveQuiescense) {			\
       pMGA->GetQuiescence( pScrn );		\
diff --git a/src/mga_merge.c b/src/mga_merge.c
index aec3443..f355f76 100644
--- a/src/mga_merge.c
+++ b/src/mga_merge.c
@@ -316,7 +316,7 @@ MGAPreInitMergedFB(ScrnInfoPtr pScrn1, int flags)
     pMga->Chipset = pMga1->Chipset;
     pMga->ChipRev = pMga1->ChipRev;
 
-#ifdef XF86DRI
+#ifdef MGADRI
     pMga->agpMode = pMga1->agpMode;
 #endif
 
diff --git a/src/mga_storm.c b/src/mga_storm.c
index f0e6194..7ac3ae0 100644
--- a/src/mga_storm.c
+++ b/src/mga_storm.c
@@ -24,7 +24,7 @@
 #include "miline.h"
 #include "servermd.h"
 
-#ifdef XF86DRI
+#ifdef MGADRI
 #include "GL/glxtokens.h"
 #endif
 
@@ -32,7 +32,7 @@
 #include "mga_reg.h"
 #include "mga_macros.h"
 
-#ifdef XF86DRI
+#ifdef MGADRI
 #include "mga_dri.h"
 #endif
 
@@ -797,7 +797,7 @@ Bool mgaAccelInit( ScreenPtr pScreen )
 	break;
     }
 
-#ifdef XF86DRI
+#ifdef MGADRI
     if ( pMga->directRenderingEnabled ) {
        MGADRIServerPrivatePtr pMGADRIServer = pMga->DRIServerInfo;
        BoxRec MemBox;
@@ -899,7 +899,7 @@ Bool mgaAccelInit( ScreenPtr pScreen )
 		   pMGADRIServer->textureOffset );
     }
     else
-#endif /* defined(XF86DRI) */
+#endif /* defined(MGADRI) */
     {
        AvailFBArea.x1 = 0;
        AvailFBArea.x2 = pScrn->displayWidth;
--
cgit v0.9.0.2-2-gbebe
