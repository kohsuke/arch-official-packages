diff --git a/drivers/gpu/drm/nouveau/nv04_dac.c b/drivers/gpu/drm/nouveau/nv04_dac.c
index 587b6f5..3aedd20 100644
--- a/drivers/gpu/drm/nouveau/nv04_dac.c
+++ b/drivers/gpu/drm/nouveau/nv04_dac.c
@@ -236,29 +236,42 @@ enum drm_connector_status nv17_dac_detect(struct drm_encoder *encoder,
 			testval = dev_priv->vbios->dactestval;
 	}
 
+	nv_wr32(dev, 0x60081c, 0x22255256); /*216780.520000   write32 #1 NV_PCRTC[0].CRTC_081C <- 0x22255256*/
+	nv_wr32(dev, 0x60281c, 0x22255256); /*216781.520033   write32 #1 NV_PCRTC[1].CRTC_081C <- 0x22255256*/
+	nv_wr32(dev, 0x1084, 0x205749); /*216786.521228   write32 #1 NV_PBUS+0x84 <- 0x00205749*/
+	nv_wr32(dev, 0x1588, 0x88802015); /*216796.521681   write32 #1 NV_PBUS+0x588 <- 0x88802015*/
+	nv_wr32(dev, 0x682608, 0x20100000); /*216798.521747   write32 #1 NV11_PRAMDAC.TEST_CONTROL_OR_2_3 <- 0x20100000*/
+	nv_wr32(dev, 0x68252c, 0x111);
+	msleep(10);
+
 	saved_rtest_ctrl = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);
 	NVWriteRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset,
 		      saved_rtest_ctrl & ~NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF);
 
 	saved_powerctrl_2 = nvReadMC(dev, NV_PBUS_POWERCTRL_2);
 
-	nvWriteMC(dev, NV_PBUS_POWERCTRL_2, saved_powerctrl_2 & 0xd7ffffff);
+	nvWriteMC(dev, NV_PBUS_POWERCTRL_2, saved_powerctrl_2 /*& 0xd7ffffff */);
 	if (regoffset == 0x68) {
 		saved_powerctrl_4 = nvReadMC(dev, NV_PBUS_POWERCTRL_4);
+#if 0
 		nvWriteMC(dev, NV_PBUS_POWERCTRL_4, saved_powerctrl_4 & 0xffffffcf);
+#endif
 	}
 
 	if (dev_priv->chipset >= 0x34) {
 		saved_gpio_ext = NVReadCRTC(dev, 0, NV_PCRTC_GPIO_EXT);
 
+#if 0
 		NVWriteCRTC(dev, 0, NV_PCRTC_GPIO_EXT, (saved_gpio_ext & ~(3 << 20)) |
 			    (dcb->type == OUTPUT_TV ? (1 << 20) : 0));
+#endif
 	}
 
-	msleep(4);
+	msleep(10);
 
 	saved_routput = NVReadRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset);
-	head = (saved_routput & 0x100) >> 8;
+	/* head = (saved_routput & 0x100) >> 8; */
+	head = 1;
 #if 0
 	/* if there's a spare crtc, using it will minimise flicker for the case
 	 * where the in-use crtc is in use by an off-chip tmds encoder */
@@ -267,13 +280,14 @@ enum drm_connector_status nv17_dac_detect(struct drm_encoder *encoder,
 #endif
 	/* nv driver and nv31 use 0xfffffeee, nv34 and 6600 use 0xfffffece */
 	routput = (saved_routput & 0xfffffece) | head << 8;
-
+#if 0
 	if (nv_arch(dev) >= NV_40) {
 		if (dcb->type == OUTPUT_TV)
 			routput |= 1 << 20;
 		else
 			routput &= ~(1 << 20);
 	}
+#endif
 
 	NVWriteRAMDAC(dev, 0, NV_PRAMDAC_DACCLK + regoffset, routput);
 	msleep(1);
@@ -286,10 +300,12 @@ enum drm_connector_status nv17_dac_detect(struct drm_encoder *encoder,
 	temp = NVReadRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL);
 	NVWriteRAMDAC(dev, head, NV_PRAMDAC_TEST_CONTROL,
 		      temp | NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED);
-	msleep(5);
+	msleep(10);
 
 	temp = NVReadRAMDAC(dev, 0, NV_PRAMDAC_TEST_CONTROL + regoffset);
 
+	printk("NV_PRAMDAC_TEST_CONTROL + %x: %x\n", regoffset, temp);
+
 	if (dcb->type == OUTPUT_TV)
 		present = (nv17_tv_detect(encoder, connector, (temp >> 28) & 0xe)
 			   == connector_status_connected);
