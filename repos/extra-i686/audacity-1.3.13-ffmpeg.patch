Index: src/FFmpeg.h
===================================================================
--- src/FFmpeg.h	(revision 11286)
+++ src/FFmpeg.h	(working copy)
@@ -47,6 +47,21 @@
    #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(52, 94, 1)
    #define AVSampleFormat SampleFormat
    #endif
+
+   #if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 120, 0)
+   #define CodecType AVMediaType
+   #define CODEC_TYPE_UNKNOWN    AVMEDIA_TYPE_UNKNOWN
+   #define CODEC_TYPE_VIDEO      AVMEDIA_TYPE_VIDEO
+   #define CODEC_TYPE_AUDIO      AVMEDIA_TYPE_AUDIO
+   #define CODEC_TYPE_DATA       AVMEDIA_TYPE_DATA
+   #define CODEC_TYPE_SUBTITLE   AVMEDIA_TYPE_SUBTITLE
+   #define CODEC_TYPE_ATTACHMENT AVMEDIA_TYPE_ATTACHMENT
+   #define CODEC_TYPE_NB         AVMEDIA_TYPE_NB
+   #endif
+
+   #ifndef PKT_FLAG_KEY
+   #define PKT_FLAG_KEY          AV_PKT_FLAG_KEY
+   #endif  
 }
 #endif
 
@@ -505,20 +520,23 @@
       (AVCodecContext *avctx, AVCodec *codec),
       (avctx, codec);
    );
+#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 25, 0)
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
+      avcodec_decode_audio3,
+      (AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, AVPacket *avpkt),
+      (avctx, samples, frame_size_ptr, avpkt)
+   );
+#else
+   FFMPEG_FUNCTION_WITH_RETURN(
+      int,
       avcodec_decode_audio2,
       (AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, const uint8_t *buf, int buf_size),
       (avctx, samples, frame_size_ptr, buf, buf_size)
    );
+#endif
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
-      avcodec_decode_audio3,
-      (AVCodecContext *avctx, int16_t *samples, int *frame_size_ptr, AVPacket *avpkt),
-      (avctx, samples, frame_size_ptr, avpkt)
-   );
-   FFMPEG_FUNCTION_WITH_RETURN(
-      int,
       avcodec_encode_audio,
       (AVCodecContext *avctx, uint8_t *buf, int buf_size, const short *samples),
       (avctx, buf, buf_size, samples)
@@ -556,13 +574,22 @@
       (void),
       ()
    );
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(53, 0, 0)
    FFMPEG_FUNCTION_WITH_RETURN(
       void*,
       av_fast_realloc,
       (void *ptr, unsigned int *size, unsigned int min_size),
       (ptr, size, min_size)
    );
+#else
    FFMPEG_FUNCTION_WITH_RETURN(
+      void*,
+      av_fast_realloc,
+      (void *ptr, unsigned int *size, size_t min_size),
+      (ptr, size, min_size)
+   );
+#endif
+   FFMPEG_FUNCTION_WITH_RETURN(
       int,
       av_open_input_stream,
       (AVFormatContext **ic_ptr, AVIOContext *pb, const char *filename, AVInputFormat *fmt, AVFormatParameters *ap),
@@ -744,12 +771,21 @@
       (AVFifoBuffer *f),
       (f)
    );
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(51, 0, 0)
    FFMPEG_FUNCTION_WITH_RETURN(
       void*,
       av_malloc,
       (unsigned int size),
       (size)
    );
+#else
+   FFMPEG_FUNCTION_WITH_RETURN(
+      void*,
+      av_malloc,
+      (size_t size),
+      (size)
+   );
+#endif
    FFMPEG_FUNCTION_NO_RETURN(
       av_freep,
       (void *ptr),
@@ -761,11 +797,16 @@
       (int64_t a, AVRational bq, AVRational cq),
       (a, bq, cq)
    );
+
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(52, 31, 0)
    FFMPEG_FUNCTION_NO_RETURN(
       av_free_packet,
       (AVPacket *pkt),
       (pkt)
    );
+#endif
+
+#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
    FFMPEG_FUNCTION_WITH_RETURN(
       AVFifoBuffer*,
       av_fifo_alloc,
@@ -778,8 +819,22 @@
       (AVFifoBuffer *f, void *buf, int buf_size, void (*func)(void*, void*, int)),
       (f, buf, buf_size, func)
    );
+#else
    FFMPEG_FUNCTION_WITH_RETURN(
       int,
+      av_fifo_init,
+      (AVFifoBuffer *f, unsigned int size),
+      (f, size)
+   );
+   FFMPEG_FUNCTION_WITH_RETURN(
+      int,
+      av_fifo_generic_read,
+      (AVFifoBuffer *f, int buf_size, void (*func)(void*, void*, int), void* dest),
+      (f, buf_size, func, dest)
+   );
+#endif
+   FFMPEG_FUNCTION_WITH_RETURN(
+      int,
       av_fifo_realloc2,
       (AVFifoBuffer *f, unsigned int size),
       (f, size)
Index: src/FFmpeg.cpp
===================================================================
--- src/FFmpeg.cpp	(revision 11286)
+++ src/FFmpeg.cpp	(working copy)
@@ -186,9 +186,15 @@
       return AVERROR(ENOMEM);
    }
 
-   if (flags & URL_RDWR) {
+   // LLL:  These really should be logical AND tests, but on 2011/04/28, the URL_ open flags
+   //       changed in the FFmpeg source to values that were not compatible with previous
+   //       values.
+   //
+   //       Since Audacity doesn't use any other open flags (there aren't any others defined
+   //       anyway), making equality tests works for older and new FFmpeg headers.
+   if (flags == URL_RDWR) {
       mode = wxFile::read_write;
-   } else if (flags & URL_WRONLY) {
+   } else if (flags == URL_WRONLY) {
       mode = wxFile::write;
    } else {
       mode = wxFile::read;
@@ -222,6 +228,10 @@
 {
    wxSeekMode mode = wxFromStart;
 
+#if !defined(AVSEEK_FORCE)
+#define AVSEEK_FORCE 0
+#endif
+
    switch (whence & ~AVSEEK_FORCE)
    {
    case (SEEK_SET):
@@ -316,7 +326,7 @@
    pd.buf_size = 0;
    pd.buf = (unsigned char *) av_malloc(PROBE_BUF_MAX + AVPROBE_PADDING_SIZE);
    if (pd.buf == NULL) {
-      err = AVERROR_NOMEM;
+      err = AVERROR(ENOMEM);
       goto fail;
    }
 
@@ -381,7 +391,7 @@
 
    // Didn't find a suitable format, so bail
    if (!fmt) {
-      err = AVERROR_NOFMT;
+      err = AVERROR(EILSEQ);
       goto fail;
    }
 
@@ -847,39 +857,53 @@
    FFMPEG_INITALT(avformat, av_guess_format, guess_format);
    FFMPEG_INITALT(avformat, av_match_ext, match_ext);
 
-   FFMPEG_INITDYN(codec, av_init_packet);
-   FFMPEG_INITDYN(codec, av_free_packet);
-   FFMPEG_INITDYN(codec, avcodec_init);
-   FFMPEG_INITDYN(codec, avcodec_find_encoder);
-   FFMPEG_INITDYN(codec, avcodec_find_encoder_by_name);
-   FFMPEG_INITDYN(codec, avcodec_find_decoder);
-   FFMPEG_INITDYN(codec, avcodec_get_context_defaults);
-   FFMPEG_INITDYN(codec, avcodec_open);
-   FFMPEG_INITDYN(codec, avcodec_decode_audio2);
-   FFMPEG_INITDYN(codec, avcodec_decode_audio3);
-   FFMPEG_INITDYN(codec, avcodec_encode_audio);
-   FFMPEG_INITDYN(codec, avcodec_close);
-   FFMPEG_INITDYN(codec, avcodec_register_all);
-   FFMPEG_INITDYN(codec, avcodec_version);
-   FFMPEG_INITDYN(codec, av_fast_realloc);
-   FFMPEG_INITDYN(codec, av_codec_next);
-   FFMPEG_INITDYN(codec, av_get_bits_per_sample_format);
+#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 58, 0)
+   FFMPEG_INITDYN(avcodec, av_init_packet);
+#else
+   FFMPEG_INITDYN(avformat, av_init_packet);
+#endif
 
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(52, 31, 0)
+   FFMPEG_INITDYN(avcodec, av_free_packet);
+#endif
+   FFMPEG_INITDYN(avcodec, avcodec_init);
+   FFMPEG_INITDYN(avcodec, avcodec_find_encoder);
+   FFMPEG_INITDYN(avcodec, avcodec_find_encoder_by_name);
+   FFMPEG_INITDYN(avcodec, avcodec_find_decoder);
+   FFMPEG_INITDYN(avcodec, avcodec_get_context_defaults);
+   FFMPEG_INITDYN(avcodec, avcodec_open);
+#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 25, 0)
+   FFMPEG_INITDYN(avcodec, avcodec_decode_audio3);
+#else
+   FFMPEG_INITDYN(avcodec, avcodec_decode_audio2);
+#endif
+   FFMPEG_INITDYN(avcodec, avcodec_encode_audio);
+   FFMPEG_INITDYN(avcodec, avcodec_close);
+   FFMPEG_INITDYN(avcodec, avcodec_register_all);
+   FFMPEG_INITDYN(avcodec, avcodec_version);
+   FFMPEG_INITDYN(avcodec, av_fast_realloc);
+   FFMPEG_INITDYN(avcodec, av_codec_next);
+   FFMPEG_INITDYN(avcodec, av_get_bits_per_sample_format);
+
    FFMPEG_INITALT(avcodec, av_get_bits_per_sample_fmt, av_get_bits_per_sample_format);
 
-   FFMPEG_INITDYN(util, av_free);
-   FFMPEG_INITDYN(util, av_log_set_callback);
-   FFMPEG_INITDYN(util, av_log_default_callback);
-   FFMPEG_INITDYN(util, av_fifo_alloc);
-   FFMPEG_INITDYN(util, av_fifo_generic_read);
-   FFMPEG_INITDYN(util, av_fifo_realloc2);
-   FFMPEG_INITDYN(util, av_fifo_free);
-   FFMPEG_INITDYN(util, av_fifo_size);
-   FFMPEG_INITDYN(util, av_malloc);
-   FFMPEG_INITDYN(util, av_fifo_generic_write);
-   FFMPEG_INITDYN(util, av_freep);
-   FFMPEG_INITDYN(util, av_rescale_q);
-   FFMPEG_INITDYN(util, avutil_version);
+   FFMPEG_INITDYN(avutil, av_free);
+   FFMPEG_INITDYN(avutil, av_log_set_callback);
+   FFMPEG_INITDYN(avutil, av_log_default_callback);
+#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
+   FFMPEG_INITDYN(avutil, av_fifo_alloc);
+#else
+   FFMPEG_INITDYN(avutil, av_fifo_init);
+#endif
+   FFMPEG_INITDYN(avutil, av_fifo_generic_read);
+   FFMPEG_INITDYN(avutil, av_fifo_realloc2);
+   FFMPEG_INITDYN(avutil, av_fifo_free);
+   FFMPEG_INITDYN(avutil, av_fifo_size);
+   FFMPEG_INITDYN(avutil, av_malloc);
+   FFMPEG_INITDYN(avutil, av_fifo_generic_write);
+   FFMPEG_INITDYN(avutil, av_freep);
+   FFMPEG_INITDYN(avutil, av_rescale_q);
+   FFMPEG_INITDYN(avutil, avutil_version);
 
    //FFmpeg initialization
    wxLogMessage(wxT("All symbols loaded successfully. Initializing the library."));
Index: src/import/ImportFFmpeg.cpp
===================================================================
--- src/import/ImportFFmpeg.cpp	(revision 11286)
+++ src/import/ImportFFmpeg.cpp	(working copy)
@@ -808,9 +808,12 @@
       }
    }
 
+
+   sc->m_decodedAudioSamplesValidSiz = sc->m_decodedAudioSamplesSiz;
+
+#if LIBAVCODEC_VERSION_INT > AV_VERSION_INT(52, 25, 0)
    // avcodec_decode_audio3() expects the size of the output buffer as the 3rd parameter but
    // also returns the number of bytes it decoded in the same parameter.
-   sc->m_decodedAudioSamplesValidSiz = sc->m_decodedAudioSamplesSiz;
    AVPacket avpkt;
    av_init_packet(&avpkt);
    avpkt.data = pDecode;
@@ -820,7 +823,16 @@
                             (int16_t *)sc->m_decodedAudioSamples,    // out
                             &sc->m_decodedAudioSamplesValidSiz,      // in/out
                             &avpkt);                                 // in
-
+#else
+   // avcodec_decode_audio2() expects the size of the output buffer as the 3rd parameter but
+   // also returns the number of bytes it decoded in the same parameter.
+   nBytesDecoded =
+      avcodec_decode_audio2(sc->m_codecCtx, 
+                            (int16_t *) sc->m_decodedAudioSamples,   // out
+                            &sc->m_decodedAudioSamplesValidSiz,      // in/out
+                            pDecode,                                 // in
+                            nDecodeSiz);                             // in
+#endif
    if (nBytesDecoded < 0)
    {
       // Decoding failed. Don't stop.
Index: src/export/ExportFFmpeg.cpp
===================================================================
--- src/export/ExportFFmpeg.cpp	(revision 11286)
+++ src/export/ExportFFmpeg.cpp	(working copy)
@@ -154,6 +154,10 @@
    AVFifoBuffer	 * mEncAudioFifo;				// FIFO to write incoming audio samples into
    uint8_t         *	mEncAudioFifoOutBuf;		// buffer to read _out_ of the FIFO into
 
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(50, 0, 0)
+   AVFifoBuffer      mEncAudioFifoBuffer;    // FIFO to write incoming audio samples into
+#endif
+
    wxString          mName;
 
    int               mSubFormat;
@@ -174,6 +178,11 @@
    #define MAX_AUDIO_PACKET_SIZE (128 * 1024)
    mEncAudioEncodedBufSiz = 4*MAX_AUDIO_PACKET_SIZE;
    mEncAudioFifoOutBuf = NULL;	// buffer to read _out_ of the FIFO into
+   
+#if LIBAVUTIL_VERSION_INT < AV_VERSION_INT(50, 0, 0)
+   mEncAudioFifo = &mEncAudioFifoBuffer;
+#endif
+
    mSampleRate = 0;
    mSupportsUTF8 = true;
 
@@ -350,7 +359,6 @@
    mEncAudioCodecCtx = mEncAudioStream->codec;
   
    avcodec_get_context_defaults(mEncAudioCodecCtx);
-
    mEncAudioCodecCtx->codec_id = ExportFFmpegOptions::fmts[mSubFormat].codecid;
    mEncAudioCodecCtx->codec_type = CODEC_TYPE_AUDIO;
    mEncAudioCodecCtx->codec_tag = av_codec_get_tag((const AVCodecTag **)mEncFormatCtx->oformat->codec_tag,mEncAudioCodecCtx->codec_id);
@@ -403,7 +411,9 @@
       mEncAudioCodecCtx->flags2 = 0;
       if (gPrefs->Read(wxT("/FileFormats/FFmpegBitReservoir"),true)) mEncAudioCodecCtx->flags2 |= CODEC_FLAG2_BIT_RESERVOIR;
       if (gPrefs->Read(wxT("/FileFormats/FFmpegVariableBlockLen"),true)) mEncAudioCodecCtx->flags2 |= 0x0004; //WMA only?
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(53, 0, 0)
       mEncAudioCodecCtx->use_lpc = gPrefs->Read(wxT("/FileFormats/FFmpegUseLPC"),true);
+#endif
       mEncAudioCodecCtx->compression_level = gPrefs->Read(wxT("/FileFormats/FFmpegCompLevel"),-1);
       mEncAudioCodecCtx->frame_size = gPrefs->Read(wxT("/FileFormats/FFmpegFrameSize"),(long)0);
       mEncAudioCodecCtx->lpc_coeff_precision = gPrefs->Read(wxT("/FileFormats/FFmpegLPCCoefPrec"),(long)0);
@@ -487,7 +497,11 @@
    // The encoder may require a minimum number of raw audio samples for each encoding but we can't
    // guarantee we'll get this minimum each time an audio frame is decoded from the input file so 
    // we use a FIFO to store up incoming raw samples until we have enough for one call to the codec.
+#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
    mEncAudioFifo = av_fifo_alloc(1024);
+#else
+   av_fifo_init(mEncAudioFifo, 1024);
+#endif
 
    // Allocate a buffer to read OUT of the FIFO into. The FIFO maintains its own buffer internally.
    if ((mEncAudioFifoOutBuf = (uint8_t*)av_malloc(2*MAX_AUDIO_PACKET_SIZE)) == NULL)
@@ -544,7 +558,11 @@
                nFifoBytes, mEncAudioCodecCtx->frame_size);
 
             // Pull the bytes out from the FIFO and feed them to the encoder.
+#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
             if (av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nFifoBytes, NULL) == 0)
+#else
+            if (av_fifo_generic_read(mEncAudioFifo, nFifoBytes, NULL, mEncAudioFifoOutBuf) == 0)
+#endif
             {
                if (mEncAudioCodecCtx->frame_size != 1)
                   nEncodedBytes = avcodec_encode_audio(mEncAudioCodecCtx, mEncAudioEncodedBuf, mEncAudioEncodedBufSiz, (int16_t*)mEncAudioFifoOutBuf);
@@ -609,7 +627,10 @@
       av_free(mEncAudioFifoOutBuf);
 
    av_fifo_free(mEncAudioFifo);
+
+#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
    mEncAudioFifo = NULL;
+#endif
 
    return true;
 }
@@ -635,7 +656,11 @@
    // Read raw audio samples out of the FIFO in nAudioFrameSizeOut byte-sized groups to encode.
    while ((ret = av_fifo_size(mEncAudioFifo)) >= nAudioFrameSizeOut)
    {
+#if LIBAVUTIL_VERSION_INT > AV_VERSION_INT(49, 15, 0)
       ret = av_fifo_generic_read(mEncAudioFifo, mEncAudioFifoOutBuf, nAudioFrameSizeOut, NULL);
+#else
+      ret = av_fifo_generic_read(mEncAudioFifo, nAudioFrameSizeOut, NULL, mEncAudioFifoOutBuf);
+#endif
 
       av_init_packet(&pkt);
 
