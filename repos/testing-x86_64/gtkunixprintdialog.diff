--- psprint/inc/cupsmgr.hxx
+++ psprint/inc/cupsmgr.hxx
@@ -99,7 +99,9 @@
     virtual void changePrinterInfo( const ::rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
 
     // check if the printer configuration has changed
+    virtual void startsearch ();
     virtual bool checkPrintersChanged( bool bWait );
+    virtual void stopsearch ();
 
     // members for administration (->padmin)
     // disable for CUPS
--- psprint/inc/psprint/jobdata.hxx
+++ psprint/inc/psprint/jobdata.hxx
@@ -51,6 +51,7 @@
 
 struct JobData
 {
+    bool                    m_bCupsJob;
     int                     m_nCopies;
     int                     m_nLeftMarginAdjust;
     int                     m_nRightMarginAdjust;
@@ -66,6 +67,7 @@
     PPDContext              m_aContext;
 
     JobData() :
+            m_bCupsJob( false ),
             m_nCopies( 1 ),
             m_nLeftMarginAdjust( 0 ),
             m_nRightMarginAdjust( 0 ),
--- psprint/inc/psprint/ppdparser.hxx
+++ psprint/inc/psprint/ppdparser.hxx
@@ -61,6 +61,7 @@
     String          m_aOptionTranslation;
     String          m_aValue;
     String          m_aValueTranslation;
+    PPDValue() : m_eType(eInvocation) {}
 };
 
 // ----------------------------------------------------------------------
@@ -89,6 +90,7 @@
 private:
 
     bool				m_bUIOption;
+    bool                		m_bPseudo;
     String				m_aUITranslation;
     UIType				m_eUIType;
     int					m_nOrderDependency;
@@ -110,6 +112,8 @@
 
     const String&       getKey() const { return m_aKey; }
     bool                isUIKey() const { return m_bUIOption; }
+    bool                isPseudoKey() const { return m_bPseudo; }
+    void                setPseudoKey() { m_bPseudo = true; }
     const String&       getUITranslation() const { return m_aUITranslation; }
     UIType              getUIType() const { return m_eUIType; }
     SetupType           getSetupType() const { return m_eSetupType; }
@@ -139,8 +143,9 @@
 
     typedef ::std::hash_map< ::rtl::OUString, PPDKey*, ::rtl::OUStringHash > hash_type;
     typedef ::std::vector< PPDKey* > value_type;
-
+public:
     void insertKey( const String& rKey, PPDKey* pKey );
+    void Reset();
 public:
     struct PPDConstraint
     {
@@ -302,6 +307,7 @@
     // returns false: check failed, new value is constrained
     //         true:  check succeded, new value can be set
     bool checkConstraints( const PPDKey*, const PPDValue*, bool bDoReset );
+public:
     bool resetValue( const PPDKey*, bool bDefaultable = false );
 public:
     PPDContext( const PPDParser* pParser = NULL );
--- psprint/inc/psprint/printerinfomanager.hxx
+++ psprint/inc/psprint/printerinfomanager.hxx
@@ -193,7 +193,9 @@
     // check if the printer configuration has changed
     // if bwait is true, then this method waits for eventual asynchronous
     // printer discovery to finish
+    virtual void startsearch();
     virtual bool checkPrintersChanged( bool bWait );
+    virtual void stopsearch();
 
     // members for administration (->padmin)
 
--- psprint/source/helper/ppdparser.cxx
+++ psprint/source/helper/ppdparser.cxx
@@ -53,6 +53,7 @@
 #include <osl/thread.h>
 #include <rtl/strbuf.hxx>
 #include <rtl/ustrbuf.hxx>
+#include <algorithm>
 
 #define PRINTER_PPDDIR "driver"
 
@@ -486,6 +487,23 @@
         delete it->second;
 }
 
+void PPDParser::Reset()
+{
+    for( PPDParser::hash_type::iterator it = m_aKeys.begin(); it != m_aKeys.end(); /*nothing*/ )
+    {
+        PPDKey* pKey = it->second;
+        if (pKey->isPseudoKey())
+	{
+	    m_aOrderedKeys.erase(::std::remove(m_aOrderedKeys.begin(), 
+                m_aOrderedKeys.end(), pKey), m_aOrderedKeys.end());
+            delete it->second;
+	    m_aKeys.erase(it++);
+	}
+	else
+	    ++it;
+    }
+}
+
 void PPDParser::insertKey( const String& rKey, PPDKey* pKey )
 {
     m_aKeys[ rKey ] = pKey;
@@ -1238,6 +1256,7 @@
         m_pDefaultValue( NULL ),
         m_bQueryValue( false ),
         m_bUIOption( false ),
+        m_bPseudo( false ),
         m_eUIType( PickOne ),
         m_nOrderDependency( 100 ),
         m_eSetupType( AnySetup )
--- psprint/source/printer/cupsmgr.cxx
+++ psprint/source/printer/cupsmgr.cxx
@@ -409,10 +409,15 @@
         m_pDests( NULL ),
         m_bNewDests( false )
 {
+    startsearch();
+}
+
+void CUPSManager::startsearch()
+{
     m_aDestThread = osl_createThread( run_dest_thread_stub, this );
 }
 
-CUPSManager::~CUPSManager()
+void CUPSManager::stopsearch()
 {
     if( m_aDestThread )
     {
@@ -424,6 +429,11 @@
 
     if( m_nDests && m_pDests )
         m_pCUPSWrapper->cupsFreeDests( m_nDests, (cups_dest_t*)m_pDests );
+}
+
+CUPSManager::~CUPSManager()
+{
+    stopsearch();
     delete m_pCUPSWrapper;
 }
 
@@ -477,9 +487,10 @@
 
     // clear old stuff
     m_aCUPSDestMap.clear();
-
+#if 0
     if( ! (m_nDests && m_pDests ) )
         return;
+#endif
     
     // check for CUPS server(?) > 1.2
     // since there is no API to query, check for options that were
@@ -487,9 +498,9 @@
     // this is needed to check for %%IncludeFeature support
     // (#i65684#, #i65491#)
     cups_dest_t* pDest = ((cups_dest_t*)m_pDests);
-    const char* pOpt = m_pCUPSWrapper->cupsGetOption( "printer-info",
+    const char* pOpt = pDest ? m_pCUPSWrapper->cupsGetOption( "printer-info",
                                                       pDest->num_options,
-                                                      pDest->options );
+                                                      pDest->options ) : 0;
     if( pOpt )
         m_bUseIncludeFeature = true;
 
@@ -579,6 +590,10 @@
 
     m_pCUPSWrapper->cupsSetPasswordCB( setPasswordCallback );
 #endif // ENABLE_CUPS
+
+	addPrinter(rtl::OUString::createFromAscii("Generic Printer"),
+		rtl::OUString::createFromAscii("SGENPRT"));
+
 }
 
 #ifdef ENABLE_CUPS
--- psprint/source/printer/jobdata.cxx
+++ psprint/source/printer/jobdata.cxx
@@ -46,6 +46,7 @@
 
 JobData& JobData::operator=(const JobData& rRight)
 {
+    m_bCupsJob				= rRight.m_bCupsJob;
     m_nCopies				= rRight.m_nCopies;
     m_nLeftMarginAdjust		= rRight.m_nLeftMarginAdjust;
     m_nRightMarginAdjust	= rRight.m_nRightMarginAdjust;
@@ -94,6 +95,10 @@
     aLine += ByteString::CreateFromInt32( m_nCopies );
     aStream.WriteLine( aLine );
 
+    aLine = "cups=";
+    aLine += ByteString::CreateFromInt32( m_bCupsJob );
+    aStream.WriteLine( aLine );
+
     aLine = "margindajustment=";
     aLine += ByteString::CreateFromInt32( m_nLeftMarginAdjust );
     aLine += ',';
@@ -136,6 +141,7 @@
     bool bVersion       = false;
     bool bPrinter       = false;
     bool bOrientation   = false;
+    bool bCups          = false;
     bool bCopies        = false;
     bool bContext       = false;
     bool bMargin        = false;
@@ -162,6 +168,11 @@
             bCopies = true;
             rJobData.m_nCopies = aLine.Copy( 7 ).ToInt32();
         }
+        else if( aLine.CompareTo( "cups=", 5 ) == COMPARE_EQUAL )
+        {
+            bCups = true;
+            rJobData.m_bCupsJob = aLine.Copy( 5 ).ToInt32();
+        }
         else if( aLine.CompareTo( "margindajustment=",17 ) == COMPARE_EQUAL )
         {
             bMargin = true;
--- psprint/source/printer/printerinfomanager.cxx
+++ psprint/source/printer/printerinfomanager.cxx
@@ -221,6 +221,14 @@
 
 // -----------------------------------------------------------------
 
+void PrinterInfoManager::startsearch()
+{
+}
+
+void PrinterInfoManager::stopsearch()
+{
+}
+
 bool PrinterInfoManager::checkPrintersChanged( bool bWait )
 {
     // check if files were created, deleted or modified since initialize()
--- psprint/source/printergfx/printerjob.cxx
+++ psprint/source/printergfx/printerjob.cxx
@@ -1197,7 +1197,7 @@
             WritePS (pFile, "<< /NumCopies null /Policies << /NumCopies 1 >> >> setpagedevice\n" );
     }
 
-    bool bFeatureSuccess = writeFeatureList( pFile, rJob, true );
+    bool bFeatureSuccess = !rJob.m_bCupsJob ? writeFeatureList( pFile, rJob, true ) : true;
 
     WritePS (pFile, "%%EndSetup\n");
 
--- sfx2/source/view/viewprn.cxx
+++ sfx2/source/view/viewprn.cxx
@@ -180,6 +180,7 @@
 
 	// Dialog ausf"uhren
 	SfxPrintOptionsDialog* pDlg = new SfxPrintOptionsDialog( _pParent, _pViewSh, _pOptions );
+        pDlg->SetNativeParent(_pParent ? _pParent->GetNativeHandle() : 0);
 	if ( _bHelpDisabled )
 		pDlg->DisableHelp();
 	if ( pDlg->Execute() == RET_OK )
--- svtools/inc/svtools/printdlg.hxx
+++ svtools/inc/svtools/printdlg.hxx
@@ -163,6 +163,9 @@
 	Link				maOKHdlLink;	  // Link zum OK-Handler
 
     String				maAllFilterStr;
+    String				maPaperFormatStr;
+    String				maOrientationStr;
+    unsigned long			mnNativeHandle;
 
     SVT_DLLPRIVATE void     ImplCheckOK();
     SVT_DLLPRIVATE void     ImplInitControls();
@@ -241,6 +244,8 @@
 	virtual short		Execute();
 
 	void				DisableHelp();
+
+    virtual unsigned long GetNativeHandle() const;
 };
 
 inline void PrintDialog::EnableRange( PrintDialogRange eRange )
--- svtools/source/dialogs/makefile.mk
+++ svtools/source/dialogs/makefile.mk
@@ -43,6 +43,10 @@
 .INCLUDE :	settings.mk
 .INCLUDE :  $(PRJ)$/util$/svt.pmk
 
+
+PKGCONFIG_MODULES=gtk+-unix-print-2.0
+.INCLUDE: pkg_config.mk
+
 # --- Files --------------------------------------------------------
 
 SRS1NAME=$(TARGET)
--- svtools/source/dialogs/printdlg.cxx
+++ svtools/source/dialogs/printdlg.cxx
@@ -85,9 +85,64 @@
 #ifndef _COMPHELPER_PROCESSFACTORY_HXX_
 #include <comphelper/processfactory.hxx>
 #endif
+extern void ImplDeletePrnQueueList();
+#ifndef _COM_SUN_STAR_FRAME_XFRAME_HPP_
+#include <com/sun/star/frame/XFrame.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UTIL_URL_HPP_
+#include <com/sun/star/util/URL.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UTIL_XURLTRANSFORMER_HPP_
+#include <com/sun/star/util/XURLTransformer.hpp>
+#endif
+#ifndef _COM_SUN_STAR_FRAME_XDISPATCHPROVIDER_HPP_
+#include <com/sun/star/frame/XDispatchProvider.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
+#include <com/sun/star/beans/PropertyValue.hpp>
+#endif
+#ifndef _COM_SUN_STAR_VIEW_XSELECTIONSUPPLIER_HPP_
+#include <com/sun/star/view/XSelectionSupplier.hpp>
+#endif
+
+#include <com/sun/star/document/XFilter.hpp>
+#include <com/sun/star/document/XExporter.hpp>
+#include <com/sun/star/io/XOutputStream.hpp>
+#include <com/sun/star/sheet/XSpreadsheetDocument.hpp>
+#include <com/sun/star/sheet/XSpreadsheetView.hpp>
+#include <com/sun/star/sheet/XSpreadsheet.hpp>
+#include <com/sun/star/container/XNamed.hpp>
+#include <unotools/streamwrap.hxx>
+#include <unotools/ucbstreamhelper.hxx>
+
+#ifndef INCLUDED_SVTOOLS_MISCOPT_HXX
+#include "svtools/miscopt.hxx"
+#endif
+#include <gtk/gtkprintunixdialog.h>
+#include <gtk/gtkstock.h>
+#include <gtk/gtkcheckbutton.h>
+#include <gtk/gtkcombobox.h>
+#include <gtk/gtklabel.h>
+#include <gtk/gtktable.h>
+#include <gtk/gtkcombobox.h>
+#include <gtk/gtkvbox.h>
+#include <gtk/gtknotebook.h>
+#include <psprint/printerinfomanager.hxx>
+
+using namespace osl;
+
 
 using rtl::OUString;
 using namespace com::sun::star;
+using namespace ::com::sun::star::frame;
+using namespace ::com::sun::star::beans;
+using namespace com::sun::star::view;
+using namespace com::sun::star::document;
+using namespace com::sun::star::sheet;
+using namespace com::sun::star::container;
+using namespace com::sun::star::io;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
 
 struct SvtPrinterImpl
 {
@@ -144,8 +199,10 @@
     maBtnCancel         ( this, SvtResId( BTN_CANCEL ) ),
     maBtnHelp           ( this, SvtResId( BTN_HELP ) ),
     mbWithSheetsAndCells( bWithSheetsAndCells ),
-    maAllFilterStr      (       SvtResId( STR_ALLFILTER ) )
-
+    maAllFilterStr      (       SvtResId( STR_ALLFILTER ) ),
+    maPaperFormatStr    (       SvtResId( STR_PAPER_PAPER_TXT ) ),
+    maOrientationStr    (       SvtResId( STR_PAPER_ORIENTATION_TXT ) ),
+    mnNativeHandle(0)
 {
 	FreeResource();
 
@@ -781,6 +838,250 @@
 
 // -----------------------------------------------------------------------
 
+unsigned long PrintDialog::GetNativeHandle() const
+{
+    return !mnNativeHandle ? Window::GetNativeHandle() : mnNativeHandle;
+}
+
+#define ASCII_STR(x) rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(x))
+
+static void setcupskey(const gchar *key, const gchar *value, gpointer user_data)
+{
+	Printer *pPrinter = (Printer*)user_data;
+	if ((strlen(key) > 5) && (!strncmp(key, "cups-", 5)))
+		pPrinter->SetJobCupsKey( String::CreateFromAscii(key+5), String::CreateFromAscii(value));
+	else if ((!strcmp(key, "reverse")) && (!strcmp(value, "true")))
+		pPrinter->SetJobCupsKey(String::CreateFromAscii("OutputOrder"), String::CreateFromAscii("Reverse"));
+	else if ((!strcmp(key, "collate")) && (!strcmp(value, "true")))
+		pPrinter->SetJobCupsKey(String::CreateFromAscii("Collate"), String::CreateFromAscii("True"));
+	else if (!strcmp(key, "n-copies"))
+		pPrinter->SetJobCupsKey(String::CreateFromAscii("copies"), String::CreateFromAscii(value));
+}
+
+void ExportAsPDF(const rtl::OUString &rFileURL, PrintDialogRange eRange, const OUString &rRange)
+{
+		Reference < XFramesSupplier > xDesktop =
+                Reference < XFramesSupplier >(
+        ::comphelper::getProcessServiceFactory()->
+		createInstance( ASCII_STR("com.sun.star.frame.Desktop") ), UNO_QUERY );
+        Reference < XFrame > xFrame( xDesktop->getActiveFrame() );
+        if ( !xFrame.is() )
+        	xFrame = Reference < XFrame >( xDesktop, UNO_QUERY );
+
+        Reference < XFilter >
+                xFilter( ::comphelper::getProcessServiceFactory()->
+                        createInstance( ASCII_STR("com.sun.star.document.PDFFilter") ), UNO_QUERY );
+
+        if (xFilter.is())
+        {
+			Reference< XController > xController;
+			Reference< XComponent > xDoc;
+			if (xFrame.is())
+				xController = xFrame->getController();
+			if (xController.is())
+				xDoc = Reference< XComponent >( xController->getModel(), UNO_QUERY );
+
+			SvFileStream aStream (rFileURL, STREAM_READWRITE | STREAM_SHARE_DENYWRITE | STREAM_TRUNC);
+	        Reference< XOutputStream > xOStm( new utl::OOutputStreamWrapper ( aStream ) );
+
+			Reference< XExporter > xExport(xFilter, UNO_QUERY);
+			xExport->setSourceDocument(xDoc);
+			Sequence<PropertyValue> aFilterData(2);
+			aFilterData[0].Name = ASCII_STR("PageLayout");
+			aFilterData[0].Value <<= sal_Int32(0);
+			aFilterData[1].Name = ASCII_STR("FirstPageOnLeft");
+			aFilterData[1].Value <<= sal_False;
+			switch (eRange)
+			{
+       			case PRINTDIALOG_ALL:
+				case PRINTDIALOG_FROMTO:
+					break;
+        		case PRINTDIALOG_RANGE:
+					aFilterData.realloc(aFilterData.getLength()+1);
+					aFilterData[aFilterData.getLength()-1].Name = ASCII_STR("PageRange");
+					aFilterData[aFilterData.getLength()-1].Value <<= rRange;
+					break;
+        		case PRINTDIALOG_SELECTION:
+				{
+					Any aSelection;
+					try
+					{
+						if( xController.is() )
+						{
+							Reference< XSelectionSupplier > xView( xController, UNO_QUERY );
+							if( xView.is() )
+								xView->getSelection() >>= aSelection;
+						}
+					}
+					catch( RuntimeException )
+					{
+					}
+					if (aSelection.hasValue())
+					{
+							aFilterData.realloc(aFilterData.getLength()+1);
+							aFilterData[aFilterData.getLength()-1].Name = ASCII_STR("Selection");
+							aFilterData[aFilterData.getLength()-1].Value <<= aSelection;
+					}
+					break;
+				}
+			}
+            Sequence<PropertyValue> aArgs(2);
+			aArgs[0].Name = ASCII_STR("FilterData");
+			aArgs[0].Value <<= aFilterData;
+	        aArgs[1].Name = ASCII_STR("OutputStream");
+	        aArgs[1].Value <<= xOStm;
+	        xFilter->filter( aArgs );
+        }
+}
+
+struct ourhandle
+{
+  	int papers;
+  	int orients;
+	GtkWidget *pDialog;
+	GtkWidget *notebook;
+   	GtkWidget *orientwidget;
+   	GtkWidget *paperwidget;
+	Printer *pPrinter;
+	rtl::OUString sPrinter;
+	ourhandle() : papers(0), orients(0), pDialog(0), notebook(0), orientwidget(0), paperwidget(0), pPrinter(0) {}
+};
+
+static rtl::OUString OOoPrintName(GtkWidget *pDialog)
+{
+	rtl::OUString sPrinterName(ASCII_STR("Generic Printer"));
+
+	if (GtkPrintSettings* pSettings = gtk_print_unix_dialog_get_settings (GTK_PRINT_UNIX_DIALOG(pDialog)))
+	{
+		if (const gchar *uri = gtk_print_settings_get(pSettings, GTK_PRINT_SETTINGS_OUTPUT_URI))
+		{
+			if (gchar *pFile = g_filename_from_uri (uri, NULL, NULL))
+			{
+				if (pFile && strlen(pFile))
+				{
+					const gchar *pStr = gtk_print_settings_get(pSettings, GTK_PRINT_SETTINGS_OUTPUT_FILE_FORMAT);
+					if (pStr && !strcmp(pStr, "pdf"))
+						sPrinterName = rtl::OUString();
+				}
+				g_free(pFile);
+				g_object_unref(pSettings);
+				return sPrinterName;
+			}
+		}
+	
+		if (GtkPrinter* pPrinter = gtk_print_unix_dialog_get_selected_printer(GTK_PRINT_UNIX_DIALOG(pDialog)))
+		{
+			const gchar *pStr = gtk_printer_get_name(pPrinter);
+			sPrinterName = rtl::OUString((const sal_Char *)pStr, strlen((const sal_Char*)(pStr)), RTL_TEXTENCODING_UTF8);
+		}
+		g_object_unref(pSettings);
+	}
+
+	return sPrinterName;
+}
+
+void SetProperties(ourhandle &rHandle, bool bForceUpdate)
+{
+	rtl::OUString sPrinter = OOoPrintName(rHandle.pDialog);
+
+	if (rHandle.sPrinter == sPrinter && !bForceUpdate)
+		return;
+
+	rHandle.sPrinter = sPrinter;
+
+	while (rHandle.orients)
+		gtk_combo_box_remove_text(GTK_COMBO_BOX(rHandle.orientwidget), --rHandle.orients);
+	while (rHandle.papers)
+		gtk_combo_box_remove_text(GTK_COMBO_BOX(rHandle.paperwidget), --rHandle.papers);
+
+	gtk_widget_set_sensitive(rHandle.orientwidget, sPrinter.getLength());
+	gtk_widget_set_sensitive(rHandle.paperwidget, sPrinter.getLength());
+	rHandle.orients = 2;
+
+	if (!sPrinter.getLength())
+		return;
+
+	Printer *pFoo=0;
+	String sSelectedPaper;
+	if (rHandle.pPrinter && rtl::OUString(rHandle.pPrinter->GetName()) == sPrinter)
+		pFoo = rHandle.pPrinter;
+	else
+		pFoo = new Printer(sPrinter);
+
+	using namespace psp;
+
+    PrinterInfo aInfo(pFoo->GetPrinterInfo());
+
+	gtk_combo_box_append_text(GTK_COMBO_BOX(rHandle.orientwidget), "Portrait");
+	gtk_combo_box_append_text(GTK_COMBO_BOX(rHandle.orientwidget), "Landscape");
+	gtk_combo_box_set_active(GTK_COMBO_BOX(rHandle.orientwidget), aInfo.m_eOrientation == orientation::Landscape ? 1 : 0);
+
+	::Orientation orient = pFoo->GetOrientation();
+	gtk_combo_box_set_active(GTK_COMBO_BOX(rHandle.orientwidget), orient == ORIENTATION_LANDSCAPE ? 1 : 0);
+	pFoo->SetOrientation(ORIENTATION_PORTRAIT);
+	const vcl::PaperInfo &rPaperInfo = pFoo->GetCurrentPaperInfo();
+	pFoo->SetOrientation(orient);
+	sSelectedPaper = rPaperInfo.m_aPaperName;
+
+	if (aInfo.m_pParser)
+	{
+		const PPDKey* pKey = 0;
+
+		if ((pKey = aInfo.m_pParser->getKey(String(RTL_CONSTASCII_USTRINGPARAM("Duplex")))))
+		{
+			if (const PPDValue* pVal = aInfo.m_aContext.getValue( pKey ))
+			{
+				GtkPrintSettings* pTempSettings = gtk_print_unix_dialog_get_settings(GTK_PRINT_UNIX_DIALOG(rHandle.pDialog));
+
+				String sDuplex(pVal->m_aOption);
+				GtkPrintDuplex eDuplex = GTK_PRINT_DUPLEX_SIMPLEX;
+
+				if (pVal->m_aOption.EqualsIgnoreCaseAscii("DuplexNoTumble", 0, 14))
+					eDuplex = GTK_PRINT_DUPLEX_HORIZONTAL;
+				else if (pVal->m_aOption.EqualsIgnoreCaseAscii("DuplexTumble", 0, 12))
+					eDuplex = GTK_PRINT_DUPLEX_VERTICAL;
+
+				gtk_print_settings_set_duplex(pTempSettings, eDuplex);
+	        	gtk_print_unix_dialog_set_settings(GTK_PRINT_UNIX_DIALOG(rHandle.pDialog), pTempSettings);
+	        	g_object_unref(pTempSettings);
+			}
+		}
+
+		if ((pKey = aInfo.m_pParser->getKey(String(RTL_CONSTASCII_USTRINGPARAM("PageSize")))))
+		{
+			int select = -1;
+			const PPDValue* pSelectValue = sSelectedPaper.Len() ? 0 : aInfo.m_aContext.getValue(pKey);
+			for (int i = 0; i < pKey->countValues(); i++)
+			{
+				const PPDValue* pValue = pKey->getValue(i);
+				String aOptionText = pValue->m_aOptionTranslation.Len() ? 
+					pValue->m_aOptionTranslation : pValue->m_aOption;
+	              
+				if (aInfo.m_aContext.checkConstraints(pKey, pValue))
+				{
+					gtk_combo_box_append_text(GTK_COMBO_BOX(rHandle.paperwidget), 
+						rtl::OUStringToOString(aOptionText, RTL_TEXTENCODING_UTF8).getStr());
+					if (pValue == pSelectValue || sSelectedPaper == aOptionText)
+						select = i;
+					++rHandle.papers;
+				}
+			}
+
+			if (select != -1)
+				gtk_combo_box_set_active(GTK_COMBO_BOX(rHandle.paperwidget), select);
+ 		}
+	}
+
+	if (pFoo != rHandle.pPrinter)
+		delete pFoo;
+}
+
+void switch_page_cb(GtkNotebook *, GtkNotebookPage *, guint, ourhandle *pHandle)
+{
+	if (pHandle)
+		SetProperties(*pHandle, false);
+}
+
 short PrintDialog::Execute()
 {
 	if ( !mpPrinter || mpPrinter->IsPrinting() || mpPrinter->IsJobActive() )
@@ -803,15 +1104,325 @@
 	ImplInitControls();
 	ImplModifyControlHdl( NULL );
 
-    // Dialog starten
-	short nRet = ModalDialog::Execute();
+	short nRet = false;
 
-	// Wenn Dialog mit OK beendet wurde, dann die Daten updaten
-	if( nRet == TRUE )
+	if (
+	    SvtMiscOptions().UseSystemFileDialog() &&
+	    !Application::GetDesktopEnvironment().equalsIgnoreAsciiCaseAscii("kde")
+	   )
 	{
-		if ( TEMPPRINTER() )
-			mpPrinter->SetPrinterProps( TEMPPRINTER() );
-		ImplFillDialogData();
+ 		unsigned long handle = GetParent() ? GetParent()->GetNativeHandle() : 0;
+ 		GtkWindow *parent = handle ? GTK_WINDOW(handle) : NULL;
+ 		
+ 		static ourhandle aHandle;
+ 		if (!aHandle.pDialog)
+ 		{
+ 			aHandle.pDialog = gtk_print_unix_dialog_new (NULL, parent);
+ 
+ 			rtl::OString aOptions(rtl::OUStringToOString(maBtnOptions.GetText(), RTL_TEXTENCODING_UTF8));
+ 			aOptions = aOptions.replace('~','_');
+ 
+ 			gtk_dialog_add_button( GTK_DIALOG( aHandle.pDialog ), aOptions.getStr(), GTK_RESPONSE_HELP);
+ 
+ 			rtl::OUString aProperties(maBtnProperties.GetText());
+ 			aProperties = aProperties.copy(0, aProperties.lastIndexOf(OUString(RTL_CONSTASCII_USTRINGPARAM(("...")))));
+ 			aProperties = aProperties.replaceAt(aProperties.indexOf('~'), 1, OUString());
+ 
+ 			gtk_print_unix_dialog_set_manual_capabilities(GTK_PRINT_UNIX_DIALOG(aHandle.pDialog), 
+ 				GtkPrintCapabilities(GTK_PRINT_CAPABILITY_COPIES | GTK_PRINT_CAPABILITY_COLLATE | 
+ 				GTK_PRINT_CAPABILITY_REVERSE|GTK_PRINT_CAPABILITY_GENERATE_PDF|GTK_PRINT_CAPABILITY_GENERATE_PS));
+ 
+ 			GtkWidget *box = gtk_vbox_new(FALSE, 18);
+ 			gtk_container_set_border_width (GTK_CONTAINER (box), 12);
+ 
+ 			GtkWidget *tablewidget = gtk_table_new (2, 2, FALSE);
+ 			gtk_table_set_row_spacings (GTK_TABLE (tablewidget), 6);
+ 			gtk_table_set_col_spacings (GTK_TABLE (tablewidget), 12);
+ 
+ 			gtk_box_pack_start (GTK_BOX (box), tablewidget, FALSE, FALSE, 0); 
+ 
+ 
+ 			aHandle.orientwidget = gtk_combo_box_new_text();
+ 			aHandle.paperwidget = gtk_combo_box_new_text();
+ 
+ 			gtk_table_attach(GTK_TABLE(tablewidget), gtk_label_new(
+ 					rtl::OUStringToOString(maOrientationStr, RTL_TEXTENCODING_UTF8).getStr()), 
+ 				0, 1, 0, 1, GTK_FILL, GTK_EXPAND, 0, 0);
+ 			gtk_table_attach(GTK_TABLE(tablewidget), aHandle.orientwidget, 1, 2, 0, 1,
+ 				GTK_FILL, GTK_EXPAND, 0, 0);
+ 			gtk_table_attach(GTK_TABLE(tablewidget),  gtk_label_new(
+ 					rtl::OUStringToOString(maPaperFormatStr, RTL_TEXTENCODING_UTF8).getStr()),
+ 				0, 1, 1, 2, GTK_FILL, GTK_EXPAND, 0, 0);
+ 			gtk_table_attach(GTK_TABLE(tablewidget), aHandle.paperwidget, 1, 2, 1, 2,
+ 				GTK_FILL, GTK_EXPAND, 0, 0);
+ 
+ 			gtk_widget_show_all(box);
+ 
+ 			rtl::OString sProperties(OUStringToOString(aProperties, RTL_TEXTENCODING_UTF8));
+ 			gtk_print_unix_dialog_add_custom_tab(GTK_PRINT_UNIX_DIALOG(aHandle.pDialog), box,
+ 				gtk_label_new(sProperties.getStr()));
+ 
+ 			g_object_get(G_OBJECT(box),"parent", &aHandle.notebook,NULL);
+ 		}
+ 
+ 		//make this the child of the OOo document window, and make it
+ 		//the parent of the future OOo options window
+ 		if (parent) gtk_window_set_transient_for(GTK_WINDOW(aHandle.pDialog), parent);
+ 		mnNativeHandle = reinterpret_cast<unsigned long>(aHandle.pDialog);
+ 
+ 		GtkPrintSettings* pTempSettings = gtk_print_unix_dialog_get_settings(GTK_PRINT_UNIX_DIALOG(aHandle.pDialog));
+ 		if (const QueueInfo* pInfo = (const QueueInfo*)(maLbName.GetEntryData(maLbName.GetSelectEntryPos())))
+ 		{
+ 			gtk_print_settings_set_printer(pTempSettings, rtl::OUStringToOString(pInfo->GetPrinterName(), 
+ 				RTL_TEXTENCODING_UTF8).getStr());
+ 		}
+ 
+ 		gtk_print_settings_set_int(pTempSettings, "n-copies", GetCopyCount());
+ 		gtk_print_settings_set_collate(pTempSettings, IsCollateEnabled() && IsCollateChecked());
+ 		if (mbRange)
+ 		{
+ 			GtkPageRange page_ranges;
+ 			page_ranges.start = page_ranges.end = maRangeText.ToInt32()-1;
+ 			gtk_print_settings_set_page_ranges(pTempSettings, &page_ranges, 1);
+ 			gtk_print_unix_dialog_set_current_page(GTK_PRINT_UNIX_DIALOG(aHandle.pDialog), page_ranges.start);
+ 		}
+ 		gtk_print_unix_dialog_set_settings(GTK_PRINT_UNIX_DIALOG(aHandle.pDialog), pTempSettings);
+ 		g_object_unref(pTempSettings);
+ 
+ 		aHandle.pPrinter = mpPrinter;
+ 
+ 		SetProperties(aHandle, true);
+ 
+ 		gulong nHID_PageChange=0;
+ 		if (aHandle.notebook && GTK_IS_NOTEBOOK(aHandle.notebook))
+ 		{
+ 			gtk_notebook_set_current_page(GTK_NOTEBOOK(aHandle.notebook), 0);
+ 			nHID_PageChange = g_signal_connect(G_OBJECT(aHandle.notebook), "switch-page", G_CALLBACK(switch_page_cb), &aHandle);
+ 		}
+ 
+ 		bool bContinue = true;
+ 		while(bContinue)
+ 		{
+ 			bContinue = false;
+ 			gint nStatus = gtk_dialog_run( GTK_DIALOG( aHandle.pDialog ) );
+ 			switch( nStatus )
+ 			{
+ 			    case GTK_RESPONSE_HELP:
+ 				ClickOptionsHdl();
+ 				bContinue = true;
+ 				break;
+ 			    case GTK_RESPONSE_OK:
+ 				{
+ 				GtkPrintSettings* pSettings = gtk_print_unix_dialog_get_settings (GTK_PRINT_UNIX_DIALOG(aHandle.pDialog));
+ 
+ 				rtl::OUString sPath;
+ 				if (const gchar *uri = gtk_print_settings_get(pSettings, GTK_PRINT_SETTINGS_OUTPUT_URI))
+ 				{
+ 					if (gchar *pFile = g_filename_from_uri (uri, NULL, NULL))
+ 					{
+ 						sPath = rtl::OUString((const sal_Char *)pFile, strlen((const sal_Char*)(pFile)), osl_getThreadTextEncoding());
+ 						g_free(pFile);
+ 					}
+ 				}
+ 				const gchar *pStr = gtk_print_settings_get(pSettings, GTK_PRINT_SETTINGS_PRINT_PAGES);
+ 				if (pStr && !strcmp(pStr, "ranges"))
+ 				{
+ 					maRangeText = String();
+ 					gint num_ranges;
+ 					const GtkPageRange* pRanges = gtk_print_settings_get_page_ranges(pSettings, &num_ranges);
+ 					for (gint i = 0; i < num_ranges; ++i)
+ 					{
+ 						maRangeText.Append(String::CreateFromInt32(pRanges[i].start+1));
+ 						if (pRanges[i].start != pRanges[i].end)
+ 						{
+ 							maRangeText.AppendAscii("-");
+ 							maRangeText.Append(String::CreateFromInt32(pRanges[i].end+1));
+ 						}
+ 						
+ 						if (i != num_ranges-1)
+ 							maRangeText.AppendAscii(",");
+ 					}
+ 					meCheckRange = PRINTDIALOG_RANGE;
+ 				}
+ 				else if (pStr && !strcmp(pStr, "current"))
+ 				{
+ 					meCheckRange = PRINTDIALOG_RANGE;
+ 					
+ 					try
+ 					{
+                         Reference < XFramesSupplier > xDesktop = Reference < XFramesSupplier >(
+                                 ::comphelper::getProcessServiceFactory()->
+                                 createInstance( ASCII_STR("com.sun.star.frame.Desktop") ), UNO_QUERY );
+                         Reference < XFrame > xFrame( xDesktop->getActiveFrame() );
+                         if ( !xFrame.is() )
+                             xFrame = Reference < XFrame >( xDesktop, UNO_QUERY );
+ 
+                         Reference< XController > xController;
+                         Reference< XSpreadsheetView > xSpreadsheetView;
+                         Reference< XSpreadsheet> xSheet;
+                         Reference< XSpreadsheetDocument > xSheetDoc;
+                         Reference< XIndexAccess > xSheets;
+                         Reference< XNamed > xName;
+ 
+                         if (xFrame.is())
+                             xController = xFrame->getController();
+                         if (xController.is())
+                             xSpreadsheetView = Reference< XSpreadsheetView >(xController, UNO_QUERY);
+                         if (xSpreadsheetView.is())
+                             xSheet = Reference< XSpreadsheet>(xSpreadsheetView->getActiveSheet());
+                         if (xSheet.is())
+                             xName = Reference < XNamed >(xSheet, UNO_QUERY);
+                         if (xName.is())
+                             xSheetDoc = Reference< XSpreadsheetDocument >(xController->getModel(), UNO_QUERY);
+                         if (xSheetDoc.is())
+                             xSheets = Reference< XIndexAccess >(xSheetDoc->getSheets(), UNO_QUERY);
+                         if (xSheets.is())
+                         {
+                             const rtl::OUString &rName = xName->getName();
+ 
+                             sal_Int32 i;
+ 
+                             for( i = 0; i < xSheets->getCount(); ++i)
+                             {
+                                 Reference < XNamed > xItem =
+                                     Reference < XNamed >(xSheets->getByIndex(i), UNO_QUERY);
+                                 if (rName == xItem->getName())
+                                     break;
+                             }
+ 
+                             if (i < xSheets->getCount())
+                                 maRangeText = String::CreateFromInt32( i + 1 );
+                         }
+ 					}
+                     catch (...) {}
+ 				}
+ 				else
+ 					meCheckRange = PRINTDIALOG_ALL;
+ 
+ 				//Tell OOo to only print 1 simple copy, we'll stick everything
+ 				//else through cups
+ 				SetCopyCount(1);
+ 				EnableCollate(false);
+ 				CheckCollate(false);
+ 
+ 				pStr = 0;
+ 
+ 				if (sPath.getLength())
+ 					pStr = gtk_print_settings_get(pSettings, GTK_PRINT_SETTINGS_OUTPUT_FILE_FORMAT);
+ 
+ 				if (pStr && !strcmp(pStr, "pdf"))
+ 				{
+ 					gtk_widget_hide( aHandle.pDialog );
+ 					rtl::OUString sFileURL;
+ 					FileBase::getFileURLFromSystemPath(sPath, sFileURL);
+ 					ExportAsPDF(sFileURL, meCheckRange, maRangeText);
+ 				}
+ 				else
+ 				{
+ 					nRet = TRUE;
+ 					rtl::OUString sNewPrinterName(mpPrinter->GetName());
+ 
+ 					if (sPath.getLength())
+ 					{
+ 						mpPrinter->EnablePrintFile(true);
+ 						mpPrinter->SetPrintFile(sPath);
+ 						sNewPrinterName = ASCII_STR("Generic Printer");
+ 					}
+ 					else if (GtkPrinter* pPrinter = gtk_print_unix_dialog_get_selected_printer(GTK_PRINT_UNIX_DIALOG(aHandle.pDialog)))
+ 					{
+ 					    pStr = gtk_print_settings_get(pSettings, "lpr-commandline");
+ 					    if (pStr && *pStr)
+ 					    {
+ 						    sNewPrinterName = ASCII_STR("Generic Printer");
+                            psp::PrinterInfoManager& rManager( psp::PrinterInfoManager::get() );
+                            psp::PrinterInfo aInfo(rManager.getPrinterInfo(sNewPrinterName));
+                            aInfo.m_aCommand = rtl::OUString((const sal_Char *)pStr, strlen((const sal_Char*)(pStr)), RTL_TEXTENCODING_UTF8);
+                            rManager.changePrinterInfo(sNewPrinterName, aInfo);
+ 					    }
+ 					    else
+ 					    {
+ 						    pStr = gtk_printer_get_name(pPrinter);
+ 						    sNewPrinterName = rtl::OUString((const sal_Char *)pStr, strlen((const sal_Char*)(pStr)), RTL_TEXTENCODING_UTF8);
+ 					    }
+ 					}
+ 					
+ 					OUString sOldPrinterName(mpPrinter->GetName());
+ 					if (sNewPrinterName != sOldPrinterName)
+ 					{
+ 						for (int i = 0; i < 2; ++i)
+ 						{
+ 	                        if (const QueueInfo* pInfo = Printer::GetQueueInfo( sNewPrinterName, false ))
+ 	                        {
+ 	                            Printer aTempPrinter(*pInfo);
+ 	                            mpPrinter->SetPrinterProps(&aTempPrinter);
+ 								break;
+ 	                        }
+ 							else
+ 							{
+ 								if (!i)
+ 								{
+                                     psp::PrinterInfoManager& rManager( psp::PrinterInfoManager::get() );
+ 									rManager.stopsearch();
+ 								    rManager.startsearch();
+ 									rManager.checkPrintersChanged(true);
+ 									ImplDeletePrnQueueList();
+ 								}
+ 								else
+ 								{
+ 									fprintf(stderr, "OOo UNKNOWN PRINTER \"%s\"\n", 
+ 										rtl::OUStringToOString(sNewPrinterName, RTL_TEXTENCODING_UTF8).getStr());
+ 								}
+ 							}
+ 						}
+ 					}
+ 					mpPrinter->Reset();
+ 					gtk_print_settings_foreach(pSettings, setcupskey, mpPrinter);
+ 
+ 					mpPrinter->SetOrientation(ORIENTATION_PORTRAIT);
+ 
+ 					int nPapers = mpPrinter->GetPaperInfoCount();
+ 					pStr = gtk_combo_box_get_active_text(GTK_COMBO_BOX(aHandle.paperwidget)); 
+ 					if ( pStr && nPapers )
+ 					{
+ 					    rtl::OUString sPaper((const sal_Char*)pStr, strlen((const sal_Char*)(pStr)), RTL_TEXTENCODING_UTF8);
+ 					    for (int i = 0; i < nPapers; ++i)
+ 					    {
+ 						    const vcl::PaperInfo &rInfo = mpPrinter->GetPaperInfo(i);
+ 						    if (rtl::OUString(rInfo.m_aPaperName) == sPaper)
+ 						    {
+ 							    mpPrinter->SetPaperFromInfo(rInfo);
+ 							    break;
+ 						    }
+ 					    }
+ 					}
+ 
+ 					if (1 == gtk_combo_box_get_active(GTK_COMBO_BOX(aHandle.orientwidget)))
+ 						mpPrinter->SetOrientation(ORIENTATION_LANDSCAPE);
+ 				}
+ 				g_object_unref(pSettings);
+ 				}
+ 				break;
+ 			    default:
+ 				break;
+ 			}
+ 		}
+ 		gtk_widget_hide( aHandle.pDialog );
+ 		if (nHID_PageChange)
+         	g_signal_handler_disconnect(G_OBJECT(aHandle.notebook), nHID_PageChange);
+ //		gtk_widget_destroy( aHandle.pDialog );
+ 	}
+ 	else
+ 	{
+ 		// Dialog starten
+ 		nRet = ModalDialog::Execute();
+ 
+ 		// Wenn Dialog mit OK beendet wurde, dann die Daten updaten
+ 		if( nRet == TRUE )
+ 		{
+ 			if ( TEMPPRINTER() )
+ 				mpPrinter->SetPrinterProps( TEMPPRINTER() );
+ 			ImplFillDialogData();
+ 		}
 	}
 
 	maStatusTimer.Stop();
@@ -826,4 +1437,3 @@
 	mpPrinterImpl->m_bHelpDisabled = sal_True;
 	maBtnHelp.Disable();
 }
-
--- svtools/source/dialogs/printdlg.hrc
+++ svtools/source/dialogs/printdlg.hrc
@@ -78,5 +78,6 @@
 #define BTN_HELP                53
 #define BTN_OPTIONS             54
 
-#define STR_ALLFILTER           10
-
+#define STR_ALLFILTER           	10
+#define STR_PAPER_PAPER_TXT			11
+#define STR_PAPER_ORIENTATION_TXT	12
--- svtools/source/dialogs/printdlg.src
+++ svtools/source/dialogs/printdlg.src
@@ -282,6 +282,16 @@
     {
     	Text [ en-US ] = "<All>";
 	};
+    String STR_PAPER_PAPER_TXT
+    {
+        Text [ de ] = "Papierformat:";
+        Text [ en-US ] = "Paper size:";
+    };
+    String STR_PAPER_ORIENTATION_TXT
+    {
+        Text [ de ] = "Orientierung:";
+        Text [ en-US ] = "Orientation:";
+    };
 };
 
 Image RID_IMG_PRNDLG_COLLATE
--- svtools/util/makefile.mk
+++ svtools/util/makefile.mk
@@ -45,6 +45,9 @@
 GEN_HID_OTHER=TRUE
 ENABLE_EXCEPTIONS=TRUE
 
+PKGCONFIG_MODULES=gtk+-unix-print-2.0
+.INCLUDE: pkg_config.mk
+
 # --- Settings -----------------------------------------------------
 
 .INCLUDE :	settings.mk
@@ -153,9 +156,12 @@
 		$(CPPULIB)			\
 		$(VOSLIB)			\
 		$(SALLIB)			\
-		$(ICUUCLIB)		\
+		$(ICUUCLIB)			\
+		-lpsp$(VERSION)$(DLLPOSTFIX)\
 		$(JVMFWKLIB)
 
+SHL1STDLIBS+=$(PKGCONFIG_LIBS)
+
 .IF "$(OS)"=="MACOSX"
 # static libraries go at end
 SHL1STDLIBS+= $(JPEG3RDLIB)
--- vcl/inc/vcl/jobset.hxx
+++ vcl/inc/vcl/jobset.hxx
@@ -50,6 +50,7 @@
 #ifndef _SV_PRNTYPES_HXX
 #include <vcl/prntypes.hxx>
 #endif
+#include <psprint/printerinfomanager.hxx>
 
 class SvStream;
 struct ImplJobSetup;
@@ -87,6 +88,9 @@
 	 */
 	String				GetValue( const String& rKey ) const;
 	void				SetValue( const String& rKey, const String& rValue );
+        void                            SetCupsKey( const String& rKey, const String& rValue );
+        void                            Reset( );
+        psp::PrinterInfo                GetPrinterInfo() const;
 
 	JobSetup&			operator=( const JobSetup& rJob );
 
--- vcl/inc/vcl/print.h
+++ vcl/inc/vcl/print.h
@@ -99,6 +99,6 @@
 // - Prototypes -
 // --------------
 
-void ImplDeletePrnQueueList();
+VCL_DLLPUBLIC void ImplDeletePrnQueueList();
 
 #endif // _SV_PRINT_H
--- vcl/inc/vcl/print.hxx
+++ vcl/inc/vcl/print.hxx
@@ -354,6 +354,10 @@
 	const JobSetup& 			GetJobSetup() const { return maJobSetup; }
 	String						GetJobValue( const String& rKey ) const { return maJobSetup.GetValue( rKey ); }
 	void						SetJobValue( const String& rKey, const String& rValue ) { maJobSetup.SetValue( rKey, rValue ); }
+	void                        SetJobCupsKey( const String& rKey, const String& rValue ) { maJobSetup.SetCupsKey( rKey, rValue ); }
+	void Reset( ) { maJobSetup.Reset(); }
+    psp::PrinterInfo            GetPrinterInfo() const;
+
 
 	BOOL						Setup( Window* pWindow = NULL );
 	BOOL						SetPrinterProps( const Printer* pPrinter );
--- vcl/inc/vcl/salframe.hxx
+++ vcl/inc/vcl/salframe.hxx
@@ -302,6 +302,9 @@
     // (e.g. input methods, printer update handlers).
     long						CallCallback( USHORT nEvent, const void* pEvent ) const
     { return m_pProc ? m_pProc( m_pWindow, const_cast<SalFrame*>(this), nEvent, pEvent ) : 0; }
+
+    virtual unsigned long GetNativeHandle() const { return 0; }
+    virtual void SetNativeParent(unsigned long nParent) {}
 };
 
 #endif // __cplusplus
--- vcl/inc/vcl/window.hxx
+++ vcl/inc/vcl/window.hxx
@@ -1121,6 +1121,9 @@
     /* mark Window for deletion in top of event queue
     */
     void doLazyDelete();
+
+    virtual unsigned long GetNativeHandle() const;
+    virtual void SetNativeParent(unsigned long nParent);
 };
 
 
--- vcl/source/gdi/jobset.cxx
+++ vcl/source/gdi/jobset.cxx
@@ -53,6 +53,7 @@
 #include <vcl/jobset.h>
 #endif
 
+#include <psprint/printerinfomanager.hxx>
 // =======================================================================
 
 DBG_NAME( JobSetup )
@@ -246,6 +247,231 @@
 	mpData->maValueMap[ rKey ] = rValue;
 }
 
+inline int PtTo10Mu( int nPoints ) { return (int)((((double)nPoints)*35.27777778)+0.5); }
+void copyJobDataToJobSetup( ImplJobSetup* pJobSetup, psp::JobData& rData );
+
+static struct
+{
+	int			width;
+	int			height;
+	const char*	name;
+	int			namelength;
+	Paper		paper;
+} aPaperTab[] =
+{
+	{ 29700, 42000,	"A3",			2,	PAPER_A3		},
+	{ 21000, 29700,	"A4",			2,	PAPER_A4		},
+	{ 14800, 21000,	"A5",			2,	PAPER_A5		},
+	{ 25000, 35300,	"B4",			2,	PAPER_B4		},
+	{ 17600, 25000,	"B5",			2,	PAPER_B5		},
+	{ 21600, 27900,	"Letter",		6,	PAPER_LETTER	},
+	{ 21600, 35600,	"Legal",		5,	PAPER_LEGAL		},
+	{ 27900, 43100,	"Tabloid",		7,	PAPER_TABLOID	},
+	{ 0, 0,	  		"USER",			4,	PAPER_USER		}
+};
+
+static Paper getPaperType( const String& rPaperName )
+{
+	ByteString aPaper( rPaperName, RTL_TEXTENCODING_ISO_8859_1 );
+	for( unsigned int i = 0; i < sizeof( aPaperTab )/sizeof( aPaperTab[0] ); i++ )
+	{
+		if( ! strcmp( aPaper.GetBuffer(), aPaperTab[i].name ) )
+			return aPaperTab[i].paper;
+	}
+	return PAPER_USER;
+}
+
+
+
+void copyJobDataToJobSetup( ImplJobSetup* pJobSetup, psp::JobData& rData )
+{
+	using namespace psp;
+
+	pJobSetup->meOrientation	= (Orientation)(rData.m_eOrientation == orientation::Landscape ? ORIENTATION_LANDSCAPE : ORIENTATION_PORTRAIT);
+
+
+	// copy page size
+	String aPaper;
+	int width, height;
+
+	rData.m_aContext.getPageSize( aPaper, width, height );
+	pJobSetup->mePaperFormat	= getPaperType( aPaper );
+	pJobSetup->mnPaperWidth		= 0;
+	pJobSetup->mnPaperHeight	= 0;
+	if( pJobSetup->mePaperFormat == PAPER_USER )
+	{
+		// transform to 100dth mm
+		width				= PtTo10Mu( width );
+		height				= PtTo10Mu( height );
+
+        if( rData.m_eOrientation == psp::orientation::Portrait )
+        {
+            pJobSetup->mnPaperWidth	= width;
+            pJobSetup->mnPaperHeight= height;
+        }
+        else
+        {
+            pJobSetup->mnPaperWidth	= height;
+            pJobSetup->mnPaperHeight= width;
+        }
+	}
+
+	// copy input slot
+	const PPDKey* pKey = NULL;
+	const PPDValue* pValue = NULL;
+
+    pJobSetup->mnPaperBin = 0xffff;
+	pKey						= rData.m_pParser->getKey( String( RTL_CONSTASCII_USTRINGPARAM( "InputSlot" ) ) );
+    if( pKey )
+        pValue					= rData.m_aContext.getValue( pKey );
+    if( pKey && pValue )
+    {
+        for( pJobSetup->mnPaperBin = 0;
+             pValue != pKey->getValue( pJobSetup->mnPaperBin ) &&
+                 pJobSetup->mnPaperBin < pKey->countValues();
+             pJobSetup->mnPaperBin++ )
+            ;
+        if( pJobSetup->mnPaperBin >= pKey->countValues() || pValue == pKey->getDefaultValue() )
+            pJobSetup->mnPaperBin = 0xffff;
+    }
+	
+
+	// copy the whole context
+	if( pJobSetup->mpDriverData )
+		rtl_freeMemory( pJobSetup->mpDriverData );
+
+	int nBytes;
+	void* pBuffer = NULL;
+	if( rData.getStreamBuffer( pBuffer, nBytes ) )
+	{
+		pJobSetup->mnDriverDataLen = nBytes;
+		pJobSetup->mpDriverData = (BYTE*)pBuffer;
+	}
+	else
+	{
+		pJobSetup->mnDriverDataLen = 0;
+		pJobSetup->mpDriverData = NULL;
+	}
+}
+
+psp::PrinterInfo JobSetup::GetPrinterInfo() const
+{
+	using namespace psp;
+
+	PrinterInfoManager& rManager = PrinterInfoManager::get();
+	PrinterInfo aInfo(rManager.getPrinterInfo(mpData->maPrinterName));
+	if (mpData->mpDriverData)
+	{
+		JobData::constructFromStreamBuffer(mpData->mpDriverData, 
+			mpData->mnDriverDataLen, aInfo);
+	}
+
+	return aInfo;
+}
+
+void JobSetup::Reset( )
+{
+	if( ! mpData )
+		mpData = new ImplJobSetup();
+
+	using namespace psp;
+
+	PrinterInfoManager& rManager = PrinterInfoManager::get();
+	PrinterInfo aInfo(rManager.getPrinterInfo(mpData->maPrinterName));
+	if (mpData->mpDriverData )
+	{
+		JobData::constructFromStreamBuffer(mpData->mpDriverData, 
+		mpData->mnDriverDataLen, aInfo);
+	}
+
+	int nDifferent = aInfo.m_aContext.countValuesModified();
+	for (int i = 0; i < nDifferent; ++i)
+	{
+		const PPDKey* pKey = aInfo.m_aContext.getModifiedKey(i);
+		bool bResult = aInfo.m_aContext.resetValue(pKey, true);
+	}
+
+	if (aInfo.m_pParser)
+        const_cast<PPDParser*>(aInfo.m_pParser)->Reset();
+
+    aInfo.m_aContext.rebuildFromStreamBuffer( NULL, 0 );
+    
+    aInfo.m_bCupsJob=false;
+    copyJobDataToJobSetup( mpData, aInfo );
+}
+
+void JobSetup::SetCupsKey( const String& rKey, const String& rValue )
+{
+	if( ! mpData )
+		mpData = new ImplJobSetup();
+
+	using namespace psp;
+
+	PrinterInfoManager& rManager = PrinterInfoManager::get();
+	PrinterInfo aInfo(rManager.getPrinterInfo(mpData->maPrinterName));
+	if (mpData->mpDriverData )
+	{
+		JobData::constructFromStreamBuffer(mpData->mpDriverData, 
+		mpData->mnDriverDataLen, aInfo);
+	}
+	if (aInfo.m_pParser)
+	{
+		//fprintf(stderr, "key of %s, value of %s\n", 
+		//    rtl::OUStringToOString(rKey, RTL_TEXTENCODING_UTF8).getStr(), 
+		//	rtl::OUStringToOString(rValue, RTL_TEXTENCODING_UTF8).getStr());
+
+		if (const PPDKey* pKey = aInfo.m_pParser->getKey(rKey))
+		{
+			bool bFound = false;
+			for (int i = 0; i < pKey->countValues(); ++i)
+			{
+               			const PPDValue *pValue = pKey->getValue(i);
+				//fprintf(stderr, "possible of %s\n", rtl::OUStringToOString(pValue->m_aOption, RTL_TEXTENCODING_UTF8).getStr());
+               			if (rValue == pValue->m_aOption)
+				{
+					aInfo.m_aContext.setValue(pKey, pValue);
+					bFound = true;
+					break;
+				}
+			}
+			if (!bFound && rKey == String::CreateFromAscii("PageSize"))
+			{
+				String aString(rValue);
+				if (aString == String::CreateFromAscii("USLetter"))
+					aString = String::CreateFromAscii("Letter");
+				else if (aString == String::CreateFromAscii("USLegal"))
+					aString = String::CreateFromAscii("Legal");
+				for (int i = 0; i < pKey->countValues(); ++i)
+				{
+					const PPDValue *pValue = pKey->getValue(i);
+					if (aString == pValue->m_aOption)
+					{
+						aInfo.m_aContext.setValue(pKey, pValue);
+						bFound = true;
+						break;
+					}
+				}
+			}
+			//if (!bFound)	
+			//	fprintf(stderr, "Warning uknown PPD value %s\n", rtl::OUStringToOString(rValue, RTL_TEXTENCODING_UTF8).getStr());
+		}
+		else
+		{
+			PPDKey* pNewKey = new PPDKey( rKey );
+            pNewKey->setPseudoKey();
+			 pNewKey->insertValue(String(RTL_CONSTASCII_USTRINGPARAM("None")));
+            PPDValue* pValue = pNewKey->insertValue(rValue);
+            pValue->m_eType = eInvocation;
+            pValue->m_aValue = rValue;
+			const_cast<PPDParser*>(aInfo.m_pParser)->insertKey( rKey, pNewKey );
+			aInfo.m_aContext.setValue(pNewKey, pValue);
+		}
+	}
+    aInfo.m_bCupsJob=true;
+    copyJobDataToJobSetup( mpData, aInfo );
+
+}
+
 // -----------------------------------------------------------------------
 
 JobSetup& JobSetup::operator=( const JobSetup& rJobSetup )
--- vcl/source/gdi/print.cxx
+++ vcl/source/gdi/print.cxx
@@ -803,6 +803,17 @@
 	return FALSE;
 }
 
+psp::PrinterInfo Printer::GetPrinterInfo() const
+{
+	if (maJobSetup.GetPrinterName() == maPrinterName)
+		return maJobSetup.GetPrinterInfo();
+
+       	using namespace psp;
+        PrinterInfoManager& rManager = PrinterInfoManager::get();
+        PrinterInfo aInfo(rManager.getPrinterInfo(maPrinterName));
+        return aInfo;
+}
+
 // -----------------------------------------------------------------------
 
 
--- vcl/source/window/window.cxx
+++ vcl/source/window/window.cxx
@@ -4315,6 +4315,16 @@
         pFocusWin->mpFontCache->Release( pFontEntry );
 }
 
+unsigned long Window::GetNativeHandle() const
+{
+    return ImplGetFrame() ? ImplGetFrame()->GetNativeHandle() : 0;
+}
+
+void Window::SetNativeParent(unsigned long nParent)
+{
+    if (ImplGetFrame()) ImplGetFrame()->SetNativeParent(nParent);
+}
+
 // -----------------------------------------------------------------------
 
 Window::Window( WindowType nType )
--- vcl/unx/gtk/window/gtkframe.cxx
+++ vcl/unx/gtk/window/gtkframe.cxx
@@ -773,6 +773,17 @@
     return pWindow->GetAccessible( bCreate );
 }
 
+unsigned long GtkSalFrame::GetNativeHandle() const
+{
+    return reinterpret_cast<unsigned long>(m_pWindow);
+}
+
+void GtkSalFrame::SetNativeParent(unsigned long nParent)
+{
+    if (GtkWindow* pNativeParent = GTK_WINDOW(nParent))
+        gtk_window_set_transient_for( m_pWindow, pNativeParent );
+}
+
 void GtkSalFrame::Init( SalFrame* pParent, ULONG nStyle )
 {
     if( nStyle & SAL_FRAME_STYLE_DEFAULT ) // ensure default style
--- vcl/unx/inc/plugins/gtk/gtkframe.hxx
+++ vcl/unx/inc/plugins/gtk/gtkframe.hxx
@@ -387,6 +387,9 @@
 	::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > getAccessible( bool bCreate = true );
     
     static AtkRole              GetAtkRole( GtkWindow* window );
+
+    virtual unsigned long GetNativeHandle() const;
+    virtual void SetNativeParent(unsigned long nParent);
 };
 
 
