commit 19213a6c34e1b47a100815ccbfee8b5c70c3c12a
Author: Alex Fiestas <afiestas@kde.org>
Date:   Tue Jun 5 18:12:28 2012 +0200

    Emit deviceRemoved/Added with the right deviceList set
    
    The problem is quite straightforward, deviceAdded is being emitted when
    the m_deviceList has the OLD list, so the new device is still NOT in it.
    If the user of the library instances a device Solid::Device(UDI) in the
    slot after that signal, the device will be null because it will not be
    found in m_deviceList.
    
    REVIEW: 105132

diff --git a/solid/solid/backends/fstab/fstabmanager.cpp b/solid/solid/backends/fstab/fstabmanager.cpp
index 608159f..6b29fa4 100644
--- a/solid/solid/backends/fstab/fstabmanager.cpp
+++ b/solid/solid/backends/fstab/fstabmanager.cpp
@@ -116,17 +116,19 @@ void FstabManager::_k_updateDeviceList()
     QSet<QString> newlist = deviceList.toSet();
     QSet<QString> oldlist = m_deviceList.toSet();
 
-    foreach(const QString &device, newlist) {
-        if ( !oldlist.contains(device) )
-            emit deviceAdded(udiPrefix() + "/" + device);
-    }
-
     foreach(const QString &device, oldlist) {
-        if ( !newlist.contains(device) )
+        if ( !newlist.contains(device) ) {
             emit deviceRemoved(udiPrefix() + "/" + device);
+        }
     }
 
     m_deviceList = deviceList;
+
+    foreach(const QString &device, newlist) {
+        if ( !oldlist.contains(device) ) {
+            emit deviceAdded(udiPrefix() + "/" + device);
+        }
+    }
 }
 
 void FstabManager::onMtabChanged()
