From 048c67d6f351083741ef68e94a278a445c16436d Mon Sep 17 00:00:00 2001
From: Martin-Éric Racine <martin-eric.racine@iki.fi>
Date: Mon, 02 Jan 2012 15:49:10 +0000
Subject: z4l.c: drop unnecessary #include linux/types.h

On hybrid platforms, such as Debian GNU/KFreeBSD, that support V4L2
and yet without providing the full complement of Linux headers, ZTV
fails to compile because of this missing header.

Given how removing this header does not adversely affect compiling,
plus it might improve portability, we went ahead and removed it.

Nonetheless, as observed by Gaetan Nadon, z4l.c includes code that
explicitly disables the module on any OS other than Linux:

    LoaderGetOS(&osname, NULL, NULL, NULL);

    if (osname == NULL || strcmp(osname, "linux") != 0) {
    if (errmaj)
        *errmaj = LDR_BADOS;
    if (errmin)
        *errmin = 0;

    return NULL;
    }

Still, in the interest of OS neutrality, we decided to leave recent
autoconf magic in place and to let OS vendors figure out how to get
the module loaded on non-Linux OS themselves. Patches are welcome.

Signed-off-by: Martin-Éric Racine <martin-eric.racine@iki.fi>
---
diff --git a/src/z4l.c b/src/z4l.c
index c6a7c58..a21e492 100644
--- a/src/z4l.c
+++ b/src/z4l.c
@@ -47,8 +47,6 @@
 #include "xf86xv.h"
 #include "fourcc.h"
 
-#include <linux/types.h>
-
 #define __s64 __s_64
 typedef long long __s64;
 
--
cgit v0.9.0.2-2-gbebe
From b9afafec0a26eaec49e7f0ff08297c2bb795a9c2 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Tue, 03 Apr 2012 10:08:09 +0000
Subject: geode: fix compile on x86-64 in tinderbox.

geode_ddc.c: In function 'GeodeI2CInit':
geode_ddc.c:158: error: cast to pointer from integer of different size

Signed-off-by: Dave Airlie <airlied@redhat.com>
---
diff --git a/src/geode_ddc.c b/src/geode_ddc.c
index 086dbb1..4691d12 100644
--- a/src/geode_ddc.c
+++ b/src/geode_ddc.c
@@ -155,7 +155,7 @@ GeodeI2CInit(ScrnInfoPtr pScrni, I2CBusPtr * ptr, char *name)
 
     bus->I2CGetBits = geode_ddc_getbits;
     bus->I2CPutBits = geode_ddc_putbits;
-    bus->DriverPrivate.ptr = (void *)(ddciobase);
+    bus->DriverPrivate.ptr = (void *)(unsigned long)(ddciobase);
 
     if (!xf86I2CBusInit(bus))
 	return FALSE;
--
cgit v0.9.0.2-2-gbebe
From 1ed67d70ac9d3afd9b372c311aaf7b77e38b3e21 Mon Sep 17 00:00:00 2001
From: Martin-Éric Racine <martin-eric.racine@iki.fi>
Date: Wed, 11 Jul 2012 12:50:28 +0000
Subject: Whitespace cleanup using ../modular/x-indent.sh

---
diff --git a/src/cim/cim_defs.h b/src/cim/cim_defs.h
index eea2f49..9084a07 100644
--- a/src/cim/cim_defs.h
+++ b/src/cim/cim_defs.h
@@ -284,7 +284,6 @@
 
 #elif CIMARRON_MSR_HOOKS
 
-
 #define MSR_READ(msr_reg, device_add, data64_ptr)                  \
 {                                                                  \
     unsigned long addr, val1, val2;                                \
@@ -311,7 +310,7 @@
 }
 #endif
 
-#endif /* #ifdef CIMARRON_INCLUDE_MSR_MACROS */
+#endif                          /* #ifdef CIMARRON_INCLUDE_MSR_MACROS */
 
 /*-----------------------------------------------------------------*/
 /* STRING MACROS                                                   */
@@ -518,7 +517,7 @@
 
 #endif
 
-#endif /* #ifdef CIMARRON_INCLUDE_STRING_MACROS */
+#endif                          /* #ifdef CIMARRON_INCLUDE_STRING_MACROS */
 
 /*-----------------------------------------------------------------
  * WRITE_COMMAND_STRING8
@@ -585,14 +584,11 @@ void
 cim_outd(unsigned short port, unsigned long data)
 {
     _asm {
-    pushf mov eax, data mov dx, port out dx, eax popf}
-}
-
+pushf mov eax, data mov dx, port out dx, eax popf}}
 /*-------------------------------------------
  * IND
  * Reads one DWORD from a single I/O address.
  *-------------------------------------------*/
-
 #define IND(port) cim_ind(port)
 unsigned long
 cim_ind(unsigned short port)
@@ -600,8 +596,7 @@ cim_ind(unsigned short port)
     unsigned long data;
 
     _asm {
-    pushf mov dx, port in eax, dx mov data, eax popf}
-    return data;
+    pushf mov dx, port in eax, dx mov data, eax popf} return data;
 }
 
 /*-------------------------------------------
@@ -614,14 +609,11 @@ void
 cim_outw(unsigned short port, unsigned short data)
 {
     _asm {
-    pushf mov ax, data mov dx, port out dx, ax popf}
-}
-
+pushf mov ax, data mov dx, port out dx, ax popf}}
 /*-------------------------------------------
  * INW
  * Reads one WORD from a single I/O address.
  *-------------------------------------------*/
-
 #define INW(port) cim_inw(port)
 unsigned short
 cim_inw(unsigned short port)
@@ -629,8 +621,7 @@ cim_inw(unsigned short port)
     unsigned short data;
 
     _asm {
-    pushf mov dx, port in ax, dx mov data, ax popf}
-    return data;
+    pushf mov dx, port in ax, dx mov data, ax popf} return data;
 }
 
 /*-------------------------------------------
@@ -643,14 +634,11 @@ void
 cim_outb(unsigned short port, unsigned char data)
 {
     _asm {
-    pushf mov al, data mov dx, port out dx, al popf}
-}
-
+pushf mov al, data mov dx, port out dx, al popf}}
 /*-------------------------------------------
  * INB
  * Reads one BYTE from a single I/O address.
  *-------------------------------------------*/
-
 #define INB(port) cim_inb(port)
 unsigned char
 cim_inb(unsigned short port)
@@ -658,8 +646,7 @@ cim_inb(unsigned short port)
     unsigned char data;
 
     _asm {
-    pushf mov dx, port in al, dx mov data, al popf}
-    return data;
+    pushf mov dx, port in al, dx mov data, al popf} return data;
 }
 
 #elif CIMARRON_IO_ABSTRACTED_ASM
@@ -753,9 +740,9 @@ cim_outb(unsigned short port, unsigned char data)
 
 #endif
 
-#endif /* CIMARRON_INCLUDE_IO_MACROS */
+#endif                          /* CIMARRON_INCLUDE_IO_MACROS */
 
-extern void (*cim_rdmsr)(unsigned long, unsigned long *, unsigned long *);
-extern void (*cim_wrmsr)(unsigned long, unsigned long, unsigned long);
+extern void (*cim_rdmsr) (unsigned long, unsigned long *, unsigned long *);
+extern void (*cim_wrmsr) (unsigned long, unsigned long, unsigned long);
 
 #endif
diff --git a/src/cim/cim_df.c b/src/cim/cim_df.c
index f81b740..abf1745 100644
--- a/src/cim/cim_df.c
+++ b/src/cim/cim_df.c
@@ -49,7 +49,7 @@ df_set_crt_enable(int crt_output)
     case DF_CRT_DISABLE:
 
         config &= ~(DF_DCFG_DIS_EN | DF_DCFG_HSYNC_EN |
-            DF_DCFG_VSYNC_EN | DF_DCFG_DAC_BL_EN);
+                    DF_DCFG_VSYNC_EN | DF_DCFG_DAC_BL_EN);
         misc |= DF_DAC_POWER_DOWN;
         break;
 
@@ -58,7 +58,7 @@ df_set_crt_enable(int crt_output)
     case DF_CRT_ENABLE:
 
         config |= (DF_DCFG_DIS_EN | DF_DCFG_HSYNC_EN |
-            DF_DCFG_VSYNC_EN | DF_DCFG_DAC_BL_EN);
+                   DF_DCFG_VSYNC_EN | DF_DCFG_DAC_BL_EN);
         misc &= ~(DF_DAC_POWER_DOWN | DF_ANALOG_POWER_DOWN);
         break;
 
@@ -67,7 +67,7 @@ df_set_crt_enable(int crt_output)
     case DF_CRT_STANDBY:
 
         config = (config & ~(DF_DCFG_DIS_EN | DF_DCFG_HSYNC_EN |
-                DF_DCFG_DAC_BL_EN)) | DF_DCFG_VSYNC_EN;
+                             DF_DCFG_DAC_BL_EN)) | DF_DCFG_VSYNC_EN;
         misc |= DF_DAC_POWER_DOWN;
         break;
 
@@ -76,7 +76,7 @@ df_set_crt_enable(int crt_output)
     case DF_CRT_SUSPEND:
 
         config = (config & ~(DF_DCFG_DIS_EN | DF_DCFG_VSYNC_EN |
-                DF_DCFG_DAC_BL_EN)) | DF_DCFG_HSYNC_EN;
+                             DF_DCFG_DAC_BL_EN)) | DF_DCFG_HSYNC_EN;
         misc |= DF_DAC_POWER_DOWN;
         break;
 
@@ -121,7 +121,7 @@ df_set_panel_enable(int enable)
 
 int
 df_configure_video_source(DF_VIDEO_SOURCE_PARAMS * video_source_odd,
-    DF_VIDEO_SOURCE_PARAMS * video_source_even)
+                          DF_VIDEO_SOURCE_PARAMS * video_source_even)
 {
     unsigned long pitch, ctrl, vcfg;
     unsigned long lock, vg_line, gcfg;
@@ -153,15 +153,15 @@ df_configure_video_source(DF_VIDEO_SOURCE_PARAMS * video_source_odd,
     /* PARAMETER - VIDEO PITCH */
 
     pitch =
-        (video_source_odd->y_pitch >> 3) | ((video_source_odd->
-            uv_pitch >> 3) << 16);
+        (video_source_odd->
+         y_pitch >> 3) | ((video_source_odd->uv_pitch >> 3) << 16);
 
     /* PARAMETER - VIDEO FORMAT */
 
     gcfg &= ~DC3_GCFG_YUV_420;
     vcfg &= ~(DF_VCFG_VID_INP_FORMAT | DF_VCFG_4_2_0_MODE);
     ctrl &= ~(DF_VIDEO_INPUT_IS_RGB | DF_CSC_VIDEO_YUV_TO_RGB | DF_HD_VIDEO |
-        DF_YUV_CSC_EN);
+              DF_YUV_CSC_EN);
 
     /* SELECT PIXEL ORDERING */
 
@@ -225,7 +225,7 @@ df_configure_video_source(DF_VIDEO_SOURCE_PARAMS * video_source_odd,
     /* appropriate pitch and clipping the video window.              */
 
     vcfg &= ~(DF_VCFG_LINE_SIZE_LOWER_MASK | DF_VCFG_LINE_SIZE_BIT8 |
-        DF_VCFG_LINE_SIZE_BIT9);
+              DF_VCFG_LINE_SIZE_BIT9);
 
     size = ((video_source_odd->width >> 1) + 7) & 0xFFF8;
 
@@ -286,7 +286,7 @@ df_configure_video_source(DF_VIDEO_SOURCE_PARAMS * video_source_odd,
 
 int
 df_set_video_offsets(int even, unsigned long y_offset,
-    unsigned long u_offset, unsigned long v_offset)
+                     unsigned long u_offset, unsigned long v_offset)
 {
     unsigned long lock = READ_REG32(DC3_UNLOCK);
 
@@ -296,7 +296,8 @@ df_set_video_offsets(int even, unsigned long y_offset,
         WRITE_REG32(DC3_VID_EVEN_Y_ST_OFFSET, y_offset);
         WRITE_REG32(DC3_VID_EVEN_U_ST_OFFSET, u_offset);
         WRITE_REG32(DC3_VID_EVEN_V_ST_OFFSET, v_offset);
-    } else {
+    }
+    else {
         WRITE_REG32(DC3_VID_Y_ST_OFFSET, y_offset);
         WRITE_REG32(DC3_VID_U_ST_OFFSET, u_offset);
         WRITE_REG32(DC3_VID_V_ST_OFFSET, v_offset);
@@ -317,7 +318,8 @@ df_set_video_offsets(int even, unsigned long y_offset,
 
 int
 df_set_video_scale(unsigned long src_width, unsigned long src_height,
-    unsigned long dst_width, unsigned long dst_height, unsigned long flags)
+                   unsigned long dst_width, unsigned long dst_height,
+                   unsigned long flags)
 {
     unsigned long temp, misc;
     unsigned long scale, gfxscale;
@@ -377,14 +379,14 @@ df_set_video_scale(unsigned long src_width, unsigned long src_height,
         scale = READ_VID32(DF_VIDEO_SCALER);
         vcfg = READ_VID32(DF_VIDEO_CONFIG);
         vcfg &= ~(DF_VCFG_LINE_SIZE_LOWER_MASK | DF_VCFG_LINE_SIZE_BIT8 |
-            DF_VCFG_LINE_SIZE_BIT9);
+                  DF_VCFG_LINE_SIZE_BIT9);
 
         if (dst_width < (src_width >> 2)) {
             src_width >>= 1;
             WRITE_VID32(DF_VIDEO_SCALER, scale | DF_SCALE_DOUBLE_H_DOWNSCALE);
-        } else {
-            WRITE_VID32(DF_VIDEO_SCALER,
-                scale & ~DF_SCALE_DOUBLE_H_DOWNSCALE);
+        }
+        else {
+            WRITE_VID32(DF_VIDEO_SCALER, scale & ~DF_SCALE_DOUBLE_H_DOWNSCALE);
         }
 
         /* PROGRAM A NEW LINE SIZE */
@@ -416,9 +418,9 @@ df_set_video_scale(unsigned long src_width, unsigned long src_height,
 
             WRITE_REG32(DC3_VID_DS_DELTA, downscale);
             WRITE_VID32(DF_VIDEO_YSCALE, 0x20000);
-        } else {
-            WRITE_VID32(DF_VIDEO_YSCALE,
-                ((0x10000 * src_height) / dst_height));
+        }
+        else {
+            WRITE_VID32(DF_VIDEO_YSCALE, ((0x10000 * src_height) / dst_height));
         }
         WRITE_REG32(DC3_GENERAL_CFG, gcfg);
         WRITE_REG32(DC3_UNLOCK, unlock);
@@ -431,7 +433,8 @@ df_set_video_scale(unsigned long src_width, unsigned long src_height,
     if ((READ_VID32(DF_VIDEO_XSCALE) == 0x10000) &&
         (READ_VID32(DF_VIDEO_YSCALE) == 0x10000)) {
         WRITE_VID32(DF_VIDEO_CONFIG, (temp | DF_VCFG_SC_BYP));
-    } else
+    }
+    else
         WRITE_VID32(DF_VIDEO_CONFIG, (temp & ~DF_VCFG_SC_BYP));
 
     return CIM_STATUS_OK;
@@ -487,7 +490,8 @@ df_set_video_position(DF_VIDEO_POSITION * video_window)
         border_y = vtotal - vblankend;
         hactive = hblankstart + htotal - hblankend;
         vactive = vblankstart + vtotal - vblankend;
-    } else {
+    }
+    else {
         border_x = border_y = 0;
     }
 
@@ -539,7 +543,8 @@ df_set_video_position(DF_VIDEO_POSITION * video_window)
         if (video_window->flags & DF_POSFLAG_INCLUDEBORDER) {
             border_y_even = vtotal_even - vblankend_even;
             vactive_even = vblankstart_even + vtotal_even - vblankend_even;
-        } else
+        }
+        else
             border_y_even = 0;
 
         /*
@@ -596,7 +601,8 @@ df_set_video_position(DF_VIDEO_POSITION * video_window)
             y <<= 1;
             height += height_even;
             adjust = border_y + border_y_even;
-        } else {
+        }
+        else {
             adjust = border_y;
             if (height_even > height)
                 height = height_even;
@@ -605,7 +611,8 @@ df_set_video_position(DF_VIDEO_POSITION * video_window)
             if (y > adjust) {
                 y -= adjust;
                 adjust = 0;
-            } else {
+            }
+            else {
                 adjust -= y;
                 if (height > adjust)
                     height -= adjust;
@@ -614,7 +621,8 @@ df_set_video_position(DF_VIDEO_POSITION * video_window)
             }
         }
 
-    } else {
+    }
+    else {
         y = y_copy;
 
         height = height_copy;
@@ -671,7 +679,8 @@ df_set_video_position(DF_VIDEO_POSITION * video_window)
         initread = (initread * xscale) / 0x10000;
         if (xscale)
             dst_clip = ((initread & 3) * 0x10000) / xscale;
-    } else
+    }
+    else
         dst_clip = video_window->dst_clip;
 
     /*
@@ -745,7 +754,8 @@ df_set_video_filter_coefficients(long taps[][4], int phase256)
     if (phase256) {
         WRITE_VID32(DF_VIDEO_SCALER, (scale & ~DF_SCALE_128_PHASES));
         defaults = CimarronVideoFilter256;
-    } else {
+    }
+    else {
         WRITE_VID32(DF_VIDEO_SCALER, (scale | DF_SCALE_128_PHASES));
         defaults = CimarronVideoFilter128;
     }
@@ -756,7 +766,8 @@ df_set_video_filter_coefficients(long taps[][4], int phase256)
         if (!taps) {
             coeff0 = defaults[i][0];
             coeff1 = defaults[i][1];
-        } else {
+        }
+        else {
             if (taps[i][1] < 0)
                 coeff0 = -taps[i][1] | 0x8000;
             else
@@ -842,13 +853,15 @@ df_set_video_enable(int enable, unsigned long flags)
 
             vg_ckey = READ_REG32(DC3_COLOR_KEY);
             WRITE_REG32(DC3_COLOR_KEY, (vg_ckey & ~DC3_CLR_KEY_ENABLE));
-        } else if (!(READ_VID32(DF_DISPLAY_CONFIG) & DF_DCFG_VG_CK)) {
+        }
+        else if (!(READ_VID32(DF_DISPLAY_CONFIG) & DF_DCFG_VG_CK)) {
             /* OTHERWISE RE-ENABLE COLOR KEYING */
 
             vg_ckey = READ_REG32(DC3_COLOR_KEY);
             WRITE_REG32(DC3_COLOR_KEY, (vg_ckey | DC3_CLR_KEY_ENABLE));
         }
-    } else {
+    }
+    else {
         WRITE_VID32(DF_VIDEO_CONFIG, (vcfg & ~DF_VCFG_VID_EN));
         WRITE_REG32(DC3_GENERAL_CFG, (gcfg & ~DC3_GCFG_VIDE));
 
@@ -898,7 +911,8 @@ df_set_video_color_key(unsigned long key, unsigned long mask, int graphics)
         WRITE_VID32(DF_DISPLAY_CONFIG, df_dcfg);
         WRITE_REG32(DC3_COLOR_KEY, vg_ckey);
         WRITE_REG32(DC3_COLOR_MASK, (mask & 0xFFFFFF));
-    } else {
+    }
+    else {
         /* CHROMA KEY - USE DF HARDWARE */
 
         df_dcfg |= DF_DCFG_VG_CK;
@@ -1016,8 +1030,9 @@ df_configure_video_cursor_color_key(DF_VIDEO_CURSOR_PARAMS * cursor_color_key)
         return CIM_STATUS_INVALIDPARAMS;
 
     key = READ_VID32(DF_CURSOR_COLOR_KEY) & DF_CURSOR_COLOR_KEY_ENABLE;
-    key = key | (cursor_color_key->key & 0xFFFFFF) | (cursor_color_key->
-        select_color2 << 24);
+    key =
+        key | (cursor_color_key->
+               key & 0xFFFFFF) | (cursor_color_key->select_color2 << 24);
 
     WRITE_VID32(DF_CURSOR_COLOR_KEY, key);
     WRITE_VID32(DF_CURSOR_COLOR_MASK, (cursor_color_key->mask & 0xFFFFFF));
@@ -1143,8 +1158,7 @@ df_configure_alpha_window(int window, DF_ALPHA_REGION_PARAMS * alpha_data)
         if (yend > (vactive + vadjust))
             yend = vactive + vadjust;
 
-        WRITE_VID32((DF_ALPHA_YPOS_1 + (window << 5)),
-            (ystart | (yend << 16)));
+        WRITE_VID32((DF_ALPHA_YPOS_1 + (window << 5)), (ystart | (yend << 16)));
 
         /* SET Y POSITION FOR EVEN FIELD */
 
@@ -1158,8 +1172,9 @@ df_configure_alpha_window(int window, DF_ALPHA_REGION_PARAMS * alpha_data)
             yend = vactive_even + vadjust;
 
         WRITE_VID32((DF_VID_ALPHA_Y_EVEN_1 + (window << 3)),
-            (ystart | (yend << 16)));
-    } else {
+                    (ystart | (yend << 16)));
+    }
+    else {
         y = y_copy;
         height = height_copy;
         vadjust = vtotal - vsyncend + 1;
@@ -1170,8 +1185,7 @@ df_configure_alpha_window(int window, DF_ALPHA_REGION_PARAMS * alpha_data)
         if (yend > (vactive + vadjust))
             yend = vactive + vadjust;
 
-        WRITE_VID32((DF_ALPHA_YPOS_1 + (window << 5)),
-            (ystart | (yend << 16)));
+        WRITE_VID32((DF_ALPHA_YPOS_1 + (window << 5)), (ystart | (yend << 16)));
     }
 
     /* SET ALPHA X POSITION */
@@ -1200,7 +1214,7 @@ df_configure_alpha_window(int window, DF_ALPHA_REGION_PARAMS * alpha_data)
     alpha_ctl = READ_VID32(DF_ALPHA_CONTROL_1 + (window << 5)) &
         DF_ACTRL_WIN_ENABLE;
     alpha_ctl |= (alpha_data->alpha_value & 0xFF) | DF_ACTRL_LOAD_ALPHA |
-        (((unsigned long)alpha_data->delta & 0xFF) << 8);
+        (((unsigned long) alpha_data->delta & 0xFF) << 8);
     if (alpha_data->flags & DF_ALPHAFLAG_PERPIXELENABLED)
         alpha_ctl |= DF_ACTRL_PERPIXEL_EN;
 
@@ -1306,7 +1320,7 @@ df_set_output_color_space(int color_space)
     alpha_ctl = READ_VID32(DF_VID_ALPHA_CONTROL);
 
     alpha_ctl &= ~(DF_CSC_GRAPHICS_RGB_TO_YUV | DF_CSC_VIDEO_YUV_TO_RGB |
-        DF_HD_GRAPHICS | DF_YUV_CSC_EN | DF_ALPHA_DRGB);
+                   DF_HD_GRAPHICS | DF_YUV_CSC_EN | DF_ALPHA_DRGB);
 
     /* OUTPUT IS RGB */
     /* Enable YUV->RGB CSC if necessary and enable alpha output if  */
@@ -1333,7 +1347,8 @@ df_set_output_color_space(int color_space)
 
         if (color_space == DF_OUTPUT_HDTV)
             alpha_ctl |= DF_HD_GRAPHICS;
-    } else
+    }
+    else
         return CIM_STATUS_INVALIDPARAMS;
 
     WRITE_VID32(DF_VID_ALPHA_CONTROL, alpha_ctl);
@@ -1376,7 +1391,8 @@ df_set_output_path(int format)
         panel_pm &= ~DF_PM_PANEL_ON;
         panel_tim2 |= DF_PMTIM2_TFT_PASSHTHROUGH;
         output = DF_OUTPUT_PANEL | DF_SIMULTANEOUS_CRT_FP;
-    } else if (format == DF_DISPLAY_FP || format == DF_DISPLAY_CRT_FP) {
+    }
+    else if (format == DF_DISPLAY_FP || format == DF_DISPLAY_CRT_FP) {
         panel_pm |= DF_PM_PANEL_ON;
         panel_tim2 &= ~DF_PMTIM2_TFT_PASSHTHROUGH;
 
@@ -1384,7 +1400,8 @@ df_set_output_path(int format)
             output = DF_OUTPUT_PANEL;
         else if (format == DF_DISPLAY_CRT_FP)
             output = DF_OUTPUT_PANEL | DF_SIMULTANEOUS_CRT_FP;
-    } else {
+    }
+    else {
         switch (format) {
         case DF_DISPLAY_VOP:
             output = DF_OUTPUT_VOP;
@@ -1479,26 +1496,22 @@ df_save_state(DF_SAVE_RESTORE * df_state)
     /* READ FILTER COEFFICIENTS */
 
     for (i = 0; i < 512; i++)
-        df_state->coefficients[i] =
-            READ_VID32(DF_COEFFICIENT_BASE + (i << 2));
+        df_state->coefficients[i] = READ_VID32(DF_COEFFICIENT_BASE + (i << 2));
 
     /* READ ALL DF MSRS */
 
-    msr_read64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_CAP,
-        &(df_state->msr_cap));
+    msr_read64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_CAP, &(df_state->msr_cap));
     msr_read64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_CONFIG,
-        &(df_state->msr_config));
-    msr_read64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_SMI,
-        &(df_state->msr_smi));
+               &(df_state->msr_config));
+    msr_read64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_SMI, &(df_state->msr_smi));
     msr_read64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_ERROR,
-        &(df_state->msr_error));
+               &(df_state->msr_error));
     msr_read64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_PM, &(df_state->msr_pm));
     msr_read64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_DIAG,
-        &(df_state->msr_diag));
+               &(df_state->msr_diag));
     msr_read64(MSR_DEVICE_GEODELX_DF, DF_MBD_MSR_DIAG_DF,
-        &(df_state->msr_df_diag));
-    msr_read64(MSR_DEVICE_GEODELX_DF, DF_MSR_PAD_SEL,
-        &(df_state->msr_pad_sel));
+               &(df_state->msr_df_diag));
+    msr_read64(MSR_DEVICE_GEODELX_DF, DF_MSR_PAD_SEL, &(df_state->msr_pad_sel));
 
     return CIM_STATUS_OK;
 }
@@ -1521,21 +1534,19 @@ df_restore_state(DF_SAVE_RESTORE * df_state)
 
     /* RESTORE DF MSRS */
 
-    msr_write64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_CAP,
-        &(df_state->msr_cap));
+    msr_write64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_CAP, &(df_state->msr_cap));
     msr_write64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_CONFIG,
-        &(df_state->msr_config));
-    msr_write64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_SMI,
-        &(df_state->msr_smi));
+                &(df_state->msr_config));
+    msr_write64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_SMI, &(df_state->msr_smi));
     msr_write64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_ERROR,
-        &(df_state->msr_error));
+                &(df_state->msr_error));
     msr_write64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_PM, &(df_state->msr_pm));
     msr_write64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_DIAG,
-        &(df_state->msr_diag));
+                &(df_state->msr_diag));
     msr_write64(MSR_DEVICE_GEODELX_DF, DF_MBD_MSR_DIAG_DF,
-        &(df_state->msr_df_diag));
+                &(df_state->msr_df_diag));
     msr_write64(MSR_DEVICE_GEODELX_DF, DF_MSR_PAD_SEL,
-        &(df_state->msr_pad_sel));
+                &(df_state->msr_pad_sel));
 
     /* RESTORE ALL DF REGISTERS */
 
@@ -1584,8 +1595,7 @@ df_restore_state(DF_SAVE_RESTORE * df_state)
     /* RESTORE FILTER COEFFICIENTS */
 
     for (i = 0; i < 512; i++)
-        WRITE_VID32(DF_COEFFICIENT_BASE + (i << 2),
-            df_state->coefficients[i]);
+        WRITE_VID32(DF_COEFFICIENT_BASE + (i << 2), df_state->coefficients[i]);
 
     /* RESTORE DCFG AND VCFG */
 
@@ -1655,9 +1665,10 @@ df_read_composite_crc(int crc_source)
         do {
             line = READ_REG32(DC3_LINE_CNT_STATUS);
         } while ((line & DC3_LNCNT_EVEN_FIELD) != field ||
-            ((line & DC3_LNCNT_V_LINE_CNT) >> 16) < 10 ||
-            ((line & DC3_LNCNT_V_LINE_CNT) >> 16) > 15);
-    } else {
+                 ((line & DC3_LNCNT_V_LINE_CNT) >> 16) < 10 ||
+                 ((line & DC3_LNCNT_V_LINE_CNT) >> 16) > 15);
+    }
+    else {
         /* NON-INTERLACED - EVEN FIELD CRCS ARE INVALID */
 
         if (crc_source & DF_CRC_SOURCE_EVEN)
@@ -1670,7 +1681,7 @@ df_read_composite_crc(int crc_source)
 
     /* WAIT FOR THE CRC TO BE COMPLETED */
 
-    while (!(READ_VID32(DF_VID_CRC) & 4)) ;
+    while (!(READ_VID32(DF_VID_CRC) & 4));
 
     crc = READ_VID32(DF_VID_CRC32);
 
@@ -1686,7 +1697,8 @@ df_read_composite_crc(int crc_source)
 
 unsigned long
 df_read_composite_window_crc(unsigned long x, unsigned long y,
-    unsigned long width, unsigned long height, int source)
+                             unsigned long width, unsigned long height,
+                             int source)
 {
     Q_WORD msr_value;
     unsigned long interlaced;
@@ -1709,7 +1721,8 @@ df_read_composite_window_crc(unsigned long x, unsigned long y,
         vsyncstart = (READ_REG32(DC3_V_SYNC_EVEN) & 0xFFF) + 1;
         vactive = (READ_REG32(DC3_V_ACTIVE_EVEN) & 0xFFF) + 1;
         vblankstart = (READ_REG32(DC3_V_BLANK_EVEN) & 0xFFF) + 1;
-    } else {
+    }
+    else {
         vsyncend = ((READ_REG32(DC3_V_SYNC_TIMING) >> 16) & 0xFFF) + 1;
         vtotal = ((READ_REG32(DC3_V_ACTIVE_TIMING) >> 16) & 0xFFF) + 1;
         vsyncstart = (READ_REG32(DC3_V_SYNC_TIMING) & 0xFFF) + 1;
@@ -1942,9 +1955,10 @@ df_read_composite_window_crc(unsigned long x, unsigned long y,
         do {
             line = READ_REG32(DC3_LINE_CNT_STATUS);
         } while ((line & DC3_LNCNT_EVEN_FIELD) != field ||
-            ((line & DC3_LNCNT_V_LINE_CNT) >> 16) < 1 ||
-            ((line & DC3_LNCNT_V_LINE_CNT) >> 16) > 5);
-    } else {
+                 ((line & DC3_LNCNT_V_LINE_CNT) >> 16) < 1 ||
+                 ((line & DC3_LNCNT_V_LINE_CNT) >> 16) > 5);
+    }
+    else {
         /* NON-INTERLACED - EVEN FIELD CRCS ARE INVALID */
 
         if (source & DF_CRC_SOURCE_EVEN)
@@ -1970,11 +1984,11 @@ df_read_composite_window_crc(unsigned long x, unsigned long y,
 
     /* DELAY TWO FRAMES */
 
-    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA) ;
-    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA)) ;
-    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA) ;
-    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA)) ;
-    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA) ;
+    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA);
+    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA));
+    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA);
+    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA));
+    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA);
 
     /* VERIFY THAT XSTATE = 11 */
 
@@ -2033,7 +2047,7 @@ df_read_panel_crc(void)
 
     /* WAIT FOR THE CRC TO BE COMPLETED */
 
-    while (!(READ_VID32(DF_PANEL_CRC) & 4)) ;
+    while (!(READ_VID32(DF_PANEL_CRC) & 4));
 
     return READ_VID32(DF_PANEL_CRC32);
 }
@@ -2076,7 +2090,7 @@ df_get_video_enable(int *enable, unsigned long *flags)
 
 int
 df_get_video_source_configuration(DF_VIDEO_SOURCE_PARAMS * video_source_odd,
-    DF_VIDEO_SOURCE_PARAMS * video_source_even)
+                                  DF_VIDEO_SOURCE_PARAMS * video_source_even)
 {
     unsigned long format, temp;
     unsigned long size;
@@ -2171,7 +2185,8 @@ df_get_video_position(DF_VIDEO_POSITION * video_window)
     if (READ_REG32(DC3_IRQ_FILT_CTL) & DC3_IRQFILT_INTL_EN) {
         vsyncend = ((READ_REG32(DC3_V_SYNC_EVEN) >> 16) & 0xFFF) + 1;
         vtotal = ((READ_REG32(DC3_V_ACTIVE_EVEN) >> 16) & 0xFFF) + 1;
-    } else {
+    }
+    else {
         vsyncend = ((READ_REG32(DC3_V_SYNC_TIMING) >> 16) & 0xFFF) + 1;
         vtotal = ((READ_REG32(DC3_V_ACTIVE_TIMING) >> 16) & 0xFFF) + 1;
     }
@@ -2326,7 +2341,8 @@ df_get_video_color_key(unsigned long *key, unsigned long *mask, int *graphics)
         *graphics = 0;
         *key = READ_VID32(DF_VIDEO_COLOR_KEY) & 0xFFFFFF;
         *mask = READ_VID32(DF_VIDEO_COLOR_MASK) & 0xFFFFFF;
-    } else {
+    }
+    else {
         *graphics = 1;
 
         *key = READ_REG32(DC3_COLOR_KEY) & 0xFFFFFF;
@@ -2423,7 +2439,7 @@ df_get_video_cursor_color_key_enable(void)
 
 int
 df_get_alpha_window_configuration(int window,
-    DF_ALPHA_REGION_PARAMS * alpha_data)
+                                  DF_ALPHA_REGION_PARAMS * alpha_data)
 {
     unsigned long pos, color, alpha_ctl;
     unsigned long hsyncend, htotal;
@@ -2442,7 +2458,8 @@ df_get_alpha_window_configuration(int window,
     if (READ_REG32(DC3_IRQ_FILT_CTL) & DC3_IRQFILT_INTL_EN) {
         vtotal = ((READ_REG32(DC3_V_ACTIVE_EVEN) >> 16) & 0xFFF) + 1;
         vsyncend = ((READ_REG32(DC3_V_SYNC_EVEN) >> 16) & 0xFFF) + 1;
-    } else {
+    }
+    else {
         vtotal = ((READ_REG32(DC3_V_ACTIVE_TIMING) >> 16) & 0xFFF) + 1;
         vsyncend = ((READ_REG32(DC3_V_SYNC_TIMING) >> 16) & 0xFFF) + 1;
     }
@@ -2510,8 +2527,8 @@ df_get_alpha_window_configuration(int window,
     if (alpha_ctl & DF_ACTRL_PERPIXEL_EN)
         alpha_data->flags |= DF_ALPHAFLAG_PERPIXELENABLED;
 
-    delta = (char)((alpha_ctl >> 8) & 0xFF);
-    alpha_data->delta = (long)delta;
+    delta = (char) ((alpha_ctl >> 8) & 0xFF);
+    alpha_data->delta = (long) delta;
     return CIM_STATUS_OK;
 }
 
@@ -2579,7 +2596,8 @@ df_get_output_color_space(int *color_space)
             *color_space = DF_OUTPUT_ARGB;
         else
             *color_space = DF_OUTPUT_RGB;
-    } else {
+    }
+    else {
         *color_space = DF_OUTPUT_SDTV;
 
         if (alpha_ctl & DF_HD_GRAPHICS)
diff --git a/src/cim/cim_filter.c b/src/cim/cim_filter.c
index 87c1bf6..68e9ae5 100644
--- a/src/cim/cim_filter.c
+++ b/src/cim/cim_filter.c
@@ -29,519 +29,519 @@
   */
 
 long CimarronVideoFilter256[][2] = {
-    {0x10000000, 0x00000000},          /*     0, 4096,    0,    0 */
-    {0x10008008, 0x00000008},          /*    -8, 4096,    8,    0 */
-    {0x10008010, 0x80010011},          /*   -16, 4096,   17,   -1 */
-    {0x10008019, 0x8001001A},          /*   -25, 4096,   26,   -1 */
-    {0x10008021, 0x80020023},          /*   -33, 4096,   35,   -2 */
-    {0x0FFF8029, 0x8003002D},          /*   -41, 4095,   45,   -3 */
-    {0x0FFE8031, 0x80030036},          /*   -49, 4094,   54,   -3 */
-    {0x0FFC8038, 0x80040040},          /*   -56, 4092,   64,   -4 */
-    {0x0FFB8040, 0x8005004A},          /*   -64, 4091,   74,   -5 */
-    {0x0FF88047, 0x80050054},          /*   -71, 4088,   84,   -5 */
-    {0x0FF6804E, 0x8006005E},          /*   -78, 4086,   94,   -6 */
-    {0x0FF48055, 0x80070068},          /*   -85, 4084,  104,   -7 */
-    {0x0FF0805C, 0x80070073},          /*   -92, 4080,  115,   -7 */
-    {0x0FEE8063, 0x8008007D},          /*   -99, 4078,  125,   -8 */
-    {0x0FEA8069, 0x80090088},          /*  -105, 4074,  136,   -9 */
-    {0x0FE78070, 0x800A0093},          /*  -112, 4071,  147,  -10 */
-    {0x0FE28076, 0x800A009E},          /*  -118, 4066,  158,  -10 */
-    {0x0FDD807C, 0x800B00AA},          /*  -124, 4061,  170,  -11 */
-    {0x0FD98082, 0x800C00B5},          /*  -130, 4057,  181,  -12 */
-    {0x0FD48088, 0x800D00C1},          /*  -136, 4052,  193,  -13 */
-    {0x0FCE808E, 0x800D00CD},          /*  -142, 4046,  205,  -13 */
-    {0x0FC88093, 0x800E00D9},          /*  -147, 4040,  217,  -14 */
-    {0x0FC38099, 0x800F00E5},          /*  -153, 4035,  229,  -15 */
-    {0x0FBD809E, 0x801000F1},          /*  -158, 4029,  241,  -16 */
-    {0x0FB680A3, 0x801000FD},          /*  -163, 4022,  253,  -16 */
-    {0x0FAF80A8, 0x8011010A},          /*  -168, 4015,  266,  -17 */
-    {0x0FA880AD, 0x80120117},          /*  -173, 4008,  279,  -18 */
-    {0x0FA180B2, 0x80130124},          /*  -178, 4001,  292,  -19 */
-    {0x0F9980B6, 0x80140131},          /*  -182, 3993,  305,  -20 */
-    {0x0F9280BB, 0x8015013E},          /*  -187, 3986,  318,  -21 */
-    {0x0F8880BF, 0x8015014C},          /*  -191, 3976,  332,  -21 */
-    {0x0F8080C3, 0x80160159},          /*  -195, 3968,  345,  -22 */
-    {0x0F7880C8, 0x80170167},          /*  -200, 3960,  359,  -23 */
-    {0x0F6E80CB, 0x80180175},          /*  -203, 3950,  373,  -24 */
-    {0x0F6580CF, 0x80190183},          /*  -207, 3941,  387,  -25 */
-    {0x0F5C80D3, 0x801A0191},          /*  -211, 3932,  401,  -26 */
-    {0x0F5280D7, 0x801B01A0},          /*  -215, 3922,  416,  -27 */
-    {0x0F4880DA, 0x801C01AE},          /*  -218, 3912,  430,  -28 */
-    {0x0F3D80DD, 0x801D01BD},          /*  -221, 3901,  445,  -29 */
-    {0x0F3280E0, 0x801E01CC},          /*  -224, 3890,  460,  -30 */
-    {0x0F2880E4, 0x801F01DB},          /*  -228, 3880,  475,  -31 */
-    {0x0F1C80E6, 0x802001EA},          /*  -230, 3868,  490,  -32 */
-    {0x0F1180E9, 0x802101F9},          /*  -233, 3857,  505,  -33 */
-    {0x0F0480EB, 0x80210208},          /*  -235, 3844,  520,  -33 */
-    {0x0EFA80EF, 0x80230218},          /*  -239, 3834,  536,  -35 */
-    {0x0EEC80F0, 0x80230227},          /*  -240, 3820,  551,  -35 */
-    {0x0EE080F3, 0x80240237},          /*  -243, 3808,  567,  -36 */
-    {0x0ED380F5, 0x80250247},          /*  -245, 3795,  583,  -37 */
-    {0x0EC780F7, 0x80270257},          /*  -247, 3783,  599,  -39 */
-    {0x0EB980F9, 0x80280268},          /*  -249, 3769,  616,  -40 */
-    {0x0EAC80FB, 0x80290278},          /*  -251, 3756,  632,  -41 */
-    {0x0E9E80FD, 0x802A0289},          /*  -253, 3742,  649,  -42 */
-    {0x0E9080FE, 0x802B0299},          /*  -254, 3728,  665,  -43 */
-    {0x0E838100, 0x802D02AA},          /*  -256, 3715,  682,  -45 */
-    {0x0E758102, 0x802E02BB},          /*  -258, 3701,  699,  -46 */
-    {0x0E668103, 0x802F02CC},          /*  -259, 3686,  716,  -47 */
-    {0x0E568104, 0x803002DE},          /*  -260, 3670,  734,  -48 */
-    {0x0E498106, 0x803202EF},          /*  -262, 3657,  751,  -50 */
-    {0x0E398107, 0x80330301},          /*  -263, 3641,  769,  -51 */
-    {0x0E298108, 0x80340313},          /*  -264, 3625,  787,  -52 */
-    {0x0E1A8109, 0x80360325},          /*  -265, 3610,  805,  -54 */
-    {0x0E0B810A, 0x80370336},          /*  -266, 3595,  822,  -55 */
-    {0x0DFA810A, 0x80380348},          /*  -266, 3578,  840,  -56 */
-    {0x0DEA810B, 0x803A035B},          /*  -267, 3562,  859,  -58 */
-    {0x0DDA810C, 0x803B036D},          /*  -268, 3546,  877,  -59 */
-    {0x0DCA810C, 0x803D037F},          /*  -268, 3530,  895,  -61 */
-    {0x0DB7810B, 0x803E0392},          /*  -267, 3511,  914,  -62 */
-    {0x0DA7810C, 0x804003A5},          /*  -268, 3495,  933,  -64 */
-    {0x0D95810C, 0x804103B8},          /*  -268, 3477,  952,  -65 */
-    {0x0D85810C, 0x804303CA},          /*  -268, 3461,  970,  -67 */
-    {0x0D73810C, 0x804403DD},          /*  -268, 3443,  989,  -68 */
-    {0x0D61810C, 0x804603F1},          /*  -268, 3425, 1009,  -70 */
-    {0x0D50810C, 0x80480404},          /*  -268, 3408, 1028,  -72 */
-    {0x0D3E810C, 0x80490417},          /*  -268, 3390, 1047,  -73 */
-    {0x0D2C810C, 0x804B042B},          /*  -268, 3372, 1067,  -75 */
-    {0x0D1B810C, 0x804D043E},          /*  -268, 3355, 1086,  -77 */
-    {0x0D07810B, 0x804E0452},          /*  -267, 3335, 1106,  -78 */
-    {0x0CF5810B, 0x80500466},          /*  -267, 3317, 1126,  -80 */
-    {0x0CE2810A, 0x8052047A},          /*  -266, 3298, 1146,  -82 */
-    {0x0CCF810A, 0x8053048E},          /*  -266, 3279, 1166,  -83 */
-    {0x0CBC8109, 0x805504A2},          /*  -265, 3260, 1186,  -85 */
-    {0x0CA98108, 0x805704B6},          /*  -264, 3241, 1206,  -87 */
-    {0x0C968108, 0x805904CB},          /*  -264, 3222, 1227,  -89 */
-    {0x0C838107, 0x805B04DF},          /*  -263, 3203, 1247,  -91 */
-    {0x0C6F8106, 0x805C04F3},          /*  -262, 3183, 1267,  -92 */
-    {0x0C5B8105, 0x805E0508},          /*  -261, 3163, 1288,  -94 */
-    {0x0C478104, 0x8060051D},          /*  -260, 3143, 1309,  -96 */
-    {0x0C348103, 0x80620531},          /*  -259, 3124, 1329,  -98 */
-    {0x0C1F8102, 0x80640547},          /*  -258, 3103, 1351, -100 */
-    {0x0C0C8101, 0x8066055B},          /*  -257, 3084, 1371, -102 */
-    {0x0BF88100, 0x80680570},          /*  -256, 3064, 1392, -104 */
-    {0x0BE380FE, 0x806A0585},          /*  -254, 3043, 1413, -106 */
-    {0x0BCF80FD, 0x806C059A},          /*  -253, 3023, 1434, -108 */
-    {0x0BBA80FC, 0x806E05B0},          /*  -252, 3002, 1456, -110 */
-    {0x0BA480F9, 0x807005C5},          /*  -249, 2980, 1477, -112 */
-    {0x0B8F80F8, 0x807205DB},          /*  -248, 2959, 1499, -114 */
-    {0x0B7A80F6, 0x807405F0},          /*  -246, 2938, 1520, -116 */
-    {0x0B6580F5, 0x80760606},          /*  -245, 2917, 1542, -118 */
-    {0x0B4F80F3, 0x8077061B},          /*  -243, 2895, 1563, -119 */
-    {0x0B3A80F2, 0x80790631},          /*  -242, 2874, 1585, -121 */
-    {0x0B2480F0, 0x807B0647},          /*  -240, 2852, 1607, -123 */
-    {0x0B0F80EE, 0x807D065C},          /*  -238, 2831, 1628, -125 */
-    {0x0AF980ED, 0x807F0673},          /*  -237, 2809, 1651, -127 */
-    {0x0AE480EB, 0x80810688},          /*  -235, 2788, 1672, -129 */
-    {0x0ACE80E9, 0x8084069F},          /*  -233, 2766, 1695, -132 */
-    {0x0AB980E7, 0x808606B4},          /*  -231, 2745, 1716, -134 */
-    {0x0AA380E6, 0x808806CB},          /*  -230, 2723, 1739, -136 */
-    {0x0A8D80E4, 0x808A06E1},          /*  -228, 2701, 1761, -138 */
-    {0x0A7780E2, 0x808C06F7},          /*  -226, 2679, 1783, -140 */
-    {0x0A6180E0, 0x808E070D},          /*  -224, 2657, 1805, -142 */
-    {0x0A4B80DE, 0x80910724},          /*  -222, 2635, 1828, -145 */
-    {0x0A3580DC, 0x8093073A},          /*  -220, 2613, 1850, -147 */
-    {0x0A1F80DA, 0x80950750},          /*  -218, 2591, 1872, -149 */
-    {0x0A0880D8, 0x80970767},          /*  -216, 2568, 1895, -151 */
-    {0x09F280D6, 0x8099077D},          /*  -214, 2546, 1917, -153 */
-    {0x09DD80D4, 0x809C0793},          /*  -212, 2525, 1939, -156 */
-    {0x09C680D2, 0x809E07AA},          /*  -210, 2502, 1962, -158 */
-    {0x09B080D0, 0x80A007C0},          /*  -208, 2480, 1984, -160 */
-    {0x099980CE, 0x80A207D7},          /*  -206, 2457, 2007, -162 */
-    {0x098380CB, 0x80A507ED},          /*  -203, 2435, 2029, -165 */
-    {0x096C80C9, 0x80A70804},          /*  -201, 2412, 2052, -167 */
-    {0x095680C7, 0x80A9081A},          /*  -199, 2390, 2074, -169 */
-    {0x094080C5, 0x80AB0830},          /*  -197, 2368, 2096, -171 */
-    {0x092980C3, 0x80AE0848},          /*  -195, 2345, 2120, -174 */
-    {0x091380C1, 0x80B0085E},          /*  -193, 2323, 2142, -176 */
-    {0x08FC80BE, 0x80B20874},          /*  -190, 2300, 2164, -178 */
-    {0x08E580BC, 0x80B4088B},          /*  -188, 2277, 2187, -180 */
-    {0x08D080BB, 0x80B708A2},          /*  -187, 2256, 2210, -183 */
-    {0x08B980B9, 0x80B908B9},          /*  -185, 2233, 2233, -185 */
-    {0x08A380B7, 0x80BB08CF},          /*  -183, 2211, 2255, -187 */
-    {0x088B80B4, 0x80BC08E5},          /*  -180, 2187, 2277, -188 */
-    {0x087480B2, 0x80BE08FC},          /*  -178, 2164, 2300, -190 */
-    {0x085E80B0, 0x80C10913},          /*  -176, 2142, 2323, -193 */
-    {0x084880AE, 0x80C30929},          /*  -174, 2120, 2345, -195 */
-    {0x083080AB, 0x80C50940},          /*  -171, 2096, 2368, -197 */
-    {0x081A80A9, 0x80C70956},          /*  -169, 2074, 2390, -199 */
-    {0x080480A7, 0x80C9096C},          /*  -167, 2052, 2412, -201 */
-    {0x07ED80A5, 0x80CB0983},          /*  -165, 2029, 2435, -203 */
-    {0x07D780A2, 0x80CE0999},          /*  -162, 2007, 2457, -206 */
-    {0x07C080A0, 0x80D009B0},          /*  -160, 1984, 2480, -208 */
-    {0x07AA809E, 0x80D209C6},          /*  -158, 1962, 2502, -210 */
-    {0x0793809C, 0x80D409DD},          /*  -156, 1939, 2525, -212 */
-    {0x077D8099, 0x80D609F2},          /*  -153, 1917, 2546, -214 */
-    {0x07668097, 0x80D80A09},          /*  -151, 1894, 2569, -216 */
-    {0x074F8095, 0x80DA0A20},          /*  -149, 1871, 2592, -218 */
-    {0x073A8093, 0x80DC0A35},          /*  -147, 1850, 2613, -220 */
-    {0x07238091, 0x80DE0A4C},          /*  -145, 1827, 2636, -222 */
-    {0x070C808E, 0x80E00A62},          /*  -142, 1804, 2658, -224 */
-    {0x06F7808C, 0x80E20A77},          /*  -140, 1783, 2679, -226 */
-    {0x06E0808A, 0x80E40A8E},          /*  -138, 1760, 2702, -228 */
-    {0x06CA8088, 0x80E60AA4},          /*  -136, 1738, 2724, -230 */
-    {0x06B48086, 0x80E70AB9},          /*  -134, 1716, 2745, -231 */
-    {0x069E8084, 0x80E90ACF},          /*  -132, 1694, 2767, -233 */
-    {0x06878081, 0x80EB0AE5},          /*  -129, 1671, 2789, -235 */
-    {0x0672807F, 0x80ED0AFA},          /*  -127, 1650, 2810, -237 */
-    {0x065C807D, 0x80EE0B0F},          /*  -125, 1628, 2831, -238 */
-    {0x0646807B, 0x80F00B25},          /*  -123, 1606, 2853, -240 */
-    {0x06308079, 0x80F20B3B},          /*  -121, 1584, 2875, -242 */
-    {0x061A8077, 0x80F30B50},          /*  -119, 1562, 2896, -243 */
-    {0x06068076, 0x80F50B65},          /*  -118, 1542, 2917, -245 */
-    {0x05F08074, 0x80F60B7A},          /*  -116, 1520, 2938, -246 */
-    {0x05DB8072, 0x80F80B8F},          /*  -114, 1499, 2959, -248 */
-    {0x05C58070, 0x80F90BA4},          /*  -112, 1477, 2980, -249 */
-    {0x05B1806E, 0x80FC0BB9},          /*  -110, 1457, 3001, -252 */
-    {0x059B806C, 0x80FD0BCE},          /*  -108, 1435, 3022, -253 */
-    {0x0586806A, 0x80FE0BE2},          /*  -106, 1414, 3042, -254 */
-    {0x05718068, 0x81000BF7},          /*  -104, 1393, 3063, -256 */
-    {0x055C8066, 0x81010C0B},          /*  -102, 1372, 3083, -257 */
-    {0x05478064, 0x81020C1F},          /*  -100, 1351, 3103, -258 */
-    {0x05328062, 0x81030C33},          /*   -98, 1330, 3123, -259 */
-    {0x051D8060, 0x81040C47},          /*   -96, 1309, 3143, -260 */
-    {0x0508805E, 0x81050C5B},          /*   -94, 1288, 3163, -261 */
-    {0x04F3805C, 0x81060C6F},          /*   -92, 1267, 3183, -262 */
-    {0x04E0805B, 0x81070C82},          /*   -91, 1248, 3202, -263 */
-    {0x04CB8059, 0x81080C96},          /*   -89, 1227, 3222, -264 */
-    {0x04B68057, 0x81080CA9},          /*   -87, 1206, 3241, -264 */
-    {0x04A28055, 0x81090CBC},          /*   -85, 1186, 3260, -265 */
-    {0x048E8053, 0x810A0CCF},          /*   -83, 1166, 3279, -266 */
-    {0x047A8052, 0x810A0CE2},          /*   -82, 1146, 3298, -266 */
-    {0x04668050, 0x810B0CF5},          /*   -80, 1126, 3317, -267 */
-    {0x0451804E, 0x810B0D08},          /*   -78, 1105, 3336, -267 */
-    {0x043E804D, 0x810C0D1B},          /*   -77, 1086, 3355, -268 */
-    {0x042B804B, 0x810C0D2C},          /*   -75, 1067, 3372, -268 */
-    {0x04178049, 0x810C0D3E},          /*   -73, 1047, 3390, -268 */
-    {0x04038048, 0x810C0D51},          /*   -72, 1027, 3409, -268 */
-    {0x03F08046, 0x810C0D62},          /*   -70, 1008, 3426, -268 */
-    {0x03DD8044, 0x810C0D73},          /*   -68,  989, 3443, -268 */
-    {0x03CA8043, 0x810C0D85},          /*   -67,  970, 3461, -268 */
-    {0x03B78041, 0x810C0D96},          /*   -65,  951, 3478, -268 */
-    {0x03A48040, 0x810C0DA8},          /*   -64,  932, 3496, -268 */
-    {0x0391803E, 0x810B0DB8},          /*   -62,  913, 3512, -267 */
-    {0x0380803D, 0x810C0DC9},          /*   -61,  896, 3529, -268 */
-    {0x036D803B, 0x810C0DDA},          /*   -59,  877, 3546, -268 */
-    {0x035B803A, 0x810B0DEA},          /*   -58,  859, 3562, -267 */
-    {0x03488038, 0x810A0DFA},          /*   -56,  840, 3578, -266 */
-    {0x03368037, 0x810A0E0B},          /*   -55,  822, 3595, -266 */
-    {0x03248036, 0x81090E1B},          /*   -54,  804, 3611, -265 */
-    {0x03128034, 0x81080E2A},          /*   -52,  786, 3626, -264 */
-    {0x03018033, 0x81070E39},          /*   -51,  769, 3641, -263 */
-    {0x02EF8032, 0x81060E49},          /*   -50,  751, 3657, -262 */
-    {0x02DE8030, 0x81040E56},          /*   -48,  734, 3670, -260 */
-    {0x02CC802F, 0x81030E66},          /*   -47,  716, 3686, -259 */
-    {0x02BB802E, 0x81020E75},          /*   -46,  699, 3701, -258 */
-    {0x02AA802D, 0x81000E83},          /*   -45,  682, 3715, -256 */
-    {0x0299802B, 0x80FE0E90},          /*   -43,  665, 3728, -254 */
-    {0x0288802A, 0x80FD0E9F},          /*   -42,  648, 3743, -253 */
-    {0x02778029, 0x80FB0EAD},          /*   -41,  631, 3757, -251 */
-    {0x02678028, 0x80F90EBA},          /*   -40,  615, 3770, -249 */
-    {0x02568027, 0x80F70EC8},          /*   -39,  598, 3784, -247 */
-    {0x02468025, 0x80F50ED4},          /*   -37,  582, 3796, -245 */
-    {0x02368024, 0x80F30EE1},          /*   -36,  566, 3809, -243 */
-    {0x02268023, 0x80F00EED},          /*   -35,  550, 3821, -240 */
-    {0x02188023, 0x80EF0EFA},          /*   -35,  536, 3834, -239 */
-    {0x02078021, 0x80EB0F05},          /*   -33,  519, 3845, -235 */
-    {0x01F98021, 0x80E90F11},          /*   -33,  505, 3857, -233 */
-    {0x01EA8020, 0x80E60F1C},          /*   -32,  490, 3868, -230 */
-    {0x01DC801F, 0x80E40F27},          /*   -31,  476, 3879, -228 */
-    {0x01CD801E, 0x80E00F31},          /*   -30,  461, 3889, -224 */
-    {0x01BE801D, 0x80DD0F3C},          /*   -29,  446, 3900, -221 */
-    {0x01AF801C, 0x80DA0F47},          /*   -28,  431, 3911, -218 */
-    {0x01A1801B, 0x80D70F51},          /*   -27,  417, 3921, -215 */
-    {0x0192801A, 0x80D30F5B},          /*   -26,  402, 3931, -211 */
-    {0x01848019, 0x80CF0F64},          /*   -25,  388, 3940, -207 */
-    {0x01768018, 0x80CB0F6D},          /*   -24,  374, 3949, -203 */
-    {0x01688017, 0x80C80F77},          /*   -23,  360, 3959, -200 */
-    {0x015A8016, 0x80C30F7F},          /*   -22,  346, 3967, -195 */
-    {0x014D8015, 0x80BF0F87},          /*   -21,  333, 3975, -191 */
-    {0x013F8015, 0x80BB0F91},          /*   -21,  319, 3985, -187 */
-    {0x01328014, 0x80B60F98},          /*   -20,  306, 3992, -182 */
-    {0x01258013, 0x80B20FA0},          /*   -19,  293, 4000, -178 */
-    {0x01188012, 0x80AD0FA7},          /*   -18,  280, 4007, -173 */
-    {0x010B8011, 0x80A80FAE},          /*   -17,  267, 4014, -168 */
-    {0x00FE8010, 0x80A30FB5},          /*   -16,  254, 4021, -163 */
-    {0x00F28010, 0x809E0FBC},          /*   -16,  242, 4028, -158 */
-    {0x00E6800F, 0x80990FC2},          /*   -15,  230, 4034, -153 */
-    {0x00DA800E, 0x80930FC7},          /*   -14,  218, 4039, -147 */
-    {0x00CE800D, 0x808E0FCD},          /*   -13,  206, 4045, -142 */
-    {0x00C2800D, 0x80880FD3},          /*   -13,  194, 4051, -136 */
-    {0x00B6800C, 0x80820FD8},          /*   -12,  182, 4056, -130 */
-    {0x00AB800B, 0x807C0FDC},          /*   -11,  171, 4060, -124 */
-    {0x009F800A, 0x80760FE1},          /*   -10,  159, 4065, -118 */
-    {0x0094800A, 0x80700FE6},          /*   -10,  148, 4070, -112 */
-    {0x00898009, 0x80690FE9},          /*    -9,  137, 4073, -105 */
-    {0x007E8008, 0x80630FED},          /*    -8,  126, 4077,  -99 */
-    {0x00748007, 0x805C0FEF},          /*    -7,  116, 4079,  -92 */
-    {0x00698007, 0x80550FF3},          /*    -7,  105, 4083,  -85 */
-    {0x005F8006, 0x804E0FF5},          /*    -6,   95, 4085,  -78 */
-    {0x00558005, 0x80470FF7},          /*    -5,   85, 4087,  -71 */
-    {0x004B8005, 0x80400FFA},          /*    -5,   75, 4090,  -64 */
-    {0x00418004, 0x80380FFB},          /*    -4,   65, 4091,  -56 */
-    {0x00378003, 0x80310FFD},          /*    -3,   55, 4093,  -49 */
-    {0x002E8003, 0x80290FFE},          /*    -3,   46, 4094,  -41 */
-    {0x00238002, 0x80211000},          /*    -2,   35, 4096,  -33 */
-    {0x001A8001, 0x80191000},          /*    -1,   26, 4096,  -25 */
-    {0x00118001, 0x80101000},          /*    -1,   17, 4096,  -16 */
-    {0x00080000, 0x80081000},          /*     0,    8, 4096,   -8 */
+    {0x10000000, 0x00000000},   /*     0, 4096,    0,    0 */
+    {0x10008008, 0x00000008},   /*    -8, 4096,    8,    0 */
+    {0x10008010, 0x80010011},   /*   -16, 4096,   17,   -1 */
+    {0x10008019, 0x8001001A},   /*   -25, 4096,   26,   -1 */
+    {0x10008021, 0x80020023},   /*   -33, 4096,   35,   -2 */
+    {0x0FFF8029, 0x8003002D},   /*   -41, 4095,   45,   -3 */
+    {0x0FFE8031, 0x80030036},   /*   -49, 4094,   54,   -3 */
+    {0x0FFC8038, 0x80040040},   /*   -56, 4092,   64,   -4 */
+    {0x0FFB8040, 0x8005004A},   /*   -64, 4091,   74,   -5 */
+    {0x0FF88047, 0x80050054},   /*   -71, 4088,   84,   -5 */
+    {0x0FF6804E, 0x8006005E},   /*   -78, 4086,   94,   -6 */
+    {0x0FF48055, 0x80070068},   /*   -85, 4084,  104,   -7 */
+    {0x0FF0805C, 0x80070073},   /*   -92, 4080,  115,   -7 */
+    {0x0FEE8063, 0x8008007D},   /*   -99, 4078,  125,   -8 */
+    {0x0FEA8069, 0x80090088},   /*  -105, 4074,  136,   -9 */
+    {0x0FE78070, 0x800A0093},   /*  -112, 4071,  147,  -10 */
+    {0x0FE28076, 0x800A009E},   /*  -118, 4066,  158,  -10 */
+    {0x0FDD807C, 0x800B00AA},   /*  -124, 4061,  170,  -11 */
+    {0x0FD98082, 0x800C00B5},   /*  -130, 4057,  181,  -12 */
+    {0x0FD48088, 0x800D00C1},   /*  -136, 4052,  193,  -13 */
+    {0x0FCE808E, 0x800D00CD},   /*  -142, 4046,  205,  -13 */
+    {0x0FC88093, 0x800E00D9},   /*  -147, 4040,  217,  -14 */
+    {0x0FC38099, 0x800F00E5},   /*  -153, 4035,  229,  -15 */
+    {0x0FBD809E, 0x801000F1},   /*  -158, 4029,  241,  -16 */
+    {0x0FB680A3, 0x801000FD},   /*  -163, 4022,  253,  -16 */
+    {0x0FAF80A8, 0x8011010A},   /*  -168, 4015,  266,  -17 */
+    {0x0FA880AD, 0x80120117},   /*  -173, 4008,  279,  -18 */
+    {0x0FA180B2, 0x80130124},   /*  -178, 4001,  292,  -19 */
+    {0x0F9980B6, 0x80140131},   /*  -182, 3993,  305,  -20 */
+    {0x0F9280BB, 0x8015013E},   /*  -187, 3986,  318,  -21 */
+    {0x0F8880BF, 0x8015014C},   /*  -191, 3976,  332,  -21 */
+    {0x0F8080C3, 0x80160159},   /*  -195, 3968,  345,  -22 */
+    {0x0F7880C8, 0x80170167},   /*  -200, 3960,  359,  -23 */
+    {0x0F6E80CB, 0x80180175},   /*  -203, 3950,  373,  -24 */
+    {0x0F6580CF, 0x80190183},   /*  -207, 3941,  387,  -25 */
+    {0x0F5C80D3, 0x801A0191},   /*  -211, 3932,  401,  -26 */
+    {0x0F5280D7, 0x801B01A0},   /*  -215, 3922,  416,  -27 */
+    {0x0F4880DA, 0x801C01AE},   /*  -218, 3912,  430,  -28 */
+    {0x0F3D80DD, 0x801D01BD},   /*  -221, 3901,  445,  -29 */
+    {0x0F3280E0, 0x801E01CC},   /*  -224, 3890,  460,  -30 */
+    {0x0F2880E4, 0x801F01DB},   /*  -228, 3880,  475,  -31 */
+    {0x0F1C80E6, 0x802001EA},   /*  -230, 3868,  490,  -32 */
+    {0x0F1180E9, 0x802101F9},   /*  -233, 3857,  505,  -33 */
+    {0x0F0480EB, 0x80210208},   /*  -235, 3844,  520,  -33 */
+    {0x0EFA80EF, 0x80230218},   /*  -239, 3834,  536,  -35 */
+    {0x0EEC80F0, 0x80230227},   /*  -240, 3820,  551,  -35 */
+    {0x0EE080F3, 0x80240237},   /*  -243, 3808,  567,  -36 */
+    {0x0ED380F5, 0x80250247},   /*  -245, 3795,  583,  -37 */
+    {0x0EC780F7, 0x80270257},   /*  -247, 3783,  599,  -39 */
+    {0x0EB980F9, 0x80280268},   /*  -249, 3769,  616,  -40 */
+    {0x0EAC80FB, 0x80290278},   /*  -251, 3756,  632,  -41 */
+    {0x0E9E80FD, 0x802A0289},   /*  -253, 3742,  649,  -42 */
+    {0x0E9080FE, 0x802B0299},   /*  -254, 3728,  665,  -43 */
+    {0x0E838100, 0x802D02AA},   /*  -256, 3715,  682,  -45 */
+    {0x0E758102, 0x802E02BB},   /*  -258, 3701,  699,  -46 */
+    {0x0E668103, 0x802F02CC},   /*  -259, 3686,  716,  -47 */
+    {0x0E568104, 0x803002DE},   /*  -260, 3670,  734,  -48 */
+    {0x0E498106, 0x803202EF},   /*  -262, 3657,  751,  -50 */
+    {0x0E398107, 0x80330301},   /*  -263, 3641,  769,  -51 */
+    {0x0E298108, 0x80340313},   /*  -264, 3625,  787,  -52 */
+    {0x0E1A8109, 0x80360325},   /*  -265, 3610,  805,  -54 */
+    {0x0E0B810A, 0x80370336},   /*  -266, 3595,  822,  -55 */
+    {0x0DFA810A, 0x80380348},   /*  -266, 3578,  840,  -56 */
+    {0x0DEA810B, 0x803A035B},   /*  -267, 3562,  859,  -58 */
+    {0x0DDA810C, 0x803B036D},   /*  -268, 3546,  877,  -59 */
+    {0x0DCA810C, 0x803D037F},   /*  -268, 3530,  895,  -61 */
+    {0x0DB7810B, 0x803E0392},   /*  -267, 3511,  914,  -62 */
+    {0x0DA7810C, 0x804003A5},   /*  -268, 3495,  933,  -64 */
+    {0x0D95810C, 0x804103B8},   /*  -268, 3477,  952,  -65 */
+    {0x0D85810C, 0x804303CA},   /*  -268, 3461,  970,  -67 */
+    {0x0D73810C, 0x804403DD},   /*  -268, 3443,  989,  -68 */
+    {0x0D61810C, 0x804603F1},   /*  -268, 3425, 1009,  -70 */
+    {0x0D50810C, 0x80480404},   /*  -268, 3408, 1028,  -72 */
+    {0x0D3E810C, 0x80490417},   /*  -268, 3390, 1047,  -73 */
+    {0x0D2C810C, 0x804B042B},   /*  -268, 3372, 1067,  -75 */
+    {0x0D1B810C, 0x804D043E},   /*  -268, 3355, 1086,  -77 */
+    {0x0D07810B, 0x804E0452},   /*  -267, 3335, 1106,  -78 */
+    {0x0CF5810B, 0x80500466},   /*  -267, 3317, 1126,  -80 */
+    {0x0CE2810A, 0x8052047A},   /*  -266, 3298, 1146,  -82 */
+    {0x0CCF810A, 0x8053048E},   /*  -266, 3279, 1166,  -83 */
+    {0x0CBC8109, 0x805504A2},   /*  -265, 3260, 1186,  -85 */
+    {0x0CA98108, 0x805704B6},   /*  -264, 3241, 1206,  -87 */
+    {0x0C968108, 0x805904CB},   /*  -264, 3222, 1227,  -89 */
+    {0x0C838107, 0x805B04DF},   /*  -263, 3203, 1247,  -91 */
+    {0x0C6F8106, 0x805C04F3},   /*  -262, 3183, 1267,  -92 */
+    {0x0C5B8105, 0x805E0508},   /*  -261, 3163, 1288,  -94 */
+    {0x0C478104, 0x8060051D},   /*  -260, 3143, 1309,  -96 */
+    {0x0C348103, 0x80620531},   /*  -259, 3124, 1329,  -98 */
+    {0x0C1F8102, 0x80640547},   /*  -258, 3103, 1351, -100 */
+    {0x0C0C8101, 0x8066055B},   /*  -257, 3084, 1371, -102 */
+    {0x0BF88100, 0x80680570},   /*  -256, 3064, 1392, -104 */
+    {0x0BE380FE, 0x806A0585},   /*  -254, 3043, 1413, -106 */
+    {0x0BCF80FD, 0x806C059A},   /*  -253, 3023, 1434, -108 */
+    {0x0BBA80FC, 0x806E05B0},   /*  -252, 3002, 1456, -110 */
+    {0x0BA480F9, 0x807005C5},   /*  -249, 2980, 1477, -112 */
+    {0x0B8F80F8, 0x807205DB},   /*  -248, 2959, 1499, -114 */
+    {0x0B7A80F6, 0x807405F0},   /*  -246, 2938, 1520, -116 */
+    {0x0B6580F5, 0x80760606},   /*  -245, 2917, 1542, -118 */
+    {0x0B4F80F3, 0x8077061B},   /*  -243, 2895, 1563, -119 */
+    {0x0B3A80F2, 0x80790631},   /*  -242, 2874, 1585, -121 */
+    {0x0B2480F0, 0x807B0647},   /*  -240, 2852, 1607, -123 */
+    {0x0B0F80EE, 0x807D065C},   /*  -238, 2831, 1628, -125 */
+    {0x0AF980ED, 0x807F0673},   /*  -237, 2809, 1651, -127 */
+    {0x0AE480EB, 0x80810688},   /*  -235, 2788, 1672, -129 */
+    {0x0ACE80E9, 0x8084069F},   /*  -233, 2766, 1695, -132 */
+    {0x0AB980E7, 0x808606B4},   /*  -231, 2745, 1716, -134 */
+    {0x0AA380E6, 0x808806CB},   /*  -230, 2723, 1739, -136 */
+    {0x0A8D80E4, 0x808A06E1},   /*  -228, 2701, 1761, -138 */
+    {0x0A7780E2, 0x808C06F7},   /*  -226, 2679, 1783, -140 */
+    {0x0A6180E0, 0x808E070D},   /*  -224, 2657, 1805, -142 */
+    {0x0A4B80DE, 0x80910724},   /*  -222, 2635, 1828, -145 */
+    {0x0A3580DC, 0x8093073A},   /*  -220, 2613, 1850, -147 */
+    {0x0A1F80DA, 0x80950750},   /*  -218, 2591, 1872, -149 */
+    {0x0A0880D8, 0x80970767},   /*  -216, 2568, 1895, -151 */
+    {0x09F280D6, 0x8099077D},   /*  -214, 2546, 1917, -153 */
+    {0x09DD80D4, 0x809C0793},   /*  -212, 2525, 1939, -156 */
+    {0x09C680D2, 0x809E07AA},   /*  -210, 2502, 1962, -158 */
+    {0x09B080D0, 0x80A007C0},   /*  -208, 2480, 1984, -160 */
+    {0x099980CE, 0x80A207D7},   /*  -206, 2457, 2007, -162 */
+    {0x098380CB, 0x80A507ED},   /*  -203, 2435, 2029, -165 */
+    {0x096C80C9, 0x80A70804},   /*  -201, 2412, 2052, -167 */
+    {0x095680C7, 0x80A9081A},   /*  -199, 2390, 2074, -169 */
+    {0x094080C5, 0x80AB0830},   /*  -197, 2368, 2096, -171 */
+    {0x092980C3, 0x80AE0848},   /*  -195, 2345, 2120, -174 */
+    {0x091380C1, 0x80B0085E},   /*  -193, 2323, 2142, -176 */
+    {0x08FC80BE, 0x80B20874},   /*  -190, 2300, 2164, -178 */
+    {0x08E580BC, 0x80B4088B},   /*  -188, 2277, 2187, -180 */
+    {0x08D080BB, 0x80B708A2},   /*  -187, 2256, 2210, -183 */
+    {0x08B980B9, 0x80B908B9},   /*  -185, 2233, 2233, -185 */
+    {0x08A380B7, 0x80BB08CF},   /*  -183, 2211, 2255, -187 */
+    {0x088B80B4, 0x80BC08E5},   /*  -180, 2187, 2277, -188 */
+    {0x087480B2, 0x80BE08FC},   /*  -178, 2164, 2300, -190 */
+    {0x085E80B0, 0x80C10913},   /*  -176, 2142, 2323, -193 */
+    {0x084880AE, 0x80C30929},   /*  -174, 2120, 2345, -195 */
+    {0x083080AB, 0x80C50940},   /*  -171, 2096, 2368, -197 */
+    {0x081A80A9, 0x80C70956},   /*  -169, 2074, 2390, -199 */
+    {0x080480A7, 0x80C9096C},   /*  -167, 2052, 2412, -201 */
+    {0x07ED80A5, 0x80CB0983},   /*  -165, 2029, 2435, -203 */
+    {0x07D780A2, 0x80CE0999},   /*  -162, 2007, 2457, -206 */
+    {0x07C080A0, 0x80D009B0},   /*  -160, 1984, 2480, -208 */
+    {0x07AA809E, 0x80D209C6},   /*  -158, 1962, 2502, -210 */
+    {0x0793809C, 0x80D409DD},   /*  -156, 1939, 2525, -212 */
+    {0x077D8099, 0x80D609F2},   /*  -153, 1917, 2546, -214 */
+    {0x07668097, 0x80D80A09},   /*  -151, 1894, 2569, -216 */
+    {0x074F8095, 0x80DA0A20},   /*  -149, 1871, 2592, -218 */
+    {0x073A8093, 0x80DC0A35},   /*  -147, 1850, 2613, -220 */
+    {0x07238091, 0x80DE0A4C},   /*  -145, 1827, 2636, -222 */
+    {0x070C808E, 0x80E00A62},   /*  -142, 1804, 2658, -224 */
+    {0x06F7808C, 0x80E20A77},   /*  -140, 1783, 2679, -226 */
+    {0x06E0808A, 0x80E40A8E},   /*  -138, 1760, 2702, -228 */
+    {0x06CA8088, 0x80E60AA4},   /*  -136, 1738, 2724, -230 */
+    {0x06B48086, 0x80E70AB9},   /*  -134, 1716, 2745, -231 */
+    {0x069E8084, 0x80E90ACF},   /*  -132, 1694, 2767, -233 */
+    {0x06878081, 0x80EB0AE5},   /*  -129, 1671, 2789, -235 */
+    {0x0672807F, 0x80ED0AFA},   /*  -127, 1650, 2810, -237 */
+    {0x065C807D, 0x80EE0B0F},   /*  -125, 1628, 2831, -238 */
+    {0x0646807B, 0x80F00B25},   /*  -123, 1606, 2853, -240 */
+    {0x06308079, 0x80F20B3B},   /*  -121, 1584, 2875, -242 */
+    {0x061A8077, 0x80F30B50},   /*  -119, 1562, 2896, -243 */
+    {0x06068076, 0x80F50B65},   /*  -118, 1542, 2917, -245 */
+    {0x05F08074, 0x80F60B7A},   /*  -116, 1520, 2938, -246 */
+    {0x05DB8072, 0x80F80B8F},   /*  -114, 1499, 2959, -248 */
+    {0x05C58070, 0x80F90BA4},   /*  -112, 1477, 2980, -249 */
+    {0x05B1806E, 0x80FC0BB9},   /*  -110, 1457, 3001, -252 */
+    {0x059B806C, 0x80FD0BCE},   /*  -108, 1435, 3022, -253 */
+    {0x0586806A, 0x80FE0BE2},   /*  -106, 1414, 3042, -254 */
+    {0x05718068, 0x81000BF7},   /*  -104, 1393, 3063, -256 */
+    {0x055C8066, 0x81010C0B},   /*  -102, 1372, 3083, -257 */
+    {0x05478064, 0x81020C1F},   /*  -100, 1351, 3103, -258 */
+    {0x05328062, 0x81030C33},   /*   -98, 1330, 3123, -259 */
+    {0x051D8060, 0x81040C47},   /*   -96, 1309, 3143, -260 */
+    {0x0508805E, 0x81050C5B},   /*   -94, 1288, 3163, -261 */
+    {0x04F3805C, 0x81060C6F},   /*   -92, 1267, 3183, -262 */
+    {0x04E0805B, 0x81070C82},   /*   -91, 1248, 3202, -263 */
+    {0x04CB8059, 0x81080C96},   /*   -89, 1227, 3222, -264 */
+    {0x04B68057, 0x81080CA9},   /*   -87, 1206, 3241, -264 */
+    {0x04A28055, 0x81090CBC},   /*   -85, 1186, 3260, -265 */
+    {0x048E8053, 0x810A0CCF},   /*   -83, 1166, 3279, -266 */
+    {0x047A8052, 0x810A0CE2},   /*   -82, 1146, 3298, -266 */
+    {0x04668050, 0x810B0CF5},   /*   -80, 1126, 3317, -267 */
+    {0x0451804E, 0x810B0D08},   /*   -78, 1105, 3336, -267 */
+    {0x043E804D, 0x810C0D1B},   /*   -77, 1086, 3355, -268 */
+    {0x042B804B, 0x810C0D2C},   /*   -75, 1067, 3372, -268 */
+    {0x04178049, 0x810C0D3E},   /*   -73, 1047, 3390, -268 */
+    {0x04038048, 0x810C0D51},   /*   -72, 1027, 3409, -268 */
+    {0x03F08046, 0x810C0D62},   /*   -70, 1008, 3426, -268 */
+    {0x03DD8044, 0x810C0D73},   /*   -68,  989, 3443, -268 */
+    {0x03CA8043, 0x810C0D85},   /*   -67,  970, 3461, -268 */
+    {0x03B78041, 0x810C0D96},   /*   -65,  951, 3478, -268 */
+    {0x03A48040, 0x810C0DA8},   /*   -64,  932, 3496, -268 */
+    {0x0391803E, 0x810B0DB8},   /*   -62,  913, 3512, -267 */
+    {0x0380803D, 0x810C0DC9},   /*   -61,  896, 3529, -268 */
+    {0x036D803B, 0x810C0DDA},   /*   -59,  877, 3546, -268 */
+    {0x035B803A, 0x810B0DEA},   /*   -58,  859, 3562, -267 */
+    {0x03488038, 0x810A0DFA},   /*   -56,  840, 3578, -266 */
+    {0x03368037, 0x810A0E0B},   /*   -55,  822, 3595, -266 */
+    {0x03248036, 0x81090E1B},   /*   -54,  804, 3611, -265 */
+    {0x03128034, 0x81080E2A},   /*   -52,  786, 3626, -264 */
+    {0x03018033, 0x81070E39},   /*   -51,  769, 3641, -263 */
+    {0x02EF8032, 0x81060E49},   /*   -50,  751, 3657, -262 */
+    {0x02DE8030, 0x81040E56},   /*   -48,  734, 3670, -260 */
+    {0x02CC802F, 0x81030E66},   /*   -47,  716, 3686, -259 */
+    {0x02BB802E, 0x81020E75},   /*   -46,  699, 3701, -258 */
+    {0x02AA802D, 0x81000E83},   /*   -45,  682, 3715, -256 */
+    {0x0299802B, 0x80FE0E90},   /*   -43,  665, 3728, -254 */
+    {0x0288802A, 0x80FD0E9F},   /*   -42,  648, 3743, -253 */
+    {0x02778029, 0x80FB0EAD},   /*   -41,  631, 3757, -251 */
+    {0x02678028, 0x80F90EBA},   /*   -40,  615, 3770, -249 */
+    {0x02568027, 0x80F70EC8},   /*   -39,  598, 3784, -247 */
+    {0x02468025, 0x80F50ED4},   /*   -37,  582, 3796, -245 */
+    {0x02368024, 0x80F30EE1},   /*   -36,  566, 3809, -243 */
+    {0x02268023, 0x80F00EED},   /*   -35,  550, 3821, -240 */
+    {0x02188023, 0x80EF0EFA},   /*   -35,  536, 3834, -239 */
+    {0x02078021, 0x80EB0F05},   /*   -33,  519, 3845, -235 */
+    {0x01F98021, 0x80E90F11},   /*   -33,  505, 3857, -233 */
+    {0x01EA8020, 0x80E60F1C},   /*   -32,  490, 3868, -230 */
+    {0x01DC801F, 0x80E40F27},   /*   -31,  476, 3879, -228 */
+    {0x01CD801E, 0x80E00F31},   /*   -30,  461, 3889, -224 */
+    {0x01BE801D, 0x80DD0F3C},   /*   -29,  446, 3900, -221 */
+    {0x01AF801C, 0x80DA0F47},   /*   -28,  431, 3911, -218 */
+    {0x01A1801B, 0x80D70F51},   /*   -27,  417, 3921, -215 */
+    {0x0192801A, 0x80D30F5B},   /*   -26,  402, 3931, -211 */
+    {0x01848019, 0x80CF0F64},   /*   -25,  388, 3940, -207 */
+    {0x01768018, 0x80CB0F6D},   /*   -24,  374, 3949, -203 */
+    {0x01688017, 0x80C80F77},   /*   -23,  360, 3959, -200 */
+    {0x015A8016, 0x80C30F7F},   /*   -22,  346, 3967, -195 */
+    {0x014D8015, 0x80BF0F87},   /*   -21,  333, 3975, -191 */
+    {0x013F8015, 0x80BB0F91},   /*   -21,  319, 3985, -187 */
+    {0x01328014, 0x80B60F98},   /*   -20,  306, 3992, -182 */
+    {0x01258013, 0x80B20FA0},   /*   -19,  293, 4000, -178 */
+    {0x01188012, 0x80AD0FA7},   /*   -18,  280, 4007, -173 */
+    {0x010B8011, 0x80A80FAE},   /*   -17,  267, 4014, -168 */
+    {0x00FE8010, 0x80A30FB5},   /*   -16,  254, 4021, -163 */
+    {0x00F28010, 0x809E0FBC},   /*   -16,  242, 4028, -158 */
+    {0x00E6800F, 0x80990FC2},   /*   -15,  230, 4034, -153 */
+    {0x00DA800E, 0x80930FC7},   /*   -14,  218, 4039, -147 */
+    {0x00CE800D, 0x808E0FCD},   /*   -13,  206, 4045, -142 */
+    {0x00C2800D, 0x80880FD3},   /*   -13,  194, 4051, -136 */
+    {0x00B6800C, 0x80820FD8},   /*   -12,  182, 4056, -130 */
+    {0x00AB800B, 0x807C0FDC},   /*   -11,  171, 4060, -124 */
+    {0x009F800A, 0x80760FE1},   /*   -10,  159, 4065, -118 */
+    {0x0094800A, 0x80700FE6},   /*   -10,  148, 4070, -112 */
+    {0x00898009, 0x80690FE9},   /*    -9,  137, 4073, -105 */
+    {0x007E8008, 0x80630FED},   /*    -8,  126, 4077,  -99 */
+    {0x00748007, 0x805C0FEF},   /*    -7,  116, 4079,  -92 */
+    {0x00698007, 0x80550FF3},   /*    -7,  105, 4083,  -85 */
+    {0x005F8006, 0x804E0FF5},   /*    -6,   95, 4085,  -78 */
+    {0x00558005, 0x80470FF7},   /*    -5,   85, 4087,  -71 */
+    {0x004B8005, 0x80400FFA},   /*    -5,   75, 4090,  -64 */
+    {0x00418004, 0x80380FFB},   /*    -4,   65, 4091,  -56 */
+    {0x00378003, 0x80310FFD},   /*    -3,   55, 4093,  -49 */
+    {0x002E8003, 0x80290FFE},   /*    -3,   46, 4094,  -41 */
+    {0x00238002, 0x80211000},   /*    -2,   35, 4096,  -33 */
+    {0x001A8001, 0x80191000},   /*    -1,   26, 4096,  -25 */
+    {0x00118001, 0x80101000},   /*    -1,   17, 4096,  -16 */
+    {0x00080000, 0x80081000},   /*     0,    8, 4096,   -8 */
 };
 
 long CimarronVideoFilter128[][2] = {
-    {0x10000000, 0x00000000},          /*     0, 4096,    0,    0 */
-    {0x10018011, 0x80010011},          /*   -17, 4097,   17,   -1 */
-    {0x10008021, 0x80020023},          /*   -33, 4096,   35,   -2 */
-    {0x0FFE8031, 0x80030036},          /*   -49, 4094,   54,   -3 */
-    {0x0FFB8040, 0x8005004A},          /*   -64, 4091,   74,   -5 */
-    {0x0FF6804E, 0x8006005E},          /*   -78, 4086,   94,   -6 */
-    {0x0FF0805C, 0x80070073},          /*   -92, 4080,  115,   -7 */
-    {0x0FEB806A, 0x80090088},          /*  -106, 4075,  136,   -9 */
-    {0x0FE18076, 0x800A009F},          /*  -118, 4065,  159,  -10 */
-    {0x0FD98082, 0x800C00B5},          /*  -130, 4057,  181,  -12 */
-    {0x0FCE808E, 0x800D00CD},          /*  -142, 4046,  205,  -13 */
-    {0x0FC38099, 0x800F00E5},          /*  -153, 4035,  229,  -15 */
-    {0x0FB680A4, 0x801000FE},          /*  -164, 4022,  254,  -16 */
-    {0x0FA880AD, 0x80120117},          /*  -173, 4008,  279,  -18 */
-    {0x0F9A80B7, 0x80140131},          /*  -183, 3994,  305,  -20 */
-    {0x0F8980C0, 0x8015014C},          /*  -192, 3977,  332,  -21 */
-    {0x0F7880C8, 0x80170167},          /*  -200, 3960,  359,  -23 */
-    {0x0F6680D0, 0x80190183},          /*  -208, 3942,  387,  -25 */
-    {0x0F5280D7, 0x801B01A0},          /*  -215, 3922,  416,  -27 */
-    {0x0F3E80DE, 0x801D01BD},          /*  -222, 3902,  445,  -29 */
-    {0x0F2880E4, 0x801F01DB},          /*  -228, 3880,  475,  -31 */
-    {0x0F1180EA, 0x802101FA},          /*  -234, 3857,  506,  -33 */
-    {0x0EF880EE, 0x80220218},          /*  -238, 3832,  536,  -34 */
-    {0x0EDF80F3, 0x80240238},          /*  -243, 3807,  568,  -36 */
-    {0x0EC680F7, 0x80270258},          /*  -247, 3782,  600,  -39 */
-    {0x0EAB80FB, 0x80290279},          /*  -251, 3755,  633,  -41 */
-    {0x0E9080FF, 0x802B029A},          /*  -255, 3728,  666,  -43 */
-    {0x0E748102, 0x802E02BC},          /*  -258, 3700,  700,  -46 */
-    {0x0E588105, 0x803102DE},          /*  -261, 3672,  734,  -49 */
-    {0x0E388107, 0x80330302},          /*  -263, 3640,  770,  -51 */
-    {0x0E1A8109, 0x80360325},          /*  -265, 3610,  805,  -54 */
-    {0x0DFB810B, 0x80390349},          /*  -267, 3579,  841,  -57 */
-    {0x0DDB810C, 0x803C036D},          /*  -268, 3547,  877,  -60 */
-    {0x0DBA810D, 0x803F0392},          /*  -269, 3514,  914,  -63 */
-    {0x0D98810E, 0x804203B8},          /*  -270, 3480,  952,  -66 */
-    {0x0D74810D, 0x804503DE},          /*  -269, 3444,  990,  -69 */
-    {0x0D50810D, 0x80480405},          /*  -269, 3408, 1029,  -72 */
-    {0x0D2C810C, 0x804B042B},          /*  -268, 3372, 1067,  -75 */
-    {0x0D08810C, 0x804F0453},          /*  -268, 3336, 1107,  -79 */
-    {0x0CE3810B, 0x8052047A},          /*  -267, 3299, 1146,  -82 */
-    {0x0CBD810A, 0x805604A3},          /*  -266, 3261, 1187,  -86 */
-    {0x0C968108, 0x805904CB},          /*  -264, 3222, 1227,  -89 */
-    {0x0C708107, 0x805D04F4},          /*  -263, 3184, 1268,  -93 */
-    {0x0C488105, 0x8061051E},          /*  -261, 3144, 1310,  -97 */
-    {0x0C208103, 0x80640547},          /*  -259, 3104, 1351, -100 */
-    {0x0BF78100, 0x80680571},          /*  -256, 3063, 1393, -104 */
-    {0x0BCF80FE, 0x806C059B},          /*  -254, 3023, 1435, -108 */
-    {0x0BA480FA, 0x807005C6},          /*  -250, 2980, 1478, -112 */
-    {0x0B7A80F7, 0x807405F1},          /*  -247, 2938, 1521, -116 */
-    {0x0B4F80F4, 0x8077061C},          /*  -244, 2895, 1564, -119 */
-    {0x0B2580F1, 0x807C0648},          /*  -241, 2853, 1608, -124 */
-    {0x0AFA80ED, 0x80800673},          /*  -237, 2810, 1651, -128 */
-    {0x0ACF80EA, 0x8084069F},          /*  -234, 2767, 1695, -132 */
-    {0x0AA380E6, 0x808806CB},          /*  -230, 2723, 1739, -136 */
-    {0x0A7880E2, 0x808D06F7},          /*  -226, 2680, 1783, -141 */
-    {0x0A4C80DF, 0x80910724},          /*  -223, 2636, 1828, -145 */
-    {0x0A2080DB, 0x80960751},          /*  -219, 2592, 1873, -150 */
-    {0x09F480D7, 0x809A077D},          /*  -215, 2548, 1917, -154 */
-    {0x09C780D2, 0x809F07AA},          /*  -210, 2503, 1962, -159 */
-    {0x099A80CE, 0x80A307D7},          /*  -206, 2458, 2007, -163 */
-    {0x096D80CA, 0x80A70804},          /*  -202, 2413, 2052, -167 */
-    {0x094180C6, 0x80AC0831},          /*  -198, 2369, 2097, -172 */
-    {0x091380C1, 0x80B0085E},          /*  -193, 2323, 2142, -176 */
-    {0x08E780BE, 0x80B5088C},          /*  -190, 2279, 2188, -181 */
-    {0x08B980B9, 0x80B908B9},          /*  -185, 2233, 2233, -185 */
-    {0x088C80B5, 0x80BE08E7},          /*  -181, 2188, 2279, -190 */
-    {0x085E80B0, 0x80C10913},          /*  -176, 2142, 2323, -193 */
-    {0x083180AC, 0x80C60941},          /*  -172, 2097, 2369, -198 */
-    {0x080480A7, 0x80CA096D},          /*  -167, 2052, 2413, -202 */
-    {0x07D780A3, 0x80CE099A},          /*  -163, 2007, 2458, -206 */
-    {0x07AA809F, 0x80D209C7},          /*  -159, 1962, 2503, -210 */
-    {0x077D809A, 0x80D709F4},          /*  -154, 1917, 2548, -215 */
-    {0x07518096, 0x80DB0A20},          /*  -150, 1873, 2592, -219 */
-    {0x07248091, 0x80DF0A4C},          /*  -145, 1828, 2636, -223 */
-    {0x06F7808D, 0x80E20A78},          /*  -141, 1783, 2680, -226 */
-    {0x06CA8088, 0x80E60AA4},          /*  -136, 1738, 2724, -230 */
-    {0x069E8084, 0x80EA0AD0},          /*  -132, 1694, 2768, -234 */
-    {0x06738080, 0x80ED0AFA},          /*  -128, 1651, 2810, -237 */
-    {0x0647807C, 0x80F10B26},          /*  -124, 1607, 2854, -241 */
-    {0x061B8077, 0x80F40B50},          /*  -119, 1563, 2896, -244 */
-    {0x05F18074, 0x80F70B7A},          /*  -116, 1521, 2938, -247 */
-    {0x05C68070, 0x80FA0BA4},          /*  -112, 1478, 2980, -250 */
-    {0x059C806C, 0x80FE0BCE},          /*  -108, 1436, 3022, -254 */
-    {0x05728068, 0x81000BF6},          /*  -104, 1394, 3062, -256 */
-    {0x05478064, 0x81030C20},          /*  -100, 1351, 3104, -259 */
-    {0x051E8061, 0x81050C48},          /*   -97, 1310, 3144, -261 */
-    {0x04F4805D, 0x81070C70},          /*   -93, 1268, 3184, -263 */
-    {0x04CB8059, 0x81080C96},          /*   -89, 1227, 3222, -264 */
-    {0x04A38056, 0x810A0CBD},          /*   -86, 1187, 3261, -266 */
-    {0x047A8052, 0x810B0CE3},          /*   -82, 1146, 3299, -267 */
-    {0x0453804F, 0x810C0D08},          /*   -79, 1107, 3336, -268 */
-    {0x042B804B, 0x810C0D2C},          /*   -75, 1067, 3372, -268 */
-    {0x04048048, 0x810D0D51},          /*   -72, 1028, 3409, -269 */
-    {0x03DE8045, 0x810D0D74},          /*   -69,  990, 3444, -269 */
-    {0x03B88042, 0x810E0D98},          /*   -66,  952, 3480, -270 */
-    {0x0393803F, 0x810D0DB9},          /*   -63,  915, 3513, -269 */
-    {0x036E803C, 0x810C0DDA},          /*   -60,  878, 3546, -268 */
-    {0x03498039, 0x810B0DFB},          /*   -57,  841, 3579, -267 */
-    {0x03258036, 0x81090E1A},          /*   -54,  805, 3610, -265 */
-    {0x03018033, 0x81070E39},          /*   -51,  769, 3641, -263 */
-    {0x02DE8031, 0x81050E58},          /*   -49,  734, 3672, -261 */
-    {0x02BC802E, 0x81020E74},          /*   -46,  700, 3700, -258 */
-    {0x0299802B, 0x80FF0E91},          /*   -43,  665, 3729, -255 */
-    {0x02788029, 0x80FB0EAC},          /*   -41,  632, 3756, -251 */
-    {0x02578027, 0x80F70EC7},          /*   -39,  599, 3783, -247 */
-    {0x02378024, 0x80F30EE0},          /*   -36,  567, 3808, -243 */
-    {0x02178022, 0x80EE0EF9},          /*   -34,  535, 3833, -238 */
-    {0x01FA8021, 0x80EA0F11},          /*   -33,  506, 3857, -234 */
-    {0x01DC801F, 0x80E40F27},          /*   -31,  476, 3879, -228 */
-    {0x01BE801D, 0x80DE0F3D},          /*   -29,  446, 3901, -222 */
-    {0x01A1801B, 0x80D70F51},          /*   -27,  417, 3921, -215 */
-    {0x01848019, 0x80D00F65},          /*   -25,  388, 3941, -208 */
-    {0x01688017, 0x80C80F77},          /*   -23,  360, 3959, -200 */
-    {0x014D8015, 0x80C00F88},          /*   -21,  333, 3976, -192 */
-    {0x01328014, 0x80B70F99},          /*   -20,  306, 3993, -183 */
-    {0x01188012, 0x80AD0FA7},          /*   -18,  280, 4007, -173 */
-    {0x00FF8010, 0x80A40FB5},          /*   -16,  255, 4021, -164 */
-    {0x00E6800F, 0x80990FC2},          /*   -15,  230, 4034, -153 */
-    {0x00CE800D, 0x808E0FCD},          /*   -13,  206, 4045, -142 */
-    {0x00B6800C, 0x80820FD8},          /*   -12,  182, 4056, -130 */
-    {0x00A0800A, 0x80760FE0},          /*   -10,  160, 4064, -118 */
-    {0x00898009, 0x806A0FEA},          /*    -9,  137, 4074, -106 */
-    {0x00748007, 0x805C0FEF},          /*    -7,  116, 4079,  -92 */
-    {0x005F8006, 0x804E0FF5},          /*    -6,   95, 4085,  -78 */
-    {0x004B8005, 0x80400FFA},          /*    -5,   75, 4090,  -64 */
-    {0x00378003, 0x80310FFD},          /*    -3,   55, 4093,  -49 */
-    {0x00238002, 0x80211000},          /*    -2,   35, 4096,  -33 */
-    {0x00118001, 0x80111001},          /*    -1,   17, 4097,  -17 */
-    {0x10000000, 0x00000000},          /*     0, 4096,    0,    0 */
-    {0x10018011, 0x80010011},          /*   -17, 4097,   17,   -1 */
-    {0x10008021, 0x80020023},          /*   -33, 4096,   35,   -2 */
-    {0x0FFE8031, 0x80030036},          /*   -49, 4094,   54,   -3 */
-    {0x0FFB8040, 0x8005004A},          /*   -64, 4091,   74,   -5 */
-    {0x0FF6804E, 0x8006005E},          /*   -78, 4086,   94,   -6 */
-    {0x0FF0805C, 0x80070073},          /*   -92, 4080,  115,   -7 */
-    {0x0FEB806A, 0x80090088},          /*  -106, 4075,  136,   -9 */
-    {0x0FE18076, 0x800A009F},          /*  -118, 4065,  159,  -10 */
-    {0x0FD98082, 0x800C00B5},          /*  -130, 4057,  181,  -12 */
-    {0x0FCE808E, 0x800D00CD},          /*  -142, 4046,  205,  -13 */
-    {0x0FC38099, 0x800F00E5},          /*  -153, 4035,  229,  -15 */
-    {0x0FB680A4, 0x801000FE},          /*  -164, 4022,  254,  -16 */
-    {0x0FA880AD, 0x80120117},          /*  -173, 4008,  279,  -18 */
-    {0x0F9A80B7, 0x80140131},          /*  -183, 3994,  305,  -20 */
-    {0x0F8980C0, 0x8015014C},          /*  -192, 3977,  332,  -21 */
-    {0x0F7880C8, 0x80170167},          /*  -200, 3960,  359,  -23 */
-    {0x0F6680D0, 0x80190183},          /*  -208, 3942,  387,  -25 */
-    {0x0F5280D7, 0x801B01A0},          /*  -215, 3922,  416,  -27 */
-    {0x0F3E80DE, 0x801D01BD},          /*  -222, 3902,  445,  -29 */
-    {0x0F2880E4, 0x801F01DB},          /*  -228, 3880,  475,  -31 */
-    {0x0F1180EA, 0x802101FA},          /*  -234, 3857,  506,  -33 */
-    {0x0EF880EE, 0x80220218},          /*  -238, 3832,  536,  -34 */
-    {0x0EDF80F3, 0x80240238},          /*  -243, 3807,  568,  -36 */
-    {0x0EC680F7, 0x80270258},          /*  -247, 3782,  600,  -39 */
-    {0x0EAB80FB, 0x80290279},          /*  -251, 3755,  633,  -41 */
-    {0x0E9080FF, 0x802B029A},          /*  -255, 3728,  666,  -43 */
-    {0x0E748102, 0x802E02BC},          /*  -258, 3700,  700,  -46 */
-    {0x0E588105, 0x803102DE},          /*  -261, 3672,  734,  -49 */
-    {0x0E388107, 0x80330302},          /*  -263, 3640,  770,  -51 */
-    {0x0E1A8109, 0x80360325},          /*  -265, 3610,  805,  -54 */
-    {0x0DFB810B, 0x80390349},          /*  -267, 3579,  841,  -57 */
-    {0x0DDB810C, 0x803C036D},          /*  -268, 3547,  877,  -60 */
-    {0x0DBA810D, 0x803F0392},          /*  -269, 3514,  914,  -63 */
-    {0x0D98810E, 0x804203B8},          /*  -270, 3480,  952,  -66 */
-    {0x0D74810D, 0x804503DE},          /*  -269, 3444,  990,  -69 */
-    {0x0D50810D, 0x80480405},          /*  -269, 3408, 1029,  -72 */
-    {0x0D2C810C, 0x804B042B},          /*  -268, 3372, 1067,  -75 */
-    {0x0D08810C, 0x804F0453},          /*  -268, 3336, 1107,  -79 */
-    {0x0CE3810B, 0x8052047A},          /*  -267, 3299, 1146,  -82 */
-    {0x0CBD810A, 0x805604A3},          /*  -266, 3261, 1187,  -86 */
-    {0x0C968108, 0x805904CB},          /*  -264, 3222, 1227,  -89 */
-    {0x0C708107, 0x805D04F4},          /*  -263, 3184, 1268,  -93 */
-    {0x0C488105, 0x8061051E},          /*  -261, 3144, 1310,  -97 */
-    {0x0C208103, 0x80640547},          /*  -259, 3104, 1351, -100 */
-    {0x0BF78100, 0x80680571},          /*  -256, 3063, 1393, -104 */
-    {0x0BCF80FE, 0x806C059B},          /*  -254, 3023, 1435, -108 */
-    {0x0BA480FA, 0x807005C6},          /*  -250, 2980, 1478, -112 */
-    {0x0B7A80F7, 0x807405F1},          /*  -247, 2938, 1521, -116 */
-    {0x0B4F80F4, 0x8077061C},          /*  -244, 2895, 1564, -119 */
-    {0x0B2580F1, 0x807C0648},          /*  -241, 2853, 1608, -124 */
-    {0x0AFA80ED, 0x80800673},          /*  -237, 2810, 1651, -128 */
-    {0x0ACF80EA, 0x8084069F},          /*  -234, 2767, 1695, -132 */
-    {0x0AA380E6, 0x808806CB},          /*  -230, 2723, 1739, -136 */
-    {0x0A7880E2, 0x808D06F7},          /*  -226, 2680, 1783, -141 */
-    {0x0A4C80DF, 0x80910724},          /*  -223, 2636, 1828, -145 */
-    {0x0A2080DB, 0x80960751},          /*  -219, 2592, 1873, -150 */
-    {0x09F480D7, 0x809A077D},          /*  -215, 2548, 1917, -154 */
-    {0x09C780D2, 0x809F07AA},          /*  -210, 2503, 1962, -159 */
-    {0x099A80CE, 0x80A307D7},          /*  -206, 2458, 2007, -163 */
-    {0x096D80CA, 0x80A70804},          /*  -202, 2413, 2052, -167 */
-    {0x094180C6, 0x80AC0831},          /*  -198, 2369, 2097, -172 */
-    {0x091380C1, 0x80B0085E},          /*  -193, 2323, 2142, -176 */
-    {0x08E780BE, 0x80B5088C},          /*  -190, 2279, 2188, -181 */
-    {0x08B980B9, 0x80B908B9},          /*  -185, 2233, 2233, -185 */
-    {0x088C80B5, 0x80BE08E7},          /*  -181, 2188, 2279, -190 */
-    {0x085E80B0, 0x80C10913},          /*  -176, 2142, 2323, -193 */
-    {0x083180AC, 0x80C60941},          /*  -172, 2097, 2369, -198 */
-    {0x080480A7, 0x80CA096D},          /*  -167, 2052, 2413, -202 */
-    {0x07D780A3, 0x80CE099A},          /*  -163, 2007, 2458, -206 */
-    {0x07AA809F, 0x80D209C7},          /*  -159, 1962, 2503, -210 */
-    {0x077D809A, 0x80D709F4},          /*  -154, 1917, 2548, -215 */
-    {0x07518096, 0x80DB0A20},          /*  -150, 1873, 2592, -219 */
-    {0x07248091, 0x80DF0A4C},          /*  -145, 1828, 2636, -223 */
-    {0x06F7808D, 0x80E20A78},          /*  -141, 1783, 2680, -226 */
-    {0x06CA8088, 0x80E60AA4},          /*  -136, 1738, 2724, -230 */
-    {0x069E8084, 0x80EA0AD0},          /*  -132, 1694, 2768, -234 */
-    {0x06738080, 0x80ED0AFA},          /*  -128, 1651, 2810, -237 */
-    {0x0647807C, 0x80F10B26},          /*  -124, 1607, 2854, -241 */
-    {0x061B8077, 0x80F40B50},          /*  -119, 1563, 2896, -244 */
-    {0x05F18074, 0x80F70B7A},          /*  -116, 1521, 2938, -247 */
-    {0x05C68070, 0x80FA0BA4},          /*  -112, 1478, 2980, -250 */
-    {0x059C806C, 0x80FE0BCE},          /*  -108, 1436, 3022, -254 */
-    {0x05728068, 0x81000BF6},          /*  -104, 1394, 3062, -256 */
-    {0x05478064, 0x81030C20},          /*  -100, 1351, 3104, -259 */
-    {0x051E8061, 0x81050C48},          /*   -97, 1310, 3144, -261 */
-    {0x04F4805D, 0x81070C70},          /*   -93, 1268, 3184, -263 */
-    {0x04CB8059, 0x81080C96},          /*   -89, 1227, 3222, -264 */
-    {0x04A38056, 0x810A0CBD},          /*   -86, 1187, 3261, -266 */
-    {0x047A8052, 0x810B0CE3},          /*   -82, 1146, 3299, -267 */
-    {0x0453804F, 0x810C0D08},          /*   -79, 1107, 3336, -268 */
-    {0x042B804B, 0x810C0D2C},          /*   -75, 1067, 3372, -268 */
-    {0x04048048, 0x810D0D51},          /*   -72, 1028, 3409, -269 */
-    {0x03DE8045, 0x810D0D74},          /*   -69,  990, 3444, -269 */
-    {0x03B88042, 0x810E0D98},          /*   -66,  952, 3480, -270 */
-    {0x0393803F, 0x810D0DB9},          /*   -63,  915, 3513, -269 */
-    {0x036E803C, 0x810C0DDA},          /*   -60,  878, 3546, -268 */
-    {0x03498039, 0x810B0DFB},          /*   -57,  841, 3579, -267 */
-    {0x03258036, 0x81090E1A},          /*   -54,  805, 3610, -265 */
-    {0x03018033, 0x81070E39},          /*   -51,  769, 3641, -263 */
-    {0x02DE8031, 0x81050E58},          /*   -49,  734, 3672, -261 */
-    {0x02BC802E, 0x81020E74},          /*   -46,  700, 3700, -258 */
-    {0x0299802B, 0x80FF0E91},          /*   -43,  665, 3729, -255 */
-    {0x02788029, 0x80FB0EAC},          /*   -41,  632, 3756, -251 */
-    {0x02578027, 0x80F70EC7},          /*   -39,  599, 3783, -247 */
-    {0x02378024, 0x80F30EE0},          /*   -36,  567, 3808, -243 */
-    {0x02178022, 0x80EE0EF9},          /*   -34,  535, 3833, -238 */
-    {0x01FA8021, 0x80EA0F11},          /*   -33,  506, 3857, -234 */
-    {0x01DC801F, 0x80E40F27},          /*   -31,  476, 3879, -228 */
-    {0x01BE801D, 0x80DE0F3D},          /*   -29,  446, 3901, -222 */
-    {0x01A1801B, 0x80D70F51},          /*   -27,  417, 3921, -215 */
-    {0x01848019, 0x80D00F65},          /*   -25,  388, 3941, -208 */
-    {0x01688017, 0x80C80F77},          /*   -23,  360, 3959, -200 */
-    {0x014D8015, 0x80C00F88},          /*   -21,  333, 3976, -192 */
-    {0x01328014, 0x80B70F99},          /*   -20,  306, 3993, -183 */
-    {0x01188012, 0x80AD0FA7},          /*   -18,  280, 4007, -173 */
-    {0x00FF8010, 0x80A40FB5},          /*   -16,  255, 4021, -164 */
-    {0x00E6800F, 0x80990FC2},          /*   -15,  230, 4034, -153 */
-    {0x00CE800D, 0x808E0FCD},          /*   -13,  206, 4045, -142 */
-    {0x00B6800C, 0x80820FD8},          /*   -12,  182, 4056, -130 */
-    {0x00A0800A, 0x80760FE0},          /*   -10,  160, 4064, -118 */
-    {0x00898009, 0x806A0FEA},          /*    -9,  137, 4074, -106 */
-    {0x00748007, 0x805C0FEF},          /*    -7,  116, 4079,  -92 */
-    {0x005F8006, 0x804E0FF5},          /*    -6,   95, 4085,  -78 */
-    {0x004B8005, 0x80400FFA},          /*    -5,   75, 4090,  -64 */
-    {0x00378003, 0x80310FFD},          /*    -3,   55, 4093,  -49 */
-    {0x00238002, 0x80211000},          /*    -2,   35, 4096,  -33 */
-    {0x00118001, 0x80111001},          /*    -1,   17, 4097,  -17 */
+    {0x10000000, 0x00000000},   /*     0, 4096,    0,    0 */
+    {0x10018011, 0x80010011},   /*   -17, 4097,   17,   -1 */
+    {0x10008021, 0x80020023},   /*   -33, 4096,   35,   -2 */
+    {0x0FFE8031, 0x80030036},   /*   -49, 4094,   54,   -3 */
+    {0x0FFB8040, 0x8005004A},   /*   -64, 4091,   74,   -5 */
+    {0x0FF6804E, 0x8006005E},   /*   -78, 4086,   94,   -6 */
+    {0x0FF0805C, 0x80070073},   /*   -92, 4080,  115,   -7 */
+    {0x0FEB806A, 0x80090088},   /*  -106, 4075,  136,   -9 */
+    {0x0FE18076, 0x800A009F},   /*  -118, 4065,  159,  -10 */
+    {0x0FD98082, 0x800C00B5},   /*  -130, 4057,  181,  -12 */
+    {0x0FCE808E, 0x800D00CD},   /*  -142, 4046,  205,  -13 */
+    {0x0FC38099, 0x800F00E5},   /*  -153, 4035,  229,  -15 */
+    {0x0FB680A4, 0x801000FE},   /*  -164, 4022,  254,  -16 */
+    {0x0FA880AD, 0x80120117},   /*  -173, 4008,  279,  -18 */
+    {0x0F9A80B7, 0x80140131},   /*  -183, 3994,  305,  -20 */
+    {0x0F8980C0, 0x8015014C},   /*  -192, 3977,  332,  -21 */
+    {0x0F7880C8, 0x80170167},   /*  -200, 3960,  359,  -23 */
+    {0x0F6680D0, 0x80190183},   /*  -208, 3942,  387,  -25 */
+    {0x0F5280D7, 0x801B01A0},   /*  -215, 3922,  416,  -27 */
+    {0x0F3E80DE, 0x801D01BD},   /*  -222, 3902,  445,  -29 */
+    {0x0F2880E4, 0x801F01DB},   /*  -228, 3880,  475,  -31 */
+    {0x0F1180EA, 0x802101FA},   /*  -234, 3857,  506,  -33 */
+    {0x0EF880EE, 0x80220218},   /*  -238, 3832,  536,  -34 */
+    {0x0EDF80F3, 0x80240238},   /*  -243, 3807,  568,  -36 */
+    {0x0EC680F7, 0x80270258},   /*  -247, 3782,  600,  -39 */
+    {0x0EAB80FB, 0x80290279},   /*  -251, 3755,  633,  -41 */
+    {0x0E9080FF, 0x802B029A},   /*  -255, 3728,  666,  -43 */
+    {0x0E748102, 0x802E02BC},   /*  -258, 3700,  700,  -46 */
+    {0x0E588105, 0x803102DE},   /*  -261, 3672,  734,  -49 */
+    {0x0E388107, 0x80330302},   /*  -263, 3640,  770,  -51 */
+    {0x0E1A8109, 0x80360325},   /*  -265, 3610,  805,  -54 */
+    {0x0DFB810B, 0x80390349},   /*  -267, 3579,  841,  -57 */
+    {0x0DDB810C, 0x803C036D},   /*  -268, 3547,  877,  -60 */
+    {0x0DBA810D, 0x803F0392},   /*  -269, 3514,  914,  -63 */
+    {0x0D98810E, 0x804203B8},   /*  -270, 3480,  952,  -66 */
+    {0x0D74810D, 0x804503DE},   /*  -269, 3444,  990,  -69 */
+    {0x0D50810D, 0x80480405},   /*  -269, 3408, 1029,  -72 */
+    {0x0D2C810C, 0x804B042B},   /*  -268, 3372, 1067,  -75 */
+    {0x0D08810C, 0x804F0453},   /*  -268, 3336, 1107,  -79 */
+    {0x0CE3810B, 0x8052047A},   /*  -267, 3299, 1146,  -82 */
+    {0x0CBD810A, 0x805604A3},   /*  -266, 3261, 1187,  -86 */
+    {0x0C968108, 0x805904CB},   /*  -264, 3222, 1227,  -89 */
+    {0x0C708107, 0x805D04F4},   /*  -263, 3184, 1268,  -93 */
+    {0x0C488105, 0x8061051E},   /*  -261, 3144, 1310,  -97 */
+    {0x0C208103, 0x80640547},   /*  -259, 3104, 1351, -100 */
+    {0x0BF78100, 0x80680571},   /*  -256, 3063, 1393, -104 */
+    {0x0BCF80FE, 0x806C059B},   /*  -254, 3023, 1435, -108 */
+    {0x0BA480FA, 0x807005C6},   /*  -250, 2980, 1478, -112 */
+    {0x0B7A80F7, 0x807405F1},   /*  -247, 2938, 1521, -116 */
+    {0x0B4F80F4, 0x8077061C},   /*  -244, 2895, 1564, -119 */
+    {0x0B2580F1, 0x807C0648},   /*  -241, 2853, 1608, -124 */
+    {0x0AFA80ED, 0x80800673},   /*  -237, 2810, 1651, -128 */
+    {0x0ACF80EA, 0x8084069F},   /*  -234, 2767, 1695, -132 */
+    {0x0AA380E6, 0x808806CB},   /*  -230, 2723, 1739, -136 */
+    {0x0A7880E2, 0x808D06F7},   /*  -226, 2680, 1783, -141 */
+    {0x0A4C80DF, 0x80910724},   /*  -223, 2636, 1828, -145 */
+    {0x0A2080DB, 0x80960751},   /*  -219, 2592, 1873, -150 */
+    {0x09F480D7, 0x809A077D},   /*  -215, 2548, 1917, -154 */
+    {0x09C780D2, 0x809F07AA},   /*  -210, 2503, 1962, -159 */
+    {0x099A80CE, 0x80A307D7},   /*  -206, 2458, 2007, -163 */
+    {0x096D80CA, 0x80A70804},   /*  -202, 2413, 2052, -167 */
+    {0x094180C6, 0x80AC0831},   /*  -198, 2369, 2097, -172 */
+    {0x091380C1, 0x80B0085E},   /*  -193, 2323, 2142, -176 */
+    {0x08E780BE, 0x80B5088C},   /*  -190, 2279, 2188, -181 */
+    {0x08B980B9, 0x80B908B9},   /*  -185, 2233, 2233, -185 */
+    {0x088C80B5, 0x80BE08E7},   /*  -181, 2188, 2279, -190 */
+    {0x085E80B0, 0x80C10913},   /*  -176, 2142, 2323, -193 */
+    {0x083180AC, 0x80C60941},   /*  -172, 2097, 2369, -198 */
+    {0x080480A7, 0x80CA096D},   /*  -167, 2052, 2413, -202 */
+    {0x07D780A3, 0x80CE099A},   /*  -163, 2007, 2458, -206 */
+    {0x07AA809F, 0x80D209C7},   /*  -159, 1962, 2503, -210 */
+    {0x077D809A, 0x80D709F4},   /*  -154, 1917, 2548, -215 */
+    {0x07518096, 0x80DB0A20},   /*  -150, 1873, 2592, -219 */
+    {0x07248091, 0x80DF0A4C},   /*  -145, 1828, 2636, -223 */
+    {0x06F7808D, 0x80E20A78},   /*  -141, 1783, 2680, -226 */
+    {0x06CA8088, 0x80E60AA4},   /*  -136, 1738, 2724, -230 */
+    {0x069E8084, 0x80EA0AD0},   /*  -132, 1694, 2768, -234 */
+    {0x06738080, 0x80ED0AFA},   /*  -128, 1651, 2810, -237 */
+    {0x0647807C, 0x80F10B26},   /*  -124, 1607, 2854, -241 */
+    {0x061B8077, 0x80F40B50},   /*  -119, 1563, 2896, -244 */
+    {0x05F18074, 0x80F70B7A},   /*  -116, 1521, 2938, -247 */
+    {0x05C68070, 0x80FA0BA4},   /*  -112, 1478, 2980, -250 */
+    {0x059C806C, 0x80FE0BCE},   /*  -108, 1436, 3022, -254 */
+    {0x05728068, 0x81000BF6},   /*  -104, 1394, 3062, -256 */
+    {0x05478064, 0x81030C20},   /*  -100, 1351, 3104, -259 */
+    {0x051E8061, 0x81050C48},   /*   -97, 1310, 3144, -261 */
+    {0x04F4805D, 0x81070C70},   /*   -93, 1268, 3184, -263 */
+    {0x04CB8059, 0x81080C96},   /*   -89, 1227, 3222, -264 */
+    {0x04A38056, 0x810A0CBD},   /*   -86, 1187, 3261, -266 */
+    {0x047A8052, 0x810B0CE3},   /*   -82, 1146, 3299, -267 */
+    {0x0453804F, 0x810C0D08},   /*   -79, 1107, 3336, -268 */
+    {0x042B804B, 0x810C0D2C},   /*   -75, 1067, 3372, -268 */
+    {0x04048048, 0x810D0D51},   /*   -72, 1028, 3409, -269 */
+    {0x03DE8045, 0x810D0D74},   /*   -69,  990, 3444, -269 */
+    {0x03B88042, 0x810E0D98},   /*   -66,  952, 3480, -270 */
+    {0x0393803F, 0x810D0DB9},   /*   -63,  915, 3513, -269 */
+    {0x036E803C, 0x810C0DDA},   /*   -60,  878, 3546, -268 */
+    {0x03498039, 0x810B0DFB},   /*   -57,  841, 3579, -267 */
+    {0x03258036, 0x81090E1A},   /*   -54,  805, 3610, -265 */
+    {0x03018033, 0x81070E39},   /*   -51,  769, 3641, -263 */
+    {0x02DE8031, 0x81050E58},   /*   -49,  734, 3672, -261 */
+    {0x02BC802E, 0x81020E74},   /*   -46,  700, 3700, -258 */
+    {0x0299802B, 0x80FF0E91},   /*   -43,  665, 3729, -255 */
+    {0x02788029, 0x80FB0EAC},   /*   -41,  632, 3756, -251 */
+    {0x02578027, 0x80F70EC7},   /*   -39,  599, 3783, -247 */
+    {0x02378024, 0x80F30EE0},   /*   -36,  567, 3808, -243 */
+    {0x02178022, 0x80EE0EF9},   /*   -34,  535, 3833, -238 */
+    {0x01FA8021, 0x80EA0F11},   /*   -33,  506, 3857, -234 */
+    {0x01DC801F, 0x80E40F27},   /*   -31,  476, 3879, -228 */
+    {0x01BE801D, 0x80DE0F3D},   /*   -29,  446, 3901, -222 */
+    {0x01A1801B, 0x80D70F51},   /*   -27,  417, 3921, -215 */
+    {0x01848019, 0x80D00F65},   /*   -25,  388, 3941, -208 */
+    {0x01688017, 0x80C80F77},   /*   -23,  360, 3959, -200 */
+    {0x014D8015, 0x80C00F88},   /*   -21,  333, 3976, -192 */
+    {0x01328014, 0x80B70F99},   /*   -20,  306, 3993, -183 */
+    {0x01188012, 0x80AD0FA7},   /*   -18,  280, 4007, -173 */
+    {0x00FF8010, 0x80A40FB5},   /*   -16,  255, 4021, -164 */
+    {0x00E6800F, 0x80990FC2},   /*   -15,  230, 4034, -153 */
+    {0x00CE800D, 0x808E0FCD},   /*   -13,  206, 4045, -142 */
+    {0x00B6800C, 0x80820FD8},   /*   -12,  182, 4056, -130 */
+    {0x00A0800A, 0x80760FE0},   /*   -10,  160, 4064, -118 */
+    {0x00898009, 0x806A0FEA},   /*    -9,  137, 4074, -106 */
+    {0x00748007, 0x805C0FEF},   /*    -7,  116, 4079,  -92 */
+    {0x005F8006, 0x804E0FF5},   /*    -6,   95, 4085,  -78 */
+    {0x004B8005, 0x80400FFA},   /*    -5,   75, 4090,  -64 */
+    {0x00378003, 0x80310FFD},   /*    -3,   55, 4093,  -49 */
+    {0x00238002, 0x80211000},   /*    -2,   35, 4096,  -33 */
+    {0x00118001, 0x80111001},   /*    -1,   17, 4097,  -17 */
+    {0x10000000, 0x00000000},   /*     0, 4096,    0,    0 */
+    {0x10018011, 0x80010011},   /*   -17, 4097,   17,   -1 */
+    {0x10008021, 0x80020023},   /*   -33, 4096,   35,   -2 */
+    {0x0FFE8031, 0x80030036},   /*   -49, 4094,   54,   -3 */
+    {0x0FFB8040, 0x8005004A},   /*   -64, 4091,   74,   -5 */
+    {0x0FF6804E, 0x8006005E},   /*   -78, 4086,   94,   -6 */
+    {0x0FF0805C, 0x80070073},   /*   -92, 4080,  115,   -7 */
+    {0x0FEB806A, 0x80090088},   /*  -106, 4075,  136,   -9 */
+    {0x0FE18076, 0x800A009F},   /*  -118, 4065,  159,  -10 */
+    {0x0FD98082, 0x800C00B5},   /*  -130, 4057,  181,  -12 */
+    {0x0FCE808E, 0x800D00CD},   /*  -142, 4046,  205,  -13 */
+    {0x0FC38099, 0x800F00E5},   /*  -153, 4035,  229,  -15 */
+    {0x0FB680A4, 0x801000FE},   /*  -164, 4022,  254,  -16 */
+    {0x0FA880AD, 0x80120117},   /*  -173, 4008,  279,  -18 */
+    {0x0F9A80B7, 0x80140131},   /*  -183, 3994,  305,  -20 */
+    {0x0F8980C0, 0x8015014C},   /*  -192, 3977,  332,  -21 */
+    {0x0F7880C8, 0x80170167},   /*  -200, 3960,  359,  -23 */
+    {0x0F6680D0, 0x80190183},   /*  -208, 3942,  387,  -25 */
+    {0x0F5280D7, 0x801B01A0},   /*  -215, 3922,  416,  -27 */
+    {0x0F3E80DE, 0x801D01BD},   /*  -222, 3902,  445,  -29 */
+    {0x0F2880E4, 0x801F01DB},   /*  -228, 3880,  475,  -31 */
+    {0x0F1180EA, 0x802101FA},   /*  -234, 3857,  506,  -33 */
+    {0x0EF880EE, 0x80220218},   /*  -238, 3832,  536,  -34 */
+    {0x0EDF80F3, 0x80240238},   /*  -243, 3807,  568,  -36 */
+    {0x0EC680F7, 0x80270258},   /*  -247, 3782,  600,  -39 */
+    {0x0EAB80FB, 0x80290279},   /*  -251, 3755,  633,  -41 */
+    {0x0E9080FF, 0x802B029A},   /*  -255, 3728,  666,  -43 */
+    {0x0E748102, 0x802E02BC},   /*  -258, 3700,  700,  -46 */
+    {0x0E588105, 0x803102DE},   /*  -261, 3672,  734,  -49 */
+    {0x0E388107, 0x80330302},   /*  -263, 3640,  770,  -51 */
+    {0x0E1A8109, 0x80360325},   /*  -265, 3610,  805,  -54 */
+    {0x0DFB810B, 0x80390349},   /*  -267, 3579,  841,  -57 */
+    {0x0DDB810C, 0x803C036D},   /*  -268, 3547,  877,  -60 */
+    {0x0DBA810D, 0x803F0392},   /*  -269, 3514,  914,  -63 */
+    {0x0D98810E, 0x804203B8},   /*  -270, 3480,  952,  -66 */
+    {0x0D74810D, 0x804503DE},   /*  -269, 3444,  990,  -69 */
+    {0x0D50810D, 0x80480405},   /*  -269, 3408, 1029,  -72 */
+    {0x0D2C810C, 0x804B042B},   /*  -268, 3372, 1067,  -75 */
+    {0x0D08810C, 0x804F0453},   /*  -268, 3336, 1107,  -79 */
+    {0x0CE3810B, 0x8052047A},   /*  -267, 3299, 1146,  -82 */
+    {0x0CBD810A, 0x805604A3},   /*  -266, 3261, 1187,  -86 */
+    {0x0C968108, 0x805904CB},   /*  -264, 3222, 1227,  -89 */
+    {0x0C708107, 0x805D04F4},   /*  -263, 3184, 1268,  -93 */
+    {0x0C488105, 0x8061051E},   /*  -261, 3144, 1310,  -97 */
+    {0x0C208103, 0x80640547},   /*  -259, 3104, 1351, -100 */
+    {0x0BF78100, 0x80680571},   /*  -256, 3063, 1393, -104 */
+    {0x0BCF80FE, 0x806C059B},   /*  -254, 3023, 1435, -108 */
+    {0x0BA480FA, 0x807005C6},   /*  -250, 2980, 1478, -112 */
+    {0x0B7A80F7, 0x807405F1},   /*  -247, 2938, 1521, -116 */
+    {0x0B4F80F4, 0x8077061C},   /*  -244, 2895, 1564, -119 */
+    {0x0B2580F1, 0x807C0648},   /*  -241, 2853, 1608, -124 */
+    {0x0AFA80ED, 0x80800673},   /*  -237, 2810, 1651, -128 */
+    {0x0ACF80EA, 0x8084069F},   /*  -234, 2767, 1695, -132 */
+    {0x0AA380E6, 0x808806CB},   /*  -230, 2723, 1739, -136 */
+    {0x0A7880E2, 0x808D06F7},   /*  -226, 2680, 1783, -141 */
+    {0x0A4C80DF, 0x80910724},   /*  -223, 2636, 1828, -145 */
+    {0x0A2080DB, 0x80960751},   /*  -219, 2592, 1873, -150 */
+    {0x09F480D7, 0x809A077D},   /*  -215, 2548, 1917, -154 */
+    {0x09C780D2, 0x809F07AA},   /*  -210, 2503, 1962, -159 */
+    {0x099A80CE, 0x80A307D7},   /*  -206, 2458, 2007, -163 */
+    {0x096D80CA, 0x80A70804},   /*  -202, 2413, 2052, -167 */
+    {0x094180C6, 0x80AC0831},   /*  -198, 2369, 2097, -172 */
+    {0x091380C1, 0x80B0085E},   /*  -193, 2323, 2142, -176 */
+    {0x08E780BE, 0x80B5088C},   /*  -190, 2279, 2188, -181 */
+    {0x08B980B9, 0x80B908B9},   /*  -185, 2233, 2233, -185 */
+    {0x088C80B5, 0x80BE08E7},   /*  -181, 2188, 2279, -190 */
+    {0x085E80B0, 0x80C10913},   /*  -176, 2142, 2323, -193 */
+    {0x083180AC, 0x80C60941},   /*  -172, 2097, 2369, -198 */
+    {0x080480A7, 0x80CA096D},   /*  -167, 2052, 2413, -202 */
+    {0x07D780A3, 0x80CE099A},   /*  -163, 2007, 2458, -206 */
+    {0x07AA809F, 0x80D209C7},   /*  -159, 1962, 2503, -210 */
+    {0x077D809A, 0x80D709F4},   /*  -154, 1917, 2548, -215 */
+    {0x07518096, 0x80DB0A20},   /*  -150, 1873, 2592, -219 */
+    {0x07248091, 0x80DF0A4C},   /*  -145, 1828, 2636, -223 */
+    {0x06F7808D, 0x80E20A78},   /*  -141, 1783, 2680, -226 */
+    {0x06CA8088, 0x80E60AA4},   /*  -136, 1738, 2724, -230 */
+    {0x069E8084, 0x80EA0AD0},   /*  -132, 1694, 2768, -234 */
+    {0x06738080, 0x80ED0AFA},   /*  -128, 1651, 2810, -237 */
+    {0x0647807C, 0x80F10B26},   /*  -124, 1607, 2854, -241 */
+    {0x061B8077, 0x80F40B50},   /*  -119, 1563, 2896, -244 */
+    {0x05F18074, 0x80F70B7A},   /*  -116, 1521, 2938, -247 */
+    {0x05C68070, 0x80FA0BA4},   /*  -112, 1478, 2980, -250 */
+    {0x059C806C, 0x80FE0BCE},   /*  -108, 1436, 3022, -254 */
+    {0x05728068, 0x81000BF6},   /*  -104, 1394, 3062, -256 */
+    {0x05478064, 0x81030C20},   /*  -100, 1351, 3104, -259 */
+    {0x051E8061, 0x81050C48},   /*   -97, 1310, 3144, -261 */
+    {0x04F4805D, 0x81070C70},   /*   -93, 1268, 3184, -263 */
+    {0x04CB8059, 0x81080C96},   /*   -89, 1227, 3222, -264 */
+    {0x04A38056, 0x810A0CBD},   /*   -86, 1187, 3261, -266 */
+    {0x047A8052, 0x810B0CE3},   /*   -82, 1146, 3299, -267 */
+    {0x0453804F, 0x810C0D08},   /*   -79, 1107, 3336, -268 */
+    {0x042B804B, 0x810C0D2C},   /*   -75, 1067, 3372, -268 */
+    {0x04048048, 0x810D0D51},   /*   -72, 1028, 3409, -269 */
+    {0x03DE8045, 0x810D0D74},   /*   -69,  990, 3444, -269 */
+    {0x03B88042, 0x810E0D98},   /*   -66,  952, 3480, -270 */
+    {0x0393803F, 0x810D0DB9},   /*   -63,  915, 3513, -269 */
+    {0x036E803C, 0x810C0DDA},   /*   -60,  878, 3546, -268 */
+    {0x03498039, 0x810B0DFB},   /*   -57,  841, 3579, -267 */
+    {0x03258036, 0x81090E1A},   /*   -54,  805, 3610, -265 */
+    {0x03018033, 0x81070E39},   /*   -51,  769, 3641, -263 */
+    {0x02DE8031, 0x81050E58},   /*   -49,  734, 3672, -261 */
+    {0x02BC802E, 0x81020E74},   /*   -46,  700, 3700, -258 */
+    {0x0299802B, 0x80FF0E91},   /*   -43,  665, 3729, -255 */
+    {0x02788029, 0x80FB0EAC},   /*   -41,  632, 3756, -251 */
+    {0x02578027, 0x80F70EC7},   /*   -39,  599, 3783, -247 */
+    {0x02378024, 0x80F30EE0},   /*   -36,  567, 3808, -243 */
+    {0x02178022, 0x80EE0EF9},   /*   -34,  535, 3833, -238 */
+    {0x01FA8021, 0x80EA0F11},   /*   -33,  506, 3857, -234 */
+    {0x01DC801F, 0x80E40F27},   /*   -31,  476, 3879, -228 */
+    {0x01BE801D, 0x80DE0F3D},   /*   -29,  446, 3901, -222 */
+    {0x01A1801B, 0x80D70F51},   /*   -27,  417, 3921, -215 */
+    {0x01848019, 0x80D00F65},   /*   -25,  388, 3941, -208 */
+    {0x01688017, 0x80C80F77},   /*   -23,  360, 3959, -200 */
+    {0x014D8015, 0x80C00F88},   /*   -21,  333, 3976, -192 */
+    {0x01328014, 0x80B70F99},   /*   -20,  306, 3993, -183 */
+    {0x01188012, 0x80AD0FA7},   /*   -18,  280, 4007, -173 */
+    {0x00FF8010, 0x80A40FB5},   /*   -16,  255, 4021, -164 */
+    {0x00E6800F, 0x80990FC2},   /*   -15,  230, 4034, -153 */
+    {0x00CE800D, 0x808E0FCD},   /*   -13,  206, 4045, -142 */
+    {0x00B6800C, 0x80820FD8},   /*   -12,  182, 4056, -130 */
+    {0x00A0800A, 0x80760FE0},   /*   -10,  160, 4064, -118 */
+    {0x00898009, 0x806A0FEA},   /*    -9,  137, 4074, -106 */
+    {0x00748007, 0x805C0FEF},   /*    -7,  116, 4079,  -92 */
+    {0x005F8006, 0x804E0FF5},   /*    -6,   95, 4085,  -78 */
+    {0x004B8005, 0x80400FFA},   /*    -5,   75, 4090,  -64 */
+    {0x00378003, 0x80310FFD},   /*    -3,   55, 4093,  -49 */
+    {0x00238002, 0x80211000},   /*    -2,   35, 4096,  -33 */
+    {0x00118001, 0x80111001},   /*    -1,   17, 4097,  -17 */
 };
diff --git a/src/cim/cim_gp.c b/src/cim/cim_gp.c
index 7c4bc5b..2085d4f 100644
--- a/src/cim/cim_gp.c
+++ b/src/cim/cim_gp.c
@@ -89,7 +89,7 @@ gp_set_limit_on_buffer_lead(unsigned long lead)
 
 void
 gp_set_command_buffer_base(unsigned long address, unsigned long start,
-    unsigned long stop)
+                           unsigned long stop)
 {
     Q_WORD msr_value;
 
@@ -262,7 +262,8 @@ gp_declare_blt(unsigned long flags)
         /* command buffer.                                               */
 
         GP3_WAIT_WRAP(temp);
-    } else {
+    }
+    else {
         gp3_cmd_header = GP3_BLT_HDR_TYPE;
 
         /* WAIT FOR AVAILABLE SPACE */
@@ -274,7 +275,7 @@ gp_declare_blt(unsigned long flags)
         while (1) {
             temp = READ_GP32(GP3_CMD_READ);
             if (((gp3_cmd_current >= temp)
-                    && ((gp3_cmd_current - temp) <= gp3_buffer_lead))
+                 && ((gp3_cmd_current - temp) <= gp3_buffer_lead))
                 || ((gp3_cmd_current < temp)
                     && ((gp3_cmd_current + (gp3_cmd_bottom - temp)) <=
                         gp3_buffer_lead))) {
@@ -330,7 +331,8 @@ gp_declare_vector(unsigned long flags)
         /* CHECK WRAP CONDITION */
 
         GP3_WAIT_WRAP(temp);
-    } else {
+    }
+    else {
         gp3_cmd_header = GP3_VEC_HDR_TYPE;
 
         /* WAIT FOR AVAILABLE SPACE */
@@ -344,7 +346,7 @@ gp_declare_vector(unsigned long flags)
         while (1) {
             temp = READ_GP32(GP3_CMD_READ);
             if (((gp3_cmd_current >= temp)
-                    && ((gp3_cmd_current - temp) <= gp3_buffer_lead))
+                 && ((gp3_cmd_current - temp) <= gp3_buffer_lead))
                 || ((gp3_cmd_current < temp)
                     && ((gp3_cmd_current + (gp3_cmd_bottom - temp)) <=
                         gp3_buffer_lead))) {
@@ -406,7 +408,7 @@ gp_set_raster_operation(unsigned char ROP)
     /* WRITE THE RASTER MODE REGISTER                                   */
     /* This register is in the same location in BLT and vector commands */
 
-    gp3_raster_mode = gp3_bpp | (unsigned long)ROP;
+    gp3_raster_mode = gp3_bpp | (unsigned long) ROP;
     WRITE_COMMAND32(GP3_BLT_RASTER_MODE, gp3_raster_mode);
 
     /* CHECK IF DESTINATION IS REQUIRED */
@@ -414,7 +416,8 @@ gp_set_raster_operation(unsigned char ROP)
     if ((ROP & 0x55) ^ ((ROP >> 1) & 0x55)) {
         gp3_blt_mode = GP3_BM_DST_REQ;
         gp3_vec_mode = GP3_VM_DST_REQ;
-    } else {
+    }
+    else {
         gp3_blt_mode = gp3_vec_mode = 0;
     }
 }
@@ -461,7 +464,7 @@ gp_set_raster_operation(unsigned char ROP)
 
 void
 gp_set_alpha_operation(int alpha_operation, int alpha_type, int channel,
-    int apply_alpha, unsigned char alpha)
+                       int apply_alpha, unsigned char alpha)
 {
     gp3_cmd_header |= GP3_BLT_HDR_RASTER_ENABLE;
 
@@ -470,25 +473,26 @@ gp_set_alpha_operation(int alpha_operation, int alpha_type, int channel,
     /* also implies that there is no mechanism to detect invalid */
     /* parameters.                                               */
 
-    gp3_raster_mode = gp3_bpp | (unsigned long)alpha |
-        ((unsigned long)apply_alpha << 22) |
-        ((unsigned long)alpha_operation << 20) |
-        ((unsigned long)alpha_type << 17) | ((unsigned long)channel << 16);
+    gp3_raster_mode = gp3_bpp | (unsigned long) alpha |
+        ((unsigned long) apply_alpha << 22) |
+        ((unsigned long) alpha_operation << 20) |
+        ((unsigned long) alpha_type << 17) | ((unsigned long) channel << 16);
 
     WRITE_COMMAND32(GP3_BLT_RASTER_MODE, gp3_raster_mode);
 
     /* CHECK IF DESTINATION IS REQUIRED */
 
     if ((alpha_operation == CIMGP_ALPHA_TIMES_A &&
-            channel == CIMGP_CHANNEL_A_SOURCE &&
-            alpha_type != CIMGP_CHANNEL_B_ALPHA &&
-            alpha_type != CIMGP_ALPHA_FROM_RGB_B) ||
+         channel == CIMGP_CHANNEL_A_SOURCE &&
+         alpha_type != CIMGP_CHANNEL_B_ALPHA &&
+         alpha_type != CIMGP_ALPHA_FROM_RGB_B) ||
         (alpha_operation == CIMGP_BETA_TIMES_B &&
-            channel == CIMGP_CHANNEL_A_DEST &&
-            alpha_type != CIMGP_CHANNEL_A_ALPHA &&
-            alpha_type != CIMGP_ALPHA_FROM_RGB_A)) {
+         channel == CIMGP_CHANNEL_A_DEST &&
+         alpha_type != CIMGP_CHANNEL_A_ALPHA &&
+         alpha_type != CIMGP_ALPHA_FROM_RGB_A)) {
         gp3_blt_mode = 0;
-    } else
+    }
+    else
         gp3_blt_mode = GP3_BM_DST_REQ;
 }
 
@@ -518,7 +522,8 @@ gp_set_solid_pattern(unsigned long color)
         gp3_cmd_header |= GP3_BLT_HDR_PAT_CLR0_ENABLE;
 
         WRITE_COMMAND32(GP3_BLT_PAT_COLOR_0, color);
-    } else {
+    }
+    else {
         gp3_cmd_header |= GP3_VEC_HDR_PAT_CLR0_ENABLE;
 
         WRITE_COMMAND32(GP3_VECTOR_PAT_COLOR_0, color);
@@ -534,7 +539,8 @@ gp_set_solid_pattern(unsigned long color)
 
 void
 gp_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, int transparent, int x, int y)
+                    unsigned long data0, unsigned long data1, int transparent,
+                    int x, int y)
 {
     /* CHANNEL 3 IS NOT NEEDED FOR MONOCHROME PATTERNS */
 
@@ -556,16 +562,17 @@ gp_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
     if (gp3_blt) {
         gp3_cmd_header |=
             (GP3_BLT_HDR_PAT_CLR0_ENABLE | GP3_BLT_HDR_PAT_CLR1_ENABLE |
-            GP3_BLT_HDR_PAT_DATA0_ENABLE | GP3_BLT_HDR_PAT_DATA1_ENABLE);
+             GP3_BLT_HDR_PAT_DATA0_ENABLE | GP3_BLT_HDR_PAT_DATA1_ENABLE);
 
         WRITE_COMMAND32(GP3_BLT_PAT_COLOR_0, bgcolor);
         WRITE_COMMAND32(GP3_BLT_PAT_COLOR_1, fgcolor);
         WRITE_COMMAND32(GP3_BLT_PAT_DATA_0, data0);
         WRITE_COMMAND32(GP3_BLT_PAT_DATA_1, data1);
-    } else {
+    }
+    else {
         gp3_cmd_header |=
             (GP3_VEC_HDR_PAT_CLR0_ENABLE | GP3_VEC_HDR_PAT_CLR1_ENABLE |
-            GP3_VEC_HDR_PAT_DATA0_ENABLE | GP3_VEC_HDR_PAT_DATA1_ENABLE);
+             GP3_VEC_HDR_PAT_DATA0_ENABLE | GP3_VEC_HDR_PAT_DATA1_ENABLE);
 
         WRITE_COMMAND32(GP3_VECTOR_PAT_COLOR_0, bgcolor);
         WRITE_COMMAND32(GP3_VECTOR_PAT_COLOR_1, fgcolor);
@@ -575,8 +582,8 @@ gp_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
 
     /* SAVE PATTERN ORIGIN */
 
-    gp3_pat_origin = ((unsigned long)y << 29) |
-        (((unsigned long)x & 7) << 26);
+    gp3_pat_origin = ((unsigned long) y << 29) |
+        (((unsigned long) x & 7) << 26);
 }
 
 /*---------------------------------------------------------------------------
@@ -592,8 +599,8 @@ gp_set_pattern_origin(int x, int y)
 {
     /* SAVE PATTERN ORIGIN */
 
-    gp3_pat_origin = ((unsigned long)y << 29) |
-        (((unsigned long)x & 7) << 26);
+    gp3_pat_origin = ((unsigned long) y << 29) |
+        (((unsigned long) x & 7) << 26);
 }
 
 /*---------------------------------------------------------------------------
@@ -620,9 +627,9 @@ gp_set_color_pattern(unsigned long *pattern, int format, int x, int y)
      * 4BPP patterns are not supported.
      */
 
-    gp3_pat_pix_shift = (unsigned long)((format >> 2) & 3);
-    gp3_pat_format = (((unsigned long)format & 0xF) << 24) |
-        (((unsigned long)format & 0x10) << 17) |
+    gp3_pat_pix_shift = (unsigned long) ((format >> 2) & 3);
+    gp3_pat_format = (((unsigned long) format & 0xF) << 24) |
+        (((unsigned long) format & 0x10) << 17) |
         GP3_CH3_COLOR_PAT_ENABLE | GP3_CH3_C3EN;
 
     size_dwords = (64 << gp3_pat_pix_shift) >> 2;
@@ -641,7 +648,8 @@ gp_set_color_pattern(unsigned long *pattern, int format, int x, int y)
         /* Same logic as BLT wrapping. */
 
         GP3_WAIT_WRAP(temp);
-    } else {
+    }
+    else {
         gp3_cmd_header = GP3_LUT_HDR_TYPE | GP3_LUT_HDR_DATA_ENABLE;
 
         /* WAIT FOR AVAILABLE SPACE */
@@ -671,8 +679,8 @@ gp_set_color_pattern(unsigned long *pattern, int format, int x, int y)
 
     /* SAVE PATTERN ORIGIN */
 
-    gp3_pat_origin = ((unsigned long)y << 29) |
-        (((unsigned long)x & 7) << 26);
+    gp3_pat_origin = ((unsigned long) y << 29) |
+        (((unsigned long) x & 7) << 26);
 }
 
 /*---------------------------------------------------------------------------
@@ -683,7 +691,7 @@ gp_set_color_pattern(unsigned long *pattern, int format, int x, int y)
 
 void
 gp_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-    int transparent)
+                   int transparent)
 {
     /* UPDATE RASTER MODE REGISTER IF TRANSPARENT */
 
@@ -784,7 +792,8 @@ gp_program_lut(unsigned long *colors, int full_lut)
         /* Same logic as BLT wrapping. */
 
         GP3_WAIT_WRAP(temp);
-    } else {
+    }
+    else {
         gp3_cmd_header = GP3_LUT_HDR_TYPE | GP3_LUT_HDR_DATA_ENABLE;
 
         /* WAIT FOR AVAILABLE SPACE */
@@ -865,7 +874,8 @@ gp_set_vector_pattern(unsigned long pattern, unsigned long color, int length)
         /* Same logic as BLT wrapping. */
 
         GP3_WAIT_WRAP(temp);
-    } else {
+    }
+    else {
         gp3_cmd_header = GP3_LUT_HDR_TYPE | GP3_LUT_HDR_DATA_ENABLE;
 
         /* WAIT FOR AVAILABLE SPACE */
@@ -953,9 +963,9 @@ gp_set_source_format(int format)
     /* of 3 being a special case for 4BPP data.  Clever, yes?  Even more    */
     /* clever, bit 4 indicates BGR ordering.                                */
 
-    gp3_src_pix_shift = (unsigned long)((format >> 2) & 3);
-    gp3_src_format = (((unsigned long)format & 0xF) << 24) |
-        (((unsigned long)format & 0x10) << 18);
+    gp3_src_pix_shift = (unsigned long) ((format >> 2) & 3);
+    gp3_src_format = (((unsigned long) format & 0xF) << 24) |
+        (((unsigned long) format & 0x10) << 18);
 }
 
 /*---------------------------------------------------------------------------
@@ -968,7 +978,7 @@ gp_set_source_format(int format)
 
 void
 gp_pattern_fill(unsigned long dstoffset, unsigned long width,
-    unsigned long height)
+                unsigned long height)
 {
     unsigned long base_register;
 
@@ -1006,12 +1016,13 @@ gp_pattern_fill(unsigned long dstoffset, unsigned long width,
         WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, gp3_pat_origin);
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET, dstoffset & 0x3FFFFF);
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, gp3_pat_format);
-    } else {
+    }
+    else {
         /* DISABLE CHANNEL 3 AND USE NORMAL PATTERN ORIGINS */
 
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, 0);
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET,
-            ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
+                        ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
     }
 
     /* START THE BLT */
@@ -1042,7 +1053,7 @@ gp_pattern_fill(unsigned long dstoffset, unsigned long width,
 
 void
 gp_screen_to_screen_blt(unsigned long dstoffset, unsigned long srcoffset,
-    unsigned long width, unsigned long height, int flags)
+                        unsigned long width, unsigned long height, int flags)
 {
     unsigned long base;
     unsigned long ch3_flags = 0;
@@ -1102,11 +1113,12 @@ gp_screen_to_screen_blt(unsigned long dstoffset, unsigned long srcoffset,
         WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, size);
         WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR,
-            GP3_CH3_C3EN | GP3_CH3_REPLACE_SOURCE |
-            gp3_ch3_bpp | gp3_src_stride | ch3_flags |
-            ((gp3_blt_flags & CIMGP_ENABLE_PREFETCH) << 17) |
-            ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
-    } else {
+                        GP3_CH3_C3EN | GP3_CH3_REPLACE_SOURCE |
+                        gp3_ch3_bpp | gp3_src_stride | ch3_flags |
+                        ((gp3_blt_flags & CIMGP_ENABLE_PREFETCH) << 17) |
+                        ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
+    }
+    else {
         /* CALCULATE BASE OFFSET REGISTER */
 
         base = ((gp3_fb_base << 24) + dstbase) |
@@ -1133,7 +1145,8 @@ gp_screen_to_screen_blt(unsigned long dstoffset, unsigned long srcoffset,
             WRITE_COMMAND32(GP3_BLT_DST_OFFSET, dstoffset);
             WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, gp3_pat_format | ch3_flags);
             WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, size);
-        } else {
+        }
+        else {
             WRITE_COMMAND32(GP3_BLT_DST_OFFSET, dstoffset | gp3_pat_origin);
             WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, 0);
         }
@@ -1151,7 +1164,6 @@ gp_screen_to_screen_blt(unsigned long dstoffset, unsigned long srcoffset,
     gp3_cmd_current = gp3_cmd_next;
 }
 
-
 /*---------------------------------------------------------------------------
  * gp_screen_to_screen_convert
  *
@@ -1162,7 +1174,8 @@ gp_screen_to_screen_blt(unsigned long dstoffset, unsigned long srcoffset,
 
 void
 gp_screen_to_screen_convert(unsigned long dstoffset, unsigned long srcoffset,
-    unsigned long width, unsigned long height, int nibble)
+                            unsigned long width, unsigned long height,
+                            int nibble)
 {
     unsigned long size = ((width << 16) | height);
     unsigned long ch3_offset = srcoffset & 0x3FFFFF;
@@ -1195,14 +1208,15 @@ gp_screen_to_screen_convert(unsigned long dstoffset, unsigned long srcoffset,
     /* WRITE ALL BLT REGISTERS */
 
     WRITE_COMMAND32(GP3_BLT_DST_OFFSET,
-        (dstoffset & 0x3FFFFF) | gp3_pat_origin);
+                    (dstoffset & 0x3FFFFF) | gp3_pat_origin);
     WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, size);
     WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, ch3_size);
     WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, ch3_offset);
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR,
-        GP3_CH3_C3EN | GP3_CH3_REPLACE_SOURCE | gp3_src_format |
-        ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20) |
-        ((gp3_blt_flags & CIMGP_ENABLE_PREFETCH) << 17) | gp3_src_stride);
+                    GP3_CH3_C3EN | GP3_CH3_REPLACE_SOURCE | gp3_src_format |
+                    ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20) |
+                    ((gp3_blt_flags & CIMGP_ENABLE_PREFETCH) << 17) |
+                    gp3_src_stride);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
 
     /* START THE BLT */
@@ -1223,8 +1237,8 @@ gp_screen_to_screen_convert(unsigned long dstoffset, unsigned long srcoffset,
 
 void
 gp_color_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
-    unsigned long width, unsigned long height, unsigned char *data,
-    long pitch)
+                              unsigned long width, unsigned long height,
+                              unsigned char *data, long pitch)
 {
     unsigned long indent, temp;
     unsigned long total_dwords, size_dwords;
@@ -1261,16 +1275,17 @@ gp_color_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET, (dstoffset & 0x3FFFFF));
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, gp3_pat_format);
         WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, size);
-    } else {
+    }
+    else {
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET,
-            ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
+                        ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, 0);
     }
 
     WRITE_COMMAND32(GP3_BLT_SRC_OFFSET, indent);
     WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, size);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET,
-        ((gp3_fb_base << 24) + (dstoffset & 0xFFC00000)));
+                    ((gp3_fb_base << 24) + (dstoffset & 0xFFC00000)));
     WRITE_COMMAND32(GP3_BLT_MODE, gp3_blt_mode | GP3_BM_SRC_HOST);
 
     /* START THE BLT */
@@ -1304,12 +1319,13 @@ gp_color_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
             GP3_WAIT_WRAP(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                GP3_DATA_LOAD_HDR_ENABLE);
-        } else {
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
+                            GP3_DATA_LOAD_HDR_ENABLE);
+        }
+        else {
             GP3_WAIT_PRIMITIVE(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
         }
 
         /* WRITE DWORD COUNT */
@@ -1321,7 +1337,7 @@ gp_color_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
             WRITE_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                  srcoffset + (dword_count << 2), byte_count);
 
             srcoffset += pitch;
             cim_cmd_ptr += total_dwords << 2;
@@ -1329,7 +1345,8 @@ gp_color_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
         WRITE_GP32(GP3_CMD_WRITE, gp3_cmd_next);
         gp3_cmd_current = gp3_cmd_next;
-    } else {
+    }
+    else {
         /*
          * Each line will be created as a separate command buffer entry to
          * allow line-by-line wrapping and to allow simultaneous rendering
@@ -1355,13 +1372,15 @@ gp_color_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
                 GP3_WAIT_WRAP(temp);
                 WRITE_COMMAND32(0, GP3_DATA_LOAD_HDR_TYPE |
-                    GP3_DATA_LOAD_HDR_WRAP | GP3_DATA_LOAD_HDR_ENABLE);
-            } else {
+                                GP3_DATA_LOAD_HDR_WRAP |
+                                GP3_DATA_LOAD_HDR_ENABLE);
+            }
+            else {
                 /* WAIT FOR AVAILABLE SPACE */
 
                 GP3_WAIT_PRIMITIVE(temp);
                 WRITE_COMMAND32(0, GP3_DATA_LOAD_HDR_TYPE |
-                    GP3_DATA_LOAD_HDR_ENABLE);
+                                GP3_DATA_LOAD_HDR_ENABLE);
             }
 
             /* WRITE DWORD COUNT */
@@ -1372,7 +1391,7 @@ gp_color_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
             WRITE_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                  srcoffset + (dword_count << 2), byte_count);
 
             /* UPDATE POINTERS */
 
@@ -1393,8 +1412,8 @@ gp_color_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
 void
 gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
-    unsigned long width, unsigned long height,
-    unsigned char *data, long pitch)
+                     unsigned long width, unsigned long height,
+                     unsigned char *data, long pitch)
 {
     unsigned long indent, temp;
     unsigned long total_dwords, size_dwords;
@@ -1427,7 +1446,8 @@ gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
         ch3_offset = 0;
         temp = width * 3;
         ch3_size = (((temp + 3) >> 2) << 16) | height;
-    } else {
+    }
+    else {
         ch3_size = size;
 
         if (gp3_src_pix_shift == 3) {
@@ -1439,7 +1459,8 @@ gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
             ch3_offset = indent | ((srcx & 1) << 25);
 
             temp = ((width + (srcx & 1) + 1) >> 1) + indent;
-        } else {
+        }
+        else {
             indent = (srcx << gp3_src_pix_shift);
             srcoffset = (indent & ~3L);
             indent &= 3;
@@ -1467,14 +1488,15 @@ gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
         GP3_BLT_HDR_BASE_OFFSET_ENABLE | GP3_BLT_HDR_BLT_MODE_ENABLE;
 
     WRITE_COMMAND32(GP3_BLT_DST_OFFSET,
-        (dstoffset & 0x3FFFFF) | gp3_pat_origin);
+                    (dstoffset & 0x3FFFFF) | gp3_pat_origin);
     WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, ch3_offset);
     WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, size);
     WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, ch3_size);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, GP3_CH3_C3EN |
-        GP3_CH3_REPLACE_SOURCE | GP3_CH3_HST_SRC_ENABLE |
-        gp3_src_format | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
+                    GP3_CH3_REPLACE_SOURCE | GP3_CH3_HST_SRC_ENABLE |
+                    gp3_src_format | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT)
+                                      << 20));
     WRITE_COMMAND32(GP3_BLT_MODE, gp3_blt_mode);
 
     /* START THE BLT */
@@ -1498,24 +1520,24 @@ gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
             GP3_WAIT_WRAP(temp);
             WRITE_COMMAND32(0, GP3_DATA_LOAD_HDR_TYPE |
-                GP3_DATA_LOAD_HDR_WRAP | GP3_DATA_LOAD_HDR_ENABLE);
-        } else {
+                            GP3_DATA_LOAD_HDR_WRAP | GP3_DATA_LOAD_HDR_ENABLE);
+        }
+        else {
             GP3_WAIT_PRIMITIVE(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
         }
 
         /* WRITE DWORD COUNT */
 
-        WRITE_COMMAND32(4, GP3_CH3_HOST_SOURCE_TYPE |
-            (total_dwords * height));
+        WRITE_COMMAND32(4, GP3_CH3_HOST_SOURCE_TYPE | (total_dwords * height));
 
         while (height--) {
             /* WRITE DATA */
 
             WRITE_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                  srcoffset + (dword_count << 2), byte_count);
 
             srcoffset += pitch;
             cim_cmd_ptr += total_dwords << 2;
@@ -1523,7 +1545,8 @@ gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
         WRITE_GP32(GP3_CMD_WRITE, gp3_cmd_next);
         gp3_cmd_current = gp3_cmd_next;
-    } else {
+    }
+    else {
         /* WRITE DATA LINE BY LINE
          * Each line will be created as a separate command buffer entry to
          * allow line-by-line wrapping and to allow simultaneous rendering
@@ -1549,13 +1572,15 @@ gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
                 GP3_WAIT_WRAP(temp);
                 WRITE_COMMAND32(0, GP3_DATA_LOAD_HDR_TYPE |
-                    GP3_DATA_LOAD_HDR_WRAP | GP3_DATA_LOAD_HDR_ENABLE);
-            } else {
+                                GP3_DATA_LOAD_HDR_WRAP |
+                                GP3_DATA_LOAD_HDR_ENABLE);
+            }
+            else {
                 /* WAIT FOR AVAILABLE SPACE */
 
                 GP3_WAIT_PRIMITIVE(temp);
                 WRITE_COMMAND32(0, GP3_DATA_LOAD_HDR_TYPE |
-                    GP3_DATA_LOAD_HDR_ENABLE);
+                                GP3_DATA_LOAD_HDR_ENABLE);
             }
 
             /* WRITE DWORD COUNT */
@@ -1566,7 +1591,7 @@ gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
             WRITE_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                  srcoffset + (dword_count << 2), byte_count);
 
             /* UPDATE POINTERS */
 
@@ -1589,8 +1614,8 @@ gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
 void
 gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
-    unsigned long width, unsigned long height,
-    unsigned char *data, long pitch)
+                      unsigned long width, unsigned long height,
+                      unsigned char *data, long pitch)
 {
     unsigned long indent, temp;
     unsigned long total_dwords, size_dwords;
@@ -1622,7 +1647,8 @@ gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
         ch3_offset = 0;
         temp = width * 3;
         ch3_size = (((temp + 3) >> 2) << 16) | height;
-    } else {
+    }
+    else {
         ch3_size = size;
 
         if (gp3_src_pix_shift == 3) {
@@ -1634,7 +1660,8 @@ gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
             ch3_offset = indent | ((srcx & 1) << 25);
 
             temp = ((width + (srcx & 1) + 1) >> 1) + indent;
-        } else {
+        }
+        else {
             indent = (srcx << gp3_src_pix_shift);
             srcoffset = (indent & ~3L);
             indent &= 3;
@@ -1662,14 +1689,15 @@ gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
         GP3_BLT_HDR_BASE_OFFSET_ENABLE | GP3_BLT_HDR_BLT_MODE_ENABLE;
 
     WRITE_COMMAND32(GP3_BLT_DST_OFFSET,
-        (dstoffset & 0x3FFFFF) | gp3_pat_origin);
+                    (dstoffset & 0x3FFFFF) | gp3_pat_origin);
     WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, ch3_offset);
     WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, size);
     WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, ch3_size);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, GP3_CH3_C3EN |
-        GP3_CH3_REPLACE_SOURCE | GP3_CH3_HST_SRC_ENABLE |
-        gp3_src_format | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
+                    GP3_CH3_REPLACE_SOURCE | GP3_CH3_HST_SRC_ENABLE |
+                    gp3_src_format | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT)
+                                      << 20));
     WRITE_COMMAND32(GP3_BLT_MODE, gp3_blt_mode);
 
     /* START THE BLT */
@@ -1693,25 +1721,26 @@ gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
             GP3_WAIT_WRAP(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                GP3_DATA_LOAD_HDR_ENABLE);
-        } else {
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
+                            GP3_DATA_LOAD_HDR_ENABLE);
+        }
+        else {
             GP3_WAIT_PRIMITIVE(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
         }
 
         /* WRITE DWORD COUNT */
 
-        WRITE_COMMAND32(4,
-            GP3_CH3_HOST_SOURCE_TYPE | (total_dwords * height));
+        WRITE_COMMAND32(4, GP3_CH3_HOST_SOURCE_TYPE | (total_dwords * height));
 
         while (height--) {
             /* WRITE DATA */
 
             WRITE_CUSTOM_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_CUSTOM_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                         srcoffset + (dword_count << 2),
+                                         byte_count);
 
             srcoffset += pitch;
             cim_cmd_ptr += total_dwords << 2;
@@ -1719,7 +1748,8 @@ gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
         WRITE_GP32(GP3_CMD_WRITE, gp3_cmd_next);
         gp3_cmd_current = gp3_cmd_next;
-    } else {
+    }
+    else {
         /* WRITE DATA LINE BY LINE
          * Each line will be created as a separate command buffer entry to
          * allow line-by-line wrapping and to allow simultaneous rendering
@@ -1745,14 +1775,16 @@ gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
                 GP3_WAIT_WRAP(temp);
                 WRITE_COMMAND32(0,
-                    GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                    GP3_DATA_LOAD_HDR_ENABLE);
-            } else {
+                                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP
+                                | GP3_DATA_LOAD_HDR_ENABLE);
+            }
+            else {
                 /* WAIT FOR AVAILABLE SPACE */
 
                 GP3_WAIT_PRIMITIVE(temp);
                 WRITE_COMMAND32(0,
-                    GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                                GP3_DATA_LOAD_HDR_TYPE |
+                                GP3_DATA_LOAD_HDR_ENABLE);
             }
 
             /* WRITE DWORD COUNT */
@@ -1763,7 +1795,8 @@ gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
             WRITE_CUSTOM_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_CUSTOM_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                         srcoffset + (dword_count << 2),
+                                         byte_count);
 
             /* UPDATE POINTERS */
 
@@ -1786,7 +1819,7 @@ gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
 
 void
 gp_rotate_blt(unsigned long dstoffset, unsigned long srcoffset,
-    unsigned long width, unsigned long height, int degrees)
+              unsigned long width, unsigned long height, int degrees)
 {
     unsigned long sizein, sizeout;
     unsigned long ch3_flags;
@@ -1852,8 +1885,9 @@ gp_rotate_blt(unsigned long dstoffset, unsigned long srcoffset,
     WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, sizein);
     WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, srcoffset);
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, ch3_flags | gp3_src_format |
-        ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20) |
-        ((gp3_blt_flags & CIMGP_ENABLE_PREFETCH) << 17) | gp3_src_stride);
+                    ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20) |
+                    ((gp3_blt_flags & CIMGP_ENABLE_PREFETCH) << 17) |
+                    gp3_src_stride);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
 
     /* START THE BLT */
@@ -1878,8 +1912,8 @@ gp_rotate_blt(unsigned long dstoffset, unsigned long srcoffset,
 
 void
 gp_mono_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
-    unsigned long width, unsigned long height,
-    unsigned char *data, long stride)
+                             unsigned long width, unsigned long height,
+                             unsigned char *data, long stride)
 {
     unsigned long indent, temp;
     unsigned long total_dwords, size_dwords;
@@ -1918,24 +1952,26 @@ gp_mono_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET, (dstoffset & 0x3FFFFF));
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, gp3_pat_format);
         WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, size);
-    } else {
+    }
+    else {
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET,
-            ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
+                        ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, 0);
     }
     if (gp3_blt_flags & CIMGP_BLTFLAGS_INVERTMONO) {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_raster_mode | GP3_RM_SOURCE_INVERT);
-    } else {
+                        gp3_raster_mode | GP3_RM_SOURCE_INVERT);
+    }
+    else {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_raster_mode & ~GP3_RM_SOURCE_INVERT);
+                        gp3_raster_mode & ~GP3_RM_SOURCE_INVERT);
     }
     WRITE_COMMAND32(GP3_BLT_SRC_OFFSET, src_value);
     WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, size);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET,
-        ((gp3_fb_base << 24) + (dstoffset & 0xFFC00000)));
+                    ((gp3_fb_base << 24) + (dstoffset & 0xFFC00000)));
     WRITE_COMMAND32(GP3_BLT_MODE,
-        gp3_blt_mode | GP3_BM_SRC_HOST | GP3_BM_SRC_MONO);
+                    gp3_blt_mode | GP3_BM_SRC_HOST | GP3_BM_SRC_MONO);
 
     /* START THE BLT */
 
@@ -1971,12 +2007,13 @@ gp_mono_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
             GP3_WAIT_WRAP(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                GP3_DATA_LOAD_HDR_ENABLE);
-        } else {
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
+                            GP3_DATA_LOAD_HDR_ENABLE);
+        }
+        else {
             GP3_WAIT_PRIMITIVE(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
         }
 
         /* WRITE DWORD COUNT */
@@ -1988,7 +2025,7 @@ gp_mono_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
             WRITE_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                  srcoffset + (dword_count << 2), byte_count);
 
             srcoffset += stride;
             cim_cmd_ptr += total_dwords << 2;
@@ -1996,7 +2033,8 @@ gp_mono_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
         WRITE_GP32(GP3_CMD_WRITE, gp3_cmd_next);
         gp3_cmd_current = gp3_cmd_next;
-    } else {
+    }
+    else {
         /* WRITE DATA LINE BY LINE
          * Each line will be created as a separate command buffer entry to
          * allow line-by-line wrapping and to allow simultaneous rendering
@@ -2022,14 +2060,16 @@ gp_mono_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
                 GP3_WAIT_WRAP(temp);
                 WRITE_COMMAND32(0,
-                    GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                    GP3_DATA_LOAD_HDR_ENABLE);
-            } else {
+                                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP
+                                | GP3_DATA_LOAD_HDR_ENABLE);
+            }
+            else {
                 /* WAIT FOR AVAILABLE SPACE */
 
                 GP3_WAIT_PRIMITIVE(temp);
                 WRITE_COMMAND32(0,
-                    GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                                GP3_DATA_LOAD_HDR_TYPE |
+                                GP3_DATA_LOAD_HDR_ENABLE);
             }
 
             /* WRITE DWORD COUNT */
@@ -2040,7 +2080,7 @@ gp_mono_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
             WRITE_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                  srcoffset + (dword_count << 2), byte_count);
 
             /* UPDATE POINTERS */
 
@@ -2060,7 +2100,7 @@ gp_mono_bitmap_to_screen_blt(unsigned long dstoffset, unsigned long srcx,
 
 void
 gp_text_blt(unsigned long dstoffset, unsigned long width,
-    unsigned long height, unsigned char *data)
+            unsigned long height, unsigned char *data)
 {
     unsigned long temp, dwords_total;
     unsigned long dword_count, byte_count;
@@ -2087,25 +2127,27 @@ gp_text_blt(unsigned long dstoffset, unsigned long width,
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET, (dstoffset & 0x3FFFFF));
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, gp3_pat_format);
         WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, size);
-    } else {
+    }
+    else {
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET,
-            ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
+                        ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, 0);
     }
     if (gp3_blt_flags & CIMGP_BLTFLAGS_INVERTMONO) {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_raster_mode | GP3_RM_SOURCE_INVERT);
-    } else {
+                        gp3_raster_mode | GP3_RM_SOURCE_INVERT);
+    }
+    else {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_raster_mode & ~GP3_RM_SOURCE_INVERT);
+                        gp3_raster_mode & ~GP3_RM_SOURCE_INVERT);
     }
 
     WRITE_COMMAND32(GP3_BLT_SRC_OFFSET, 0);
     WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, size);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET,
-        ((gp3_fb_base << 24) + (dstoffset & 0xFFC00000)));
+                    ((gp3_fb_base << 24) + (dstoffset & 0xFFC00000)));
     WRITE_COMMAND32(GP3_BLT_MODE,
-        gp3_blt_mode | GP3_BM_SRC_HOST | GP3_BM_SRC_BP_MONO);
+                    gp3_blt_mode | GP3_BM_SRC_HOST | GP3_BM_SRC_BP_MONO);
 
     /* START THE BLT */
 
@@ -2129,7 +2171,8 @@ gp_text_blt(unsigned long dstoffset, unsigned long width,
             byte_count = 0;
             dwords_total = 2048;
             size -= 8192;
-        } else {
+        }
+        else {
             dword_count = (size >> 2);
             byte_count = (size & 3);
             dwords_total = (size + 3) >> 2;
@@ -2146,14 +2189,15 @@ gp_text_blt(unsigned long dstoffset, unsigned long width,
 
             GP3_WAIT_WRAP(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                GP3_DATA_LOAD_HDR_ENABLE);
-        } else {
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
+                            GP3_DATA_LOAD_HDR_ENABLE);
+        }
+        else {
             /* WAIT FOR AVAILABLE SPACE */
 
             GP3_WAIT_PRIMITIVE(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
         }
 
         /* WRITE DWORD COUNT */
@@ -2164,7 +2208,7 @@ gp_text_blt(unsigned long dstoffset, unsigned long width,
 
         WRITE_COMMAND_STRING32(8, data, srcoffset, dword_count);
         WRITE_COMMAND_STRING8(8 + (dword_count << 2), data,
-            srcoffset + (dword_count << 2), byte_count);
+                              srcoffset + (dword_count << 2), byte_count);
 
         WRITE_GP32(GP3_CMD_WRITE, gp3_cmd_next);
         gp3_cmd_current = gp3_cmd_next;
@@ -2190,8 +2234,8 @@ gp_text_blt(unsigned long dstoffset, unsigned long width,
 
 void
 gp_mono_expand_blt(unsigned long dstoffset, unsigned long srcoffset,
-    unsigned long srcx, unsigned long width,
-    unsigned long height, int byte_packed)
+                   unsigned long srcx, unsigned long width,
+                   unsigned long height, int byte_packed)
 {
     unsigned long base;
     unsigned long blt_mode;
@@ -2234,22 +2278,23 @@ gp_mono_expand_blt(unsigned long dstoffset, unsigned long srcoffset,
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET, (dstoffset & 0x3FFFFF));
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, gp3_pat_format);
         WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, size);
-    } else {
+    }
+    else {
         WRITE_COMMAND32(GP3_BLT_DST_OFFSET,
-            ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
+                        ((dstoffset & 0x3FFFFF) | gp3_pat_origin));
         WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, 0);
     }
     if (gp3_blt_flags & CIMGP_BLTFLAGS_INVERTMONO) {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_raster_mode | GP3_RM_SOURCE_INVERT);
-    } else {
+                        gp3_raster_mode | GP3_RM_SOURCE_INVERT);
+    }
+    else {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_raster_mode & ~GP3_RM_SOURCE_INVERT);
+                        gp3_raster_mode & ~GP3_RM_SOURCE_INVERT);
     }
 
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
-    WRITE_COMMAND32(GP3_BLT_SRC_OFFSET,
-        (srcoffset & 0x3FFFFF) | (srcx << 26));
+    WRITE_COMMAND32(GP3_BLT_SRC_OFFSET, (srcoffset & 0x3FFFFF) | (srcx << 26));
     WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, size);
 
     /* WORKAROUND FOR SIBZ #3744
@@ -2271,8 +2316,7 @@ gp_mono_expand_blt(unsigned long dstoffset, unsigned long srcoffset,
         size1 = ((8 - srcx) << 16) | 1;
         size2 = ((width + srcx - 8) << 16) | 1;
         org1 = gp3_pat_origin;
-        org2 = (org1 & 0xE0000000) |
-            ((org1 + ((8 - srcx) << 26)) & 0x1C000000);
+        org2 = (org1 & 0xE0000000) | ((org1 + ((8 - srcx) << 26)) & 0x1C000000);
         dstoff1 = dstoffset & 0x3FFFFF;
         dstoff2 = (dstoff1 + 8 - srcx) << gp3_pix_shift;
 
@@ -2282,7 +2326,7 @@ gp_mono_expand_blt(unsigned long dstoffset, unsigned long srcoffset,
             WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, size1);
             WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, size1);
             WRITE_COMMAND32(GP3_BLT_SRC_OFFSET,
-                (srcoffset & 0x3FFFFF) | (srcx << 26));
+                            (srcoffset & 0x3FFFFF) | (srcx << 26));
             WRITE_COMMAND32(GP3_BLT_DST_OFFSET, dstoff1 | org1);
             WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, org1);
             WRITE_COMMAND32(GP3_BLT_CMD_HEADER, gp3_cmd_header);
@@ -2328,12 +2372,10 @@ gp_mono_expand_blt(unsigned long dstoffset, unsigned long srcoffset,
                     GP3_BLT_HDR_WIDHI_ENABLE |
                     GP3_BLT_HDR_BLT_MODE_ENABLE |
                     GP3_BLT_HDR_CH3_OFF_ENABLE | GP3_BLT_HDR_CH3_WIDHI_ENABLE;
-                WRITE_COMMAND32(GP3_BLT_WID_HEIGHT,
-                    (width << 16) | tempheight);
-                WRITE_COMMAND32(GP3_BLT_CH3_WIDHI,
-                    (width << 16) | tempheight);
+                WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, (width << 16) | tempheight);
+                WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, (width << 16) | tempheight);
                 WRITE_COMMAND32(GP3_BLT_SRC_OFFSET,
-                    (srcoffset & 0x3FFFFF) | (srcx << 26));
+                                (srcoffset & 0x3FFFFF) | (srcx << 26));
                 WRITE_COMMAND32(GP3_BLT_DST_OFFSET, dstoff1 | org1);
                 WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, org1);
                 WRITE_COMMAND32(GP3_BLT_CMD_HEADER, gp3_cmd_header);
@@ -2393,8 +2435,8 @@ gp_mono_expand_blt(unsigned long dstoffset, unsigned long srcoffset,
 
 void
 gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
-    unsigned long width, unsigned long height,
-    unsigned char *data, long stride, int fourbpp)
+                    unsigned long width, unsigned long height,
+                    unsigned char *data, long stride, int fourbpp)
 {
     unsigned long indent, temp;
     unsigned long total_dwords, size_dwords;
@@ -2430,7 +2472,8 @@ gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
         ch3_offset = indent | ((srcx & 1) << 25);
 
         temp = ((width + (srcx & 1) + 1) >> 1) + indent;
-    } else {
+    }
+    else {
         depth_flag = GP3_CH3_SRC_8BPP_ALPHA;
         indent = srcx;
         srcoffset = (indent & ~3L);
@@ -2452,14 +2495,17 @@ gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
 
     if (gp3_bpp == GP3_RM_BPPFMT_565) {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_bpp |
-            GP3_RM_ALPHA_TO_RGB |
-            GP3_RM_ALPHA_A_PLUS_BETA_B | GP3_RM_SELECT_ALPHA_CHAN_3);
-    } else {
+                        gp3_bpp |
+                        GP3_RM_ALPHA_TO_RGB |
+                        GP3_RM_ALPHA_A_PLUS_BETA_B |
+                        GP3_RM_SELECT_ALPHA_CHAN_3);
+    }
+    else {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_bpp |
-            GP3_RM_ALPHA_ALL |
-            GP3_RM_ALPHA_A_PLUS_BETA_B | GP3_RM_SELECT_ALPHA_CHAN_3);
+                        gp3_bpp |
+                        GP3_RM_ALPHA_ALL |
+                        GP3_RM_ALPHA_A_PLUS_BETA_B |
+                        GP3_RM_SELECT_ALPHA_CHAN_3);
     }
 
     /* WRITE ALL REMAINING REGISTERS */
@@ -2470,8 +2516,9 @@ gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
     WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, size);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, GP3_CH3_C3EN |
-        GP3_CH3_HST_SRC_ENABLE |
-        depth_flag | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
+                    GP3_CH3_HST_SRC_ENABLE |
+                    depth_flag | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) <<
+                                  20));
     WRITE_COMMAND32(GP3_BLT_MODE, gp3_blt_mode | GP3_BM_DST_REQ);
 
     /* START THE BLT */
@@ -2500,25 +2547,25 @@ gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
 
             GP3_WAIT_WRAP(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                GP3_DATA_LOAD_HDR_ENABLE);
-        } else {
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
+                            GP3_DATA_LOAD_HDR_ENABLE);
+        }
+        else {
             GP3_WAIT_PRIMITIVE(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
         }
 
         /* WRITE DWORD COUNT */
 
-        WRITE_COMMAND32(4,
-            GP3_CH3_HOST_SOURCE_TYPE | (total_dwords * height));
+        WRITE_COMMAND32(4, GP3_CH3_HOST_SOURCE_TYPE | (total_dwords * height));
 
         while (height--) {
             /* WRITE DATA */
 
             WRITE_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                  srcoffset + (dword_count << 2), byte_count);
 
             srcoffset += stride;
             cim_cmd_ptr += total_dwords << 2;
@@ -2526,7 +2573,8 @@ gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
 
         WRITE_GP32(GP3_CMD_WRITE, gp3_cmd_next);
         gp3_cmd_current = gp3_cmd_next;
-    } else {
+    }
+    else {
         while (height--) {
             /* UPDATE THE COMMAND POINTER
              * The WRITE_COMMANDXX macros use a pointer to the current buffer
@@ -2546,14 +2594,16 @@ gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
 
                 GP3_WAIT_WRAP(temp);
                 WRITE_COMMAND32(0,
-                    GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                    GP3_DATA_LOAD_HDR_ENABLE);
-            } else {
+                                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP
+                                | GP3_DATA_LOAD_HDR_ENABLE);
+            }
+            else {
                 /* WAIT FOR AVAILABLE SPACE */
 
                 GP3_WAIT_PRIMITIVE(temp);
                 WRITE_COMMAND32(0,
-                    GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                                GP3_DATA_LOAD_HDR_TYPE |
+                                GP3_DATA_LOAD_HDR_ENABLE);
             }
 
             /* WRITE DWORD COUNT */
@@ -2564,7 +2614,7 @@ gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
 
             WRITE_COMMAND_STRING32(8, data, srcoffset, dword_count);
             WRITE_COMMAND_STRING8(8 + (dword_count << 2), data,
-                srcoffset + (dword_count << 2), byte_count);
+                                  srcoffset + (dword_count << 2), byte_count);
 
             /* UPDATE POINTERS */
 
@@ -2584,9 +2634,9 @@ gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
 
 void
 gp_masked_blt(unsigned long dstoffset, unsigned long width,
-    unsigned long height, unsigned long mono_srcx,
-    unsigned long color_srcx, unsigned char *mono_mask,
-    unsigned char *color_data, long mono_pitch, long color_pitch)
+              unsigned long height, unsigned long mono_srcx,
+              unsigned long color_srcx, unsigned char *mono_mask,
+              unsigned char *color_data, long mono_pitch, long color_pitch)
 {
     unsigned long indent, temp;
     unsigned long total_dwords, size_dwords;
@@ -2627,9 +2677,9 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
     WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, 0);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, GP3_CH3_C3EN |
-        GP3_CH3_REPLACE_SOURCE | GP3_CH3_HST_SRC_ENABLE |
-        GP3_CH3_SRC_8_8_8_8 |
-        ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
+                    GP3_CH3_REPLACE_SOURCE | GP3_CH3_HST_SRC_ENABLE |
+                    GP3_CH3_SRC_8_8_8_8 |
+                    ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
     WRITE_COMMAND32(GP3_BLT_MODE, 0);
     WRITE_COMMAND32(GP3_BLT_CMD_HEADER, gp3_cmd_header);
 
@@ -2657,14 +2707,15 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
 
             GP3_WAIT_WRAP(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                GP3_DATA_LOAD_HDR_ENABLE);
-        } else {
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
+                            GP3_DATA_LOAD_HDR_ENABLE);
+        }
+        else {
             /* WAIT FOR AVAILABLE SPACE */
 
             GP3_WAIT_PRIMITIVE(temp);
             WRITE_COMMAND32(0, GP3_DATA_LOAD_HDR_TYPE |
-                GP3_DATA_LOAD_HDR_ENABLE);
+                            GP3_DATA_LOAD_HDR_ENABLE);
         }
 
         /* WRITE DWORD COUNT */
@@ -2675,7 +2726,7 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
 
         WRITE_COMMAND_STRING32(8, mono_mask, srcoffset, dword_count);
         WRITE_COMMAND_STRING8(8 + (dword_count << 2), mono_mask,
-            srcoffset + (dword_count << 2), byte_count);
+                              srcoffset + (dword_count << 2), byte_count);
 
         /* UPDATE POINTERS */
 
@@ -2690,8 +2741,8 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
 
     base = ((gp3_fb_base << 24) + (dstoffset & 0xFFC00000)) |
         ((gp3_fb_base << 14) + (((gp3_scratch_base +
-                    indent) & 0xFFC00000) >> 10)) | (gp3_base_register &
-        GP3_BASE_OFFSET_CH3MASK);
+                                  indent) & 0xFFC00000) >> 10)) |
+        (gp3_base_register & GP3_BASE_OFFSET_CH3MASK);
 
     gp3_cmd_header |= GP3_BLT_HDR_RASTER_ENABLE |
         GP3_BLT_HDR_STRIDE_ENABLE | GP3_BLT_HDR_DST_OFF_ENABLE |
@@ -2707,11 +2758,12 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
      */
 
     WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-        gp3_bpp | 0xF0 | GP3_RM_SRC_TRANS | flags);
+                    gp3_bpp | 0xF0 | GP3_RM_SRC_TRANS | flags);
     WRITE_COMMAND32(GP3_BLT_STRIDE, (total_dwords << 18) | gp3_dst_stride);
     WRITE_COMMAND32(GP3_BLT_DST_OFFSET, dstoffset & 0x3FFFFF);
     WRITE_COMMAND32(GP3_BLT_SRC_OFFSET,
-        ((gp3_scratch_base + indent) & 0x3FFFFF) | ((mono_srcx & 7) << 26));
+                    ((gp3_scratch_base +
+                      indent) & 0x3FFFFF) | ((mono_srcx & 7) << 26));
     WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, (width << 16) | height);
     WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, (width << 16) | height);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
@@ -2724,9 +2776,9 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
         ch3_offset = 0;
         size = width * 3;
 
-        WRITE_COMMAND32(GP3_BLT_CH3_WIDHI,
-            (((size + 3) >> 2) << 16) | height);
-    } else if (gp3_src_pix_shift == 3) {
+        WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, (((size + 3) >> 2) << 16) | height);
+    }
+    else if (gp3_src_pix_shift == 3) {
         /* CALCULATE INDENT AND SOURCE OFFSET */
 
         indent = (color_srcx >> 1);
@@ -2735,7 +2787,8 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
         ch3_offset = indent | ((color_srcx & 1) << 25);
 
         size = ((width + (color_srcx & 1) + 1) >> 1) + indent;
-    } else {
+    }
+    else {
         indent = (color_srcx << gp3_src_pix_shift);
         srcoffset = (indent & ~3L);
         indent &= 3;
@@ -2751,10 +2804,11 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
 
     WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, ch3_offset);
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, GP3_CH3_C3EN |
-        GP3_CH3_HST_SRC_ENABLE |
-        gp3_src_format | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
+                    GP3_CH3_HST_SRC_ENABLE |
+                    gp3_src_format | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT)
+                                      << 20));
     WRITE_COMMAND32(GP3_BLT_MODE,
-        gp3_blt_mode | GP3_BM_SRC_MONO | GP3_BM_SRC_FB);
+                    gp3_blt_mode | GP3_BM_SRC_MONO | GP3_BM_SRC_FB);
 
     /* START THE BLT */
 
@@ -2777,12 +2831,13 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
 
             GP3_WAIT_WRAP(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
-                GP3_DATA_LOAD_HDR_ENABLE);
-        } else {
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_WRAP |
+                            GP3_DATA_LOAD_HDR_ENABLE);
+        }
+        else {
             GP3_WAIT_PRIMITIVE(temp);
             WRITE_COMMAND32(0,
-                GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
+                            GP3_DATA_LOAD_HDR_TYPE | GP3_DATA_LOAD_HDR_ENABLE);
         }
 
         /* WRITE DWORD COUNT */
@@ -2793,7 +2848,7 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
 
         WRITE_COMMAND_STRING32(8, color_data, srcoffset, dword_count);
         WRITE_COMMAND_STRING8(8 + (dword_count << 2), color_data,
-            srcoffset + (dword_count << 2), byte_count);
+                              srcoffset + (dword_count << 2), byte_count);
 
         /* UPDATE COMMAND BUFFER POINTERS */
         /* We do this before writing the monochrome data because otherwise */
@@ -2817,8 +2872,9 @@ gp_masked_blt(unsigned long dstoffset, unsigned long width,
 
 void
 gp_screen_to_screen_masked(unsigned long dstoffset, unsigned long srcoffset,
-    unsigned long width, unsigned long height,
-    unsigned long mono_srcx, unsigned char *mono_mask, long mono_pitch)
+                           unsigned long width, unsigned long height,
+                           unsigned long mono_srcx, unsigned char *mono_mask,
+                           long mono_pitch)
 {
     unsigned long indent, temp;
     unsigned long total_dwords, size_dwords;
@@ -2859,9 +2915,9 @@ gp_screen_to_screen_masked(unsigned long dstoffset, unsigned long srcoffset,
     WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, 0);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, GP3_CH3_C3EN |
-        GP3_CH3_REPLACE_SOURCE | GP3_CH3_HST_SRC_ENABLE |
-        GP3_CH3_SRC_8_8_8_8 |
-        ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
+                    GP3_CH3_REPLACE_SOURCE | GP3_CH3_HST_SRC_ENABLE |
+                    GP3_CH3_SRC_8_8_8_8 |
+                    ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
     WRITE_COMMAND32(GP3_BLT_MODE, 0);
     WRITE_COMMAND32(GP3_BLT_CMD_HEADER, gp3_cmd_header);
 
@@ -2889,13 +2945,14 @@ gp_screen_to_screen_masked(unsigned long dstoffset, unsigned long srcoffset,
 
             GP3_WAIT_WRAP(temp);
             WRITE_COMMAND32(0, GP3_DATA_LOAD_HDR_TYPE |
-                GP3_DATA_LOAD_HDR_WRAP | GP3_DATA_LOAD_HDR_ENABLE);
-        } else {
+                            GP3_DATA_LOAD_HDR_WRAP | GP3_DATA_LOAD_HDR_ENABLE);
+        }
+        else {
             /* WAIT FOR AVAILABLE SPACE */
 
             GP3_WAIT_PRIMITIVE(temp);
             WRITE_COMMAND32(0, GP3_DATA_LOAD_HDR_TYPE |
-                GP3_DATA_LOAD_HDR_ENABLE);
+                            GP3_DATA_LOAD_HDR_ENABLE);
         }
 
         /* WRITE DWORD COUNT */
@@ -2906,7 +2963,7 @@ gp_screen_to_screen_masked(unsigned long dstoffset, unsigned long srcoffset,
 
         WRITE_COMMAND_STRING32(8, mono_mask, srcoff, dword_count);
         WRITE_COMMAND_STRING8(8 + (dword_count << 2), mono_mask,
-            srcoff + (dword_count << 2), byte_count);
+                              srcoff + (dword_count << 2), byte_count);
 
         /* UPDATE POINTERS */
 
@@ -2921,8 +2978,11 @@ gp_screen_to_screen_masked(unsigned long dstoffset, unsigned long srcoffset,
 
     base = ((gp3_fb_base << 24) + (dstoffset & 0xFFC00000)) |
         ((gp3_fb_base << 14) + (((gp3_scratch_base +
-                    indent) & 0xFFC00000) >> 10)) | ((gp3_fb_base << 4) +
-        ((srcoffset & 0xFFC00000) >> 20));
+                                  indent) & 0xFFC00000) >> 10)) | ((gp3_fb_base
+                                                                    << 4) +
+                                                                   ((srcoffset &
+                                                                     0xFFC00000)
+                                                                    >> 20));
 
     gp3_cmd_header |= GP3_BLT_HDR_RASTER_ENABLE |
         GP3_BLT_HDR_STRIDE_ENABLE | GP3_BLT_HDR_DST_OFF_ENABLE |
@@ -2938,11 +2998,12 @@ gp_screen_to_screen_masked(unsigned long dstoffset, unsigned long srcoffset,
      */
 
     WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-        gp3_bpp | 0xF0 | GP3_RM_SRC_TRANS | flags);
+                    gp3_bpp | 0xF0 | GP3_RM_SRC_TRANS | flags);
     WRITE_COMMAND32(GP3_BLT_STRIDE, (total_dwords << 18) | gp3_dst_stride);
     WRITE_COMMAND32(GP3_BLT_DST_OFFSET, dstoffset & 0x3FFFFF);
     WRITE_COMMAND32(GP3_BLT_SRC_OFFSET,
-        ((gp3_scratch_base + indent) & 0x3FFFFF) | ((mono_srcx & 7) << 26));
+                    ((gp3_scratch_base +
+                      indent) & 0x3FFFFF) | ((mono_srcx & 7) << 26));
     WRITE_COMMAND32(GP3_BLT_WID_HEIGHT, (width << 16) | height);
     WRITE_COMMAND32(GP3_BLT_CH3_WIDHI, (width << 16) | height);
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
@@ -2951,9 +3012,10 @@ gp_screen_to_screen_masked(unsigned long dstoffset, unsigned long srcoffset,
 
     WRITE_COMMAND32(GP3_BLT_CH3_OFFSET, srcoffset & 0x3FFFFF);
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, GP3_CH3_C3EN | gp3_ch3_bpp |
-        gp3_src_stride | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
+                    gp3_src_stride | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT)
+                                      << 20));
     WRITE_COMMAND32(GP3_BLT_MODE,
-        gp3_blt_mode | GP3_BM_SRC_MONO | GP3_BM_SRC_FB);
+                    gp3_blt_mode | GP3_BM_SRC_MONO | GP3_BM_SRC_FB);
 
     /* START THE BLT */
 
@@ -2974,8 +3036,8 @@ gp_screen_to_screen_masked(unsigned long dstoffset, unsigned long srcoffset,
 
 void
 gp_bresenham_line(unsigned long dstoffset, unsigned short length,
-    unsigned short initerr, unsigned short axialerr,
-    unsigned short diagerr, unsigned long flags)
+                  unsigned short initerr, unsigned short axialerr,
+                  unsigned short diagerr, unsigned long flags)
 {
     unsigned long base;
     long offset;
@@ -3035,9 +3097,10 @@ gp_bresenham_line(unsigned long dstoffset, unsigned short length,
     /* 4MB segment we happen to be drawing to.                     */
 
     WRITE_COMMAND32(GP3_VECTOR_VEC_ERR,
-        (((unsigned long)axialerr << 16) | (unsigned long)diagerr));
+                    (((unsigned long) axialerr << 16) | (unsigned long)
+                     diagerr));
     WRITE_COMMAND32(GP3_VECTOR_VEC_LEN,
-        (((unsigned long)length << 16) | (unsigned long)initerr));
+                    (((unsigned long) length << 16) | (unsigned long) initerr));
     WRITE_COMMAND32(GP3_VECTOR_BASE_OFFSET, base);
 
     /* CHECK VECTOR PATTERN CASE */
@@ -3059,9 +3122,10 @@ gp_bresenham_line(unsigned long dstoffset, unsigned short length,
 
         WRITE_COMMAND32(GP3_VECTOR_DST_OFFSET, dstoffset);
         WRITE_COMMAND32(GP3_VECTOR_CH3_MODE_STR,
-            GP3_CH3_C3EN | GP3_CH3_REPLACE_SOURCE |
-            GP3_CH3_COLOR_PAT_ENABLE | GP3_CH3_SRC_8_8_8_8);
-    } else {
+                        GP3_CH3_C3EN | GP3_CH3_REPLACE_SOURCE |
+                        GP3_CH3_COLOR_PAT_ENABLE | GP3_CH3_SRC_8_8_8_8);
+    }
+    else {
         /* DISABLE CHANNEL 3 AND USE NORMAL PATTERN ORIGINS */
 
         WRITE_COMMAND32(GP3_VECTOR_CH3_MODE_STR, 0);
@@ -3093,16 +3157,15 @@ gp_bresenham_line(unsigned long dstoffset, unsigned short length,
          */
 
         WRITE_COMMAND32(16, GP3_VEC_HDR_TYPE | GP3_VEC_HDR_VEC_MODE_ENABLE |
-            GP3_VEC_HDR_VEC_LEN_ENABLE);
+                        GP3_VEC_HDR_VEC_LEN_ENABLE);
         WRITE_COMMAND32(16 + GP3_VECTOR_MODE, (gp3_vec_mode | flags));
         WRITE_COMMAND32(16 + GP3_VECTOR_VEC_LEN,
-            (1 << 16) | (unsigned long)initerr);
+                        (1 << 16) | (unsigned long) initerr);
 
         WRITE_COMMAND32(16 + GP3_VECTOR_COMMAND_SIZE,
-            GP3_LUT_HDR_TYPE | GP3_LUT_HDR_DATA_ENABLE);
+                        GP3_LUT_HDR_TYPE | GP3_LUT_HDR_DATA_ENABLE);
         WRITE_COMMAND32(20 + GP3_VECTOR_COMMAND_SIZE, 0x100);
-        WRITE_COMMAND32(24 + GP3_VECTOR_COMMAND_SIZE,
-            (1 | GP3_LUT_DATA_TYPE));
+        WRITE_COMMAND32(24 + GP3_VECTOR_COMMAND_SIZE, (1 | GP3_LUT_DATA_TYPE));
         WRITE_COMMAND32(28 + GP3_VECTOR_COMMAND_SIZE, gp3_vec_pat);
 
         gp3_cmd_current += 32 + GP3_VECTOR_COMMAND_SIZE;
@@ -3118,7 +3181,8 @@ gp_bresenham_line(unsigned long dstoffset, unsigned short length,
 
 void
 gp_line_from_endpoints(unsigned long dstoffset, unsigned long x0,
-    unsigned long y0, unsigned long x1, unsigned long y1, int inclusive)
+                       unsigned long y0, unsigned long x1, unsigned long y1,
+                       int inclusive)
 {
     unsigned long base;
     unsigned long length;
@@ -3133,8 +3197,8 @@ gp_line_from_endpoints(unsigned long dstoffset, unsigned long x0,
 
     /* CALCULATE BRESENHAM TERMS */
 
-    dx = (long)x1 - (long)x0;
-    dy = (long)y1 - (long)y0;
+    dx = (long) x1 - (long) x0;
+    dy = (long) y1 - (long) y0;
     if (dx < 0)
         dx = -dx;
     if (dy < 0)
@@ -3148,7 +3212,8 @@ gp_line_from_endpoints(unsigned long dstoffset, unsigned long x0,
             flags |= CIMGP_POSMAJOR;
         if (y1 > y0)
             flags |= CIMGP_POSMINOR;
-    } else {
+    }
+    else {
         dmaj = dy;
         dmin = dx;
         flags = CIMGP_YMAJOR;
@@ -3158,9 +3223,9 @@ gp_line_from_endpoints(unsigned long dstoffset, unsigned long x0,
             flags |= CIMGP_POSMAJOR;
     }
 
-    axialerr = (unsigned short)(dmin << 1);
-    diagerr = (unsigned short)((dmin - dmaj) << 1);
-    initerr = (unsigned short)((dmin << 1) - dmaj);
+    axialerr = (unsigned short) (dmin << 1);
+    diagerr = (unsigned short) ((dmin - dmaj) << 1);
+    initerr = (unsigned short) ((dmin << 1) - dmaj);
     if (!(flags & CIMGP_POSMINOR))
         initerr--;
 
@@ -3221,9 +3286,10 @@ gp_line_from_endpoints(unsigned long dstoffset, unsigned long x0,
     /* 4MB segment we happen to be drawing to.                     */
 
     WRITE_COMMAND32(GP3_VECTOR_VEC_ERR,
-        (((unsigned long)axialerr << 16) | (unsigned long)diagerr));
+                    (((unsigned long) axialerr << 16) | (unsigned long)
+                     diagerr));
     WRITE_COMMAND32(GP3_VECTOR_VEC_LEN,
-        (((unsigned long)length << 16) | (unsigned long)initerr));
+                    (((unsigned long) length << 16) | (unsigned long) initerr));
     WRITE_COMMAND32(GP3_VECTOR_BASE_OFFSET, base);
 
     /* CHECK VECTOR PATTERN CASE */
@@ -3245,9 +3311,10 @@ gp_line_from_endpoints(unsigned long dstoffset, unsigned long x0,
 
         WRITE_COMMAND32(GP3_VECTOR_DST_OFFSET, dstoffset);
         WRITE_COMMAND32(GP3_VECTOR_CH3_MODE_STR,
-            GP3_CH3_C3EN | GP3_CH3_REPLACE_SOURCE |
-            GP3_CH3_COLOR_PAT_ENABLE | GP3_CH3_SRC_8_8_8_8);
-    } else {
+                        GP3_CH3_C3EN | GP3_CH3_REPLACE_SOURCE |
+                        GP3_CH3_COLOR_PAT_ENABLE | GP3_CH3_SRC_8_8_8_8);
+    }
+    else {
         /* DISABLE CHANNEL 3 AND USE NORMAL PATTERN ORIGINS */
 
         WRITE_COMMAND32(GP3_VECTOR_CH3_MODE_STR, 0);
@@ -3278,16 +3345,15 @@ gp_line_from_endpoints(unsigned long dstoffset, unsigned long x0,
          */
 
         WRITE_COMMAND32(16, GP3_VEC_HDR_TYPE | GP3_VEC_HDR_VEC_MODE_ENABLE |
-            GP3_VEC_HDR_VEC_LEN_ENABLE);
+                        GP3_VEC_HDR_VEC_LEN_ENABLE);
         WRITE_COMMAND32(16 + GP3_VECTOR_MODE, (gp3_vec_mode | flags));
         WRITE_COMMAND32(16 + GP3_VECTOR_VEC_LEN,
-            (1 << 16) | (unsigned long)initerr);
+                        (1 << 16) | (unsigned long) initerr);
 
         WRITE_COMMAND32(16 + GP3_VECTOR_COMMAND_SIZE,
-            GP3_LUT_HDR_TYPE | GP3_LUT_HDR_DATA_ENABLE);
+                        GP3_LUT_HDR_TYPE | GP3_LUT_HDR_DATA_ENABLE);
         WRITE_COMMAND32(20 + GP3_VECTOR_COMMAND_SIZE, 0x100);
-        WRITE_COMMAND32(24 + GP3_VECTOR_COMMAND_SIZE,
-            (1 | GP3_LUT_DATA_TYPE));
+        WRITE_COMMAND32(24 + GP3_VECTOR_COMMAND_SIZE, (1 | GP3_LUT_DATA_TYPE));
         WRITE_COMMAND32(28 + GP3_VECTOR_COMMAND_SIZE, gp3_vec_pat);
 
         gp3_cmd_current += 32 + GP3_VECTOR_COMMAND_SIZE;
@@ -3306,7 +3372,7 @@ gp_wait_until_idle(void)
     unsigned long temp;
 
     while (((temp = READ_GP32(GP3_BLT_STATUS)) & GP3_BS_BLT_BUSY) ||
-        !(temp & GP3_BS_CB_EMPTY)) {
+           !(temp & GP3_BS_CB_EMPTY)) {
         ;
     }
 }
@@ -3347,7 +3413,7 @@ gp_test_blt_pending(void)
 void
 gp_wait_blt_pending(void)
 {
-    while ((READ_GP32(GP3_BLT_STATUS)) & GP3_BS_BLT_PENDING) ;
+    while ((READ_GP32(GP3_BLT_STATUS)) & GP3_BS_BLT_PENDING);
 }
 
 /*---------------------------------------------------------------------------
@@ -3372,7 +3438,7 @@ gp_save_state(GP_SAVE_RESTORE * gp_state)
     /* RESET THE READ POINTER */
 
     gp_set_command_buffer_base(gp_state->cmd_base, gp_state->cmd_top,
-        gp_state->cmd_bottom);
+                               gp_state->cmd_bottom);
 }
 
 /*---------------------------------------------------------------------------
@@ -3389,26 +3455,25 @@ gp_restore_state(GP_SAVE_RESTORE * gp_state)
     WRITE_GP32(GP3_BASE_OFFSET, gp_state->base_offset);
 
     gp_set_command_buffer_base(gp_state->cmd_base, gp_state->cmd_top,
-        gp_state->cmd_bottom);
+                               gp_state->cmd_bottom);
 }
 
 /* This is identical to gp_antialiased_text, except we support all one
    pass alpha operations similar to gp_set_alpha_operation */
 
-
 void
 gp_blend_mask_blt(unsigned long dstoffset, unsigned long srcx,
-    unsigned long width, unsigned long height,
-    unsigned long dataoffset, long stride, int operation,
-    int fourbpp)
+                  unsigned long width, unsigned long height,
+                  unsigned long dataoffset, long stride, int operation,
+                  int fourbpp)
 {
     unsigned long indent;
     unsigned long size = ((width << 16) | height);
     unsigned long base, depth_flag;
 
     base = ((gp3_fb_base << 24) + (dstoffset & 0xFFC00000)) |
-	   ((gp3_fb_base << 4) + (dataoffset >> 20)) |
-           (gp3_base_register & GP3_BASE_OFFSET_SRCMASK);
+        ((gp3_fb_base << 4) + (dataoffset >> 20)) |
+        (gp3_base_register & GP3_BASE_OFFSET_SRCMASK);
 
     /* ENABLE ALL RELEVANT REGISTERS */
     /* We override the raster mode register to force the */
@@ -3430,7 +3495,8 @@ gp_blend_mask_blt(unsigned long dstoffset, unsigned long srcx,
         depth_flag = GP3_CH3_SRC_4BPP_ALPHA;
         indent = (srcx >> 1) & 3;
         dataoffset += indent | ((srcx & 1) << 25);
-    } else {
+    }
+    else {
         depth_flag = GP3_CH3_SRC_8BPP_ALPHA;
         indent = srcx & 3;
         dataoffset += indent;
@@ -3443,14 +3509,16 @@ gp_blend_mask_blt(unsigned long dstoffset, unsigned long srcx,
 
     if (gp3_bpp == GP3_RM_BPPFMT_565) {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_bpp |
-            GP3_RM_ALPHA_TO_RGB |
-            ((unsigned long) (operation << 20)) | GP3_RM_SELECT_ALPHA_CHAN_3);
-    } else {
+                        gp3_bpp |
+                        GP3_RM_ALPHA_TO_RGB |
+                        ((unsigned long) (operation << 20)) |
+                        GP3_RM_SELECT_ALPHA_CHAN_3);
+    }
+    else {
         WRITE_COMMAND32(GP3_BLT_RASTER_MODE,
-            gp3_bpp |
-            GP3_RM_ALPHA_ALL | ((unsigned long) (operation << 20)) |
-            GP3_RM_SELECT_ALPHA_CHAN_3);
+                        gp3_bpp |
+                        GP3_RM_ALPHA_ALL | ((unsigned long) (operation << 20)) |
+                        GP3_RM_SELECT_ALPHA_CHAN_3);
     }
 
     /* WRITE ALL REMAINING REGISTERS */
@@ -3465,7 +3533,8 @@ gp_blend_mask_blt(unsigned long dstoffset, unsigned long srcx,
     WRITE_COMMAND32(GP3_BLT_BASE_OFFSET, base);
 
     WRITE_COMMAND32(GP3_BLT_CH3_MODE_STR, GP3_CH3_C3EN | (stride & 0xFFFF) |
-		    depth_flag | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) << 20));
+                    depth_flag | ((gp3_blt_flags & CIMGP_BLTFLAGS_PRES_LUT) <<
+                                  20));
 
     WRITE_COMMAND32(GP3_BLT_MODE, GP3_BM_DST_REQ);
 
diff --git a/src/cim/cim_init.c b/src/cim/cim_init.c
index 71f20b6..e80eeb1 100644
--- a/src/cim/cim_init.c
+++ b/src/cim/cim_init.c
@@ -43,8 +43,7 @@ CIMARRON_STATIC unsigned long init_video_base = 0x80000900;
  *---------------------------------------------------------------------------*/
 
 int
-init_detect_cpu(unsigned long *cpu_revision,
-    unsigned long *companion_revision)
+init_detect_cpu(unsigned long *cpu_revision, unsigned long *companion_revision)
 {
     unsigned long bus, device, i;
     unsigned long cpu_bus = 0, cpu_device = 0;
@@ -74,7 +73,8 @@ init_detect_cpu(unsigned long *cpu_revision,
                     *cpu_revision = CIM_CPU_GEODEGX;
                 else
                     *cpu_revision = CIM_CPU_GEODELX;
-            } else if (data == PCI_VENDOR_5535 || data == PCI_VENDOR_5536) {
+            }
+            else if (data == PCI_VENDOR_5535 || data == PCI_VENDOR_5536) {
                 sb_found = 1;
                 if (data == PCI_VENDOR_5535)
                     *companion_revision = CIM_SB_5535;
@@ -97,7 +97,7 @@ init_detect_cpu(unsigned long *cpu_revision,
     msr_init_table();
 
     if (msr_read64(MSR_DEVICE_GEODELX_GLCP, GLCP_REVID,
-            &msr_value) != CIM_STATUS_OK) {
+                   &msr_value) != CIM_STATUS_OK) {
         *cpu_revision = 0;
         return CIM_STATUS_CPUNOTFOUND;
     }
@@ -106,7 +106,7 @@ init_detect_cpu(unsigned long *cpu_revision,
         ((msr_value.low & 0x0F) << 16);
 
     if (msr_read64(MSR_DEVICE_5535_GLCP, GLCP_REVID,
-            &msr_value) != CIM_STATUS_OK) {
+                   &msr_value) != CIM_STATUS_OK) {
         *cpu_revision = 0;
         return CIM_STATUS_CPUNOTFOUND;
     }
@@ -125,7 +125,8 @@ init_detect_cpu(unsigned long *cpu_revision,
         if (data == PCI_VENDOR_DEVICE_GEODEGX_VIDEO) {
             num_bars = 4;
             break;
-        } else if (data == PCI_VENDOR_DEVICE_GEODELX_VIDEO) {
+        }
+        else if (data == PCI_VENDOR_DEVICE_GEODELX_VIDEO) {
             num_bars = 5;
             break;
         }
@@ -194,7 +195,7 @@ init_read_base_addresses(INIT_BASE_ADDRESSES * base_addresses)
     OUTW(0xAC1C, 0xFC53);
     OUTW(0xAC1C, 0x0200);
 
-    value = (unsigned long)(INW(0xAC1E)) & 0xFE;
+    value = (unsigned long) (INW(0xAC1E)) & 0xFE;
 
     base_addresses->framebuffer_size = value << 20;
 
@@ -217,7 +218,7 @@ init_read_cpu_frequency(unsigned long *cpu_frequency)
     OUTW(0xAC1C, 0xFC53);
     OUTW(0xAC1C, 0x1201);
 
-    *cpu_frequency = (unsigned long)(INW(0xAC1E));
+    *cpu_frequency = (unsigned long) (INW(0xAC1E));
 
     return CIM_STATUS_OK;
 }
diff --git a/src/cim/cim_modes.c b/src/cim/cim_modes.c
index 04d7edd..f61c0e4 100644
--- a/src/cim/cim_modes.c
+++ b/src/cim/cim_modes.c
@@ -35,977 +35,928 @@
 static const VG_DISPLAY_MODE CimarronDisplayModes[] = {
     /* 320 x 240 PANEL */
 
-    {VG_SUPPORTFLAG_75HZ |             /* refresh rate = 75    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,      /* Panel Mode.          */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_PANELOUT |     /* Panel output.        */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |     /* negative syncs */
-            VG_MODEFLAG_QVGA,          /* QVGA Panel size.     */
-            320, 240,                  /* No scaling.          */
-            320, 240,                  /* 320x240 active       */
-            320, 240,                  /* 320x240 panel        */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0140, 0x0148, 0x0162, 0x0180, 0x0188, 0x0190,     /* horiz timings   */
-            0x00F0, 0x00F4, 0x00F9, 0x00FD, 0x00FF, 0x0104,     /* vertical timings */
-            (31L << 16) | ((2000L * 65536L) / 10000L),  /* freq = 31.2000 MHz */
-        }
+    {VG_SUPPORTFLAG_75HZ |      /* refresh rate = 75    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,     /* Panel Mode.          */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_PANELOUT |     /* Panel output.        */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |    /* negative syncs */
+     VG_MODEFLAG_QVGA,          /* QVGA Panel size.     */
+     320, 240,                  /* No scaling.          */
+     320, 240,                  /* 320x240 active       */
+     320, 240,                  /* 320x240 panel        */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0140, 0x0148, 0x0162, 0x0180, 0x0188, 0x0190,    /* horiz timings   */
+     0x00F0, 0x00F4, 0x00F9, 0x00FD, 0x00FF, 0x0104,    /* vertical timings */
+     (31L << 16) | ((2000L * 65536L) / 10000L), /* freq = 31.2000 MHz */
+     }
     ,
 
     /* 640 x 400 */
 
-    {VG_SUPPORTFLAG_70HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC,     /* negative HSYNC       */
-            640, 400,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x280, 0x288, 0x290, 0x2F0, 0x318, 0x320,   /* horiz timings   */
-            0x190, 0x197, 0x19C, 0x19E, 0x1BA, 0x1C1,   /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (25L << 16) | ((1750L * 65536L) / 10000L),  /* freq = 25.175 MHz    */
-        }
+    {VG_SUPPORTFLAG_70HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC,     /* negative HSYNC       */
+     640, 400,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x280, 0x288, 0x290, 0x2F0, 0x318, 0x320,  /* horiz timings   */
+     0x190, 0x197, 0x19C, 0x19E, 0x1BA, 0x1C1,  /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (25L << 16) | ((1750L * 65536L) / 10000L), /* freq = 25.175 MHz    */
+     }
     ,
 
     /* 640x480 */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            640, 480,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0280, 0x0288, 0x0290, 0x02E8, 0x0318, 0x0320,     /* horiz timings   */
-            0x01E0, 0x01E8, 0x01EA, 0x01EC, 0x0205, 0x020D,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (25L << 16) | ((1750L * 65536L) / 10000L),  /* freq = 25.175 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_70HZ |             /* refresh rate = 70    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            640, 480,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0280, 0x0280, 0x0298, 0x02D8, 0x0330, 0x0330,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01E2, 0x01E5, 0x01F4, 0x01F4,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (28L << 16) | ((5600L * 65536L) / 10000L),  /* freq = 28.560 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_72HZ |             /* refresh rate = 72    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            640, 480,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0280, 0x0288, 0x0298, 0x02c0, 0x0338, 0x0340,     /* horiz timings   */
-            0x01e0, 0x01e8, 0x01e9, 0x01ec, 0x0200, 0x0208,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (31L << 16) | ((5000L * 65536L) / 10000L),  /* freq = 31.5 MHz      */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_75HZ |             /* refresh rate = 75    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            640, 480,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0280, 0x0280, 0x0290, 0x02D0, 0x0348, 0x0348,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01F4, 0x01F4,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (31L << 16) | ((5000L * 65536L) / 10000L),  /* freq = 31.5 MHz      */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_85HZ |             /* refresh rate = 85    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            640, 480,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0280, 0x0280, 0x02B8, 0x02F0, 0x0340, 0x0340,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FD, 0x01FD,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (36L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 36.0 MHz      */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_90HZ |             /* refresh rate = 90    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            640, 480,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0280, 0x0280, 0x02A0, 0x02E0, 0x0340, 0x0340,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FA, 0x01FA,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (37L << 16) | ((8890L * 65536L) / 10000L),  /* freq = 37.889 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_100HZ |            /* refresh rate = 100   */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            640, 480,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0280, 0x0280, 0x02A8, 0x02E8, 0x0350, 0x0350,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FD, 0x01FD,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (43L << 16) | ((1630L * 65536L) / 10000L),  /* freq = 43.163 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     640, 480,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0280, 0x0288, 0x0290, 0x02E8, 0x0318, 0x0320,    /* horiz timings   */
+     0x01E0, 0x01E8, 0x01EA, 0x01EC, 0x0205, 0x020D,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (25L << 16) | ((1750L * 65536L) / 10000L), /* freq = 25.175 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_70HZ |      /* refresh rate = 70    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     640, 480,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0280, 0x0280, 0x0298, 0x02D8, 0x0330, 0x0330,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01E2, 0x01E5, 0x01F4, 0x01F4,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (28L << 16) | ((5600L * 65536L) / 10000L), /* freq = 28.560 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_72HZ |      /* refresh rate = 72    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     640, 480,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0280, 0x0288, 0x0298, 0x02c0, 0x0338, 0x0340,    /* horiz timings   */
+     0x01e0, 0x01e8, 0x01e9, 0x01ec, 0x0200, 0x0208,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (31L << 16) | ((5000L * 65536L) / 10000L), /* freq = 31.5 MHz      */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_75HZ |      /* refresh rate = 75    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     640, 480,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0280, 0x0280, 0x0290, 0x02D0, 0x0348, 0x0348,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01F4, 0x01F4,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (31L << 16) | ((5000L * 65536L) / 10000L), /* freq = 31.5 MHz      */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_85HZ |      /* refresh rate = 85    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     640, 480,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0280, 0x0280, 0x02B8, 0x02F0, 0x0340, 0x0340,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FD, 0x01FD,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (36L << 16) | ((0000L * 65536L) / 10000L), /* freq = 36.0 MHz      */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_90HZ |      /* refresh rate = 90    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     640, 480,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0280, 0x0280, 0x02A0, 0x02E0, 0x0340, 0x0340,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FA, 0x01FA,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (37L << 16) | ((8890L * 65536L) / 10000L), /* freq = 37.889 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_100HZ |     /* refresh rate = 100   */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     640, 480,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0280, 0x0280, 0x02A8, 0x02E8, 0x0350, 0x0350,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FD, 0x01FD,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (43L << 16) | ((1630L * 65536L) / 10000L), /* freq = 43.163 MHz    */
+     }
     ,
 
     /* 640 x 480 PANEL */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,      /* Panel Mode.          */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_PANELOUT |     /* Panel output.        */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            640, 480,                  /* No scaling.          */
-            640, 480,                  /* 640x480 active       */
-            640, 480,                  /* 640x480 panel        */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (25L << 16) | ((1750L * 65536L) / 10000L),  /* freq = 25.175 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,     /* Panel Mode.          */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_PANELOUT |     /* Panel output.        */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     640, 480,                  /* No scaling.          */
+     640, 480,                  /* 640x480 active       */
+     640, 480,                  /* 640x480 panel        */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (25L << 16) | ((1750L * 65536L) / 10000L), /* freq = 25.175 MHz    */
+     }
     ,
 
     /* 800x600 */
 
-    {VG_SUPPORTFLAG_56HZ |             /* refresh rate = 56    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            800, 600,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x0338, 0x0380, 0x0400, 0x0400,     /* horiz timings   */
-            0x0258, 0x0258, 0x0259, 0x025B, 0x0271, 0x0271,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (36L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 36.0 MHz      */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            800, 600,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0328, 0x0348, 0x03D0, 0x0418, 0x0420,     /* horiz timings   */
-            0x0258, 0x0258, 0x0259, 0x025D, 0x0274, 0x0274,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (40L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 40.00 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_70HZ |             /* refresh rate = 70    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            800, 600,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x0348, 0x0398, 0x0410, 0x0410,     /* horiz timings   */
-            0x0258, 0x0258, 0x025c, 0x025F, 0x0274, 0x0274,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (45L << 16) | ((7200L * 65536L) / 10000L),  /* freq = 45.72 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_72HZ |             /* refresh rate = 72    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            800, 600,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x0358, 0x03D0, 0x0410, 0x0410,     /* horiz timings   */
-            0x0258, 0x0258, 0x027D, 0x0283, 0x029A, 0x029A,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (49L << 16) | ((5000L * 65536L) / 10000L),  /* freq = 49.5 MHz      */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_75HZ |             /* refresh rate = 75    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            800, 600,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x0330, 0x0380, 0x0420, 0x0420,     /* horiz timings   */
-            0x0258, 0x0258, 0x0259, 0x025C, 0x0271, 0x0271,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (49L << 16) | ((5000L * 65536L) / 10000L),  /* freq = 49.5 MHz      */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_85HZ |             /* refresh rate = 85    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            800, 600,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x0340, 0x0380, 0x0418, 0x0418,     /* horiz timings   */
-            0x0258, 0x0258, 0x0259, 0x025C, 0x0277, 0x0277,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (56L << 16) | ((2500L * 65536L) / 10000L),  /* freq = 56.25 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_90HZ |             /* refresh rate = 90    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            800, 600,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x0348, 0x03A0, 0x0420, 0x0420,     /* horiz timings   */
-            0x0258, 0x0258, 0x0259, 0x025C, 0x0278, 0x0278,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (60L << 16) | ((650L * 65536L) / 10000L),   /* freq = 60.065 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_100HZ |            /* refresh rate = 100   */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            0,
-            800, 600,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x0350, 0x03A8, 0x0430, 0x0430,     /* horiz timings   */
-            0x0258, 0x0258, 0x0259, 0x025C, 0x0277, 0x027C,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (68L << 16) | ((1790L * 65536L) / 10000L),  /* freq = 68.179 MHz    */
-        }
+    {VG_SUPPORTFLAG_56HZ |      /* refresh rate = 56    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     800, 600,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x0338, 0x0380, 0x0400, 0x0400,    /* horiz timings   */
+     0x0258, 0x0258, 0x0259, 0x025B, 0x0271, 0x0271,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (36L << 16) | ((0000L * 65536L) / 10000L), /* freq = 36.0 MHz      */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     800, 600,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0328, 0x0348, 0x03D0, 0x0418, 0x0420,    /* horiz timings   */
+     0x0258, 0x0258, 0x0259, 0x025D, 0x0274, 0x0274,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (40L << 16) | ((0000L * 65536L) / 10000L), /* freq = 40.00 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_70HZ |      /* refresh rate = 70    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     800, 600,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x0348, 0x0398, 0x0410, 0x0410,    /* horiz timings   */
+     0x0258, 0x0258, 0x025c, 0x025F, 0x0274, 0x0274,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (45L << 16) | ((7200L * 65536L) / 10000L), /* freq = 45.72 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_72HZ |      /* refresh rate = 72    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     800, 600,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x0358, 0x03D0, 0x0410, 0x0410,    /* horiz timings   */
+     0x0258, 0x0258, 0x027D, 0x0283, 0x029A, 0x029A,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (49L << 16) | ((5000L * 65536L) / 10000L), /* freq = 49.5 MHz      */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_75HZ |      /* refresh rate = 75    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     800, 600,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x0330, 0x0380, 0x0420, 0x0420,    /* horiz timings   */
+     0x0258, 0x0258, 0x0259, 0x025C, 0x0271, 0x0271,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (49L << 16) | ((5000L * 65536L) / 10000L), /* freq = 49.5 MHz      */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_85HZ |      /* refresh rate = 85    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     800, 600,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x0340, 0x0380, 0x0418, 0x0418,    /* horiz timings   */
+     0x0258, 0x0258, 0x0259, 0x025C, 0x0277, 0x0277,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (56L << 16) | ((2500L * 65536L) / 10000L), /* freq = 56.25 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_90HZ |      /* refresh rate = 90    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     800, 600,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x0348, 0x03A0, 0x0420, 0x0420,    /* horiz timings   */
+     0x0258, 0x0258, 0x0259, 0x025C, 0x0278, 0x0278,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (60L << 16) | ((650L * 65536L) / 10000L),  /* freq = 60.065 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_100HZ |     /* refresh rate = 100   */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     0,
+     800, 600,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x0350, 0x03A8, 0x0430, 0x0430,    /* horiz timings   */
+     0x0258, 0x0258, 0x0259, 0x025C, 0x0277, 0x027C,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (68L << 16) | ((1790L * 65536L) / 10000L), /* freq = 68.179 MHz    */
+     }
     ,
 
     /* 800x600 PANEL */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,      /* Panel Mode.          */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_PANELOUT |     /* Panel output.        */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            800, 600,                  /* No scaling.          */
-            800, 600,                  /* 800x600 active.      */
-            800, 600,                  /* 800x600 panel        */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x0348, 0x03C8, 0x0420, 0x0420,     /* horiz timings   */
-            0x0258, 0x0258, 0x0259, 0x025D, 0x0274, 0x0274,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (40L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 40.00 MHz     */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,     /* Panel Mode.          */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_PANELOUT |     /* Panel output.        */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     800, 600,                  /* No scaling.          */
+     800, 600,                  /* 800x600 active.      */
+     800, 600,                  /* 800x600 panel        */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x0348, 0x03C8, 0x0420, 0x0420,    /* horiz timings   */
+     0x0258, 0x0258, 0x0259, 0x025D, 0x0274, 0x0274,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (40L << 16) | ((0000L * 65536L) / 10000L), /* freq = 40.00 MHz     */
+     }
     ,
 
     /* 1024x768 */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            1024, 768,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,     /* horiz timings   */
-            0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (65L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 65.00 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_70HZ |             /* refresh rate = 70    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            1024, 768,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0418, 0x04A0, 0x0530, 0x0530,     /* horiz timings   */
-            0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (75L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 75.0 MHz      */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_72HZ |             /* refresh rate = 72    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1024, 768,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0438, 0x04A8, 0x0550, 0x0550,     /* horiz timings   */
-            0x0300, 0x0300, 0x0304, 0x0307, 0x0324, 0x0324,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (78L << 16) | ((7500L * 65536L) / 10000L),  /* freq = 78.75 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_75HZ |             /* refresh rate = 75    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1024, 768,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0410, 0x0470, 0x0520, 0x0520,     /* horiz timings   */
-            0x0300, 0x0300, 0x0301, 0x0304, 0x0320, 0x0320,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (78L << 16) | ((7500L * 65536L) / 10000L),  /* freq = 78.75 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_85HZ |             /* refresh rate = 85    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1024, 768,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0430, 0x0490, 0x0560, 0x0560,     /* horiz timings   */
-            0x0300, 0x0300, 0x0301, 0x0304, 0x0328, 0x0328,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (94L << 16) | ((5000L * 65536L) / 10000L),  /* freq = 94.50 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_90HZ |             /* refresh rate = 90    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1024, 768,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0440, 0x04B0, 0x0560, 0x0560,     /* horiz timings   */
-            0x0300, 0x0300, 0x0301, 0x0304, 0x0329, 0x0329,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (100L << 16) | ((1870L * 65536L) / 10000L), /* freq = 100.187 MHz   */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_100HZ |            /* refresh rate = 100   */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1024, 768,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0448, 0x04B8, 0x0570, 0x0570,     /* horiz timings   */
-            0x0300, 0x0300, 0x0301, 0x0304, 0x032E, 0x032E,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (113L << 16) | ((3100L * 65536L) / 10000L), /* freq = 113.31 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     1024, 768,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,    /* horiz timings   */
+     0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (65L << 16) | ((0000L * 65536L) / 10000L), /* freq = 65.00 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_70HZ |      /* refresh rate = 70    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     1024, 768,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0418, 0x04A0, 0x0530, 0x0530,    /* horiz timings   */
+     0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (75L << 16) | ((0000L * 65536L) / 10000L), /* freq = 75.0 MHz      */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_72HZ |      /* refresh rate = 72    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1024, 768,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0438, 0x04A8, 0x0550, 0x0550,    /* horiz timings   */
+     0x0300, 0x0300, 0x0304, 0x0307, 0x0324, 0x0324,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (78L << 16) | ((7500L * 65536L) / 10000L), /* freq = 78.75 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_75HZ |      /* refresh rate = 75    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1024, 768,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0410, 0x0470, 0x0520, 0x0520,    /* horiz timings   */
+     0x0300, 0x0300, 0x0301, 0x0304, 0x0320, 0x0320,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (78L << 16) | ((7500L * 65536L) / 10000L), /* freq = 78.75 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_85HZ |      /* refresh rate = 85    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1024, 768,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0430, 0x0490, 0x0560, 0x0560,    /* horiz timings   */
+     0x0300, 0x0300, 0x0301, 0x0304, 0x0328, 0x0328,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (94L << 16) | ((5000L * 65536L) / 10000L), /* freq = 94.50 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_90HZ |      /* refresh rate = 90    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1024, 768,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0440, 0x04B0, 0x0560, 0x0560,    /* horiz timings   */
+     0x0300, 0x0300, 0x0301, 0x0304, 0x0329, 0x0329,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (100L << 16) | ((1870L * 65536L) / 10000L),        /* freq = 100.187 MHz   */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_100HZ |     /* refresh rate = 100   */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1024, 768,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0448, 0x04B8, 0x0570, 0x0570,    /* horiz timings   */
+     0x0300, 0x0300, 0x0301, 0x0304, 0x032E, 0x032E,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (113L << 16) | ((3100L * 65536L) / 10000L),        /* freq = 113.31 MHz    */
+     }
     ,
 
     /* 1024x768 PANEL */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,      /* Panel Mode.          */
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            VG_MODEFLAG_PANELOUT |     /* Panel output.        */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            1024, 768,                 /* No scaling.          */
-            1024, 768,                 /* 1024x768 active.     */
-            1024, 768,                 /* 1024x768 panel       */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,     /* horiz timings   */
-            0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (65L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 65.00 MHz     */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,     /* Panel Mode.          */
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     VG_MODEFLAG_PANELOUT |     /* Panel output.        */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     1024, 768,                 /* No scaling.          */
+     1024, 768,                 /* 1024x768 active.     */
+     1024, 768,                 /* 1024x768 panel       */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,    /* horiz timings   */
+     0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (65L << 16) | ((0000L * 65536L) / 10000L), /* freq = 65.00 MHz     */
+     }
     ,
 
     /* 1152x864 */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1152, 864,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0480, 0x0480, 0x04C0, 0x0538, 0x05F0, 0x05F0,     /* horiz timings   */
-            0x0360, 0x0360, 0x0361, 0x0364, 0x037F, 0x037F,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (81L << 16) | ((6000L * 65536L) / 10000L),  /* freq = 81.60 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_70HZ |             /* refresh rate = 70    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1152, 864,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0480, 0x0480, 0x04C8, 0x0540, 0x0600, 0x0600,     /* horiz timings   */
-            0x0360, 0x0360, 0x0368, 0x036B, 0x038B, 0x038B,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (97L << 16) | ((5200L * 65536L) / 10000L),  /* freq = 97.52 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_72HZ |             /* refresh rate = 72    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1152, 864,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0480, 0x0480, 0x04C8, 0x0548, 0x0610, 0x0610,     /* horiz timings   */
-            0x0360, 0x0360, 0x0367, 0x036A, 0x038B, 0x038B,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (101L << 16) | ((4200L * 65536L) / 10000L), /* freq = 101.42 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_75HZ |             /* refresh rate = 75    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1152, 864,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0480, 0x0480, 0x04C0, 0x0540, 0x0640, 0x0640,     /* horiz timings   */
-            0x0360, 0x0360, 0x0361, 0x0364, 0x0384, 0x0384,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (108L << 16) | ((0000L * 65536L) / 10000L), /* freq = 108.00 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_85HZ |             /* refresh rate = 85    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1152, 864,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0480, 0x0480, 0x04C8, 0x0548, 0x0610, 0x0610,     /* horiz timings   */
-            0x0360, 0x0360, 0x0363, 0x0366, 0x038B, 0x038B,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (119L << 16) | ((6500L * 65536L) / 10000L), /* freq = 119.65 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_90HZ |             /* refresh rate = 90    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1152, 864,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0480, 0x0480, 0x04D0, 0x0550, 0x0620, 0x0620,     /* horiz timings   */
-            0x0360, 0x0360, 0x0369, 0x036C, 0x0396, 0x0396,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (129L << 16) | ((6000L * 65536L) / 10000L), /* freq = 129.60 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_100HZ |            /* refresh rate = 100   */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1152, 864,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0480, 0x0480, 0x04D0, 0x0550, 0x0620, 0x0620,     /* horiz timings   */
-            0x0360, 0x0360, 0x0363, 0x0366, 0x0396, 0x0396,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (144L << 16) | ((0000L * 65536L) / 10000L), /* freq = 144.00 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1152, 864,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0480, 0x0480, 0x04C0, 0x0538, 0x05F0, 0x05F0,    /* horiz timings   */
+     0x0360, 0x0360, 0x0361, 0x0364, 0x037F, 0x037F,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (81L << 16) | ((6000L * 65536L) / 10000L), /* freq = 81.60 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_70HZ |      /* refresh rate = 70    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1152, 864,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0480, 0x0480, 0x04C8, 0x0540, 0x0600, 0x0600,    /* horiz timings   */
+     0x0360, 0x0360, 0x0368, 0x036B, 0x038B, 0x038B,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (97L << 16) | ((5200L * 65536L) / 10000L), /* freq = 97.52 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_72HZ |      /* refresh rate = 72    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1152, 864,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0480, 0x0480, 0x04C8, 0x0548, 0x0610, 0x0610,    /* horiz timings   */
+     0x0360, 0x0360, 0x0367, 0x036A, 0x038B, 0x038B,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (101L << 16) | ((4200L * 65536L) / 10000L),        /* freq = 101.42 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_75HZ |      /* refresh rate = 75    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1152, 864,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0480, 0x0480, 0x04C0, 0x0540, 0x0640, 0x0640,    /* horiz timings   */
+     0x0360, 0x0360, 0x0361, 0x0364, 0x0384, 0x0384,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (108L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 108.00 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_85HZ |      /* refresh rate = 85    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1152, 864,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0480, 0x0480, 0x04C8, 0x0548, 0x0610, 0x0610,    /* horiz timings   */
+     0x0360, 0x0360, 0x0363, 0x0366, 0x038B, 0x038B,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (119L << 16) | ((6500L * 65536L) / 10000L),        /* freq = 119.65 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_90HZ |      /* refresh rate = 90    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1152, 864,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0480, 0x0480, 0x04D0, 0x0550, 0x0620, 0x0620,    /* horiz timings   */
+     0x0360, 0x0360, 0x0369, 0x036C, 0x0396, 0x0396,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (129L << 16) | ((6000L * 65536L) / 10000L),        /* freq = 129.60 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_100HZ |     /* refresh rate = 100   */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1152, 864,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0480, 0x0480, 0x04D0, 0x0550, 0x0620, 0x0620,    /* horiz timings   */
+     0x0360, 0x0360, 0x0363, 0x0366, 0x0396, 0x0396,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (144L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 144.00 MHz    */
+     }
     ,
 
     /* 1152x864 PANEL */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,      /* Panel Mode.          */
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            VG_MODEFLAG_PANELOUT |     /* Panel output.        */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            1152, 864,                 /* No scaling.          */
-            1152, 864,                 /* 1152x864 active.     */
-            1152, 864,                 /* 1152x864 panel. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0480, 0x0480, 0x04C0, 0x0538, 0x05F0, 0x05F0,     /* horiz timings   */
-            0x0360, 0x0360, 0x0361, 0x0364, 0x037F, 0x037F,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (81L << 16) | ((6000L * 65536L) / 10000L),  /* freq = 81.60 MHz     */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,     /* Panel Mode.          */
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     VG_MODEFLAG_PANELOUT |     /* Panel output.        */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     1152, 864,                 /* No scaling.          */
+     1152, 864,                 /* 1152x864 active.     */
+     1152, 864,                 /* 1152x864 panel. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0480, 0x0480, 0x04C0, 0x0538, 0x05F0, 0x05F0,    /* horiz timings   */
+     0x0360, 0x0360, 0x0361, 0x0364, 0x037F, 0x037F,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (81L << 16) | ((6000L * 65536L) / 10000L), /* freq = 81.60 MHz     */
+     }
     ,
 
     /* 1280x1024 */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1280, 1024,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0530, 0x05A0, 0x0698, 0x0698,     /* horiz timings   */
-            0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (108L << 16) | ((0000L * 65536L) / 10000L), /* freq = 108.00 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_70HZ |             /* refresh rate = 70    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1280, 1024,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0558, 0x05E0, 0x06C0, 0x06C0,     /* horiz timings   */
-            0x0400, 0x0400, 0x0406, 0x0409, 0x042F, 0x042F,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (129L << 16) | ((6000L * 65536L) / 10000L), /* freq = 129.60 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_72HZ |             /* refresh rate = 72    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1280, 1024,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0558, 0x05E0, 0x06C0, 0x06C0,     /* horiz timings   */
-            0x0400, 0x0400, 0x0407, 0x040A, 0x0431, 0x0431,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (133L << 16) | ((5000L * 65536L) / 10000L), /* freq = 133.50 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_75HZ |             /* refresh rate = 75    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1280, 1024,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0510, 0x05A0, 0x0698, 0x0698,     /* horiz timings   */
-            0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (135L << 16) | ((0000L * 65536L) / 10000L), /* freq = 135.0 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_85HZ |             /* refresh rate = 85    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1280, 1024,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0540, 0x05E0, 0x06C0, 0x06C0,     /* horiz timings   */
-            0x0400, 0x0400, 0x0401, 0x0404, 0x0430, 0x0430,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (157L << 16) | ((5000L * 65536L) / 10000L), /* freq = 157.5 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_90HZ |             /* refresh rate = 90    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1280, 1024,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0560, 0x05F0, 0x06E0, 0x06E0,     /* horiz timings   */
-            0x0400, 0x0400, 0x040C, 0x040F, 0x0442, 0x0442,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (172L << 16) | ((8000L * 65536L) / 10000L), /* freq = 172.80 MHz    */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_100HZ |            /* refresh rate = 100   */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            0,
-            1280, 1024,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0560, 0x05F0, 0x06E0, 0x06E0,     /* horiz timings   */
-            0x0400, 0x0400, 0x0406, 0x0409, 0x0442, 0x0442,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (192L << 16) | ((0000L * 65536L) / 10000L), /* freq = 192.00 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1280, 1024,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0530, 0x05A0, 0x0698, 0x0698,    /* horiz timings   */
+     0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (108L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 108.00 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_70HZ |      /* refresh rate = 70    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1280, 1024,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0558, 0x05E0, 0x06C0, 0x06C0,    /* horiz timings   */
+     0x0400, 0x0400, 0x0406, 0x0409, 0x042F, 0x042F,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (129L << 16) | ((6000L * 65536L) / 10000L),        /* freq = 129.60 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_72HZ |      /* refresh rate = 72    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1280, 1024,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0558, 0x05E0, 0x06C0, 0x06C0,    /* horiz timings   */
+     0x0400, 0x0400, 0x0407, 0x040A, 0x0431, 0x0431,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (133L << 16) | ((5000L * 65536L) / 10000L),        /* freq = 133.50 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_75HZ |      /* refresh rate = 75    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1280, 1024,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0510, 0x05A0, 0x0698, 0x0698,    /* horiz timings   */
+     0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (135L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 135.0 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_85HZ |      /* refresh rate = 85    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1280, 1024,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0540, 0x05E0, 0x06C0, 0x06C0,    /* horiz timings   */
+     0x0400, 0x0400, 0x0401, 0x0404, 0x0430, 0x0430,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (157L << 16) | ((5000L * 65536L) / 10000L),        /* freq = 157.5 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_90HZ |      /* refresh rate = 90    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1280, 1024,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0560, 0x05F0, 0x06E0, 0x06E0,    /* horiz timings   */
+     0x0400, 0x0400, 0x040C, 0x040F, 0x0442, 0x0442,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (172L << 16) | ((8000L * 65536L) / 10000L),        /* freq = 172.80 MHz    */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_100HZ |     /* refresh rate = 100   */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     0,
+     1280, 1024,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0560, 0x05F0, 0x06E0, 0x06E0,    /* horiz timings   */
+     0x0400, 0x0400, 0x0406, 0x0409, 0x0442, 0x0442,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (192L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 192.00 MHz    */
+     }
     ,
 
     /* 1280x1024 PANEL */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,      /* Panel Mode.          */
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            VG_MODEFLAG_PANELOUT |     /* Panel output.        */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            1280, 1024,                /* No scaling.          */
-            1280, 1024,                /* 1280x1024 active.    */
-            1280, 1024,                /* 1280x1024 panel      */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0530, 0x05A0, 0x0698, 0x0698,     /* horiz timings   */
-            0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (108L << 16) | ((0000L * 65536L) / 10000L), /* freq = 108.00 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,     /* Panel Mode.          */
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     VG_MODEFLAG_PANELOUT |     /* Panel output.        */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     1280, 1024,                /* No scaling.          */
+     1280, 1024,                /* 1280x1024 active.    */
+     1280, 1024,                /* 1280x1024 panel      */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0530, 0x05A0, 0x0698, 0x0698,    /* horiz timings   */
+     0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (108L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 108.00 MHz    */
+     }
     ,
 
     /* 1600 x 1200 */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1600, 1200,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,     /* horiz timings   */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (162L << 16) | ((0000L * 65536L) / 10000L), /* freq = 162.0 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_70HZ |             /* refresh rate = 70    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1600, 1200,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,     /* horiz timings   */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (189L << 16) | ((0000L * 65536L) / 10000L), /* freq = 189.0 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_72HZ |             /* refresh rate = 72    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1600, 1200,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0640, 0x0640, 0x06B0, 0x0760, 0x0880, 0x0880,     /* horiz timings   */
-            0x04B0, 0x04B0, 0x04BD, 0x04C0, 0x04EF, 0x04EF,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (198L << 16) | ((0000L * 65536L) / 10000L), /* freq = 198.0 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_75HZ |             /* refresh rate = 75    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1600, 1200,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,     /* horiz timings   */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (202L << 16) | ((5000L * 65536L) / 10000L), /* freq = 202.5 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_85HZ |             /* refresh rate = 85    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1600, 1200,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,     /* horiz timings   */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (229L << 16) | ((5000L * 65536L) / 10000L), /* freq = 229.5 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_90HZ |             /* refresh rate = 90    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1600, 1200,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0640, 0x0640, 0x06C0, 0x0770, 0x08A0, 0x08A0,     /* horiz timings   */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04F0, 0x04F0,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (251L << 16) | ((1820L * 65536L) / 10000L), /* freq = 251.182 MHz   */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_100HZ |            /* refresh rate = 100   */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1600, 1200,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0640, 0x0640, 0x06C0, 0x0770, 0x08A0, 0x08A0,     /* horiz timings   */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04F7, 0x04F7,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (280L << 16) | ((6400L * 65536L) / 10000L), /* freq = 280.64 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1600, 1200,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,    /* horiz timings   */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (162L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 162.0 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_70HZ |      /* refresh rate = 70    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1600, 1200,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,    /* horiz timings   */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (189L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 189.0 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_72HZ |      /* refresh rate = 72    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1600, 1200,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0640, 0x0640, 0x06B0, 0x0760, 0x0880, 0x0880,    /* horiz timings   */
+     0x04B0, 0x04B0, 0x04BD, 0x04C0, 0x04EF, 0x04EF,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (198L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 198.0 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_75HZ |      /* refresh rate = 75    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1600, 1200,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,    /* horiz timings   */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (202L << 16) | ((5000L * 65536L) / 10000L),        /* freq = 202.5 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_85HZ |      /* refresh rate = 85    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1600, 1200,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,    /* horiz timings   */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (229L << 16) | ((5000L * 65536L) / 10000L),        /* freq = 229.5 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_90HZ |      /* refresh rate = 90    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1600, 1200,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0640, 0x0640, 0x06C0, 0x0770, 0x08A0, 0x08A0,    /* horiz timings   */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04F0, 0x04F0,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (251L << 16) | ((1820L * 65536L) / 10000L),        /* freq = 251.182 MHz   */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_100HZ |     /* refresh rate = 100   */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1600, 1200,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0640, 0x0640, 0x06C0, 0x0770, 0x08A0, 0x08A0,    /* horiz timings   */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04F7, 0x04F7,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (280L << 16) | ((6400L * 65536L) / 10000L),        /* freq = 280.64 MHz    */
+     }
     ,
 
     /* 1600 x 1200  PANEL */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,      /* Panel Mode.          */
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            VG_MODEFLAG_PANELOUT |     /* Panel output.        */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,      /* negative syncs */
-            1600, 1200,                /* No scaling.          */
-            1600, 1200,                /* 1600x1200 Active.    */
-            1600, 1200,                /* 1600x1200 Panel.     */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,     /* horiz timings   */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (162L << 16) | ((0000L * 65536L) / 10000L), /* freq = 162.0 MHz     */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PANEL,     /* Panel Mode.          */
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     VG_MODEFLAG_PANELOUT |     /* Panel output.        */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC,     /* negative syncs */
+     1600, 1200,                /* No scaling.          */
+     1600, 1200,                /* 1600x1200 Active.    */
+     1600, 1200,                /* 1600x1200 Panel.     */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,    /* horiz timings   */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (162L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 162.0 MHz     */
+     }
     ,
 
     /* 1920x1440 */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1920, 1440,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0780, 0x0780, 0x0800, 0x08D0, 0x0A28, 0x0A28,     /* horiz timings   */
-            0x05A0, 0x05A0, 0x05A1, 0x05A4, 0x05DC, 0x05DC,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (234L << 16) | ((0000L * 65536L) / 10000L), /* freq = 234.0 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_70HZ |             /* refresh rate = 70    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1920, 1440,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0780, 0x0780, 0x0818, 0x08E8, 0x0A50, 0x0A50,     /* horiz timings   */
-            0x05A0, 0x05A0, 0x05A8, 0x05AB, 0x05E2, 0x05E2,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (278L << 16) | ((4000L * 65536L) / 10000L), /* freq = 278.4 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_72HZ |             /* refresh rate = 70    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1920, 1440,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0780, 0x0780, 0x0818, 0x08E8, 0x0A50, 0x0A50,     /* horiz timings   */
-            0x05A0, 0x05A0, 0x05A4, 0x05A7, 0x05EB, 0x05EB,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (288L << 16) | ((0000L * 65536L) / 10000L), /* freq = 288.0 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_75HZ |             /* refresh rate = 75    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1920, 1440,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0780, 0x0780, 0x0810, 0x08F0, 0x0A50, 0x0A50,     /* horiz timings   */
-            0x05A0, 0x05A0, 0x05A1, 0x05A4, 0x05DC, 0x05DC,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (297L << 16) | ((0000L * 65536L) / 10000L), /* freq = 297.0 MHz     */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_85HZ |             /* refresh rate = 85    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
-            | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP |
-            VG_SUPPORTFLAG_32BPP,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            0,
-            1920, 1440,                /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0780, 0x0780, 0x0818, 0x08F0, 0x0A60, 0x0A60,     /* horiz timings   */
-            0x05A0, 0x05A0, 0x05A1, 0x05A4, 0x05E8, 0x05E8,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings      */
-            (341L << 16) | ((3490L * 65536L) / 10000L), /* freq = 341.35 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1920, 1440,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0780, 0x0780, 0x0800, 0x08D0, 0x0A28, 0x0A28,    /* horiz timings   */
+     0x05A0, 0x05A0, 0x05A1, 0x05A4, 0x05DC, 0x05DC,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (234L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 234.0 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_70HZ |      /* refresh rate = 70    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1920, 1440,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0780, 0x0780, 0x0818, 0x08E8, 0x0A50, 0x0A50,    /* horiz timings   */
+     0x05A0, 0x05A0, 0x05A8, 0x05AB, 0x05E2, 0x05E2,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (278L << 16) | ((4000L * 65536L) / 10000L),        /* freq = 278.4 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_72HZ |      /* refresh rate = 70    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1920, 1440,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0780, 0x0780, 0x0818, 0x08E8, 0x0A50, 0x0A50,    /* horiz timings   */
+     0x05A0, 0x05A0, 0x05A4, 0x05A7, 0x05EB, 0x05EB,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (288L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 288.0 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_75HZ |      /* refresh rate = 75    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1920, 1440,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0780, 0x0780, 0x0810, 0x08F0, 0x0A50, 0x0A50,    /* horiz timings   */
+     0x05A0, 0x05A0, 0x05A1, 0x05A4, 0x05DC, 0x05DC,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (297L << 16) | ((0000L * 65536L) / 10000L),        /* freq = 297.0 MHz     */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_85HZ |      /* refresh rate = 85    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP
+     | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     0,
+     1920, 1440,                /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0780, 0x0780, 0x0818, 0x08F0, 0x0A60, 0x0A60,    /* horiz timings   */
+     0x05A0, 0x05A0, 0x05A1, 0x05A4, 0x05E8, 0x05E8,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings      */
+     (341L << 16) | ((3490L * 65536L) / 10000L),        /* freq = 341.35 MHz    */
+     }
     ,
 
 /*-------------------------------*/
@@ -1014,238 +965,237 @@ static const VG_DISPLAY_MODE CimarronDisplayModes[] = {
 
     /* 720 x 480i NTSC */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_NTSC |      /* NTSC Mode.           */
-            VG_SUPPORTFLAG_ADV7171 | VG_SUPPORTFLAG_SAA7127 |
-            VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_TVOUT,
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_INTERLACED | VG_MODEFLAG_TVOUT |        /* Interlaced TV output */
-            VG_MODEFLAG_HALFCLOCK |    /* DotPLL = 1/2 VOP     */
-            VG_MODEFLAG_INT_FLICKER,   /* Flicker Filter Out   */
-            720, 480,                  /* No downscaling.      */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x02D0, 0x02D0, 0x02E1, 0x0320, 0x035A, 0x035A,     /* horiz timings   */
-            0x00F0, 0x00F0, 0x00F4, 0x00F8, 0x0107, 0x0107,     /* vertical timings */
-            0x00F0, 0x00F0, 0x00F4, 0x00F8, 0x0106, 0x0106,     /*Even field timings */
-            (27L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 27.0 MHz      */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_NTSC |      /* NTSC Mode.           */
-            VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,        /* TV Mode. */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |     /* negative syncs */
-            VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,   /* TFT Output. */
-            640, 480,                  /* No downscaling.      */
-            640, 480,                  /* 640x480 active.      */
-            640, 480,                  /* 640x480 panel.       */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0280, 0x0280, 0x0333, 0x0373, 0x03A8, 0x03A8,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01F5, 0x01F7, 0x020D, 0x020D,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings.     */
-            (25L << 16) | ((1750L * 65536L) / 10000L),  /* freq = 25.175 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_NTSC |     /* NTSC Mode.           */
+     VG_SUPPORTFLAG_ADV7171 | VG_SUPPORTFLAG_SAA7127 |
+     VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_TVOUT,
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_INTERLACED | VG_MODEFLAG_TVOUT |       /* Interlaced TV output */
+     VG_MODEFLAG_HALFCLOCK |    /* DotPLL = 1/2 VOP     */
+     VG_MODEFLAG_INT_FLICKER,   /* Flicker Filter Out   */
+     720, 480,                  /* No downscaling.      */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x02D0, 0x02D0, 0x02E1, 0x0320, 0x035A, 0x035A,    /* horiz timings   */
+     0x00F0, 0x00F0, 0x00F4, 0x00F8, 0x0107, 0x0107,    /* vertical timings */
+     0x00F0, 0x00F0, 0x00F4, 0x00F8, 0x0106, 0x0106,    /*Even field timings */
+     (27L << 16) | ((0000L * 65536L) / 10000L), /* freq = 27.0 MHz      */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_NTSC |     /* NTSC Mode.           */
+     VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,       /* TV Mode. */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |    /* negative syncs */
+     VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,  /* TFT Output. */
+     640, 480,                  /* No downscaling.      */
+     640, 480,                  /* 640x480 active.      */
+     640, 480,                  /* 640x480 panel.       */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0280, 0x0280, 0x0333, 0x0373, 0x03A8, 0x03A8,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01F5, 0x01F7, 0x020D, 0x020D,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings.     */
+     (25L << 16) | ((1750L * 65536L) / 10000L), /* freq = 25.175 MHz    */
+     }
     ,
 
     /* 800 x 600 NTSC */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_8X6_NTSC |  /* 800x600 NTSC.        */
-            VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,        /* TV Mode. */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |     /* negative syncs */
-            VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,   /* Panel output */
-            800, 600,                  /* No downscaling.      */
-            800, 600,                  /* 800x600 active.      */
-            800, 600,                  /* 800x600 active.      */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x03A7, 0x03E7, 0x03F0, 0x03F0,     /* horiz timings   */
-            0x0258, 0x0258, 0x026A, 0x0272, 0x028A, 0x028A,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings.     */
-            (40L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 40.000 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_8X6_NTSC | /* 800x600 NTSC.        */
+     VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,       /* TV Mode. */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |    /* negative syncs */
+     VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,  /* Panel output */
+     800, 600,                  /* No downscaling.      */
+     800, 600,                  /* 800x600 active.      */
+     800, 600,                  /* 800x600 active.      */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x03A7, 0x03E7, 0x03F0, 0x03F0,    /* horiz timings   */
+     0x0258, 0x0258, 0x026A, 0x0272, 0x028A, 0x028A,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings.     */
+     (40L << 16) | ((0000L * 65536L) / 10000L), /* freq = 40.000 MHz    */
+     }
     ,
 
     /* 1024 x 768 NTSC */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_10X7_NTSC | /* 1024x768 NTSC.       */
-            VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,        /* TV Mode. */
-            VG_MODEFLAG_AVG_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |     /* negative syncs */
-            VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,   /* Panel output */
-            1024, 768,                 /* No downscaling.      */
-            1024, 768,                 /* 1024x768 active.     */
-            1024, 768,                 /* 1024x768 active.     */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0490, 0x04D0, 0x04E0, 0x04E0,     /* horiz timings   */
-            0x0300, 0x0300, 0x031B, 0x031D, 0x0339, 0x0339,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings.     */
-            (65L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 65.00 MHz     */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_10X7_NTSC |        /* 1024x768 NTSC.       */
+     VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,       /* TV Mode. */
+     VG_MODEFLAG_AVG_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |    /* negative syncs */
+     VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,  /* Panel output */
+     1024, 768,                 /* No downscaling.      */
+     1024, 768,                 /* 1024x768 active.     */
+     1024, 768,                 /* 1024x768 active.     */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0490, 0x04D0, 0x04E0, 0x04E0,    /* horiz timings   */
+     0x0300, 0x0300, 0x031B, 0x031D, 0x0339, 0x0339,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings.     */
+     (65L << 16) | ((0000L * 65536L) / 10000L), /* freq = 65.00 MHz     */
+     }
     ,
 
     /* 720 x 576i PAL */
 
     {VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PAL |      /* PAL Mode.            */
-            VG_SUPPORTFLAG_ADV7171 | VG_SUPPORTFLAG_SAA7127 | VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_TVOUT,    /* TV Mode.             */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_TVOUT | VG_MODEFLAG_INTERLACED |        /* Interlaced TV out. */
-            VG_MODEFLAG_HALFCLOCK |    /* DotPLL = 1/2 VOP     */
-            VG_MODEFLAG_INT_FLICKER,   /* Flicker Filter Out   */
-            720, 576,                  /* No downscaling.      */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x02D0, 0x02D0, 0x02E4, 0x0324, 0x0360, 0x0360,     /* horiz timings   */
-            0x0120, 0x0120, 0x0123, 0x0127, 0x0139, 0x0139,     /* vertical timings */
-            0x0120, 0x0120, 0x0123, 0x0127, 0x0138, 0x0138,     /* Even timings */
-            (27L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 27.0 MHz      */
-        }
+     VG_SUPPORTFLAG_ADV7171 | VG_SUPPORTFLAG_SAA7127 | VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_TVOUT,   /* TV Mode.             */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_TVOUT | VG_MODEFLAG_INTERLACED |       /* Interlaced TV out. */
+     VG_MODEFLAG_HALFCLOCK |    /* DotPLL = 1/2 VOP     */
+     VG_MODEFLAG_INT_FLICKER,   /* Flicker Filter Out   */
+     720, 576,                  /* No downscaling.      */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x02D0, 0x02D0, 0x02E4, 0x0324, 0x0360, 0x0360,    /* horiz timings   */
+     0x0120, 0x0120, 0x0123, 0x0127, 0x0139, 0x0139,    /* vertical timings */
+     0x0120, 0x0120, 0x0123, 0x0127, 0x0138, 0x0138,    /* Even timings */
+     (27L << 16) | ((0000L * 65536L) / 10000L), /* freq = 27.0 MHz      */
+     }
     ,
 
     {VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_PAL |      /* PAL Mode.            */
-            VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,        /* TV Mode. */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |     /* negative syncs */
-            VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,   /* Panel output */
-            640, 480,                  /* No downscaling.      */
-            640, 480,                  /* No mode dimensions.  */
-            640, 480,                  /* 640x480 active.      */
-            0, 0, 0, 0, 0,             /* 640x480 panel.       */
-            0x0280, 0x0280, 0x030F, 0x034F, 0x0360, 0x0360,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01F5, 0x01F7, 0x020D, 0x020D,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings.     */
-            (25L << 16) | ((1750L * 65536L) / 10000L),  /* freq = 25.175 MHz    */
-        }
+     VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,       /* TV Mode. */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |    /* negative syncs */
+     VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,  /* Panel output */
+     640, 480,                  /* No downscaling.      */
+     640, 480,                  /* No mode dimensions.  */
+     640, 480,                  /* 640x480 active.      */
+     0, 0, 0, 0, 0,             /* 640x480 panel.       */
+     0x0280, 0x0280, 0x030F, 0x034F, 0x0360, 0x0360,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01F5, 0x01F7, 0x020D, 0x020D,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings.     */
+     (25L << 16) | ((1750L * 65536L) / 10000L), /* freq = 25.175 MHz    */
+     }
     ,
 
     /* 800 x 600 PAL */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_8X6_PAL |   /* 800x600 PAL.         */
-            VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,        /* TV Mode. */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |     /* negative syncs */
-            VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,   /* Panel output */
-            800, 600,                  /* No downscaling.      */
-            800, 600,                  /* 800x600 active.      */
-            800, 600,                  /* 800x600 active.      */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0320, 0x0320, 0x03A7, 0x03E7, 0x03F0, 0x03F0,     /* horiz timings   */
-            0x0258, 0x0258, 0x0270, 0x0272, 0x028A, 0x028A,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings.     */
-            (40L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 40.000 MHz    */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_8X6_PAL |  /* 800x600 PAL.         */
+     VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,       /* TV Mode. */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |    /* negative syncs */
+     VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,  /* Panel output */
+     800, 600,                  /* No downscaling.      */
+     800, 600,                  /* 800x600 active.      */
+     800, 600,                  /* 800x600 active.      */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0320, 0x0320, 0x03A7, 0x03E7, 0x03F0, 0x03F0,    /* horiz timings   */
+     0x0258, 0x0258, 0x0270, 0x0272, 0x028A, 0x028A,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings.     */
+     (40L << 16) | ((0000L * 65536L) / 10000L), /* freq = 40.000 MHz    */
+     }
     ,
 
     /* 1024 x 768 PAL */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_10X7_PAL |  /* 1024x768 NTSC.       */
-            VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,        /* TV Mode. */
-            VG_MODEFLAG_AVG_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |     /* negative syncs */
-            VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,   /* Panel output */
-            1024, 768,                 /* No downscaling.      */
-            1024, 768,                 /* 1024x768 active.     */
-            1024, 768,                 /* 1024x768 active.     */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0400, 0x0400, 0x0490, 0x04d0, 0x04e0, 0x04e0,     /* horiz timings   */
-            0x0300, 0x0300, 0x031b, 0x031d, 0x0339, 0x0339,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings.     */
-            (65L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 65.00 MHz     */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_10X7_PAL | /* 1024x768 NTSC.       */
+     VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,       /* TV Mode. */
+     VG_MODEFLAG_AVG_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_NEG_HSYNC | VG_MODEFLAG_NEG_VSYNC |    /* negative syncs */
+     VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,  /* Panel output */
+     1024, 768,                 /* No downscaling.      */
+     1024, 768,                 /* 1024x768 active.     */
+     1024, 768,                 /* 1024x768 active.     */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0400, 0x0400, 0x0490, 0x04d0, 0x04e0, 0x04e0,    /* horiz timings   */
+     0x0300, 0x0300, 0x031b, 0x031d, 0x0339, 0x0339,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings.     */
+     (65L << 16) | ((0000L * 65536L) / 10000L), /* freq = 65.00 MHz     */
+     }
     ,
 
     /* 720 x 480p HDTV */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_480P |      /* 720x480P.            */
-            VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_TVOUT,      /* TV Mode. */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_TVOUT,         /* Progressive TV out.  */
-            720, 480,                  /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x02D0, 0x02D0, 0x02E0, 0x0328, 0x035A, 0x035A,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01E1, 0x01E3, 0x020D, 0x020D,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings.     */
-            (27L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 27.0 MHz      */
-        }
-    ,
-
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_480P |      /* 720x480P.            */
-            VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,        /* TV Mode. */
-            VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
-            VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,   /* Panel output */
-            720, 480,                  /* No scaling.          */
-            720, 480,                  /* 720x480 active.      */
-            720, 480,                  /* 720x480 panel.       */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x02D0, 0x02D0, 0x02E3, 0x0323, 0x035A, 0x035A,     /* horiz timings   */
-            0x01E0, 0x01E0, 0x01E4, 0x01EA, 0x020D, 0x020D,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings.     */
-            (27L << 16) | ((0000L * 65536L) / 10000L),  /* freq = 27.0 MHz      */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_480P |     /* 720x480P.            */
+     VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_TVOUT,     /* TV Mode. */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_TVOUT,         /* Progressive TV out.  */
+     720, 480,                  /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x02D0, 0x02D0, 0x02E0, 0x0328, 0x035A, 0x035A,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01E1, 0x01E3, 0x020D, 0x020D,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings.     */
+     (27L << 16) | ((0000L * 65536L) / 10000L), /* freq = 27.0 MHz      */
+     }
+    ,
+
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_480P |     /* 720x480P.            */
+     VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,       /* TV Mode. */
+     VG_MODEFLAG_LOW_BAND |     /* Low bandwidth mode.  */
+     VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,  /* Panel output */
+     720, 480,                  /* No scaling.          */
+     720, 480,                  /* 720x480 active.      */
+     720, 480,                  /* 720x480 panel.       */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x02D0, 0x02D0, 0x02E3, 0x0323, 0x035A, 0x035A,    /* horiz timings   */
+     0x01E0, 0x01E0, 0x01E4, 0x01EA, 0x020D, 0x020D,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings.     */
+     (27L << 16) | ((0000L * 65536L) / 10000L), /* freq = 27.0 MHz      */
+     }
     ,
 
     /* 1280x720p HDTV */
 
     {VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_720P |     /* 1280x720P            */
-            VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_TVOUT,      /* TV Mode. */
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            VG_MODEFLAG_TVOUT,         /* Progressive TV out   */
-            1280, 720,                 /* No scaling.          */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0546, 0x0596, 0x0672, 0x0672,     /* horiz timings   */
-            0x02D0, 0x02D0, 0x02D3, 0x02D8, 0x02EE, 0x02EE,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* even timings         */
-            (74L << 16) | ((2500L * 65536L) / 10000L),  /* freq = 74.25 MHz     */
-        }
+     VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_TVOUT,     /* TV Mode. */
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     VG_MODEFLAG_TVOUT,         /* Progressive TV out   */
+     1280, 720,                 /* No scaling.          */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0546, 0x0596, 0x0672, 0x0672,    /* horiz timings   */
+     0x02D0, 0x02D0, 0x02D3, 0x02D8, 0x02EE, 0x02EE,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* even timings         */
+     (74L << 16) | ((2500L * 65536L) / 10000L), /* freq = 74.25 MHz     */
+     }
     ,
 
     {VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_720P |     /* 1280x720P            */
-            VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,        /* TV Mode. */
-            VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
-            VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,   /* Panel output */
-            1280, 720,                 /* No scaling.          */
-            1280, 720,                 /* 1280x720 active.     */
-            1280, 720,                 /* 1280x720 panel.      */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0500, 0x0500, 0x0547, 0x0597, 0x0672, 0x0672,     /* horiz timings   */
-            0x02D0, 0x02D0, 0x02D4, 0x02D9, 0x02EE, 0x02EE,     /* vertical timings */
-            0, 0, 0, 0, 0, 0,          /* No even timings.     */
-            (74L << 16) | ((2500L * 65536L) / 10000L),  /* freq = 74.25 MHz     */
-        }
+     VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,       /* TV Mode. */
+     VG_MODEFLAG_AVG_BAND |     /* Avg bandwidth mode.  */
+     VG_MODEFLAG_PANELOUT | VG_MODEFLAG_INVERT_SHFCLK,  /* Panel output */
+     1280, 720,                 /* No scaling.          */
+     1280, 720,                 /* 1280x720 active.     */
+     1280, 720,                 /* 1280x720 panel.      */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0500, 0x0500, 0x0547, 0x0597, 0x0672, 0x0672,    /* horiz timings   */
+     0x02D0, 0x02D0, 0x02D4, 0x02D9, 0x02EE, 0x02EE,    /* vertical timings */
+     0, 0, 0, 0, 0, 0,          /* No even timings.     */
+     (74L << 16) | ((2500L * 65536L) / 10000L), /* freq = 74.25 MHz     */
+     }
     ,
 
     /* 1920x1080i HDTV */
 
-    {VG_SUPPORTFLAG_60HZ |             /* refresh rate = 60    */
-            VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_1080I |     /* 1920x1080i Mode.     */
-            VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_FS454 |
-            VG_SUPPORTFLAG_TVOUT,
-            VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
-            VG_MODEFLAG_INTERLACED | VG_MODEFLAG_TVOUT |        /* Interlaced TV out */
-            /* Interlaced addressing */
-            VG_MODEFLAG_INT_ADDRESS | VG_MODEFLAG_INVERT_SHFCLK,
-            1920, 1080,                /* 2:1 downscaling.     */
-            0, 0,                      /* No mode dimensions.  */
-            0, 0,                      /* No panel dimensions. */
-            0, 0, 0, 0, 0,             /* No panel registers   */
-            0x0780, 0x0780, 0x07AD, 0x0805, 0x0898, 0x0898,     /* horiz timings   */
-            0x021C, 0x021C, 0x021E, 0x0226, 0x0233, 0x0233,     /* vertical timings */
-            0x021C, 0x021C, 0x021E, 0x0226, 0x0232, 0x0232,     /*even field timings */
-            (74L << 16) | ((2500L * 65536L) / 10000L),  /* freq = 74.25 MHz     */
-        }
+    {VG_SUPPORTFLAG_60HZ |      /* refresh rate = 60    */
+     VG_SUPPORTFLAG_8BPP | VG_SUPPORTFLAG_12BPP | VG_SUPPORTFLAG_15BPP | VG_SUPPORTFLAG_16BPP | VG_SUPPORTFLAG_24BPP | VG_SUPPORTFLAG_32BPP | VG_SUPPORTFLAG_1080I |    /* 1920x1080i Mode.     */
+     VG_SUPPORTFLAG_ADV7300 | VG_SUPPORTFLAG_FS454 | VG_SUPPORTFLAG_TVOUT,
+     VG_MODEFLAG_HIGH_BAND |    /* High bandwidth mode. */
+     VG_MODEFLAG_INTERLACED | VG_MODEFLAG_TVOUT |       /* Interlaced TV out */
+     /* Interlaced addressing */
+     VG_MODEFLAG_INT_ADDRESS | VG_MODEFLAG_INVERT_SHFCLK,
+     1920, 1080,                /* 2:1 downscaling.     */
+     0, 0,                      /* No mode dimensions.  */
+     0, 0,                      /* No panel dimensions. */
+     0, 0, 0, 0, 0,             /* No panel registers   */
+     0x0780, 0x0780, 0x07AD, 0x0805, 0x0898, 0x0898,    /* horiz timings   */
+     0x021C, 0x021C, 0x021E, 0x0226, 0x0233, 0x0233,    /* vertical timings */
+     0x021C, 0x021C, 0x021E, 0x0226, 0x0232, 0x0232,    /*even field timings */
+     (74L << 16) | ((2500L * 65536L) / 10000L), /* freq = 74.25 MHz     */
+     }
     ,
 };
 
@@ -1258,127 +1208,127 @@ static const VG_DISPLAY_MODE CimarronDisplayModes[] = {
 
 static const PLL_FREQUENCY CimarronPLLFrequencies[] = {
     {0x000031AC, (24L << 16) | ((9230L * 65536L) / 10000L)}
-    ,                                  /* 24.9230, - 4,27,13 */
+    ,                           /* 24.9230, - 4,27,13 */
     {0x0000215D, (25L << 16) | ((1750L * 65536L) / 10000L)}
-    ,                                  /* 25.1750, - 3,22,14 */
+    ,                           /* 25.1750, - 3,22,14 */
     {0x00001087, (27L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 27.0000, - 2, 9, 8 */
+    ,                           /* 27.0000, - 2, 9, 8 */
     {0x0000216C, (28L << 16) | ((3220L * 65536L) / 10000L)}
-    ,                                  /* 28.3220, - 3,23,13 */
+    ,                           /* 28.3220, - 3,23,13 */
     {0x0000218D, (28L << 16) | ((5600L * 65536L) / 10000L)}
-    ,                                  /* 28.5600, - 3,25,14 */
+    ,                           /* 28.5600, - 3,25,14 */
     {0x000010C9, (31L << 16) | ((2000L * 65536L) / 10000L)}
-    ,                                  /* 31.2000, - 2,13,10 */
+    ,                           /* 31.2000, - 2,13,10 */
     {0x00003147, (31L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 31.5000, - 4,21, 8 */
+    ,                           /* 31.5000, - 4,21, 8 */
     {0x000010A7, (33L << 16) | ((320L * 65536L) / 10000L)}
-    ,                                  /* 33.0320, - 2,11, 8 */
+    ,                           /* 33.0320, - 2,11, 8 */
     {0x00002159, (35L << 16) | ((1120L * 65536L) / 10000L)}
-    ,                                  /* 35.1120, - 3,22,10 */
+    ,                           /* 35.1120, - 3,22,10 */
     {0x00004249, (35L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 35.5000, - 5,37,10 */
+    ,                           /* 35.5000, - 5,37,10 */
     {0x00000057, (36L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 36.0000, - 1, 6, 8 */
+    ,                           /* 36.0000, - 1, 6, 8 */
     {0x0000219A, (37L << 16) | ((8890L * 65536L) / 10000L)}
-    ,                                  /* 37.8890, - 3,26,11 */
+    ,                           /* 37.8890, - 3,26,11 */
     {0x00002158, (39L << 16) | ((1680L * 65536L) / 10000L)}
-    ,                                  /* 39.1680, - 3,22, 9 */
+    ,                           /* 39.1680, - 3,22, 9 */
     {0x00000045, (40L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 40.0000, - 1, 5, 6 */
+    ,                           /* 40.0000, - 1, 5, 6 */
     {0x00000089, (43L << 16) | ((1630L * 65536L) / 10000L)}
-    ,                                  /* 43.1630, - 1, 9,10 */
+    ,                           /* 43.1630, - 1, 9,10 */
     {0x000010E7, (44L << 16) | ((9000L * 65536L) / 10000L)}
-    ,                                  /* 44.9000, - 2,15, 8 */
+    ,                           /* 44.9000, - 2,15, 8 */
     {0x00002136, (45L << 16) | ((7200L * 65536L) / 10000L)}
-    ,                                  /* 45.7200, - 3,20, 7 */
+    ,                           /* 45.7200, - 3,20, 7 */
     {0x00003207, (49L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 49.5000, - 4,33, 8 */
+    ,                           /* 49.5000, - 4,33, 8 */
     {0x00002187, (50L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 50.0000, - 3,25, 8 */
+    ,                           /* 50.0000, - 3,25, 8 */
     {0x00004286, (56L << 16) | ((2500L * 65536L) / 10000L)}
-    ,                                  /* 56.2500, - 5,41, 7 */
+    ,                           /* 56.2500, - 5,41, 7 */
     {0x000010E5, (60L << 16) | ((650L * 65536L) / 10000L)}
-    ,                                  /* 60.0650, - 2,15, 6 */
+    ,                           /* 60.0650, - 2,15, 6 */
     {0x00004214, (65L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 65.0000, - 5,34, 5 */
+    ,                           /* 65.0000, - 5,34, 5 */
     {0x00001105, (68L << 16) | ((1790L * 65536L) / 10000L)}
-    ,                                  /* 68.1790, - 2,17, 6 */
+    ,                           /* 68.1790, - 2,17, 6 */
     {0x000031E4, (74L << 16) | ((2500L * 65536L) / 10000L)}
-    ,                                  /* 74.2500, - 4,31, 5 */
+    ,                           /* 74.2500, - 4,31, 5 */
     {0x00003183, (75L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 75.0000, - 4,25, 4 */
+    ,                           /* 75.0000, - 4,25, 4 */
     {0x00004284, (78L << 16) | ((7500L * 65536L) / 10000L)}
-    ,                                  /* 78.7500, - 5,41, 5 */
+    ,                           /* 78.7500, - 5,41, 5 */
     {0x00001104, (81L << 16) | ((6000L * 65536L) / 10000L)}
-    ,                                  /* 81.6000, - 2,17, 5 */
+    ,                           /* 81.6000, - 2,17, 5 */
     {0x00006363, (94L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 94.5000, - 7,55, 4 */
+    ,                           /* 94.5000, - 7,55, 4 */
     {0x00005303, (97L << 16) | ((5200L * 65536L) / 10000L)}
-    ,                                  /* 97.5200, - 6,49, 4 */
+    ,                           /* 97.5200, - 6,49, 4 */
     {0x00002183, (100L << 16) | ((1870L * 65536L) / 10000L)}
-    ,                                  /* 100.187, - 3,25, 4 */
+    ,                           /* 100.187, - 3,25, 4 */
     {0x00002122, (101L << 16) | ((4200L * 65536L) / 10000L)}
-    ,                                  /* 101.420, - 3,19, 3 */
+    ,                           /* 101.420, - 3,19, 3 */
     {0x000041B1, (106L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 106.50,  - 5,28, 2 */
+    ,                           /* 106.50,  - 5,28, 2 */
     {0x00001081, (108L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 108.00,  - 2, 9, 2 */
+    ,                           /* 108.00,  - 2, 9, 2 */
     {0x00006201, (113L << 16) | ((3100L * 65536L) / 10000L)}
-    ,                                  /* 113.31,  - 7,33, 2 */
+    ,                           /* 113.31,  - 7,33, 2 */
     {0x00000041, (119L << 16) | ((6500L * 65536L) / 10000L)}
-    ,                                  /* 119.65,  - 1, 5, 2 */
+    ,                           /* 119.65,  - 1, 5, 2 */
     {0x000041A1, (129L << 16) | ((6000L * 65536L) / 10000L)}
-    ,                                  /* 129.60,  - 5,27, 2 */
+    ,                           /* 129.60,  - 5,27, 2 */
     {0x00002182, (133L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 133.50,  - 3,25, 3 */
+    ,                           /* 133.50,  - 3,25, 3 */
     {0x000041B1, (135L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 135.00,  - 5,28, 2 */
+    ,                           /* 135.00,  - 5,28, 2 */
     {0x00000051, (144L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 144.00,  - 1, 6, 2 */
+    ,                           /* 144.00,  - 1, 6, 2 */
     {0x000041E1, (148L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 148.50,  - 5,31, 2 */
+    ,                           /* 148.50,  - 5,31, 2 */
     {0x000062D1, (157L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 157.50,  - 7,46, 2 */
+    ,                           /* 157.50,  - 7,46, 2 */
     {0x000031A1, (162L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 162.00,  - 4,27, 2 */
+    ,                           /* 162.00,  - 4,27, 2 */
     {0x00000061, (169L << 16) | ((2030L * 65536L) / 10000L)}
-    ,                                  /* 169.203, - 1, 7, 2 */
+    ,                           /* 169.203, - 1, 7, 2 */
     {0x00004231, (172L << 16) | ((8000L * 65536L) / 10000L)}
-    ,                                  /* 172.800, - 5,36, 2 */
+    ,                           /* 172.800, - 5,36, 2 */
     {0x00002151, (175L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 175.50,  - 3,22, 2 */
+    ,                           /* 175.50,  - 3,22, 2 */
     {0x000052E1, (189L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 189.00,  - 6,47, 2 */
+    ,                           /* 189.00,  - 6,47, 2 */
     {0x00000071, (192L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 192.00,  - 1, 8, 2 */
+    ,                           /* 192.00,  - 1, 8, 2 */
     {0x00003201, (198L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 198.00,  - 4,33, 2 */
+    ,                           /* 198.00,  - 4,33, 2 */
     {0x00004291, (202L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 202.50,  - 5,42, 2 */
+    ,                           /* 202.50,  - 5,42, 2 */
     {0x00001101, (204L << 16) | ((7500L * 65536L) / 10000L)}
-    ,                                  /* 204.75,  - 2,17, 2 */
+    ,                           /* 204.75,  - 2,17, 2 */
     {0x00007481, (218L << 16) | ((2500L * 65536L) / 10000L)}
-    ,                                  /* 218.25,  - 8,73, 2 */
+    ,                           /* 218.25,  - 8,73, 2 */
     {0x00004170, (229L << 16) | ((5000L * 65536L) / 10000L)}
-    ,                                  /* 229.50,  - 5,24, 1 */
+    ,                           /* 229.50,  - 5,24, 1 */
     {0x00006210, (234L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 234.00,  - 7,34, 1 */
+    ,                           /* 234.00,  - 7,34, 1 */
     {0x00003140, (251L << 16) | ((1820L * 65536L) / 10000L)}
-    ,                                  /* 251.182, - 4,21, 1 */
+    ,                           /* 251.182, - 4,21, 1 */
     {0x00006250, (261L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 261.00,  - 7,38, 1 */
+    ,                           /* 261.00,  - 7,38, 1 */
     {0x000041C0, (278L << 16) | ((4000L * 65536L) / 10000L)}
-    ,                                  /* 278.40,  - 5,29, 1 */
+    ,                           /* 278.40,  - 5,29, 1 */
     {0x00005220, (280L << 16) | ((6400L * 65536L) / 10000L)}
-    ,                                  /* 280.64,  - 6,35, 1 */
+    ,                           /* 280.64,  - 6,35, 1 */
     {0x00000050, (288L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 288.00,  - 1, 6, 1 */
+    ,                           /* 288.00,  - 1, 6, 1 */
     {0x000041E0, (297L << 16) | ((0000L * 65536L) / 10000L)}
-    ,                                  /* 297.00,  - 5,31, 1 */
+    ,                           /* 297.00,  - 5,31, 1 */
     {0x00002130, (320L << 16) | ((2070L * 65536L) / 10000L)}
-    ,                                  /* 320.207, - 3,20, 1 */
+    ,                           /* 320.207, - 3,20, 1 */
     {0x00006310, (341L << 16) | ((3490L * 65536L) / 10000L)}
-                                       /* 341.349, - 7,50, 1 */
+    /* 341.349, - 7,50, 1 */
 };
 
 #define NUM_CIMARRON_PLL_FREQUENCIES sizeof(CimarronPLLFrequencies) / \
@@ -1389,519 +1339,519 @@ static const PLL_FREQUENCY CimarronPLLFrequencies[] = {
 /*-----------------------------------*/
 
 static const unsigned long CimarronHorizontalGraphicsFilter[][2] = {
-    {0x1284A7D5, 0x000017D5},          /*  -43,  297,  296,  -43,    5  */
-    {0x12A497D7, 0x000013D6},          /*  -41,  293,  298,  -42,    4  */
-    {0x12D48BD7, 0x000013D6},          /*  -41,  290,  301,  -42,    4  */
-    {0x13147FD7, 0x000013D5},          /*  -41,  287,  305,  -43,    4  */
-    {0x133473D8, 0x000013D5},          /*  -40,  284,  307,  -43,    4  */
-    {0x136467D8, 0x000013D5},          /*  -40,  281,  310,  -43,    4  */
-    {0x13945FD8, 0x000013D4},          /*  -40,  279,  313,  -44,    4  */
-    {0x13B453D9, 0x000013D4},          /*  -39,  276,  315,  -44,    4  */
-    {0x13E447D9, 0x000013D4},          /*  -39,  273,  318,  -44,    4  */
-    {0x14143BDA, 0x000013D3},          /*  -38,  270,  321,  -45,    4  */
-    {0x143433DA, 0x000013D3},          /*  -38,  268,  323,  -45,    4  */
-    {0x146427DA, 0x000013D3},          /*  -38,  265,  326,  -45,    4  */
-    {0x14941BDB, 0x000013D2},          /*  -37,  262,  329,  -46,    4  */
-    {0x14C40FDB, 0x000013D2},          /*  -37,  259,  332,  -46,    4  */
-    {0x14F407DA, 0x000017D1},          /*  -38,  257,  335,  -47,    5  */
-    {0x1503FBDC, 0x000013D2},          /*  -36,  254,  336,  -46,    4  */
-    {0x1543F3DB, 0x000017D0},          /*  -37,  252,  340,  -48,    5  */
-    {0x1563E3DD, 0x000013D1},          /*  -35,  248,  342,  -47,    4  */
-    {0x1593D7DD, 0x000013D1},          /*  -35,  245,  345,  -47,    4  */
-    {0x15B3CFDD, 0x000013D1},          /*  -35,  243,  347,  -47,    4  */
-    {0x15E3C3DE, 0x000013D0},          /*  -34,  240,  350,  -48,    4  */
-    {0x1613B7DE, 0x000013D0},          /*  -34,  237,  353,  -48,    4  */
-    {0x1633ABDF, 0x000013D0},          /*  -33,  234,  355,  -48,    4  */
-    {0x16639FDF, 0x000013D0},          /*  -33,  231,  358,  -48,    4  */
-    {0x167397E0, 0x000013D0},          /*  -32,  229,  359,  -48,    4  */
-    {0x16B38BE0, 0x000013CF},          /*  -32,  226,  363,  -49,    4  */
-    {0x16E383DF, 0x000017CE},          /*  -33,  224,  366,  -50,    5  */
-    {0x170373E1, 0x000013CF},          /*  -31,  220,  368,  -49,    4  */
-    {0x17236BE1, 0x000013CF},          /*  -31,  218,  370,  -49,    4  */
-    {0x17435FE2, 0x000013CF},          /*  -30,  215,  372,  -49,    4  */
-    {0x177353E2, 0x000013CF},          /*  -30,  212,  375,  -49,    4  */
-    {0x17B34BE1, 0x000017CD},          /*  -31,  210,  379,  -51,    5  */
-    {0x17C33FE3, 0x000013CE},          /*  -29,  207,  380,  -50,    4  */
-    {0x17F333E3, 0x000013CE},          /*  -29,  204,  383,  -50,    4  */
-    {0x181327E4, 0x000013CE},          /*  -28,  201,  385,  -50,    4  */
-    {0x18431FE3, 0x000017CD},          /*  -29,  199,  388,  -51,    5  */
-    {0x186313E4, 0x000013CE},          /*  -28,  196,  390,  -50,    4  */
-    {0x188307E5, 0x000013CE},          /*  -27,  193,  392,  -50,    4  */
-    {0x18B2FBE5, 0x000013CE},          /*  -27,  190,  395,  -50,    4  */
-    {0x18C2F3E6, 0x000013CE},          /*  -26,  188,  396,  -50,    4  */
-    {0x18F2E7E6, 0x000013CE},          /*  -26,  185,  399,  -50,    4  */
-    {0x1912DBE7, 0x000013CE},          /*  -25,  182,  401,  -50,    4  */
-    {0x1952D3E6, 0x000017CC},          /*  -26,  180,  405,  -52,    5  */
-    {0x1972CBE6, 0x000017CC},          /*  -26,  178,  407,  -52,    5  */
-    {0x1992BFE7, 0x000017CC},          /*  -25,  175,  409,  -52,    5  */
-    {0x19C2B3E7, 0x000017CC},          /*  -25,  172,  412,  -52,    5  */
-    {0x19D2A7E9, 0x000013CD},          /*  -23,  169,  413,  -51,    4  */
-    {0x1A029FE8, 0x000017CC},          /*  -24,  167,  416,  -52,    5  */
-    {0x1A1293E9, 0x000013CE},          /*  -23,  164,  417,  -50,    4  */
-    {0x1A3287EA, 0x000013CE},          /*  -22,  161,  419,  -50,    4  */
-    {0x1A627FE9, 0x000017CD},          /*  -23,  159,  422,  -51,    5  */
-    {0x1A7273EB, 0x000013CE},          /*  -21,  156,  423,  -50,    4  */
-    {0x1AA267EB, 0x000013CE},          /*  -21,  153,  426,  -50,    4  */
-    {0x1AC25FEB, 0x000013CE},          /*  -21,  151,  428,  -50,    4  */
-    {0x1AE253EC, 0x000013CE},          /*  -20,  148,  430,  -50,    4  */
-    {0x1B124BEB, 0x000017CD},          /*  -21,  146,  433,  -51,    5  */
-    {0x1B223FED, 0x000013CE},          /*  -19,  143,  434,  -50,    4  */
-    {0x1B5237EC, 0x000017CD},          /*  -20,  141,  437,  -51,    5  */
-    {0x1B622BED, 0x000013CF},          /*  -19,  138,  438,  -49,    4  */
-    {0x1B821FEE, 0x000013CF},          /*  -18,  135,  440,  -49,    4  */
-    {0x1BA217EE, 0x000013CF},          /*  -18,  133,  442,  -49,    4  */
-    {0x1BC20BEF, 0x000013CF},          /*  -17,  130,  444,  -49,    4  */
-    {0x1BE203EF, 0x000013CF},          /*  -17,  128,  446,  -49,    4  */
-    {0x1C01FBEE, 0x000017CF},          /*  -18,  126,  448,  -49,    5  */
-    {0x1C11EFF0, 0x000013D0},          /*  -16,  123,  449,  -48,    4  */
-    {0x1C41E7EF, 0x000017CF},          /*  -17,  121,  452,  -49,    5  */
-    {0x1C61DFEF, 0x000017CF},          /*  -17,  119,  454,  -49,    5  */
-    {0x1C61D3F1, 0x000013D1},          /*  -15,  116,  454,  -47,    4  */
-    {0x1C91CBF0, 0x000017D0},          /*  -16,  114,  457,  -48,    5  */
-    {0x1CA1BFF2, 0x000013D1},          /*  -14,  111,  458,  -47,    4  */
-    {0x1CC1B3F2, 0x000013D2},          /*  -14,  108,  460,  -46,    4  */
-    {0x1CE1AFF1, 0x000017D1},          /*  -15,  107,  462,  -47,    5  */
-    {0x1CF1A3F3, 0x000013D2},          /*  -13,  104,  463,  -46,    4  */
-    {0x1D1197F3, 0x000013D3},          /*  -13,  101,  465,  -45,    4  */
-    {0x1D3197F2, 0x000013D2},          /*  -14,  101,  467,  -46,    4  */
-    {0x1D518BF3, 0x000013D2},          /*  -13,   98,  469,  -46,    4  */
-    {0x1D6183F3, 0x000013D3},          /*  -13,   96,  470,  -45,    4  */
-    {0x1D817BF3, 0x000013D3},          /*  -13,   94,  472,  -45,    4  */
-    {0x1D916FF4, 0x000013D4},          /*  -12,   91,  473,  -44,    4  */
-    {0x1DB167F4, 0x000013D4},          /*  -12,   89,  475,  -44,    4  */
-    {0x1DC15FF4, 0x000013D5},          /*  -12,   87,  476,  -43,    4  */
-    {0x1DE153F5, 0x000013D5},          /*  -11,   84,  478,  -43,    4  */
-    {0x1DF14BF5, 0x000013D6},          /*  -11,   82,  479,  -42,    4  */
-    {0x1E1143F5, 0x000013D6},          /*  -11,   80,  481,  -42,    4  */
-    {0x1E1137F7, 0x00000FD8},          /*   -9,   77,  481,  -40,    3  */
-    {0x1E3133F6, 0x000013D7},          /*  -10,   76,  483,  -41,    4  */
-    {0x1E412BF6, 0x000013D8},          /*  -10,   74,  484,  -40,    4  */
-    {0x1E611FF7, 0x000013D8},          /*   -9,   71,  486,  -40,    4  */
-    {0x1E7117F7, 0x000013D9},          /*   -9,   69,  487,  -39,    4  */
-    {0x1E810FF7, 0x000013DA},          /*   -9,   67,  488,  -38,    4  */
-    {0x1E9107F8, 0x000013DA},          /*   -8,   65,  489,  -38,    4  */
-    {0x1EA0FFF8, 0x000013DB},          /*   -8,   63,  490,  -37,    4  */
-    {0x1EB0F3F9, 0x00000FDD},          /*   -7,   60,  491,  -35,    3  */
-    {0x1ED0EFF8, 0x000013DC},          /*   -8,   59,  493,  -36,    4  */
-    {0x1EE0E7F9, 0x00000FDD},          /*   -7,   57,  494,  -35,    3  */
-    {0x1EF0DFF9, 0x00000FDE},          /*   -7,   55,  495,  -34,    3  */
-    {0x1F00D7F9, 0x00000FDF},          /*   -7,   53,  496,  -33,    3  */
-    {0x1F10CFFA, 0x00000FDF},          /*   -6,   51,  497,  -33,    3  */
-    {0x1F20C7FA, 0x00000FE0},          /*   -6,   49,  498,  -32,    3  */
-    {0x1F20C3FA, 0x00000FE1},          /*   -6,   48,  498,  -31,    3  */
-    {0x1F30BBFA, 0x00000FE2},          /*   -6,   46,  499,  -30,    3  */
-    {0x1F40AFFB, 0x00000FE3},          /*   -5,   43,  500,  -29,    3  */
-    {0x1F50A7FB, 0x00000FE4},          /*   -5,   41,  501,  -28,    3  */
-    {0x1F60A3FB, 0x00000FE4},          /*   -5,   40,  502,  -28,    3  */
-    {0x1F709BFB, 0x00000FE5},          /*   -5,   38,  503,  -27,    3  */
-    {0x1F7093FC, 0x00000FE6},          /*   -4,   36,  503,  -26,    3  */
-    {0x1F808FFC, 0x00000BE7},          /*   -4,   35,  504,  -25,    2  */
-    {0x1F9087FC, 0x00000BE8},          /*   -4,   33,  505,  -24,    2  */
-    {0x1F9083FC, 0x00000BE9},          /*   -4,   32,  505,  -23,    2  */
-    {0x1FA077FD, 0x00000BEA},          /*   -3,   29,  506,  -22,    2  */
-    {0x1FA073FD, 0x00000BEB},          /*   -3,   28,  506,  -21,    2  */
-    {0x1FB06BFD, 0x00000BEC},          /*   -3,   26,  507,  -20,    2  */
-    {0x1FC063FD, 0x00000BED},          /*   -3,   24,  508,  -19,    2  */
-    {0x1FC05BFE, 0x00000BEE},          /*   -2,   22,  508,  -18,    2  */
-    {0x1FC057FE, 0x00000BEF},          /*   -2,   21,  508,  -17,    2  */
-    {0x1FD053FE, 0x000007F0},          /*   -2,   20,  509,  -16,    1  */
-    {0x1FD04BFE, 0x000007F2},          /*   -2,   18,  509,  -14,    1  */
-    {0x1FE043FE, 0x000007F3},          /*   -2,   16,  510,  -13,    1  */
-    {0x1FE03BFF, 0x000007F4},          /*   -1,   14,  510,  -12,    1  */
-    {0x1FE037FF, 0x000007F5},          /*   -1,   13,  510,  -11,    1  */
-    {0x1FE033FF, 0x000007F6},          /*   -1,   12,  510,  -10,    1  */
-    {0x1FF02BFF, 0x000007F7},          /*   -1,   10,  511,   -9,    1  */
-    {0x1FF027FF, 0x000003F9},          /*   -1,    9,  511,   -7,    0  */
-    {0x1FF01C00, 0x000003FA},          /*    0,    7,  511,   -6,    0  */
-    {0x1FF01800, 0x000003FB},          /*    0,    6,  511,   -5,    0  */
-    {0x1FF01400, 0x000003FC},          /*    0,    5,  511,   -4,    0  */
-    {0x1FF00C00, 0x000003FE},          /*    0,    3,  511,   -2,    0  */
-    {0x1FF00800, 0x000003FF},          /*    0,    2,  511,   -1,    0  */
-    {0x1FF00400, 0x00000000},          /*    0,    1,  511,    0,    0  */
-    {0x1FFFFC00, 0x00000002},          /*    0,   -1,  511,    2,    0  */
-    {0x1FFFF800, 0x00000003},          /*    0,   -2,  511,    3,    0  */
-    {0x1FFFF000, 0x00000005},          /*    0,   -4,  511,    5,    0  */
-    {0x1FFFEC00, 0x00000006},          /*    0,   -5,  511,    6,    0  */
-    {0x1FFFE800, 0x00000007},          /*    0,   -6,  511,    7,    0  */
-    {0x1FFFE400, 0x000FFC09},          /*    0,   -7,  511,    9,   -1  */
-    {0x1FFFDC01, 0x000FFC0A},          /*    1,   -9,  511,   10,   -1  */
-    {0x1FEFDC01, 0x000FFC0B},          /*    1,   -9,  510,   11,   -1  */
-    {0x1FEFD401, 0x000FFC0D},          /*    1,  -11,  510,   13,   -1  */
-    {0x1FEFD001, 0x000FFC0E},          /*    1,  -12,  510,   14,   -1  */
-    {0x1FEFCC01, 0x000FF810},          /*    1,  -13,  510,   16,   -2  */
-    {0x1FDFCC01, 0x000FF811},          /*    1,  -13,  509,   17,   -2  */
-    {0x1FDFC401, 0x000FF813},          /*    1,  -15,  509,   19,   -2  */
-    {0x1FCFC002, 0x000FF814},          /*    2,  -16,  508,   20,   -2  */
-    {0x1FCFB802, 0x000FF816},          /*    2,  -18,  508,   22,   -2  */
-    {0x1FCFB402, 0x000FF418},          /*    2,  -19,  508,   24,   -3  */
-    {0x1FBFB402, 0x000FF419},          /*    2,  -19,  507,   25,   -3  */
-    {0x1FAFB002, 0x000FF41B},          /*    2,  -20,  506,   27,   -3  */
-    {0x1FAFA802, 0x000FF41D},          /*    2,  -22,  506,   29,   -3  */
-    {0x1F9FA802, 0x000FF01F},          /*    2,  -22,  505,   31,   -4  */
-    {0x1F9FA402, 0x000FF020},          /*    2,  -23,  505,   32,   -4  */
-    {0x1F8FA002, 0x000FF022},          /*    2,  -24,  504,   34,   -4  */
-    {0x1F7F9803, 0x000FF024},          /*    3,  -26,  503,   36,   -4  */
-    {0x1F7F9403, 0x000FEC26},          /*    3,  -27,  503,   38,   -5  */
-    {0x1F6F9003, 0x000FEC28},          /*    3,  -28,  502,   40,   -5  */
-    {0x1F5F9003, 0x000FEC29},          /*    3,  -28,  501,   41,   -5  */
-    {0x1F4F8C03, 0x000FEC2B},          /*    3,  -29,  500,   43,   -5  */
-    {0x1F3F8C03, 0x000FE82D},          /*    3,  -29,  499,   45,   -6  */
-    {0x1F2F8803, 0x000FE82F},          /*    3,  -30,  498,   47,   -6  */
-    {0x1F2F8003, 0x000FE831},          /*    3,  -32,  498,   49,   -6  */
-    {0x1F1F7C03, 0x000FE833},          /*    3,  -33,  497,   51,   -6  */
-    {0x1F0F7C03, 0x000FE435},          /*    3,  -33,  496,   53,   -7  */
-    {0x1EFF7803, 0x000FE437},          /*    3,  -34,  495,   55,   -7  */
-    {0x1EEF7403, 0x000FE439},          /*    3,  -35,  494,   57,   -7  */
-    {0x1EDF7004, 0x000FE03B},          /*    4,  -36,  493,   59,   -8  */
-    {0x1EBF7403, 0x000FE43C},          /*    3,  -35,  491,   60,   -7  */
-    {0x1EAF6C04, 0x000FE03F},          /*    4,  -37,  490,   63,   -8  */
-    {0x1E9F6804, 0x000FE041},          /*    4,  -38,  489,   65,   -8  */
-    {0x1E8F6804, 0x000FDC43},          /*    4,  -38,  488,   67,   -9  */
-    {0x1E7F6404, 0x000FDC45},          /*    4,  -39,  487,   69,   -9  */
-    {0x1E6F6004, 0x000FDC47},          /*    4,  -40,  486,   71,   -9  */
-    {0x1E4F6404, 0x000FD849},          /*    4,  -39,  484,   73,  -10  */
-    {0x1E3F6004, 0x000FD84B},          /*    4,  -40,  483,   75,  -10  */
-    {0x1E1F6003, 0x000FDC4D},          /*    3,  -40,  481,   77,   -9  */
-    {0x1E1F5804, 0x000FD450},          /*    4,  -42,  481,   80,  -11  */
-    {0x1DFF5804, 0x000FD452},          /*    4,  -42,  479,   82,  -11  */
-    {0x1DEF5404, 0x000FD454},          /*    4,  -43,  478,   84,  -11  */
-    {0x1DCF5804, 0x000FD056},          /*    4,  -42,  476,   86,  -12  */
-    {0x1DBF5004, 0x000FD059},          /*    4,  -44,  475,   89,  -12  */
-    {0x1D9F5004, 0x000FD05B},          /*    4,  -44,  473,   91,  -12  */
-    {0x1D8F5004, 0x000FCC5D},          /*    4,  -44,  472,   93,  -13  */
-    {0x1D6F5004, 0x000FCC5F},          /*    4,  -44,  470,   95,  -13  */
-    {0x1D5F4804, 0x000FCC62},          /*    4,  -46,  469,   98,  -13  */
-    {0x1D3F4C04, 0x000FC864},          /*    4,  -45,  467,  100,  -14  */
-    {0x1D1F4C04, 0x000FCC65},          /*    4,  -45,  465,  101,  -13  */
-    {0x1CFF4804, 0x000FCC68},          /*    4,  -46,  463,  104,  -13  */
-    {0x1CEF4405, 0x000FC46B},          /*    5,  -47,  462,  107,  -15  */
-    {0x1CCF4804, 0x000FC86C},          /*    4,  -46,  460,  108,  -14  */
-    {0x1CAF4404, 0x000FC86F},          /*    4,  -47,  458,  111,  -14  */
-    {0x1C9F4005, 0x000FC072},          /*    5,  -48,  457,  114,  -16  */
-    {0x1C6F4404, 0x000FC474},          /*    4,  -47,  454,  116,  -15  */
-    {0x1C6F3C05, 0x000FBC77},          /*    5,  -49,  454,  119,  -17  */
-    {0x1C4F3C05, 0x000FBC79},          /*    5,  -49,  452,  121,  -17  */
-    {0x1C1F4004, 0x000FC07B},          /*    4,  -48,  449,  123,  -16  */
-    {0x1C0F3C05, 0x000FB87E},          /*    5,  -49,  448,  126,  -18  */
-    {0x1BEF3C04, 0x000FBC80},          /*    4,  -49,  446,  128,  -17  */
-    {0x1BCF3C04, 0x000FBC82},          /*    4,  -49,  444,  130,  -17  */
-    {0x1BAF3C04, 0x000FB885},          /*    4,  -49,  442,  133,  -18  */
-    {0x1B8F3C04, 0x000FB887},          /*    4,  -49,  440,  135,  -18  */
-    {0x1B6F3C04, 0x000FB48A},          /*    4,  -49,  438,  138,  -19  */
-    {0x1B5F3405, 0x000FB08D},          /*    5,  -51,  437,  141,  -20  */
-    {0x1B2F3804, 0x000FB48F},          /*    4,  -50,  434,  143,  -19  */
-    {0x1B1F3405, 0x000FAC92},          /*    5,  -51,  433,  146,  -21  */
-    {0x1AEF3804, 0x000FB094},          /*    4,  -50,  430,  148,  -20  */
-    {0x1ACF3804, 0x000FAC97},          /*    4,  -50,  428,  151,  -21  */
-    {0x1AAF3804, 0x000FAC99},          /*    4,  -50,  426,  153,  -21  */
-    {0x1A7F3804, 0x000FAC9C},          /*    4,  -50,  423,  156,  -21  */
-    {0x1A6F3405, 0x000FA49F},          /*    5,  -51,  422,  159,  -23  */
-    {0x1A3F3804, 0x000FA8A1},          /*    4,  -50,  419,  161,  -22  */
-    {0x1A1F3804, 0x000FA4A4},          /*    4,  -50,  417,  164,  -23  */
-    {0x1A0F3005, 0x000FA0A7},          /*    5,  -52,  416,  167,  -24  */
-    {0x19DF3404, 0x000FA4A9},          /*    4,  -51,  413,  169,  -23  */
-    {0x19CF3005, 0x000F9CAC},          /*    5,  -52,  412,  172,  -25  */
-    {0x199F3005, 0x000F9CAF},          /*    5,  -52,  409,  175,  -25  */
-    {0x197F3005, 0x000F98B2},          /*    5,  -52,  407,  178,  -26  */
-    {0x195F3005, 0x000F98B4},          /*    5,  -52,  405,  180,  -26  */
-    {0x191F3804, 0x000F9CB6},          /*    4,  -50,  401,  182,  -25  */
-    {0x18FF3804, 0x000F98B9},          /*    4,  -50,  399,  185,  -26  */
-    {0x18CF3804, 0x000F98BC},          /*    4,  -50,  396,  188,  -26  */
-    {0x18BF3804, 0x000F94BE},          /*    4,  -50,  395,  190,  -27  */
-    {0x188F3804, 0x000F94C1},          /*    4,  -50,  392,  193,  -27  */
-    {0x186F3804, 0x000F90C4},          /*    4,  -50,  390,  196,  -28  */
-    {0x184F3405, 0x000F8CC7},          /*    5,  -51,  388,  199,  -29  */
-    {0x181F3804, 0x000F90C9},          /*    4,  -50,  385,  201,  -28  */
-    {0x17FF3804, 0x000F8CCC},          /*    4,  -50,  383,  204,  -29  */
-    {0x17CF3804, 0x000F8CCF},          /*    4,  -50,  380,  207,  -29  */
-    {0x17BF3405, 0x000F84D2},          /*    5,  -51,  379,  210,  -31  */
-    {0x177F3C04, 0x000F88D4},          /*    4,  -49,  375,  212,  -30  */
-    {0x174F3C04, 0x000F88D7},          /*    4,  -49,  372,  215,  -30  */
-    {0x172F3C04, 0x000F84DA},          /*    4,  -49,  370,  218,  -31  */
-    {0x170F3C04, 0x000F84DC},          /*    4,  -49,  368,  220,  -31  */
-    {0x16EF3805, 0x000F7CE0},          /*    5,  -50,  366,  224,  -33  */
-    {0x16BF3C04, 0x000F80E2},          /*    4,  -49,  363,  226,  -32  */
-    {0x167F4004, 0x000F80E5},          /*    4,  -48,  359,  229,  -32  */
-    {0x166F4004, 0x000F7CE7},          /*    4,  -48,  358,  231,  -33  */
-    {0x163F4004, 0x000F7CEA},          /*    4,  -48,  355,  234,  -33  */
-    {0x161F4004, 0x000F78ED},          /*    4,  -48,  353,  237,  -34  */
-    {0x15EF4004, 0x000F78F0},          /*    4,  -48,  350,  240,  -34  */
-    {0x15BF4404, 0x000F74F3},          /*    4,  -47,  347,  243,  -35  */
-    {0x159F4404, 0x000F74F5},          /*    4,  -47,  345,  245,  -35  */
-    {0x156F4404, 0x000F74F8},          /*    4,  -47,  342,  248,  -35  */
-    {0x154F4005, 0x000F6CFC},          /*    5,  -48,  340,  252,  -37  */
-    {0x150F4804, 0x000F70FE},          /*    4,  -46,  336,  254,  -36  */
-    {0x14FF4405, 0x000F6901},          /*    5,  -47,  335,  257,  -38  */
-    {0x14CF4804, 0x000F6D03},          /*    4,  -46,  332,  259,  -37  */
-    {0x149F4804, 0x000F6D06},          /*    4,  -46,  329,  262,  -37  */
-    {0x146F4C04, 0x000F6909},          /*    4,  -45,  326,  265,  -38  */
-    {0x143F4C04, 0x000F690C},          /*    4,  -45,  323,  268,  -38  */
-    {0x141F4C04, 0x000F690E},          /*    4,  -45,  321,  270,  -38  */
-    {0x13EF5004, 0x000F6511},          /*    4,  -44,  318,  273,  -39  */
-    {0x13BF5004, 0x000F6514},          /*    4,  -44,  315,  276,  -39  */
-    {0x139F5004, 0x000F6117},          /*    4,  -44,  313,  279,  -40  */
-    {0x136F5404, 0x000F6119},          /*    4,  -43,  310,  281,  -40  */
-    {0x133F5404, 0x000F611C},          /*    4,  -43,  307,  284,  -40  */
-    {0x131F5404, 0x000F5D1F},          /*    4,  -43,  305,  287,  -41  */
-    {0x12DF5C04, 0x000F5D21},          /*    4,  -41,  301,  289,  -41  */
-    {0x12AF5C04, 0x000F5D24},          /*    4,  -41,  298,  292,  -41  */
+    {0x1284A7D5, 0x000017D5},   /*  -43,  297,  296,  -43,    5  */
+    {0x12A497D7, 0x000013D6},   /*  -41,  293,  298,  -42,    4  */
+    {0x12D48BD7, 0x000013D6},   /*  -41,  290,  301,  -42,    4  */
+    {0x13147FD7, 0x000013D5},   /*  -41,  287,  305,  -43,    4  */
+    {0x133473D8, 0x000013D5},   /*  -40,  284,  307,  -43,    4  */
+    {0x136467D8, 0x000013D5},   /*  -40,  281,  310,  -43,    4  */
+    {0x13945FD8, 0x000013D4},   /*  -40,  279,  313,  -44,    4  */
+    {0x13B453D9, 0x000013D4},   /*  -39,  276,  315,  -44,    4  */
+    {0x13E447D9, 0x000013D4},   /*  -39,  273,  318,  -44,    4  */
+    {0x14143BDA, 0x000013D3},   /*  -38,  270,  321,  -45,    4  */
+    {0x143433DA, 0x000013D3},   /*  -38,  268,  323,  -45,    4  */
+    {0x146427DA, 0x000013D3},   /*  -38,  265,  326,  -45,    4  */
+    {0x14941BDB, 0x000013D2},   /*  -37,  262,  329,  -46,    4  */
+    {0x14C40FDB, 0x000013D2},   /*  -37,  259,  332,  -46,    4  */
+    {0x14F407DA, 0x000017D1},   /*  -38,  257,  335,  -47,    5  */
+    {0x1503FBDC, 0x000013D2},   /*  -36,  254,  336,  -46,    4  */
+    {0x1543F3DB, 0x000017D0},   /*  -37,  252,  340,  -48,    5  */
+    {0x1563E3DD, 0x000013D1},   /*  -35,  248,  342,  -47,    4  */
+    {0x1593D7DD, 0x000013D1},   /*  -35,  245,  345,  -47,    4  */
+    {0x15B3CFDD, 0x000013D1},   /*  -35,  243,  347,  -47,    4  */
+    {0x15E3C3DE, 0x000013D0},   /*  -34,  240,  350,  -48,    4  */
+    {0x1613B7DE, 0x000013D0},   /*  -34,  237,  353,  -48,    4  */
+    {0x1633ABDF, 0x000013D0},   /*  -33,  234,  355,  -48,    4  */
+    {0x16639FDF, 0x000013D0},   /*  -33,  231,  358,  -48,    4  */
+    {0x167397E0, 0x000013D0},   /*  -32,  229,  359,  -48,    4  */
+    {0x16B38BE0, 0x000013CF},   /*  -32,  226,  363,  -49,    4  */
+    {0x16E383DF, 0x000017CE},   /*  -33,  224,  366,  -50,    5  */
+    {0x170373E1, 0x000013CF},   /*  -31,  220,  368,  -49,    4  */
+    {0x17236BE1, 0x000013CF},   /*  -31,  218,  370,  -49,    4  */
+    {0x17435FE2, 0x000013CF},   /*  -30,  215,  372,  -49,    4  */
+    {0x177353E2, 0x000013CF},   /*  -30,  212,  375,  -49,    4  */
+    {0x17B34BE1, 0x000017CD},   /*  -31,  210,  379,  -51,    5  */
+    {0x17C33FE3, 0x000013CE},   /*  -29,  207,  380,  -50,    4  */
+    {0x17F333E3, 0x000013CE},   /*  -29,  204,  383,  -50,    4  */
+    {0x181327E4, 0x000013CE},   /*  -28,  201,  385,  -50,    4  */
+    {0x18431FE3, 0x000017CD},   /*  -29,  199,  388,  -51,    5  */
+    {0x186313E4, 0x000013CE},   /*  -28,  196,  390,  -50,    4  */
+    {0x188307E5, 0x000013CE},   /*  -27,  193,  392,  -50,    4  */
+    {0x18B2FBE5, 0x000013CE},   /*  -27,  190,  395,  -50,    4  */
+    {0x18C2F3E6, 0x000013CE},   /*  -26,  188,  396,  -50,    4  */
+    {0x18F2E7E6, 0x000013CE},   /*  -26,  185,  399,  -50,    4  */
+    {0x1912DBE7, 0x000013CE},   /*  -25,  182,  401,  -50,    4  */
+    {0x1952D3E6, 0x000017CC},   /*  -26,  180,  405,  -52,    5  */
+    {0x1972CBE6, 0x000017CC},   /*  -26,  178,  407,  -52,    5  */
+    {0x1992BFE7, 0x000017CC},   /*  -25,  175,  409,  -52,    5  */
+    {0x19C2B3E7, 0x000017CC},   /*  -25,  172,  412,  -52,    5  */
+    {0x19D2A7E9, 0x000013CD},   /*  -23,  169,  413,  -51,    4  */
+    {0x1A029FE8, 0x000017CC},   /*  -24,  167,  416,  -52,    5  */
+    {0x1A1293E9, 0x000013CE},   /*  -23,  164,  417,  -50,    4  */
+    {0x1A3287EA, 0x000013CE},   /*  -22,  161,  419,  -50,    4  */
+    {0x1A627FE9, 0x000017CD},   /*  -23,  159,  422,  -51,    5  */
+    {0x1A7273EB, 0x000013CE},   /*  -21,  156,  423,  -50,    4  */
+    {0x1AA267EB, 0x000013CE},   /*  -21,  153,  426,  -50,    4  */
+    {0x1AC25FEB, 0x000013CE},   /*  -21,  151,  428,  -50,    4  */
+    {0x1AE253EC, 0x000013CE},   /*  -20,  148,  430,  -50,    4  */
+    {0x1B124BEB, 0x000017CD},   /*  -21,  146,  433,  -51,    5  */
+    {0x1B223FED, 0x000013CE},   /*  -19,  143,  434,  -50,    4  */
+    {0x1B5237EC, 0x000017CD},   /*  -20,  141,  437,  -51,    5  */
+    {0x1B622BED, 0x000013CF},   /*  -19,  138,  438,  -49,    4  */
+    {0x1B821FEE, 0x000013CF},   /*  -18,  135,  440,  -49,    4  */
+    {0x1BA217EE, 0x000013CF},   /*  -18,  133,  442,  -49,    4  */
+    {0x1BC20BEF, 0x000013CF},   /*  -17,  130,  444,  -49,    4  */
+    {0x1BE203EF, 0x000013CF},   /*  -17,  128,  446,  -49,    4  */
+    {0x1C01FBEE, 0x000017CF},   /*  -18,  126,  448,  -49,    5  */
+    {0x1C11EFF0, 0x000013D0},   /*  -16,  123,  449,  -48,    4  */
+    {0x1C41E7EF, 0x000017CF},   /*  -17,  121,  452,  -49,    5  */
+    {0x1C61DFEF, 0x000017CF},   /*  -17,  119,  454,  -49,    5  */
+    {0x1C61D3F1, 0x000013D1},   /*  -15,  116,  454,  -47,    4  */
+    {0x1C91CBF0, 0x000017D0},   /*  -16,  114,  457,  -48,    5  */
+    {0x1CA1BFF2, 0x000013D1},   /*  -14,  111,  458,  -47,    4  */
+    {0x1CC1B3F2, 0x000013D2},   /*  -14,  108,  460,  -46,    4  */
+    {0x1CE1AFF1, 0x000017D1},   /*  -15,  107,  462,  -47,    5  */
+    {0x1CF1A3F3, 0x000013D2},   /*  -13,  104,  463,  -46,    4  */
+    {0x1D1197F3, 0x000013D3},   /*  -13,  101,  465,  -45,    4  */
+    {0x1D3197F2, 0x000013D2},   /*  -14,  101,  467,  -46,    4  */
+    {0x1D518BF3, 0x000013D2},   /*  -13,   98,  469,  -46,    4  */
+    {0x1D6183F3, 0x000013D3},   /*  -13,   96,  470,  -45,    4  */
+    {0x1D817BF3, 0x000013D3},   /*  -13,   94,  472,  -45,    4  */
+    {0x1D916FF4, 0x000013D4},   /*  -12,   91,  473,  -44,    4  */
+    {0x1DB167F4, 0x000013D4},   /*  -12,   89,  475,  -44,    4  */
+    {0x1DC15FF4, 0x000013D5},   /*  -12,   87,  476,  -43,    4  */
+    {0x1DE153F5, 0x000013D5},   /*  -11,   84,  478,  -43,    4  */
+    {0x1DF14BF5, 0x000013D6},   /*  -11,   82,  479,  -42,    4  */
+    {0x1E1143F5, 0x000013D6},   /*  -11,   80,  481,  -42,    4  */
+    {0x1E1137F7, 0x00000FD8},   /*   -9,   77,  481,  -40,    3  */
+    {0x1E3133F6, 0x000013D7},   /*  -10,   76,  483,  -41,    4  */
+    {0x1E412BF6, 0x000013D8},   /*  -10,   74,  484,  -40,    4  */
+    {0x1E611FF7, 0x000013D8},   /*   -9,   71,  486,  -40,    4  */
+    {0x1E7117F7, 0x000013D9},   /*   -9,   69,  487,  -39,    4  */
+    {0x1E810FF7, 0x000013DA},   /*   -9,   67,  488,  -38,    4  */
+    {0x1E9107F8, 0x000013DA},   /*   -8,   65,  489,  -38,    4  */
+    {0x1EA0FFF8, 0x000013DB},   /*   -8,   63,  490,  -37,    4  */
+    {0x1EB0F3F9, 0x00000FDD},   /*   -7,   60,  491,  -35,    3  */
+    {0x1ED0EFF8, 0x000013DC},   /*   -8,   59,  493,  -36,    4  */
+    {0x1EE0E7F9, 0x00000FDD},   /*   -7,   57,  494,  -35,    3  */
+    {0x1EF0DFF9, 0x00000FDE},   /*   -7,   55,  495,  -34,    3  */
+    {0x1F00D7F9, 0x00000FDF},   /*   -7,   53,  496,  -33,    3  */
+    {0x1F10CFFA, 0x00000FDF},   /*   -6,   51,  497,  -33,    3  */
+    {0x1F20C7FA, 0x00000FE0},   /*   -6,   49,  498,  -32,    3  */
+    {0x1F20C3FA, 0x00000FE1},   /*   -6,   48,  498,  -31,    3  */
+    {0x1F30BBFA, 0x00000FE2},   /*   -6,   46,  499,  -30,    3  */
+    {0x1F40AFFB, 0x00000FE3},   /*   -5,   43,  500,  -29,    3  */
+    {0x1F50A7FB, 0x00000FE4},   /*   -5,   41,  501,  -28,    3  */
+    {0x1F60A3FB, 0x00000FE4},   /*   -5,   40,  502,  -28,    3  */
+    {0x1F709BFB, 0x00000FE5},   /*   -5,   38,  503,  -27,    3  */
+    {0x1F7093FC, 0x00000FE6},   /*   -4,   36,  503,  -26,    3  */
+    {0x1F808FFC, 0x00000BE7},   /*   -4,   35,  504,  -25,    2  */
+    {0x1F9087FC, 0x00000BE8},   /*   -4,   33,  505,  -24,    2  */
+    {0x1F9083FC, 0x00000BE9},   /*   -4,   32,  505,  -23,    2  */
+    {0x1FA077FD, 0x00000BEA},   /*   -3,   29,  506,  -22,    2  */
+    {0x1FA073FD, 0x00000BEB},   /*   -3,   28,  506,  -21,    2  */
+    {0x1FB06BFD, 0x00000BEC},   /*   -3,   26,  507,  -20,    2  */
+    {0x1FC063FD, 0x00000BED},   /*   -3,   24,  508,  -19,    2  */
+    {0x1FC05BFE, 0x00000BEE},   /*   -2,   22,  508,  -18,    2  */
+    {0x1FC057FE, 0x00000BEF},   /*   -2,   21,  508,  -17,    2  */
+    {0x1FD053FE, 0x000007F0},   /*   -2,   20,  509,  -16,    1  */
+    {0x1FD04BFE, 0x000007F2},   /*   -2,   18,  509,  -14,    1  */
+    {0x1FE043FE, 0x000007F3},   /*   -2,   16,  510,  -13,    1  */
+    {0x1FE03BFF, 0x000007F4},   /*   -1,   14,  510,  -12,    1  */
+    {0x1FE037FF, 0x000007F5},   /*   -1,   13,  510,  -11,    1  */
+    {0x1FE033FF, 0x000007F6},   /*   -1,   12,  510,  -10,    1  */
+    {0x1FF02BFF, 0x000007F7},   /*   -1,   10,  511,   -9,    1  */
+    {0x1FF027FF, 0x000003F9},   /*   -1,    9,  511,   -7,    0  */
+    {0x1FF01C00, 0x000003FA},   /*    0,    7,  511,   -6,    0  */
+    {0x1FF01800, 0x000003FB},   /*    0,    6,  511,   -5,    0  */
+    {0x1FF01400, 0x000003FC},   /*    0,    5,  511,   -4,    0  */
+    {0x1FF00C00, 0x000003FE},   /*    0,    3,  511,   -2,    0  */
+    {0x1FF00800, 0x000003FF},   /*    0,    2,  511,   -1,    0  */
+    {0x1FF00400, 0x00000000},   /*    0,    1,  511,    0,    0  */
+    {0x1FFFFC00, 0x00000002},   /*    0,   -1,  511,    2,    0  */
+    {0x1FFFF800, 0x00000003},   /*    0,   -2,  511,    3,    0  */
+    {0x1FFFF000, 0x00000005},   /*    0,   -4,  511,    5,    0  */
+    {0x1FFFEC00, 0x00000006},   /*    0,   -5,  511,    6,    0  */
+    {0x1FFFE800, 0x00000007},   /*    0,   -6,  511,    7,    0  */
+    {0x1FFFE400, 0x000FFC09},   /*    0,   -7,  511,    9,   -1  */
+    {0x1FFFDC01, 0x000FFC0A},   /*    1,   -9,  511,   10,   -1  */
+    {0x1FEFDC01, 0x000FFC0B},   /*    1,   -9,  510,   11,   -1  */
+    {0x1FEFD401, 0x000FFC0D},   /*    1,  -11,  510,   13,   -1  */
+    {0x1FEFD001, 0x000FFC0E},   /*    1,  -12,  510,   14,   -1  */
+    {0x1FEFCC01, 0x000FF810},   /*    1,  -13,  510,   16,   -2  */
+    {0x1FDFCC01, 0x000FF811},   /*    1,  -13,  509,   17,   -2  */
+    {0x1FDFC401, 0x000FF813},   /*    1,  -15,  509,   19,   -2  */
+    {0x1FCFC002, 0x000FF814},   /*    2,  -16,  508,   20,   -2  */
+    {0x1FCFB802, 0x000FF816},   /*    2,  -18,  508,   22,   -2  */
+    {0x1FCFB402, 0x000FF418},   /*    2,  -19,  508,   24,   -3  */
+    {0x1FBFB402, 0x000FF419},   /*    2,  -19,  507,   25,   -3  */
+    {0x1FAFB002, 0x000FF41B},   /*    2,  -20,  506,   27,   -3  */
+    {0x1FAFA802, 0x000FF41D},   /*    2,  -22,  506,   29,   -3  */
+    {0x1F9FA802, 0x000FF01F},   /*    2,  -22,  505,   31,   -4  */
+    {0x1F9FA402, 0x000FF020},   /*    2,  -23,  505,   32,   -4  */
+    {0x1F8FA002, 0x000FF022},   /*    2,  -24,  504,   34,   -4  */
+    {0x1F7F9803, 0x000FF024},   /*    3,  -26,  503,   36,   -4  */
+    {0x1F7F9403, 0x000FEC26},   /*    3,  -27,  503,   38,   -5  */
+    {0x1F6F9003, 0x000FEC28},   /*    3,  -28,  502,   40,   -5  */
+    {0x1F5F9003, 0x000FEC29},   /*    3,  -28,  501,   41,   -5  */
+    {0x1F4F8C03, 0x000FEC2B},   /*    3,  -29,  500,   43,   -5  */
+    {0x1F3F8C03, 0x000FE82D},   /*    3,  -29,  499,   45,   -6  */
+    {0x1F2F8803, 0x000FE82F},   /*    3,  -30,  498,   47,   -6  */
+    {0x1F2F8003, 0x000FE831},   /*    3,  -32,  498,   49,   -6  */
+    {0x1F1F7C03, 0x000FE833},   /*    3,  -33,  497,   51,   -6  */
+    {0x1F0F7C03, 0x000FE435},   /*    3,  -33,  496,   53,   -7  */
+    {0x1EFF7803, 0x000FE437},   /*    3,  -34,  495,   55,   -7  */
+    {0x1EEF7403, 0x000FE439},   /*    3,  -35,  494,   57,   -7  */
+    {0x1EDF7004, 0x000FE03B},   /*    4,  -36,  493,   59,   -8  */
+    {0x1EBF7403, 0x000FE43C},   /*    3,  -35,  491,   60,   -7  */
+    {0x1EAF6C04, 0x000FE03F},   /*    4,  -37,  490,   63,   -8  */
+    {0x1E9F6804, 0x000FE041},   /*    4,  -38,  489,   65,   -8  */
+    {0x1E8F6804, 0x000FDC43},   /*    4,  -38,  488,   67,   -9  */
+    {0x1E7F6404, 0x000FDC45},   /*    4,  -39,  487,   69,   -9  */
+    {0x1E6F6004, 0x000FDC47},   /*    4,  -40,  486,   71,   -9  */
+    {0x1E4F6404, 0x000FD849},   /*    4,  -39,  484,   73,  -10  */
+    {0x1E3F6004, 0x000FD84B},   /*    4,  -40,  483,   75,  -10  */
+    {0x1E1F6003, 0x000FDC4D},   /*    3,  -40,  481,   77,   -9  */
+    {0x1E1F5804, 0x000FD450},   /*    4,  -42,  481,   80,  -11  */
+    {0x1DFF5804, 0x000FD452},   /*    4,  -42,  479,   82,  -11  */
+    {0x1DEF5404, 0x000FD454},   /*    4,  -43,  478,   84,  -11  */
+    {0x1DCF5804, 0x000FD056},   /*    4,  -42,  476,   86,  -12  */
+    {0x1DBF5004, 0x000FD059},   /*    4,  -44,  475,   89,  -12  */
+    {0x1D9F5004, 0x000FD05B},   /*    4,  -44,  473,   91,  -12  */
+    {0x1D8F5004, 0x000FCC5D},   /*    4,  -44,  472,   93,  -13  */
+    {0x1D6F5004, 0x000FCC5F},   /*    4,  -44,  470,   95,  -13  */
+    {0x1D5F4804, 0x000FCC62},   /*    4,  -46,  469,   98,  -13  */
+    {0x1D3F4C04, 0x000FC864},   /*    4,  -45,  467,  100,  -14  */
+    {0x1D1F4C04, 0x000FCC65},   /*    4,  -45,  465,  101,  -13  */
+    {0x1CFF4804, 0x000FCC68},   /*    4,  -46,  463,  104,  -13  */
+    {0x1CEF4405, 0x000FC46B},   /*    5,  -47,  462,  107,  -15  */
+    {0x1CCF4804, 0x000FC86C},   /*    4,  -46,  460,  108,  -14  */
+    {0x1CAF4404, 0x000FC86F},   /*    4,  -47,  458,  111,  -14  */
+    {0x1C9F4005, 0x000FC072},   /*    5,  -48,  457,  114,  -16  */
+    {0x1C6F4404, 0x000FC474},   /*    4,  -47,  454,  116,  -15  */
+    {0x1C6F3C05, 0x000FBC77},   /*    5,  -49,  454,  119,  -17  */
+    {0x1C4F3C05, 0x000FBC79},   /*    5,  -49,  452,  121,  -17  */
+    {0x1C1F4004, 0x000FC07B},   /*    4,  -48,  449,  123,  -16  */
+    {0x1C0F3C05, 0x000FB87E},   /*    5,  -49,  448,  126,  -18  */
+    {0x1BEF3C04, 0x000FBC80},   /*    4,  -49,  446,  128,  -17  */
+    {0x1BCF3C04, 0x000FBC82},   /*    4,  -49,  444,  130,  -17  */
+    {0x1BAF3C04, 0x000FB885},   /*    4,  -49,  442,  133,  -18  */
+    {0x1B8F3C04, 0x000FB887},   /*    4,  -49,  440,  135,  -18  */
+    {0x1B6F3C04, 0x000FB48A},   /*    4,  -49,  438,  138,  -19  */
+    {0x1B5F3405, 0x000FB08D},   /*    5,  -51,  437,  141,  -20  */
+    {0x1B2F3804, 0x000FB48F},   /*    4,  -50,  434,  143,  -19  */
+    {0x1B1F3405, 0x000FAC92},   /*    5,  -51,  433,  146,  -21  */
+    {0x1AEF3804, 0x000FB094},   /*    4,  -50,  430,  148,  -20  */
+    {0x1ACF3804, 0x000FAC97},   /*    4,  -50,  428,  151,  -21  */
+    {0x1AAF3804, 0x000FAC99},   /*    4,  -50,  426,  153,  -21  */
+    {0x1A7F3804, 0x000FAC9C},   /*    4,  -50,  423,  156,  -21  */
+    {0x1A6F3405, 0x000FA49F},   /*    5,  -51,  422,  159,  -23  */
+    {0x1A3F3804, 0x000FA8A1},   /*    4,  -50,  419,  161,  -22  */
+    {0x1A1F3804, 0x000FA4A4},   /*    4,  -50,  417,  164,  -23  */
+    {0x1A0F3005, 0x000FA0A7},   /*    5,  -52,  416,  167,  -24  */
+    {0x19DF3404, 0x000FA4A9},   /*    4,  -51,  413,  169,  -23  */
+    {0x19CF3005, 0x000F9CAC},   /*    5,  -52,  412,  172,  -25  */
+    {0x199F3005, 0x000F9CAF},   /*    5,  -52,  409,  175,  -25  */
+    {0x197F3005, 0x000F98B2},   /*    5,  -52,  407,  178,  -26  */
+    {0x195F3005, 0x000F98B4},   /*    5,  -52,  405,  180,  -26  */
+    {0x191F3804, 0x000F9CB6},   /*    4,  -50,  401,  182,  -25  */
+    {0x18FF3804, 0x000F98B9},   /*    4,  -50,  399,  185,  -26  */
+    {0x18CF3804, 0x000F98BC},   /*    4,  -50,  396,  188,  -26  */
+    {0x18BF3804, 0x000F94BE},   /*    4,  -50,  395,  190,  -27  */
+    {0x188F3804, 0x000F94C1},   /*    4,  -50,  392,  193,  -27  */
+    {0x186F3804, 0x000F90C4},   /*    4,  -50,  390,  196,  -28  */
+    {0x184F3405, 0x000F8CC7},   /*    5,  -51,  388,  199,  -29  */
+    {0x181F3804, 0x000F90C9},   /*    4,  -50,  385,  201,  -28  */
+    {0x17FF3804, 0x000F8CCC},   /*    4,  -50,  383,  204,  -29  */
+    {0x17CF3804, 0x000F8CCF},   /*    4,  -50,  380,  207,  -29  */
+    {0x17BF3405, 0x000F84D2},   /*    5,  -51,  379,  210,  -31  */
+    {0x177F3C04, 0x000F88D4},   /*    4,  -49,  375,  212,  -30  */
+    {0x174F3C04, 0x000F88D7},   /*    4,  -49,  372,  215,  -30  */
+    {0x172F3C04, 0x000F84DA},   /*    4,  -49,  370,  218,  -31  */
+    {0x170F3C04, 0x000F84DC},   /*    4,  -49,  368,  220,  -31  */
+    {0x16EF3805, 0x000F7CE0},   /*    5,  -50,  366,  224,  -33  */
+    {0x16BF3C04, 0x000F80E2},   /*    4,  -49,  363,  226,  -32  */
+    {0x167F4004, 0x000F80E5},   /*    4,  -48,  359,  229,  -32  */
+    {0x166F4004, 0x000F7CE7},   /*    4,  -48,  358,  231,  -33  */
+    {0x163F4004, 0x000F7CEA},   /*    4,  -48,  355,  234,  -33  */
+    {0x161F4004, 0x000F78ED},   /*    4,  -48,  353,  237,  -34  */
+    {0x15EF4004, 0x000F78F0},   /*    4,  -48,  350,  240,  -34  */
+    {0x15BF4404, 0x000F74F3},   /*    4,  -47,  347,  243,  -35  */
+    {0x159F4404, 0x000F74F5},   /*    4,  -47,  345,  245,  -35  */
+    {0x156F4404, 0x000F74F8},   /*    4,  -47,  342,  248,  -35  */
+    {0x154F4005, 0x000F6CFC},   /*    5,  -48,  340,  252,  -37  */
+    {0x150F4804, 0x000F70FE},   /*    4,  -46,  336,  254,  -36  */
+    {0x14FF4405, 0x000F6901},   /*    5,  -47,  335,  257,  -38  */
+    {0x14CF4804, 0x000F6D03},   /*    4,  -46,  332,  259,  -37  */
+    {0x149F4804, 0x000F6D06},   /*    4,  -46,  329,  262,  -37  */
+    {0x146F4C04, 0x000F6909},   /*    4,  -45,  326,  265,  -38  */
+    {0x143F4C04, 0x000F690C},   /*    4,  -45,  323,  268,  -38  */
+    {0x141F4C04, 0x000F690E},   /*    4,  -45,  321,  270,  -38  */
+    {0x13EF5004, 0x000F6511},   /*    4,  -44,  318,  273,  -39  */
+    {0x13BF5004, 0x000F6514},   /*    4,  -44,  315,  276,  -39  */
+    {0x139F5004, 0x000F6117},   /*    4,  -44,  313,  279,  -40  */
+    {0x136F5404, 0x000F6119},   /*    4,  -43,  310,  281,  -40  */
+    {0x133F5404, 0x000F611C},   /*    4,  -43,  307,  284,  -40  */
+    {0x131F5404, 0x000F5D1F},   /*    4,  -43,  305,  287,  -41  */
+    {0x12DF5C04, 0x000F5D21},   /*    4,  -41,  301,  289,  -41  */
+    {0x12AF5C04, 0x000F5D24},   /*    4,  -41,  298,  292,  -41  */
 };
 
 static const unsigned long CimarronVerticalGraphicsFilter[] = {
-    0x3F840D05,                        /* 261, 259,  -8  */
-    0x3F841D01,                        /* 257, 263,  -8  */
-    0x3F8428FE,                        /* 254, 266,  -8  */
-    0x3F8438FA,                        /* 250, 270,  -8  */
-    0x3F8444F7,                        /* 247, 273,  -8  */
-    0x3F8450F4,                        /* 244, 276,  -8  */
-    0x3F845CF1,                        /* 241, 279,  -8  */
-    0x3F8468EE,                        /* 238, 282,  -8  */
-    0x3F8474EB,                        /* 235, 285,  -8  */
-    0x3F8480E8,                        /* 232, 288,  -8  */
-    0x3F7490E5,                        /* 229, 292,  -9  */
-    0x3F749CE2,                        /* 226, 295,  -9  */
-    0x3F74ACDE,                        /* 222, 299,  -9  */
-    0x3F74B8DB,                        /* 219, 302,  -9  */
-    0x3F74C0D9,                        /* 217, 304,  -9  */
-    0x3F74CCD6,                        /* 214, 307,  -9  */
-    0x3F74D8D3,                        /* 211, 310,  -9  */
-    0x3F74E8CF,                        /* 207, 314,  -9  */
-    0x3F74F4CC,                        /* 204, 317,  -9  */
-    0x3F7500C9,                        /* 201, 320,  -9  */
-    0x3F750CC6,                        /* 198, 323,  -9  */
-    0x3F7518C3,                        /* 195, 326,  -9  */
-    0x3F7520C1,                        /* 193, 328,  -9  */
-    0x3F7530BD,                        /* 189, 332,  -9  */
-    0x3F753CBA,                        /* 186, 335,  -9  */
-    0x3F7548B7,                        /* 183, 338,  -9  */
-    0x3F6558B4,                        /* 180, 342, -10  */
-    0x3F6560B2,                        /* 178, 344, -10  */
-    0x3F656CAF,                        /* 175, 347, -10  */
-    0x3F6578AC,                        /* 172, 350, -10  */
-    0x3F6584A9,                        /* 169, 353, -10  */
-    0x3F658CA7,                        /* 167, 355, -10  */
-    0x3F6598A4,                        /* 164, 358, -10  */
-    0x3F65A8A0,                        /* 160, 362, -10  */
-    0x3F65B09E,                        /* 158, 364, -10  */
-    0x3F65BC9B,                        /* 155, 367, -10  */
-    0x3F65C499,                        /* 153, 369, -10  */
-    0x3F65D096,                        /* 150, 372, -10  */
-    0x3F55E093,                        /* 147, 376, -11  */
-    0x3F55E891,                        /* 145, 378, -11  */
-    0x3F55F48E,                        /* 142, 381, -11  */
-    0x3F56008B,                        /* 139, 384, -11  */
-    0x3F560C88,                        /* 136, 387, -11  */
-    0x3F561486,                        /* 134, 389, -11  */
-    0x3F562083,                        /* 131, 392, -11  */
-    0x3F562881,                        /* 129, 394, -11  */
-    0x3F56347E,                        /* 126, 397, -11  */
-    0x3F56407B,                        /* 123, 400, -11  */
-    0x3F564879,                        /* 121, 402, -11  */
-    0x3F465876,                        /* 118, 406, -12  */
-    0x3F466074,                        /* 116, 408, -12  */
-    0x3F466872,                        /* 114, 410, -12  */
-    0x3F46746F,                        /* 111, 413, -12  */
-    0x3F467C6D,                        /* 109, 415, -12  */
-    0x3F46846B,                        /* 107, 417, -12  */
-    0x3F468C69,                        /* 105, 419, -12  */
-    0x3F469866,                        /* 102, 422, -12  */
-    0x3F46A064,                        /* 100, 424, -12  */
-    0x3F46AC61,                        /*  97, 427, -12  */
-    0x3F46B45F,                        /*  95, 429, -12  */
-    0x3F46BC5D,                        /*  93, 431, -12  */
-    0x3F46C45B,                        /*  91, 433, -12  */
-    0x3F46CC59,                        /*  89, 435, -12  */
-    0x3F36DC56,                        /*  86, 439, -13  */
-    0x3F36E454,                        /*  84, 441, -13  */
-    0x3F36EC52,                        /*  82, 443, -13  */
-    0x3F36F450,                        /*  80, 445, -13  */
-    0x3F36FC4E,                        /*  78, 447, -13  */
-    0x3F37004D,                        /*  77, 448, -13  */
-    0x3F370C4A,                        /*  74, 451, -13  */
-    0x3F371448,                        /*  72, 453, -13  */
-    0x3F371C46,                        /*  70, 455, -13  */
-    0x3F372444,                        /*  68, 457, -13  */
-    0x3F372C42,                        /*  66, 459, -13  */
-    0x3F373440,                        /*  64, 461, -13  */
-    0x3F37383F,                        /*  63, 462, -13  */
-    0x3F37403D,                        /*  61, 464, -13  */
-    0x3F37483B,                        /*  59, 466, -13  */
-    0x3F375039,                        /*  57, 468, -13  */
-    0x3F375438,                        /*  56, 469, -13  */
-    0x3F375C36,                        /*  54, 471, -13  */
-    0x3F376434,                        /*  52, 473, -13  */
-    0x3F376833,                        /*  51, 474, -13  */
-    0x3F377031,                        /*  49, 476, -13  */
-    0x3F377430,                        /*  48, 477, -13  */
-    0x3F377C2E,                        /*  46, 479, -13  */
-    0x3F37842C,                        /*  44, 481, -13  */
-    0x3F37882B,                        /*  43, 482, -13  */
-    0x3F47882A,                        /*  42, 482, -12  */
-    0x3F479028,                        /*  40, 484, -12  */
-    0x3F479427,                        /*  39, 485, -12  */
-    0x3F479C25,                        /*  37, 487, -12  */
-    0x3F47A024,                        /*  36, 488, -12  */
-    0x3F47A822,                        /*  34, 490, -12  */
-    0x3F47AC21,                        /*  33, 491, -12  */
-    0x3F47B020,                        /*  32, 492, -12  */
-    0x3F57B01F,                        /*  31, 492, -11  */
-    0x3F57B81D,                        /*  29, 494, -11  */
-    0x3F57BC1C,                        /*  28, 495, -11  */
-    0x3F57C01B,                        /*  27, 496, -11  */
-    0x3F57C41A,                        /*  26, 497, -11  */
-    0x3F67C818,                        /*  24, 498, -10  */
-    0x3F67CC17,                        /*  23, 499, -10  */
-    0x3F67D016,                        /*  22, 500, -10  */
-    0x3F67D415,                        /*  21, 501, -10  */
-    0x3F67D814,                        /*  20, 502, -10  */
-    0x3F77D813,                        /*  19, 502,  -9  */
-    0x3F77DC12,                        /*  18, 503,  -9  */
-    0x3F77E011,                        /*  17, 504,  -9  */
-    0x3F87E010,                        /*  16, 504,  -8  */
-    0x3F87E40F,                        /*  15, 505,  -8  */
-    0x3F87E80E,                        /*  14, 506,  -8  */
-    0x3F97E80D,                        /*  13, 506,  -7  */
-    0x3F97EC0C,                        /*  12, 507,  -7  */
-    0x3F97F00B,                        /*  11, 508,  -7  */
-    0x3FA7F00A,                        /*  10, 508,  -6  */
-    0x3FA7F409,                        /*   9, 509,  -6  */
-    0x3FB7F408,                        /*   8, 509,  -5  */
-    0x3FB7F408,                        /*   8, 509,  -5  */
-    0x3FC7F806,                        /*   6, 510,  -4  */
-    0x3FC7F806,                        /*   6, 510,  -4  */
-    0x3FD7F805,                        /*   5, 510,  -3  */
-    0x3FD7FC04,                        /*   4, 511,  -3  */
-    0x3FE7FC03,                        /*   3, 511,  -2  */
-    0x3FE7FC03,                        /*   3, 511,  -2  */
-    0x3FF7FC02,                        /*   2, 511,  -1  */
-    0x3FF7FC02,                        /*   2, 511,  -1  */
-    0x0007FC01,                        /*   1, 511,   0  */
-    0x0007FC01,                        /*   1, 511,   0  */
-    0x0007FC01,                        /*   1, 511,   0  */
-    0x0027FFFF,                        /*  -1, 511,   2  */
-    0x0027FFFF,                        /*  -1, 511,   2  */
-    0x0037FFFE,                        /*  -2, 511,   3  */
-    0x0037FFFE,                        /*  -2, 511,   3  */
-    0x0047FFFD,                        /*  -3, 511,   4  */
-    0x0047FBFE,                        /*  -2, 510,   4  */
-    0x0057FBFD,                        /*  -3, 510,   5  */
-    0x0067FBFC,                        /*  -4, 510,   6  */
-    0x0077F7FC,                        /*  -4, 509,   7  */
-    0x0077F7FC,                        /*  -4, 509,   7  */
-    0x0087F7FB,                        /*  -5, 509,   8  */
-    0x0097F3FB,                        /*  -5, 508,   9  */
-    0x00A7F3FA,                        /*  -6, 508,  10  */
-    0x00B7EFFA,                        /*  -6, 507,  11  */
-    0x00C7EBFA,                        /*  -6, 506,  12  */
-    0x00D7EBF9,                        /*  -7, 506,  13  */
-    0x00E7E7F9,                        /*  -7, 505,  14  */
-    0x00F7E3F9,                        /*  -7, 504,  15  */
-    0x0107E3F8,                        /*  -8, 504,  16  */
-    0x0117DFF8,                        /*  -8, 503,  17  */
-    0x0127DBF8,                        /*  -8, 502,  18  */
-    0x0137DBF7,                        /*  -9, 502,  19  */
-    0x0147D7F7,                        /*  -9, 501,  20  */
-    0x0157D3F7,                        /*  -9, 500,  21  */
-    0x0167CFF7,                        /*  -9, 499,  22  */
-    0x0177CBF7,                        /*  -9, 498,  23  */
-    0x0197C7F6,                        /* -10, 497,  25  */
-    0x01A7C3F6,                        /* -10, 496,  26  */
-    0x01B7BFF6,                        /* -10, 495,  27  */
-    0x01C7BBF6,                        /* -10, 494,  28  */
-    0x01E7B3F6,                        /* -10, 492,  30  */
-    0x01F7B3F5,                        /* -11, 492,  31  */
-    0x0207AFF5,                        /* -11, 491,  32  */
-    0x0217ABF5,                        /* -11, 490,  33  */
-    0x0237A3F5,                        /* -11, 488,  35  */
-    0x02479FF5,                        /* -11, 487,  36  */
-    0x026797F5,                        /* -11, 485,  38  */
-    0x027793F5,                        /* -11, 484,  39  */
-    0x02978BF5,                        /* -11, 482,  41  */
-    0x02A78BF4,                        /* -12, 482,  42  */
-    0x02B787F4,                        /* -12, 481,  43  */
-    0x02D77FF4,                        /* -12, 479,  45  */
-    0x02F777F4,                        /* -12, 477,  47  */
-    0x030773F4,                        /* -12, 476,  48  */
-    0x03276BF4,                        /* -12, 474,  50  */
-    0x033767F4,                        /* -12, 473,  51  */
-    0x03575FF4,                        /* -12, 471,  53  */
-    0x037757F4,                        /* -12, 469,  55  */
-    0x038753F4,                        /* -12, 468,  56  */
-    0x03A74BF4,                        /* -12, 466,  58  */
-    0x03C743F4,                        /* -12, 464,  60  */
-    0x03E73BF4,                        /* -12, 462,  62  */
-    0x040737F3,                        /* -13, 461,  64  */
-    0x04272FF3,                        /* -13, 459,  66  */
-    0x044727F3,                        /* -13, 457,  68  */
-    0x04671FF3,                        /* -13, 455,  70  */
-    0x048717F3,                        /* -13, 453,  72  */
-    0x04A70FF3,                        /* -13, 451,  74  */
-    0x04C703F4,                        /* -12, 448,  76  */
-    0x04D6FFF4,                        /* -12, 447,  77  */
-    0x04F6F7F4,                        /* -12, 445,  79  */
-    0x0516EFF4,                        /* -12, 443,  81  */
-    0x0536E7F4,                        /* -12, 441,  83  */
-    0x0556DFF4,                        /* -12, 439,  85  */
-    0x0586CFF5,                        /* -11, 435,  88  */
-    0x05A6C7F5,                        /* -11, 433,  90  */
-    0x05C6BFF5,                        /* -11, 431,  92  */
-    0x05F6B7F4,                        /* -12, 429,  95  */
-    0x0616AFF4,                        /* -12, 427,  97  */
-    0x0636A3F5,                        /* -11, 424,  99  */
-    0x06569BF5,                        /* -11, 422, 101  */
-    0x06868FF5,                        /* -11, 419, 104  */
-    0x06A687F5,                        /* -11, 417, 106  */
-    0x06C67FF5,                        /* -11, 415, 108  */
-    0x06E677F5,                        /* -11, 413, 110  */
-    0x07166BF5,                        /* -11, 410, 113  */
-    0x073663F5,                        /* -11, 408, 115  */
-    0x07665BF4,                        /* -12, 406, 118  */
-    0x07964BF5,                        /* -11, 402, 121  */
-    0x07B643F5,                        /* -11, 400, 123  */
-    0x07D637F6,                        /* -10, 397, 125  */
-    0x08062BF6,                        /* -10, 394, 128  */
-    0x082623F6,                        /* -10, 392, 130  */
-    0x085617F6,                        /* -10, 389, 133  */
-    0x08760FF6,                        /* -10, 387, 135  */
-    0x08B603F5,                        /* -11, 384, 139  */
-    0x08D5F7F6,                        /* -10, 381, 141  */
-    0x0905EBF6,                        /* -10, 378, 144  */
-    0x0925E3F6,                        /* -10, 376, 146  */
-    0x0955D3F7,                        /*  -9, 372, 149  */
-    0x0985C7F7,                        /*  -9, 369, 152  */
-    0x09A5BFF7,                        /*  -9, 367, 154  */
-    0x09D5B3F7,                        /*  -9, 364, 157  */
-    0x0A05ABF6,                        /* -10, 362, 160  */
-    0x0A359BF7,                        /*  -9, 358, 163  */
-    0x0A658FF7,                        /*  -9, 355, 166  */
-    0x0A9587F6,                        /* -10, 353, 169  */
-    0x0AB57BF7,                        /*  -9, 350, 171  */
-    0x0AE56FF7,                        /*  -9, 347, 174  */
-    0x0B1563F7,                        /*  -9, 344, 177  */
-    0x0B455BF6,                        /* -10, 342, 180  */
-    0x0B754BF7,                        /*  -9, 338, 183  */
-    0x0BA53FF7,                        /*  -9, 335, 186  */
-    0x0BD533F7,                        /*  -9, 332, 189  */
-    0x0C0523F8,                        /*  -8, 328, 192  */
-    0x0C251BF8,                        /*  -8, 326, 194  */
-    0x0C550FF8,                        /*  -8, 323, 197  */
-    0x0C9503F7,                        /*  -9, 320, 201  */
-    0x0CC4F7F7,                        /*  -9, 317, 204  */
-    0x0CF4EBF7,                        /*  -9, 314, 207  */
-    0x0D24DBF8,                        /*  -8, 310, 210  */
-    0x0D54CFF8,                        /*  -8, 307, 213  */
-    0x0D84C3F8,                        /*  -8, 304, 216  */
-    0x0DB4BBF7,                        /*  -9, 302, 219  */
-    0x0DE4AFF7,                        /*  -9, 299, 222  */
-    0x0E149FF8,                        /*  -8, 295, 225  */
-    0x0E4493F8,                        /*  -8, 292, 228  */
-    0x0E7483F9,                        /*  -7, 288, 231  */
-    0x0EA477F9,                        /*  -7, 285, 234  */
-    0x0ED46BF9,                        /*  -7, 282, 237  */
-    0x0F045FF9,                        /*  -7, 279, 240  */
-    0x0F4453F8,                        /*  -8, 276, 244  */
-    0x0F7447F8,                        /*  -8, 273, 247  */
-    0x0FA43BF8,                        /*  -8, 270, 250  */
-    0x0FD42BF9,                        /*  -7, 266, 253  */
-    0x10041FF9,                        /*  -7, 263, 256  */
+    0x3F840D05,                 /* 261, 259,  -8  */
+    0x3F841D01,                 /* 257, 263,  -8  */
+    0x3F8428FE,                 /* 254, 266,  -8  */
+    0x3F8438FA,                 /* 250, 270,  -8  */
+    0x3F8444F7,                 /* 247, 273,  -8  */
+    0x3F8450F4,                 /* 244, 276,  -8  */
+    0x3F845CF1,                 /* 241, 279,  -8  */
+    0x3F8468EE,                 /* 238, 282,  -8  */
+    0x3F8474EB,                 /* 235, 285,  -8  */
+    0x3F8480E8,                 /* 232, 288,  -8  */
+    0x3F7490E5,                 /* 229, 292,  -9  */
+    0x3F749CE2,                 /* 226, 295,  -9  */
+    0x3F74ACDE,                 /* 222, 299,  -9  */
+    0x3F74B8DB,                 /* 219, 302,  -9  */
+    0x3F74C0D9,                 /* 217, 304,  -9  */
+    0x3F74CCD6,                 /* 214, 307,  -9  */
+    0x3F74D8D3,                 /* 211, 310,  -9  */
+    0x3F74E8CF,                 /* 207, 314,  -9  */
+    0x3F74F4CC,                 /* 204, 317,  -9  */
+    0x3F7500C9,                 /* 201, 320,  -9  */
+    0x3F750CC6,                 /* 198, 323,  -9  */
+    0x3F7518C3,                 /* 195, 326,  -9  */
+    0x3F7520C1,                 /* 193, 328,  -9  */
+    0x3F7530BD,                 /* 189, 332,  -9  */
+    0x3F753CBA,                 /* 186, 335,  -9  */
+    0x3F7548B7,                 /* 183, 338,  -9  */
+    0x3F6558B4,                 /* 180, 342, -10  */
+    0x3F6560B2,                 /* 178, 344, -10  */
+    0x3F656CAF,                 /* 175, 347, -10  */
+    0x3F6578AC,                 /* 172, 350, -10  */
+    0x3F6584A9,                 /* 169, 353, -10  */
+    0x3F658CA7,                 /* 167, 355, -10  */
+    0x3F6598A4,                 /* 164, 358, -10  */
+    0x3F65A8A0,                 /* 160, 362, -10  */
+    0x3F65B09E,                 /* 158, 364, -10  */
+    0x3F65BC9B,                 /* 155, 367, -10  */
+    0x3F65C499,                 /* 153, 369, -10  */
+    0x3F65D096,                 /* 150, 372, -10  */
+    0x3F55E093,                 /* 147, 376, -11  */
+    0x3F55E891,                 /* 145, 378, -11  */
+    0x3F55F48E,                 /* 142, 381, -11  */
+    0x3F56008B,                 /* 139, 384, -11  */
+    0x3F560C88,                 /* 136, 387, -11  */
+    0x3F561486,                 /* 134, 389, -11  */
+    0x3F562083,                 /* 131, 392, -11  */
+    0x3F562881,                 /* 129, 394, -11  */
+    0x3F56347E,                 /* 126, 397, -11  */
+    0x3F56407B,                 /* 123, 400, -11  */
+    0x3F564879,                 /* 121, 402, -11  */
+    0x3F465876,                 /* 118, 406, -12  */
+    0x3F466074,                 /* 116, 408, -12  */
+    0x3F466872,                 /* 114, 410, -12  */
+    0x3F46746F,                 /* 111, 413, -12  */
+    0x3F467C6D,                 /* 109, 415, -12  */
+    0x3F46846B,                 /* 107, 417, -12  */
+    0x3F468C69,                 /* 105, 419, -12  */
+    0x3F469866,                 /* 102, 422, -12  */
+    0x3F46A064,                 /* 100, 424, -12  */
+    0x3F46AC61,                 /*  97, 427, -12  */
+    0x3F46B45F,                 /*  95, 429, -12  */
+    0x3F46BC5D,                 /*  93, 431, -12  */
+    0x3F46C45B,                 /*  91, 433, -12  */
+    0x3F46CC59,                 /*  89, 435, -12  */
+    0x3F36DC56,                 /*  86, 439, -13  */
+    0x3F36E454,                 /*  84, 441, -13  */
+    0x3F36EC52,                 /*  82, 443, -13  */
+    0x3F36F450,                 /*  80, 445, -13  */
+    0x3F36FC4E,                 /*  78, 447, -13  */
+    0x3F37004D,                 /*  77, 448, -13  */
+    0x3F370C4A,                 /*  74, 451, -13  */
+    0x3F371448,                 /*  72, 453, -13  */
+    0x3F371C46,                 /*  70, 455, -13  */
+    0x3F372444,                 /*  68, 457, -13  */
+    0x3F372C42,                 /*  66, 459, -13  */
+    0x3F373440,                 /*  64, 461, -13  */
+    0x3F37383F,                 /*  63, 462, -13  */
+    0x3F37403D,                 /*  61, 464, -13  */
+    0x3F37483B,                 /*  59, 466, -13  */
+    0x3F375039,                 /*  57, 468, -13  */
+    0x3F375438,                 /*  56, 469, -13  */
+    0x3F375C36,                 /*  54, 471, -13  */
+    0x3F376434,                 /*  52, 473, -13  */
+    0x3F376833,                 /*  51, 474, -13  */
+    0x3F377031,                 /*  49, 476, -13  */
+    0x3F377430,                 /*  48, 477, -13  */
+    0x3F377C2E,                 /*  46, 479, -13  */
+    0x3F37842C,                 /*  44, 481, -13  */
+    0x3F37882B,                 /*  43, 482, -13  */
+    0x3F47882A,                 /*  42, 482, -12  */
+    0x3F479028,                 /*  40, 484, -12  */
+    0x3F479427,                 /*  39, 485, -12  */
+    0x3F479C25,                 /*  37, 487, -12  */
+    0x3F47A024,                 /*  36, 488, -12  */
+    0x3F47A822,                 /*  34, 490, -12  */
+    0x3F47AC21,                 /*  33, 491, -12  */
+    0x3F47B020,                 /*  32, 492, -12  */
+    0x3F57B01F,                 /*  31, 492, -11  */
+    0x3F57B81D,                 /*  29, 494, -11  */
+    0x3F57BC1C,                 /*  28, 495, -11  */
+    0x3F57C01B,                 /*  27, 496, -11  */
+    0x3F57C41A,                 /*  26, 497, -11  */
+    0x3F67C818,                 /*  24, 498, -10  */
+    0x3F67CC17,                 /*  23, 499, -10  */
+    0x3F67D016,                 /*  22, 500, -10  */
+    0x3F67D415,                 /*  21, 501, -10  */
+    0x3F67D814,                 /*  20, 502, -10  */
+    0x3F77D813,                 /*  19, 502,  -9  */
+    0x3F77DC12,                 /*  18, 503,  -9  */
+    0x3F77E011,                 /*  17, 504,  -9  */
+    0x3F87E010,                 /*  16, 504,  -8  */
+    0x3F87E40F,                 /*  15, 505,  -8  */
+    0x3F87E80E,                 /*  14, 506,  -8  */
+    0x3F97E80D,                 /*  13, 506,  -7  */
+    0x3F97EC0C,                 /*  12, 507,  -7  */
+    0x3F97F00B,                 /*  11, 508,  -7  */
+    0x3FA7F00A,                 /*  10, 508,  -6  */
+    0x3FA7F409,                 /*   9, 509,  -6  */
+    0x3FB7F408,                 /*   8, 509,  -5  */
+    0x3FB7F408,                 /*   8, 509,  -5  */
+    0x3FC7F806,                 /*   6, 510,  -4  */
+    0x3FC7F806,                 /*   6, 510,  -4  */
+    0x3FD7F805,                 /*   5, 510,  -3  */
+    0x3FD7FC04,                 /*   4, 511,  -3  */
+    0x3FE7FC03,                 /*   3, 511,  -2  */
+    0x3FE7FC03,                 /*   3, 511,  -2  */
+    0x3FF7FC02,                 /*   2, 511,  -1  */
+    0x3FF7FC02,                 /*   2, 511,  -1  */
+    0x0007FC01,                 /*   1, 511,   0  */
+    0x0007FC01,                 /*   1, 511,   0  */
+    0x0007FC01,                 /*   1, 511,   0  */
+    0x0027FFFF,                 /*  -1, 511,   2  */
+    0x0027FFFF,                 /*  -1, 511,   2  */
+    0x0037FFFE,                 /*  -2, 511,   3  */
+    0x0037FFFE,                 /*  -2, 511,   3  */
+    0x0047FFFD,                 /*  -3, 511,   4  */
+    0x0047FBFE,                 /*  -2, 510,   4  */
+    0x0057FBFD,                 /*  -3, 510,   5  */
+    0x0067FBFC,                 /*  -4, 510,   6  */
+    0x0077F7FC,                 /*  -4, 509,   7  */
+    0x0077F7FC,                 /*  -4, 509,   7  */
+    0x0087F7FB,                 /*  -5, 509,   8  */
+    0x0097F3FB,                 /*  -5, 508,   9  */
+    0x00A7F3FA,                 /*  -6, 508,  10  */
+    0x00B7EFFA,                 /*  -6, 507,  11  */
+    0x00C7EBFA,                 /*  -6, 506,  12  */
+    0x00D7EBF9,                 /*  -7, 506,  13  */
+    0x00E7E7F9,                 /*  -7, 505,  14  */
+    0x00F7E3F9,                 /*  -7, 504,  15  */
+    0x0107E3F8,                 /*  -8, 504,  16  */
+    0x0117DFF8,                 /*  -8, 503,  17  */
+    0x0127DBF8,                 /*  -8, 502,  18  */
+    0x0137DBF7,                 /*  -9, 502,  19  */
+    0x0147D7F7,                 /*  -9, 501,  20  */
+    0x0157D3F7,                 /*  -9, 500,  21  */
+    0x0167CFF7,                 /*  -9, 499,  22  */
+    0x0177CBF7,                 /*  -9, 498,  23  */
+    0x0197C7F6,                 /* -10, 497,  25  */
+    0x01A7C3F6,                 /* -10, 496,  26  */
+    0x01B7BFF6,                 /* -10, 495,  27  */
+    0x01C7BBF6,                 /* -10, 494,  28  */
+    0x01E7B3F6,                 /* -10, 492,  30  */
+    0x01F7B3F5,                 /* -11, 492,  31  */
+    0x0207AFF5,                 /* -11, 491,  32  */
+    0x0217ABF5,                 /* -11, 490,  33  */
+    0x0237A3F5,                 /* -11, 488,  35  */
+    0x02479FF5,                 /* -11, 487,  36  */
+    0x026797F5,                 /* -11, 485,  38  */
+    0x027793F5,                 /* -11, 484,  39  */
+    0x02978BF5,                 /* -11, 482,  41  */
+    0x02A78BF4,                 /* -12, 482,  42  */
+    0x02B787F4,                 /* -12, 481,  43  */
+    0x02D77FF4,                 /* -12, 479,  45  */
+    0x02F777F4,                 /* -12, 477,  47  */
+    0x030773F4,                 /* -12, 476,  48  */
+    0x03276BF4,                 /* -12, 474,  50  */
+    0x033767F4,                 /* -12, 473,  51  */
+    0x03575FF4,                 /* -12, 471,  53  */
+    0x037757F4,                 /* -12, 469,  55  */
+    0x038753F4,                 /* -12, 468,  56  */
+    0x03A74BF4,                 /* -12, 466,  58  */
+    0x03C743F4,                 /* -12, 464,  60  */
+    0x03E73BF4,                 /* -12, 462,  62  */
+    0x040737F3,                 /* -13, 461,  64  */
+    0x04272FF3,                 /* -13, 459,  66  */
+    0x044727F3,                 /* -13, 457,  68  */
+    0x04671FF3,                 /* -13, 455,  70  */
+    0x048717F3,                 /* -13, 453,  72  */
+    0x04A70FF3,                 /* -13, 451,  74  */
+    0x04C703F4,                 /* -12, 448,  76  */
+    0x04D6FFF4,                 /* -12, 447,  77  */
+    0x04F6F7F4,                 /* -12, 445,  79  */
+    0x0516EFF4,                 /* -12, 443,  81  */
+    0x0536E7F4,                 /* -12, 441,  83  */
+    0x0556DFF4,                 /* -12, 439,  85  */
+    0x0586CFF5,                 /* -11, 435,  88  */
+    0x05A6C7F5,                 /* -11, 433,  90  */
+    0x05C6BFF5,                 /* -11, 431,  92  */
+    0x05F6B7F4,                 /* -12, 429,  95  */
+    0x0616AFF4,                 /* -12, 427,  97  */
+    0x0636A3F5,                 /* -11, 424,  99  */
+    0x06569BF5,                 /* -11, 422, 101  */
+    0x06868FF5,                 /* -11, 419, 104  */
+    0x06A687F5,                 /* -11, 417, 106  */
+    0x06C67FF5,                 /* -11, 415, 108  */
+    0x06E677F5,                 /* -11, 413, 110  */
+    0x07166BF5,                 /* -11, 410, 113  */
+    0x073663F5,                 /* -11, 408, 115  */
+    0x07665BF4,                 /* -12, 406, 118  */
+    0x07964BF5,                 /* -11, 402, 121  */
+    0x07B643F5,                 /* -11, 400, 123  */
+    0x07D637F6,                 /* -10, 397, 125  */
+    0x08062BF6,                 /* -10, 394, 128  */
+    0x082623F6,                 /* -10, 392, 130  */
+    0x085617F6,                 /* -10, 389, 133  */
+    0x08760FF6,                 /* -10, 387, 135  */
+    0x08B603F5,                 /* -11, 384, 139  */
+    0x08D5F7F6,                 /* -10, 381, 141  */
+    0x0905EBF6,                 /* -10, 378, 144  */
+    0x0925E3F6,                 /* -10, 376, 146  */
+    0x0955D3F7,                 /*  -9, 372, 149  */
+    0x0985C7F7,                 /*  -9, 369, 152  */
+    0x09A5BFF7,                 /*  -9, 367, 154  */
+    0x09D5B3F7,                 /*  -9, 364, 157  */
+    0x0A05ABF6,                 /* -10, 362, 160  */
+    0x0A359BF7,                 /*  -9, 358, 163  */
+    0x0A658FF7,                 /*  -9, 355, 166  */
+    0x0A9587F6,                 /* -10, 353, 169  */
+    0x0AB57BF7,                 /*  -9, 350, 171  */
+    0x0AE56FF7,                 /*  -9, 347, 174  */
+    0x0B1563F7,                 /*  -9, 344, 177  */
+    0x0B455BF6,                 /* -10, 342, 180  */
+    0x0B754BF7,                 /*  -9, 338, 183  */
+    0x0BA53FF7,                 /*  -9, 335, 186  */
+    0x0BD533F7,                 /*  -9, 332, 189  */
+    0x0C0523F8,                 /*  -8, 328, 192  */
+    0x0C251BF8,                 /*  -8, 326, 194  */
+    0x0C550FF8,                 /*  -8, 323, 197  */
+    0x0C9503F7,                 /*  -9, 320, 201  */
+    0x0CC4F7F7,                 /*  -9, 317, 204  */
+    0x0CF4EBF7,                 /*  -9, 314, 207  */
+    0x0D24DBF8,                 /*  -8, 310, 210  */
+    0x0D54CFF8,                 /*  -8, 307, 213  */
+    0x0D84C3F8,                 /*  -8, 304, 216  */
+    0x0DB4BBF7,                 /*  -9, 302, 219  */
+    0x0DE4AFF7,                 /*  -9, 299, 222  */
+    0x0E149FF8,                 /*  -8, 295, 225  */
+    0x0E4493F8,                 /*  -8, 292, 228  */
+    0x0E7483F9,                 /*  -7, 288, 231  */
+    0x0EA477F9,                 /*  -7, 285, 234  */
+    0x0ED46BF9,                 /*  -7, 282, 237  */
+    0x0F045FF9,                 /*  -7, 279, 240  */
+    0x0F4453F8,                 /*  -8, 276, 244  */
+    0x0F7447F8,                 /*  -8, 273, 247  */
+    0x0FA43BF8,                 /*  -8, 270, 250  */
+    0x0FD42BF9,                 /*  -7, 266, 253  */
+    0x10041FF9,                 /*  -7, 263, 256  */
 };
diff --git a/src/cim/cim_msr.c b/src/cim/cim_msr.c
index 4a6b72d..6dd4183 100644
--- a/src/cim/cim_msr.c
+++ b/src/cim/cim_msr.c
@@ -50,7 +50,7 @@ GEODELINK_NODE msr_dev_lookup[MSR_DEVICE_EMPTY];
 int
 msr_init_table(void)
 {
-    Q_WORD msr_value = {0, 0};
+    Q_WORD msr_value = { 0, 0 };
     unsigned int i, j;
     int return_value = CIM_STATUS_OK;
 
@@ -93,19 +93,16 @@ msr_init_table(void)
 
         msr_dev_lookup[MSR_DEVICE_GEODELX_GLIU0].address_from_cpu =
             MSR_ADDRESS_GLIU0;
-        msr_dev_lookup[MSR_DEVICE_GEODELX_GLIU0].device_id =
-            MSR_DEVICE_PRESENT;
+        msr_dev_lookup[MSR_DEVICE_GEODELX_GLIU0].device_id = MSR_DEVICE_PRESENT;
         msr_dev_lookup[MSR_DEVICE_GEODELX_GLIU1].address_from_cpu =
             MSR_ADDRESS_GLIU1;
-        msr_dev_lookup[MSR_DEVICE_GEODELX_GLIU1].device_id =
-            MSR_DEVICE_PRESENT;
+        msr_dev_lookup[MSR_DEVICE_GEODELX_GLIU1].device_id = MSR_DEVICE_PRESENT;
         msr_dev_lookup[MSR_DEVICE_5535_GLIU].address_from_cpu =
             MSR_ADDRESS_GLIU2;
         msr_dev_lookup[MSR_DEVICE_5535_GLIU].device_id = MSR_DEVICE_PRESENT;
         msr_dev_lookup[MSR_DEVICE_GEODELX_VAIL].address_from_cpu =
             MSR_ADDRESS_VAIL;
-        msr_dev_lookup[MSR_DEVICE_GEODELX_VAIL].device_id =
-            MSR_DEVICE_PRESENT;
+        msr_dev_lookup[MSR_DEVICE_GEODELX_VAIL].device_id = MSR_DEVICE_PRESENT;
 
         for (i = 0; i < MSR_DEVICE_EMPTY; i++) {
             if (msr_dev_lookup[i].device_id == MSR_DEVICE_NOTFOUND) {
@@ -123,7 +120,8 @@ msr_init_table(void)
                 }
             }
         }
-    } else {
+    }
+    else {
         /* ERROR OUT THE GEODELINK TABLES */
 
         for (i = 0; i < 24; i++) {
@@ -157,7 +155,7 @@ msr_create_geodelink_table(GEODELINK_NODE * gliu_nodes)
     int glcp_count = 0;
     int usb_count = 0;
     int mpci_count = 0;
-    Q_WORD msr_value = {0, 0};
+    Q_WORD msr_value = { 0, 0 };
 
     /* ALL THREE GLIUS ARE IN ONE ARRAY                               */
     /* Entries 0-7 contain the port information for GLIU0, entries    */
@@ -199,7 +197,7 @@ msr_create_geodelink_table(GEODELINK_NODE * gliu_nodes)
             gliu_nodes[port].device_id = MSR_CLASS_CODE_UNPOPULATED;
         else {
             MSR_READ(MSR_GEODELINK_CAP, gliu_nodes[port].address_from_cpu,
-                &msr_value);
+                     &msr_value);
             gliu_nodes[port].device_id =
                 GET_DEVICE_ID(msr_value.high, msr_value.low);
         }
@@ -230,7 +228,7 @@ msr_create_geodelink_table(GEODELINK_NODE * gliu_nodes)
             gliu_nodes[index].device_id = MSR_CLASS_CODE_UNPOPULATED;
         else {
             MSR_READ(MSR_GEODELINK_CAP, gliu_nodes[index].address_from_cpu,
-                &msr_value);
+                     &msr_value);
             gliu_nodes[index].device_id =
                 GET_DEVICE_ID(msr_value.high, msr_value.low);
         }
@@ -272,7 +270,7 @@ msr_create_geodelink_table(GEODELINK_NODE * gliu_nodes)
             gliu_nodes[index].device_id = MSR_CLASS_CODE_UNPOPULATED;
         else {
             MSR_READ(MSR_GEODELINK_CAP, gliu_nodes[index].address_from_cpu,
-                &msr_value);
+                     &msr_value);
             gliu_nodes[index].device_id =
                 GET_DEVICE_ID(msr_value.high, msr_value.low);
         }
@@ -397,13 +395,12 @@ msr_create_device_list(GEODELINK_NODE * gliu_nodes, int max_devices)
  *-------------------------------------------------------------------*/
 
 int
-msr_read64(unsigned long device, unsigned long msr_register,
-    Q_WORD * msr_value)
+msr_read64(unsigned long device, unsigned long msr_register, Q_WORD * msr_value)
 {
     if (device < MSR_DEVICE_EMPTY) {
         if (msr_dev_lookup[device].device_id == MSR_DEVICE_PRESENT) {
             MSR_READ(msr_register, msr_dev_lookup[device].address_from_cpu,
-                msr_value);
+                     msr_value);
             return CIM_STATUS_OK;
         }
     }
@@ -421,12 +418,12 @@ msr_read64(unsigned long device, unsigned long msr_register,
 
 int
 msr_write64(unsigned long device, unsigned long msr_register,
-    Q_WORD * msr_value)
+            Q_WORD * msr_value)
 {
     if (device < MSR_DEVICE_EMPTY) {
         if (msr_dev_lookup[device].device_id == MSR_DEVICE_PRESENT) {
             MSR_WRITE(msr_register, msr_dev_lookup[device].address_from_cpu,
-                msr_value);
+                      msr_value);
             return CIM_STATUS_OK;
         }
     }
diff --git a/src/cim/cim_parm.h b/src/cim/cim_parm.h
index ed1df8b..a8fa9b0 100644
--- a/src/cim/cim_parm.h
+++ b/src/cim/cim_parm.h
@@ -101,8 +101,7 @@
 /* on a GeodeLink Interface Unit (GLIU)        */
 /*---------------------------------------------*/
 
-typedef struct tagGeodeLinkNode
-{
+typedef struct tagGeodeLinkNode {
     unsigned long address_from_cpu;
     unsigned long device_id;
 
@@ -113,8 +112,7 @@ typedef struct tagGeodeLinkNode
 /* 64-bit data structure for MSR acess.        */
 /*---------------------------------------------*/
 
-typedef struct tagQ_WORD
-{
+typedef struct tagQ_WORD {
     unsigned long high;
     unsigned long low;
 
@@ -124,8 +122,7 @@ typedef struct tagQ_WORD
 /*       INITIALIZATION USER PARAMETERS              */
 /*===================================================*/
 
-typedef struct tagInitBaseAddresses
-{
+typedef struct tagInitBaseAddresses {
     unsigned long framebuffer_base;
     unsigned long gp_register_base;
     unsigned long vg_register_base;
@@ -212,8 +209,7 @@ typedef struct tagInitBaseAddresses
 /* USER STRUCTURE FOR SAVING/RESTORING GP STATE */
 /*----------------------------------------------*/
 
-typedef struct tagGPSaveRestore
-{
+typedef struct tagGPSaveRestore {
     unsigned long base_offset;
     unsigned long cmd_top;
     unsigned long cmd_bottom;
@@ -326,8 +322,7 @@ typedef struct tagGPSaveRestore
                                            VG_MODEFLAG_EXCLUDEPLL     | \
                                            VG_MODEFLAG_LINEARPITCH)
 
-typedef struct tagVGDisplayMode
-{
+typedef struct tagVGDisplayMode {
     /* DISPLAY MODE FLAGS */
     /* Includes BPP, refresh rate information, interlacing, etc. */
 
@@ -402,8 +397,7 @@ typedef struct tagVGDisplayMode
 /* USER STRUCTURE FOR QUERYING DISPLAY MODES */
 /*-------------------------------------------*/
 
-typedef struct tagQueryDisplayMode
-{
+typedef struct tagQueryDisplayMode {
     int interlaced;
     int halfclock;
     unsigned long active_width;
@@ -425,8 +419,7 @@ typedef struct tagQueryDisplayMode
 /* USER STRUCTURE FOR QUERYING CURSOR DATA   */
 /*-------------------------------------------*/
 
-typedef struct tagCursorData
-{
+typedef struct tagCursorData {
     int enable;
     int color_cursor;
     unsigned long cursor_offset;
@@ -451,8 +444,7 @@ typedef struct tagCursorData
 /* USER STRUCTURE FOR SETTING COMPRESSION DATA    */
 /*------------------------------------------------*/
 
-typedef struct tagCompressionData
-{
+typedef struct tagCompressionData {
     unsigned long compression_offset;
     unsigned long pitch;
     unsigned long size;
@@ -464,8 +456,7 @@ typedef struct tagCompressionData
 /* USER STRUCTURE FOR CONFIGURING LINE INTERRUPTS  */
 /*-------------------------------------------------*/
 
-typedef struct tagInterruptInfo
-{
+typedef struct tagInterruptInfo {
     unsigned long line;
     unsigned long flags;
     int enable;
@@ -476,8 +467,7 @@ typedef struct tagInterruptInfo
 /* USER STRUCTURE FOR PANNING THE DESKTOP          */
 /*-------------------------------------------------*/
 
-typedef struct tagPanningInfo
-{
+typedef struct tagPanningInfo {
     unsigned long start_x;
     unsigned long start_y;
     int start_updated;
@@ -488,8 +478,7 @@ typedef struct tagPanningInfo
 /* USER STRUCTURE FOR SAVING/RESTORING THE VG STATE */
 /*--------------------------------------------------*/
 
-typedef struct tagVGSaveRestore
-{
+typedef struct tagVGSaveRestore {
     /* VG REGISTERS */
 
     unsigned long unlock;
@@ -680,8 +669,7 @@ typedef struct tagVGSaveRestore
 #define DF_SOURCEFLAG_HDTVSOURCE          0x0001
 #define DF_SOURCEFLAG_IMPLICITSCALING     0x0002
 
-typedef struct tagVideoSourceInfo
-{
+typedef struct tagVideoSourceInfo {
     unsigned long video_format;
     unsigned long y_offset;
     unsigned long u_offset;
@@ -701,8 +689,7 @@ typedef struct tagVideoSourceInfo
 #define DF_POSFLAG_DIRECTCLIP             0x0001
 #define DF_POSFLAG_INCLUDEBORDER          0x0002
 
-typedef struct tagVideoPosition
-{
+typedef struct tagVideoPosition {
     long x;
     long y;
     unsigned long width;
@@ -717,8 +704,7 @@ typedef struct tagVideoPosition
 /* USER STRUCTURE FOR CONFIGURING THE VIDEO CURSOR */
 /*-------------------------------------------------*/
 
-typedef struct tagVideoCursorInfo
-{
+typedef struct tagVideoCursorInfo {
     unsigned long key;
     unsigned long mask;
     unsigned long color1;
@@ -735,8 +721,7 @@ typedef struct tagVideoCursorInfo
 #define DF_ALPHAFLAG_COLORENABLED         0x0001
 #define DF_ALPHAFLAG_PERPIXELENABLED      0x0002
 
-typedef struct tagAlphaRegionInfo
-{
+typedef struct tagAlphaRegionInfo {
     unsigned long x;
     unsigned long y;
     unsigned long width;
@@ -753,8 +738,7 @@ typedef struct tagAlphaRegionInfo
 /* USER STRUCTURE FOR SAVING/RESTORING DF DATA     */
 /*-------------------------------------------------*/
 
-typedef struct tagDFSaveRestore
-{
+typedef struct tagDFSaveRestore {
     unsigned long vcfg;
     unsigned long dcfg;
     unsigned long video_x;
@@ -828,8 +812,7 @@ typedef struct tagDFSaveRestore
 /* USER STRUCTURE FOR CONFIGURING 601 SETTINGS */
 /*---------------------------------------------*/
 
-typedef struct _TAG_VIP601PARAMS
-{
+typedef struct _TAG_VIP601PARAMS {
     unsigned long flags;
     unsigned long horz_start;
     unsigned long width;
@@ -886,8 +869,7 @@ typedef struct _TAG_VIP601PARAMS
 #define VIP_420CAPTURE_ALTERNATINGLINES   0x00000002
 #define VIP_420CAPTURE_ALTERNATINGFIELDS  0x00000003
 
-typedef struct _TAG_SETMODEBUFFER
-{
+typedef struct _TAG_SETMODEBUFFER {
     unsigned long flags;
     unsigned long stream_enables;
     unsigned long operating_mode;
@@ -929,8 +911,7 @@ typedef struct _TAG_SETMODEBUFFER
 /* USER STRUCTURE FOR CONFIGURING THE VG VSYNC GENLOCK    */
 /*--------------------------------------------------------*/
 
-typedef struct _TAG_GENLOCKBUFFER
-{
+typedef struct _TAG_GENLOCKBUFFER {
     unsigned long vip_signal_loss;
     unsigned long vsync_to_vg;
     unsigned long field_to_vg;
@@ -943,8 +924,7 @@ typedef struct _TAG_GENLOCKBUFFER
 /* USER STRUCTURE FOR CONFIGURING VIP ANCILLARY CAPTURE */
 /*------------------------------------------------------*/
 
-typedef struct _TAG_ANCILLARYBUFFER
-{
+typedef struct _TAG_ANCILLARYBUFFER {
     unsigned long msg1_base;
     unsigned long msg2_base;
     unsigned long msg_size;
@@ -975,8 +955,7 @@ typedef struct _TAG_ANCILLARYBUFFER
 #define VIP_BUFFER_B_ODD                  0x0007
 #define VIP_BUFFER_B_EVEN                 0x0008
 
-typedef struct _TAG_INPUTBUFFER_ADDR
-{
+typedef struct _TAG_INPUTBUFFER_ADDR {
     unsigned long even_base[VIP_MAX_BUFFERS];
     unsigned long odd_base[VIP_MAX_BUFFERS];
     unsigned long y_pitch;
@@ -990,8 +969,7 @@ typedef struct _TAG_INPUTBUFFER_ADDR
 
 } VIPINPUTBUFFER_ADDR;
 
-typedef struct _TAG_SETINPUTBUFFER
-{
+typedef struct _TAG_SETINPUTBUFFER {
     unsigned long flags;
     VIPINPUTBUFFER_ADDR offsets[VIP_BUFFER_MAX_TASKS];
     unsigned long current_buffer;
@@ -1004,8 +982,7 @@ typedef struct _TAG_SETINPUTBUFFER
 /* USER STRUCTURE FOR CONFIGURING VIP SUBWINDOW CAPTURE */
 /*------------------------------------------------------*/
 
-typedef struct _TAG_SUBWINDOWBUFFER
-{
+typedef struct _TAG_SUBWINDOWBUFFER {
     int enable;
     unsigned long start;
     unsigned long stop;
@@ -1016,8 +993,7 @@ typedef struct _TAG_SUBWINDOWBUFFER
 /* USER STRUCTURE FOR SAVING/RESTORING VIP REGISTERS      */
 /*--------------------------------------------------------*/
 
-typedef struct _TAG_VIPSTATEBUFFER
-{
+typedef struct _TAG_VIPSTATEBUFFER {
     unsigned long control1;
     unsigned long control2;
     unsigned long vip_int;
@@ -1108,8 +1084,7 @@ typedef struct _TAG_VIPSTATEBUFFER
 /* USER STRUCTURE FOR QUERYING VIP CAPABILITIES    */
 /*-------------------------------------------------*/
 
-typedef struct _TAG_CAPABILITIESBUFFER
-{
+typedef struct _TAG_CAPABILITIESBUFFER {
     unsigned long revision_id;
     unsigned long device_id;
     unsigned long n_clock_domains;
@@ -1121,8 +1096,7 @@ typedef struct _TAG_CAPABILITIESBUFFER
 /* USER STRUCTURE FOR CONFIGURING VIP POWER        */
 /*-------------------------------------------------*/
 
-typedef struct _TAG_POWERBUFFER
-{
+typedef struct _TAG_POWERBUFFER {
     int glink_clock_mode;
     int vip_clock_mode;
 
@@ -1132,8 +1106,7 @@ typedef struct _TAG_POWERBUFFER
 /* USER STRUCTURE FOR CONFIGURING VIP PRIORITIES   */
 /*-------------------------------------------------*/
 
-typedef struct _TAG_PRIORITYBUFFER
-{
+typedef struct _TAG_PRIORITYBUFFER {
     unsigned long secondary;
     unsigned long primary;
     unsigned long pid;
@@ -1164,8 +1137,7 @@ typedef struct _TAG_PRIORITYBUFFER
 #define VIP_DIAG_LOWER_FORMATTER          0x00000200
 #define VIP_DIAG_LOWER_INPUT_CONTROL      0x00000400
 
-typedef struct _TAG_DEBUGBUFFER
-{
+typedef struct _TAG_DEBUGBUFFER {
     unsigned long bist;
     unsigned long enable_upper;
     unsigned long select_upper;
@@ -1182,8 +1154,7 @@ typedef struct _TAG_DEBUGBUFFER
 /* USER STRUCTURE FOR CONFIGURING VBI CAPTURE           */
 /*------------------------------------------------------*/
 
-typedef struct _TAG_VBIWINDOWBUFFER
-{
+typedef struct _TAG_VBIWINDOWBUFFER {
     long horz_start;
     unsigned long vbi_width;
     unsigned long odd_line_capture_mask;
@@ -1217,8 +1188,7 @@ typedef struct _TAG_VBIWINDOWBUFFER
 #define VOP_601_RGB_8_8_8                 0x00000002
 #define VOP_601_YUV_4_4_4                 0x00000003
 
-typedef struct _TAG_VOP601
-{
+typedef struct _TAG_VOP601 {
     unsigned long flags;
     unsigned long vsync_shift;
     unsigned long vsync_shift_count;
@@ -1262,8 +1232,7 @@ typedef struct _TAG_VOP601
 #define VOP_MB_SYNCSEL_STATREG17          0x00000060
 #define VOP_MB_SYNCSEL_STATREG17_INV      0x00000080
 
-typedef struct _TAG_VOPMODECONFIGURATIONBUFFER
-{
+typedef struct _TAG_VOPMODECONFIGURATIONBUFFER {
     unsigned long flags;
     unsigned long mode;
     unsigned long conversion_mode;
@@ -1276,8 +1245,7 @@ typedef struct _TAG_VOPMODECONFIGURATIONBUFFER
 /* USER STRUCTURE FOR SAVING/RESTORING VOP REGISTERS      */
 /*--------------------------------------------------------*/
 
-typedef struct _TAG_VOPSTATEBUFFER
-{
+typedef struct _TAG_VOPSTATEBUFFER {
     unsigned long config;
 } VOPSTATEBUFFER;
 
diff --git a/src/cim/cim_regs.h b/src/cim/cim_regs.h
index 6d434a2..f0bc95a 100644
--- a/src/cim/cim_regs.h
+++ b/src/cim/cim_regs.h
@@ -636,8 +636,7 @@
 /* and not the m, n and p from the PLL equation.  The PLL */
 /* equation adds 1 to each value.                         */
 
-typedef struct tagPLLFrequency
-{
+typedef struct tagPLLFrequency {
     unsigned long pll_value;
     unsigned long frequency;
 
diff --git a/src/cim/cim_rtns.h b/src/cim/cim_rtns.h
index 60bdcd1..588d3d1 100644
--- a/src/cim/cim_rtns.h
+++ b/src/cim/cim_rtns.h
@@ -38,8 +38,7 @@
 /* COMPILER OPTION FOR C++ PROGRAMS */
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
 /*--------------------------*/
@@ -59,7 +58,7 @@ extern "C"
 /*----------------------------------------*/
 
     int init_detect_cpu(unsigned long *cpu_revision,
-        unsigned long *companion_revision);
+                        unsigned long *companion_revision);
     unsigned long init_read_pci(unsigned long address);
     int init_read_base_addresses(INIT_BASE_ADDRESSES * base_addresses);
     int init_read_cpu_frequency(unsigned long *cpu_frequency);
@@ -70,7 +69,7 @@ extern "C"
 
     void gp_set_limit_on_buffer_lead(unsigned long lead);
     void gp_set_command_buffer_base(unsigned long address,
-        unsigned long start, unsigned long stop);
+                                    unsigned long start, unsigned long stop);
     void gp_set_frame_buffer_base(unsigned long address, unsigned long size);
     void gp_set_bpp(int bpp);
     void gp_declare_blt(unsigned long flags);
@@ -78,69 +77,76 @@ extern "C"
     void gp_write_parameters(void);
     void gp_set_raster_operation(unsigned char ROP);
     void gp_set_alpha_operation(int alpha_operation, int alpha_type,
-        int channel, int apply_alpha, unsigned char alpha);
+                                int channel, int apply_alpha,
+                                unsigned char alpha);
     void gp_set_solid_pattern(unsigned long color);
     void gp_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-        unsigned long data0, unsigned long data1, int transparent, int x,
-        int y);
+                             unsigned long data0, unsigned long data1,
+                             int transparent, int x, int y);
     void gp_set_pattern_origin(int x, int y);
-    void gp_set_color_pattern(unsigned long *pattern, int format, int x,
-        int y);
+    void gp_set_color_pattern(unsigned long *pattern, int format, int x, int y);
     void gp_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-        int transparent);
+                            int transparent);
     void gp_set_solid_source(unsigned long color);
     void gp_set_source_transparency(unsigned long color, unsigned long mask);
     void gp_program_lut(unsigned long *colors, int full_lut);
     void gp_set_vector_pattern(unsigned long pattern, unsigned long color,
-        int length);
+                               int length);
     void gp_set_strides(unsigned long dst_stride, unsigned long src_stride);
     void gp_set_source_format(int format);
     void gp_pattern_fill(unsigned long dstoffset, unsigned long width,
-        unsigned long height);
+                         unsigned long height);
     void gp_screen_to_screen_blt(unsigned long dstoffset,
-        unsigned long srcoffset, unsigned long width,
-        unsigned long height, int flags);
+                                 unsigned long srcoffset, unsigned long width,
+                                 unsigned long height, int flags);
     void gp_screen_to_screen_convert(unsigned long dstoffset,
-        unsigned long srcoffset, unsigned long width,
-        unsigned long height, int nibble);
+                                     unsigned long srcoffset,
+                                     unsigned long width, unsigned long height,
+                                     int nibble);
     void gp_color_bitmap_to_screen_blt(unsigned long dstoffset,
-        unsigned long srcx, unsigned long width, unsigned long height,
-        unsigned char *data, long pitch);
+                                       unsigned long srcx, unsigned long width,
+                                       unsigned long height,
+                                       unsigned char *data, long pitch);
     void gp_color_convert_blt(unsigned long dstoffset, unsigned long srcx,
-        unsigned long width, unsigned long height, unsigned char *data,
-        long pitch);
+                              unsigned long width, unsigned long height,
+                              unsigned char *data, long pitch);
     void gp_custom_convert_blt(unsigned long dstoffset, unsigned long srcx,
-        unsigned long width, unsigned long height, unsigned char *data,
-        long pitch);
+                               unsigned long width, unsigned long height,
+                               unsigned char *data, long pitch);
     void gp_rotate_blt(unsigned long dstoffset, unsigned long srcoffset,
-        unsigned long width, unsigned long height, int degrees);
+                       unsigned long width, unsigned long height, int degrees);
     void gp_mono_bitmap_to_screen_blt(unsigned long dstoffset,
-        unsigned long srcx, unsigned long width, unsigned long height,
-        unsigned char *data, long stride);
+                                      unsigned long srcx, unsigned long width,
+                                      unsigned long height, unsigned char *data,
+                                      long stride);
     void gp_text_blt(unsigned long dstoffset, unsigned long width,
-        unsigned long height, unsigned char *data);
+                     unsigned long height, unsigned char *data);
     void gp_mono_expand_blt(unsigned long dstoffset, unsigned long srcoffset,
-        unsigned long srcx, unsigned long width, unsigned long height,
-        int byte_packed);
+                            unsigned long srcx, unsigned long width,
+                            unsigned long height, int byte_packed);
     void gp_antialiased_text(unsigned long dstoffset, unsigned long srcx,
-        unsigned long width, unsigned long height, unsigned char *data,
-        long stride, int fourbpp);
-  void gp_blend_mask_blt(unsigned long dstoffset, unsigned long srcx,
-	unsigned long width, unsigned long height, unsigned long,
-        long stride, int operation, int fourbpp);
-  void gp_masked_blt(unsigned long dstoffset, unsigned long width,
-        unsigned long height, unsigned long mono_srcx,
-        unsigned long color_srcx, unsigned char *mono_mask,
-        unsigned char *color_data, long mono_pitch, long color_pitch);
+                             unsigned long width, unsigned long height,
+                             unsigned char *data, long stride, int fourbpp);
+    void gp_blend_mask_blt(unsigned long dstoffset, unsigned long srcx,
+                           unsigned long width, unsigned long height,
+                           unsigned long, long stride, int operation,
+                           int fourbpp);
+    void gp_masked_blt(unsigned long dstoffset, unsigned long width,
+                       unsigned long height, unsigned long mono_srcx,
+                       unsigned long color_srcx, unsigned char *mono_mask,
+                       unsigned char *color_data, long mono_pitch,
+                       long color_pitch);
     void gp_screen_to_screen_masked(unsigned long dstoffset,
-        unsigned long srcoffset, unsigned long width,
-        unsigned long height, unsigned long mono_srcx,
-        unsigned char *mono_mask, long mono_pitch);
+                                    unsigned long srcoffset,
+                                    unsigned long width, unsigned long height,
+                                    unsigned long mono_srcx,
+                                    unsigned char *mono_mask, long mono_pitch);
     void gp_bresenham_line(unsigned long dstoffset, unsigned short length,
-        unsigned short initerr, unsigned short axialerr,
-        unsigned short diagerr, unsigned long flags);
+                           unsigned short initerr, unsigned short axialerr,
+                           unsigned short diagerr, unsigned long flags);
     void gp_line_from_endpoints(unsigned long dstoffset, unsigned long x0,
-        unsigned long y0, unsigned long x1, unsigned long y1, int inclusive);
+                                unsigned long y0, unsigned long x1,
+                                unsigned long y1, int inclusive);
 
     int gp_test_blt_pending(void);
     void gp_wait_blt_pending(void);
@@ -155,50 +161,54 @@ extern "C"
 
     int vg_delay_milliseconds(unsigned long ms);
     int vg_set_display_mode(unsigned long src_width, unsigned long src_height,
-        unsigned long dst_width, unsigned long dst_height, int bpp, int hz,
-        unsigned long flags);
+                            unsigned long dst_width, unsigned long dst_height,
+                            int bpp, int hz, unsigned long flags);
     int vg_set_panel_mode(unsigned long src_width, unsigned long src_height,
-        unsigned long dst_width, unsigned long dst_height,
-        unsigned long panel_width, unsigned long panel_height,
-        int bpp, unsigned long flags);
+                          unsigned long dst_width, unsigned long dst_height,
+                          unsigned long panel_width, unsigned long panel_height,
+                          int bpp, unsigned long flags);
     int vg_set_tv_mode(unsigned long *src_width, unsigned long *src_height,
-        unsigned long encoder, unsigned long tvres, int bpp,
-        unsigned long flags, unsigned long h_overscan,
-        unsigned long v_overscan);
+                       unsigned long encoder, unsigned long tvres, int bpp,
+                       unsigned long flags, unsigned long h_overscan,
+                       unsigned long v_overscan);
     int vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp);
     int vg_set_display_bpp(int bpp);
     int vg_get_display_mode_index(VG_QUERY_MODE * query);
     int vg_get_display_mode_information(unsigned int index,
-        VG_DISPLAY_MODE * vg_mode);
+                                        VG_DISPLAY_MODE * vg_mode);
     int vg_get_display_mode_count(void);
     int vg_get_current_display_mode(VG_DISPLAY_MODE * current_display,
-        int *bpp);
+                                    int *bpp);
     int vg_set_scaler_filter_coefficients(long h_taps[][5], long v_taps[][3]);
     int vg_configure_flicker_filter(unsigned long flicker_strength,
-        int flicker_alpha);
+                                    int flicker_alpha);
     int vg_set_clock_frequency(unsigned long frequency,
-        unsigned long pll_flags);
+                               unsigned long pll_flags);
     int vg_set_border_color(unsigned long border_color);
     int vg_set_cursor_enable(int enable);
-    int vg_set_mono_cursor_colors(unsigned long bkcolor,
-        unsigned long fgcolor);
+    int vg_set_mono_cursor_colors(unsigned long bkcolor, unsigned long fgcolor);
     int vg_set_cursor_position(long xpos, long ypos,
-        VG_PANNING_COORDINATES * panning);
+                               VG_PANNING_COORDINATES * panning);
     int vg_set_mono_cursor_shape32(unsigned long memoffset,
-        unsigned long *andmask, unsigned long *xormask,
-        unsigned long x_hotspot, unsigned long y_hotspot);
+                                   unsigned long *andmask,
+                                   unsigned long *xormask,
+                                   unsigned long x_hotspot,
+                                   unsigned long y_hotspot);
     int vg_set_mono_cursor_shape64(unsigned long memoffset,
-        unsigned long *andmask, unsigned long *xormask,
-        unsigned long x_hotspot, unsigned long y_hotspot);
-    int vg_set_color_cursor_shape(unsigned long memoffset,
-        unsigned char *data, unsigned long width, unsigned long height,
-        long pitch, unsigned long x_hotspot, unsigned long y_hotspot);
+                                   unsigned long *andmask,
+                                   unsigned long *xormask,
+                                   unsigned long x_hotspot,
+                                   unsigned long y_hotspot);
+    int vg_set_color_cursor_shape(unsigned long memoffset, unsigned char *data,
+                                  unsigned long width, unsigned long height,
+                                  long pitch, unsigned long x_hotspot,
+                                  unsigned long y_hotspot);
     int vg_pan_desktop(unsigned long x, unsigned long y,
-        VG_PANNING_COORDINATES * panning);
+                       VG_PANNING_COORDINATES * panning);
     int vg_set_display_offset(unsigned long address);
     int vg_set_display_pitch(unsigned long pitch);
     int vg_set_display_palette_entry(unsigned long index,
-        unsigned long palette);
+                                     unsigned long palette);
     int vg_set_display_palette(unsigned long *palette);
     int vg_set_compression_enable(int enable);
     int vg_configure_compression(VG_COMPRESSION_DATA * comp_data);
@@ -218,17 +228,17 @@ extern "C"
 
     unsigned long vg_read_graphics_crc(int crc_source);
     unsigned long vg_read_window_crc(int crc_source, unsigned long x,
-        unsigned long y, unsigned long width, unsigned long height);
+                                     unsigned long y, unsigned long width,
+                                     unsigned long height);
     int vg_get_scaler_filter_coefficients(long h_taps[][5], long v_taps[][3]);
     int vg_get_flicker_filter_configuration(unsigned long *strength,
-        int *flicker_alpha);
+                                            int *flicker_alpha);
     unsigned long vg_get_display_pitch(void);
     unsigned long vg_get_frame_buffer_line_size(void);
     unsigned long vg_get_current_vline(void);
     unsigned long vg_get_display_offset(void);
     int vg_get_cursor_info(VG_CURSOR_DATA * cursor_data);
-    int vg_get_display_palette_entry(unsigned long index,
-        unsigned long *entry);
+    int vg_get_display_palette_entry(unsigned long index, unsigned long *entry);
     unsigned long vg_get_border_color(void);
     int vg_get_display_palette(unsigned long *palette);
     int vg_get_compression_info(VG_COMPRESSION_DATA * comp_data);
@@ -242,25 +252,24 @@ extern "C"
     int df_set_crt_enable(int crt_output);
     int df_set_panel_enable(int panel_output);
     int df_configure_video_source(DF_VIDEO_SOURCE_PARAMS * video_source_odd,
-        DF_VIDEO_SOURCE_PARAMS * video_source_even);
+                                  DF_VIDEO_SOURCE_PARAMS * video_source_even);
     int df_set_video_offsets(int even, unsigned long y_offset,
-        unsigned long u_offset, unsigned long v_offset);
+                             unsigned long u_offset, unsigned long v_offset);
     int df_set_video_scale(unsigned long src_width, unsigned long src_height,
-        unsigned long dst_width, unsigned long dst_height,
-        unsigned long flags);
+                           unsigned long dst_width, unsigned long dst_height,
+                           unsigned long flags);
     int df_set_video_position(DF_VIDEO_POSITION * video_window);
     int df_set_video_filter_coefficients(long taps[][4], int phase256);
     int df_set_video_enable(int enable, unsigned long flags);
     int df_set_video_color_key(unsigned long key, unsigned long mask,
-        int graphics);
+                               int graphics);
     int df_set_video_palette(unsigned long *palette);
-    int df_set_video_palette_entry(unsigned long index,
-        unsigned long palette);
+    int df_set_video_palette_entry(unsigned long index, unsigned long palette);
     int df_configure_video_cursor_color_key(DF_VIDEO_CURSOR_PARAMS *
-        cursor_color_key);
+                                            cursor_color_key);
     int df_set_video_cursor_color_key_enable(int enable);
     int df_configure_alpha_window(int window,
-        DF_ALPHA_REGION_PARAMS * alpha_data);
+                                  DF_ALPHA_REGION_PARAMS * alpha_data);
     int df_set_alpha_window_enable(int window, int enable);
     int df_set_no_ck_outside_alpha(int enable);
     int df_set_video_request(unsigned long x, unsigned long y);
@@ -276,25 +285,28 @@ extern "C"
 
     unsigned long df_read_composite_crc(int crc_source);
     unsigned long df_read_composite_window_crc(unsigned long x,
-        unsigned long y, unsigned long width, unsigned long height,
-        int source);
+                                               unsigned long y,
+                                               unsigned long width,
+                                               unsigned long height,
+                                               int source);
     unsigned long df_read_panel_crc(void);
     int df_get_video_enable(int *enable, unsigned long *flags);
     int df_get_video_source_configuration(DF_VIDEO_SOURCE_PARAMS *
-        video_source_odd, DF_VIDEO_SOURCE_PARAMS * video_source_even);
+                                          video_source_odd,
+                                          DF_VIDEO_SOURCE_PARAMS *
+                                          video_source_even);
     int df_get_video_position(DF_VIDEO_POSITION * video_window);
     int df_get_video_scale(unsigned long *x_scale, unsigned long *y_scale);
     int df_get_video_filter_coefficients(long taps[][4], int *phase256);
     int df_get_video_color_key(unsigned long *key, unsigned long *mask,
-        int *graphics);
-    int df_get_video_palette_entry(unsigned long index,
-        unsigned long *palette);
+                               int *graphics);
+    int df_get_video_palette_entry(unsigned long index, unsigned long *palette);
     int df_get_video_palette(unsigned long *palette);
     int df_get_video_cursor_color_key(DF_VIDEO_CURSOR_PARAMS *
-        cursor_color_key);
+                                      cursor_color_key);
     int df_get_video_cursor_color_key_enable(void);
     int df_get_alpha_window_configuration(int window,
-        DF_ALPHA_REGION_PARAMS * alpha_data);
+                                          DF_ALPHA_REGION_PARAMS * alpha_data);
     int df_get_alpha_window_enable(int window);
     int df_get_video_request(unsigned long *x, unsigned long *y);
     int df_get_output_color_space(int *color_space);
@@ -307,9 +319,9 @@ extern "C"
     int msr_create_geodelink_table(GEODELINK_NODE * gliu_nodes);
     int msr_create_device_list(GEODELINK_NODE * gliu_nodes, int max_devices);
     int msr_read64(unsigned long device, unsigned long msr_register,
-        Q_WORD * msr_value);
+                   Q_WORD * msr_value);
     int msr_write64(unsigned long device, unsigned long msr_register,
-        Q_WORD * msr_value);
+                    Q_WORD * msr_value);
 
 /*----------------------------------------*/
 /*        VIP ROUTINE DEFINITIONS         */
@@ -318,15 +330,15 @@ extern "C"
     int vip_initialize(VIPSETMODEBUFFER * buffer);
     int vip_update_601_params(VIP_601PARAMS * buffer);
     int vip_terminate(void);
-    int vip_configure_capture_buffers(int buffer_type,
-        VIPINPUTBUFFER * buffer);
+    int vip_configure_capture_buffers(int buffer_type, VIPINPUTBUFFER * buffer);
     int vip_toggle_video_offsets(int buffer_type, VIPINPUTBUFFER * buffer);
     int vip_max_address_enable(unsigned long max_address, int enable);
     int vip_set_interrupt_enable(unsigned long mask, int enable);
     unsigned long vip_get_interrupt_state(void);
     int vip_set_capture_state(unsigned long state);
     int vip_set_vsync_error(unsigned long vertical_count,
-        unsigned long window_before, unsigned long window_after, int enable);
+                            unsigned long window_before,
+                            unsigned long window_after, int enable);
     int vip_configure_fifo(unsigned long fifo_type, unsigned long fifo_size);
     int vip_set_loopback_enable(int bEnable);
     int vip_configure_genlock(VIPGENLOCKBUFFER * buffer);
@@ -352,8 +364,7 @@ extern "C"
 
     int vip_get_current_mode(VIPSETMODEBUFFER * buffer);
     int vip_get_601_configuration(VIP_601PARAMS * buffer);
-    int vip_get_buffer_configuration(int buffer_type,
-        VIPINPUTBUFFER * buffer);
+    int vip_get_buffer_configuration(int buffer_type, VIPINPUTBUFFER * buffer);
     int vip_get_genlock_configuration(VIPGENLOCKBUFFER * buffer);
     int vip_get_genlock_enable(void);
     int vip_is_buffer_update_latched(void);
@@ -391,5 +402,4 @@ extern "C"
 #ifdef __cplusplus
 }
 #endif
-
 #endif
diff --git a/src/cim/cim_vg.c b/src/cim/cim_vg.c
index ff24221..bc429cb 100644
--- a/src/cim/cim_vg.c
+++ b/src/cim/cim_vg.c
@@ -76,8 +76,8 @@ vg_delay_milliseconds(unsigned long ms)
 
 int
 vg_set_display_mode(unsigned long src_width, unsigned long src_height,
-    unsigned long dst_width, unsigned long dst_height,
-    int bpp, int hz, unsigned long flags)
+                    unsigned long dst_width, unsigned long dst_height,
+                    int bpp, int hz, unsigned long flags)
 {
     VG_QUERY_MODE crt_query;
     VG_DISPLAY_MODE crt_mode;
@@ -130,9 +130,9 @@ vg_set_display_mode(unsigned long src_width, unsigned long src_height,
 
 int
 vg_set_panel_mode(unsigned long src_width, unsigned long src_height,
-    unsigned long dst_width, unsigned long dst_height,
-    unsigned long panel_width, unsigned long panel_height,
-    int bpp, unsigned long flags)
+                  unsigned long dst_width, unsigned long dst_height,
+                  unsigned long panel_width, unsigned long panel_height,
+                  int bpp, unsigned long flags)
 {
     unsigned long sync_width;
     unsigned long sync_offset;
@@ -233,8 +233,9 @@ vg_set_panel_mode(unsigned long src_width, unsigned long src_height,
 
 int
 vg_set_tv_mode(unsigned long *src_width, unsigned long *src_height,
-    unsigned long encoder, unsigned long tvres, int bpp,
-    unsigned long flags, unsigned long h_overscan, unsigned long v_overscan)
+               unsigned long encoder, unsigned long tvres, int bpp,
+               unsigned long flags, unsigned long h_overscan,
+               unsigned long v_overscan)
 {
     unsigned long sync_width;
     unsigned long sync_offset;
@@ -260,17 +261,16 @@ vg_set_tv_mode(unsigned long *src_width, unsigned long *src_height,
          */
 
         if (!(*src_width) || !(*src_height)) {
-            *src_width = CimarronDisplayModes[mode].hactive -
-                (h_overscan << 1);
+            *src_width = CimarronDisplayModes[mode].hactive - (h_overscan << 1);
             *src_height = CimarronDisplayModes[mode].vactive;
 
             if (CimarronDisplayModes[mode].flags & VG_MODEFLAG_INTERLACED) {
                 if (((flags & VG_MODEFLAG_INT_OVERRIDE) &&
-                        (flags & VG_MODEFLAG_INT_MASK) ==
-                        VG_MODEFLAG_INT_LINEDOUBLE)
+                     (flags & VG_MODEFLAG_INT_MASK) ==
+                     VG_MODEFLAG_INT_LINEDOUBLE)
                     || (!(flags & VG_MODEFLAG_INT_OVERRIDE)
-                        && (CimarronDisplayModes[mode].
-                            flags & VG_MODEFLAG_INT_MASK) ==
+                        && (CimarronDisplayModes[mode].flags &
+                            VG_MODEFLAG_INT_MASK) ==
                         VG_MODEFLAG_INT_LINEDOUBLE)) {
                     if (CimarronDisplayModes[mode].vactive_even >
                         CimarronDisplayModes[mode].vactive)
@@ -279,11 +279,13 @@ vg_set_tv_mode(unsigned long *src_width, unsigned long *src_height,
                     /* ONLY 1/2 THE OVERSCAN FOR LINE DOUBLED MODES */
 
                     *src_height -= v_overscan;
-                } else {
+                }
+                else {
                     *src_height += CimarronDisplayModes[mode].vactive_even;
                     *src_height -= v_overscan << 1;
                 }
-            } else {
+            }
+            else {
                 *src_height -= v_overscan << 1;
             }
 
@@ -344,7 +346,8 @@ vg_set_tv_mode(unsigned long *src_width, unsigned long *src_height,
                 tv_mode.vsyncstart_even =
                     tv_mode.vblankstart_even + sync_offset;
                 tv_mode.vsyncend_even = tv_mode.vsyncstart_even + sync_width;
-            } else {
+            }
+            else {
                 tv_mode.vactive -= v_overscan << 1;
                 tv_mode.vblankstart = tv_mode.vactive + v_overscan;
                 tv_mode.vblankend = tv_mode.vtotal - v_overscan;
@@ -433,7 +436,8 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
             hscale = (mode_params->src_width << 14) /
                 (mode_params->mode_width - 1);
             irq_ctl |= (DC3_IRQFILT_ALPHA_FILT_EN | DC3_IRQFILT_GFX_FILT_EN);
-        } else {
+        }
+        else {
             starting_width = mode_params->hactive;
             hscale = 0x4000;
         }
@@ -443,24 +447,28 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
             vscale = (mode_params->src_height << 14) /
                 (mode_params->mode_height - 1);
             irq_ctl |= (DC3_IRQFILT_ALPHA_FILT_EN | DC3_IRQFILT_GFX_FILT_EN);
-        } else {
+        }
+        else {
             starting_height = output_height;
             vscale = 0x4000;
         }
-    } else {
+    }
+    else {
         starting_width = mode_params->src_width;
         starting_height = mode_params->src_height;
         if (mode_params->src_width != mode_params->hactive) {
             hscale = (mode_params->src_width << 14) /
                 (mode_params->hactive - 1);
             irq_ctl |= (DC3_IRQFILT_ALPHA_FILT_EN | DC3_IRQFILT_GFX_FILT_EN);
-        } else {
+        }
+        else {
             hscale = 0x4000;
         }
         if (mode_params->src_height != output_height) {
             vscale = (mode_params->src_height << 14) / (output_height - 1);
             irq_ctl |= (DC3_IRQFILT_ALPHA_FILT_EN | DC3_IRQFILT_GFX_FILT_EN);
-        } else {
+        }
+        else {
             vscale = 0x4000;
         }
     }
@@ -480,9 +488,9 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
 
     if (mode_params->flags & VG_MODEFLAG_INTERLACED) {
         if ((((mode_params->flags & VG_MODEFLAG_INT_MASK) ==
-                    VG_MODEFLAG_INT_FLICKER) && (mode_params->hactive > 1024))
+              VG_MODEFLAG_INT_FLICKER) && (mode_params->hactive > 1024))
             || (((mode_params->flags & VG_MODEFLAG_INT_MASK) ==
-                    VG_MODEFLAG_INT_ADDRESS) && irq_ctl)) {
+                 VG_MODEFLAG_INT_ADDRESS) && irq_ctl)) {
             return CIM_STATUS_INVALIDSCALE;
         }
     }
@@ -536,8 +544,9 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
         if ((mode_params->flags & VG_MODEFLAG_INVERT_SHFCLK) &&
             !(temp & DF_PM_INVERT_SHFCLK)) {
             WRITE_VID32(DF_POWER_MANAGEMENT, (temp | DF_PM_INVERT_SHFCLK));
-        } else if (!(mode_params->flags & VG_MODEFLAG_INVERT_SHFCLK) &&
-            (temp & DF_PM_INVERT_SHFCLK)) {
+        }
+        else if (!(mode_params->flags & VG_MODEFLAG_INVERT_SHFCLK) &&
+                 (temp & DF_PM_INVERT_SHFCLK)) {
             WRITE_VID32(DF_POWER_MANAGEMENT, (temp & ~DF_PM_INVERT_SHFCLK));
         }
 
@@ -552,13 +561,15 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
                 dith_ctl = DF_DEFAULT_DITHCTL;
                 msr_value.low = DF_DEFAULT_XVGA_PAD_SEL_LOW;
                 msr_value.high = DF_DEFAULT_XVGA_PAD_SEL_HIGH;
-            } else if (mode_params->flags & VG_MODEFLAG_CUSTOM_PANEL) {
+            }
+            else if (mode_params->flags & VG_MODEFLAG_CUSTOM_PANEL) {
                 pmtim1 = mode_params->panel_tim1;
                 pmtim2 = mode_params->panel_tim2;
                 dith_ctl = mode_params->panel_dither_ctl;
                 msr_value.low = mode_params->panel_pad_sel_low;
                 msr_value.high = mode_params->panel_pad_sel_high;
-            } else {
+            }
+            else {
                 pmtim1 = DF_DEFAULT_TFT_PMTIM1;
                 pmtim2 = DF_DEFAULT_TFT_PMTIM2;
                 dith_ctl = DF_DEFAULT_DITHCTL;
@@ -585,7 +596,8 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
 
         msr_write64(MSR_DEVICE_GEODELX_DF, MSR_GEODELINK_CONFIG, &msr_value);
 
-    } else if (mode_params->flags & VG_MODEFLAG_TVOUT) {
+    }
+    else if (mode_params->flags & VG_MODEFLAG_TVOUT) {
         vg3_panel_enable = 0;
 
         /* SET APPROPRIATE TV OUTPUT MODE */
@@ -607,7 +619,8 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
         msr_value.low = DF_DEFAULT_TV_PAD_SEL_LOW;
         msr_value.high = DF_DEFAULT_TV_PAD_SEL_HIGH;
         msr_write64(MSR_DEVICE_GEODELX_DF, DF_MSR_PAD_SEL, &msr_value);
-    } else {
+    }
+    else {
         vg3_panel_enable = 0;
 
         /* SET OUTPUT TO CRT ONLY */
@@ -652,7 +665,7 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
     /* DISABLE VG INTERRUPTS */
 
     WRITE_REG32(DC3_IRQ, DC3_IRQ_MASK | DC3_VSYNC_IRQ_MASK |
-        DC3_IRQ_STATUS | DC3_VSYNC_IRQ_STATUS);
+                DC3_IRQ_STATUS | DC3_VSYNC_IRQ_STATUS);
 
     /* DISABLE GENLOCK */
 
@@ -663,8 +676,7 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
 
     WRITE_VIP32(VIP_CONTROL1, 0);
     WRITE_VIP32(VIP_CONTROL2, 0);
-    WRITE_VIP32(VIP_INTERRUPT,
-        VIP_ALL_INTERRUPTS | (VIP_ALL_INTERRUPTS >> 16));
+    WRITE_VIP32(VIP_INTERRUPT, VIP_ALL_INTERRUPTS | (VIP_ALL_INTERRUPTS >> 16));
 
     /* DISABLE COLOR KEYING
      * The color key mechanism should be disabled whenever a mode switch
@@ -686,8 +698,8 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
 
     WRITE_VID32(DF_VID_MISC, (misc | DF_DAC_POWER_DOWN));
     WRITE_VID32(DF_DISPLAY_CONFIG,
-        (config & ~(DF_DCFG_DIS_EN | DF_DCFG_HSYNC_EN |
-                DF_DCFG_VSYNC_EN | DF_DCFG_DAC_BL_EN)));
+                (config & ~(DF_DCFG_DIS_EN | DF_DCFG_HSYNC_EN |
+                            DF_DCFG_VSYNC_EN | DF_DCFG_DAC_BL_EN)));
 
     /* DISABLE COMPRESSION  */
 
@@ -715,7 +727,7 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
     /* WAIT FOR THE GP TO BE IDLE (JUST IN CASE) */
 
     while (((temp = READ_GP32(GP3_BLT_STATUS)) & GP3_BS_BLT_BUSY) ||
-        !(temp & GP3_BS_CB_EMPTY)) {
+           !(temp & GP3_BS_CB_EMPTY)) {
         ;
     }
 
@@ -752,7 +764,8 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
     WRITE_REG32(DC3_CURS_ST_OFFSET, 0);
 
     genlk_ctl = READ_REG32(DC3_GENLK_CTL) & ~(DC3_GC_ALPHA_FLICK_ENABLE |
-        DC3_GC_FLICKER_FILTER_ENABLE | DC3_GC_FLICKER_FILTER_MASK);
+                                              DC3_GC_FLICKER_FILTER_ENABLE |
+                                              DC3_GC_FLICKER_FILTER_MASK);
 
     /* ENABLE INTERLACING */
 
@@ -763,7 +776,7 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
             VG_MODEFLAG_INT_ADDRESS)
             irq_ctl |= DC3_IRQFILT_INTL_ADDR;
         else if ((mode_params->flags & VG_MODEFLAG_INT_MASK) ==
-            VG_MODEFLAG_INT_FLICKER) {
+                 VG_MODEFLAG_INT_FLICKER) {
             genlk_ctl |= DC3_GC_FLICKER_FILTER_1_8 |
                 DC3_GC_FLICKER_FILTER_ENABLE | DC3_GC_ALPHA_FLICK_ENABLE;
         }
@@ -835,7 +848,8 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
 
             gcfg |= DC3_GCFG_FDTY;
             pitch = size;
-        } else {
+        }
+        else {
             WRITE_REG32(DC3_DV_TOP, 0);
         }
     }
@@ -866,8 +880,8 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
     /* ENABLE TIMING GENERATOR, TIM. REG. UPDATES, PALETTE BYPASS */
     /* AND VERT. INT. SELECT                                      */
 
-    dcfg |= (unsigned long)(DC3_DCFG_TGEN | DC3_DCFG_TRUP | DC3_DCFG_PALB |
-        DC3_DCFG_VISL);
+    dcfg |= (unsigned long) (DC3_DCFG_TGEN | DC3_DCFG_TRUP | DC3_DCFG_PALB |
+                             DC3_DCFG_VISL);
 
     /* SET FIFO PRIORITIES AND DISPLAY FIFO LOAD ENABLE
      * Note that the bandwidth setting gets upgraded when scaling or flicker
@@ -876,15 +890,17 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
 
     msr_read64(MSR_DEVICE_GEODELX_VG, DC3_SPARE_MSR, &msr_value);
     msr_value.low &= ~(DC3_SPARE_DISABLE_CFIFO_HGO |
-        DC3_SPARE_VFIFO_ARB_SELECT |
-        DC3_SPARE_LOAD_WM_LPEN_MASK | DC3_SPARE_WM_LPEN_OVRD |
-        DC3_SPARE_DISABLE_INIT_VID_PRI | DC3_SPARE_DISABLE_VFIFO_WM);
+                       DC3_SPARE_VFIFO_ARB_SELECT |
+                       DC3_SPARE_LOAD_WM_LPEN_MASK | DC3_SPARE_WM_LPEN_OVRD |
+                       DC3_SPARE_DISABLE_INIT_VID_PRI |
+                       DC3_SPARE_DISABLE_VFIFO_WM);
 
     if ((mode_params->flags & VG_MODEFLAG_BANDWIDTHMASK) ==
-        VG_MODEFLAG_HIGH_BAND
-        || ((mode_params->flags & VG_MODEFLAG_INTERLACED)
-            && (mode_params->flags & VG_MODEFLAG_INT_MASK) ==
-            VG_MODEFLAG_INT_FLICKER) || (irq_ctl & DC3_IRQFILT_GFX_FILT_EN)) {
+        VG_MODEFLAG_HIGH_BAND || ((mode_params->flags & VG_MODEFLAG_INTERLACED)
+                                  && (mode_params->
+                                      flags & VG_MODEFLAG_INT_MASK) ==
+                                  VG_MODEFLAG_INT_FLICKER) ||
+        (irq_ctl & DC3_IRQFILT_GFX_FILT_EN)) {
         /* HIGH BANDWIDTH */
         /* Set agressive watermarks and disallow forced low priority */
 
@@ -894,8 +910,9 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
 
         msr_value.low |= DC3_SPARE_DISABLE_CFIFO_HGO |
             DC3_SPARE_VFIFO_ARB_SELECT | DC3_SPARE_WM_LPEN_OVRD;
-    } else if ((mode_params->flags & VG_MODEFLAG_BANDWIDTHMASK) ==
-        VG_MODEFLAG_AVG_BAND) {
+    }
+    else if ((mode_params->flags & VG_MODEFLAG_BANDWIDTHMASK) ==
+             VG_MODEFLAG_AVG_BAND) {
         /* AVERAGE BANDWIDTH
          * Set average watermarks and allow small regions of forced low
          * priority.
@@ -917,8 +934,9 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
             temp = 127;
 
         acfg |= temp << 9;
-    } else if ((mode_params->flags & VG_MODEFLAG_BANDWIDTHMASK) ==
-        VG_MODEFLAG_LOW_BAND) {
+    }
+    else if ((mode_params->flags & VG_MODEFLAG_BANDWIDTHMASK) ==
+             VG_MODEFLAG_LOW_BAND) {
         /* LOW BANDWIDTH
          * Set low watermarks and allow larger regions of forced low priority
          */
@@ -939,7 +957,8 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
             temp = 127;
 
         acfg |= temp << 9;
-    } else {
+    }
+    else {
         /* LEGACY CHARACTERISTICS */
         /* Arbitration from a single set of watermarks. */
 
@@ -965,19 +984,17 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
     temp = (mode_params->hblankstart - 1) |
         ((mode_params->hblankend - 1) << 16);
     WRITE_REG32(DC3_H_BLANK_TIMING, temp);
-    temp = (mode_params->hsyncstart - 1) |
-        ((mode_params->hsyncend - 1) << 16);
+    temp = (mode_params->hsyncstart - 1) | ((mode_params->hsyncend - 1) << 16);
     WRITE_REG32(DC3_H_SYNC_TIMING, temp);
     temp = (mode_params->vactive - 1) | ((mode_params->vtotal - 1) << 16);
     WRITE_REG32(DC3_V_ACTIVE_TIMING, temp);
     temp = (mode_params->vblankstart - 1) |
         ((mode_params->vblankend - 1) << 16);
     WRITE_REG32(DC3_V_BLANK_TIMING, temp);
-    temp = (mode_params->vsyncstart - 1) |
-        ((mode_params->vsyncend - 1) << 16);
+    temp = (mode_params->vsyncstart - 1) | ((mode_params->vsyncend - 1) << 16);
     WRITE_REG32(DC3_V_SYNC_TIMING, temp);
     temp = (mode_params->vactive_even - 1) | ((mode_params->vtotal_even -
-            1) << 16);
+                                               1) << 16);
     WRITE_REG32(DC3_V_ACTIVE_EVEN, temp);
     temp = (mode_params->vblankstart_even - 1) |
         ((mode_params->vblankend_even - 1) << 16);
@@ -993,14 +1010,14 @@ vg_set_custom_mode(VG_DISPLAY_MODE * mode_params, int bpp)
     /* SET SOURCE DIMENSIONS */
 
     WRITE_REG32(DC3_FB_ACTIVE, ((starting_width - 1) << 16) |
-        (starting_height - 1));
+                (starting_height - 1));
 
     /* SET SYNC POLARITIES */
 
     temp = READ_VID32(DF_DISPLAY_CONFIG);
 
     temp &= ~(DF_DCFG_CRT_SYNC_SKW_MASK | DF_DCFG_PWR_SEQ_DLY_MASK |
-        DF_DCFG_CRT_HSYNC_POL | DF_DCFG_CRT_VSYNC_POL);
+              DF_DCFG_CRT_HSYNC_POL | DF_DCFG_CRT_VSYNC_POL);
 
     temp |= DF_DCFG_CRT_SYNC_SKW_INIT | DF_DCFG_PWR_SEQ_DLY_INIT;
 
@@ -1060,7 +1077,7 @@ vg_set_display_bpp(int bpp)
 
     unlock = READ_REG32(DC3_UNLOCK);
     dcfg = READ_REG32(DC3_DISPLAY_CFG) & ~(DC3_DCFG_DISP_MODE_MASK |
-        DC3_DCFG_16BPP_MODE_MASK);
+                                           DC3_DCFG_16BPP_MODE_MASK);
     dcfg |= bpp_mask;
 
     WRITE_REG32(DC3_UNLOCK, DC3_UNLOCK_VALUE);
@@ -1197,17 +1214,16 @@ vg_get_display_mode_index(VG_QUERY_MODE * query)
 
     for (mode = 0; mode < NUM_CIMARRON_DISPLAY_MODES; mode++) {
         if ((!(query->query_flags & VG_QUERYFLAG_PANEL) ||
-                (CimarronDisplayModes[mode].
-                    internal_flags & VG_SUPPORTFLAG_PANEL))
+             (CimarronDisplayModes[mode].internal_flags & VG_SUPPORTFLAG_PANEL))
             && (!(query->query_flags & VG_QUERYFLAG_TVOUT)
-                || (CimarronDisplayModes[mode].
-                    internal_flags & VG_SUPPORTFLAG_TVOUT))
+                || (CimarronDisplayModes[mode].internal_flags &
+                    VG_SUPPORTFLAG_TVOUT))
             && (!(query->query_flags & VG_QUERYFLAG_INTERLACED)
-                || (CimarronDisplayModes[mode].
-                    flags & VG_MODEFLAG_INTERLACED) == interlaced)
+                || (CimarronDisplayModes[mode].flags & VG_MODEFLAG_INTERLACED)
+                == interlaced)
             && (!(query->query_flags & VG_QUERYFLAG_HALFCLOCK)
-                || (CimarronDisplayModes[mode].
-                    flags & VG_MODEFLAG_HALFCLOCK) == halfclock)
+                || (CimarronDisplayModes[mode].flags & VG_MODEFLAG_HALFCLOCK) ==
+                halfclock)
             && (!(query->query_flags & VG_QUERYFLAG_PANELWIDTH)
                 || (CimarronDisplayModes[mode].panel_width ==
                     query->panel_width))
@@ -1215,11 +1231,9 @@ vg_get_display_mode_index(VG_QUERY_MODE * query)
                 || (CimarronDisplayModes[mode].panel_height ==
                     query->panel_height))
             && (!(query->query_flags & VG_QUERYFLAG_ACTIVEWIDTH)
-                || (CimarronDisplayModes[mode].hactive ==
-                    query->active_width))
+                || (CimarronDisplayModes[mode].hactive == query->active_width))
             && (!(query->query_flags & VG_QUERYFLAG_ACTIVEHEIGHT)
-                || (CimarronDisplayModes[mode].vactive ==
-                    query->active_height))
+                || (CimarronDisplayModes[mode].vactive == query->active_height))
             && (!(query->query_flags & VG_QUERYFLAG_TOTALWIDTH)
                 || (CimarronDisplayModes[mode].htotal == query->total_width))
             && (!(query->query_flags & VG_QUERYFLAG_TOTALHEIGHT)
@@ -1231,17 +1245,15 @@ vg_get_display_mode_index(VG_QUERY_MODE * query)
             && (!(query->query_flags & VG_QUERYFLAG_ENCODER)
                 || (CimarronDisplayModes[mode].internal_flags & enc_flag))
             && (!(query->query_flags & VG_QUERYFLAG_TVMODE)
-                || ((CimarronDisplayModes[mode].
-                        internal_flags & VG_SUPPORTFLAG_TVMODEMASK) ==
-                    tv_flag))
+                ||
+                ((CimarronDisplayModes[mode].internal_flags &
+                  VG_SUPPORTFLAG_TVMODEMASK) == tv_flag))
             && (!(query->query_flags & VG_QUERYFLAG_PIXELCLOCK)
-                || (CimarronDisplayModes[mode].frequency ==
-                    query->frequency))) {
+                || (CimarronDisplayModes[mode].frequency == query->frequency))) {
             /* ALLOW SEARCHING BASED ON AN APPROXIMATE PIXEL CLOCK */
 
             if (query->query_flags & VG_QUERYFLAG_PIXELCLOCK_APPROX) {
-                diff = query->frequency -
-                    CimarronDisplayModes[mode].frequency;
+                diff = query->frequency - CimarronDisplayModes[mode].frequency;
                 if (diff < 0)
                     diff = -diff;
 
@@ -1249,7 +1261,8 @@ vg_get_display_mode_index(VG_QUERY_MODE * query)
                     minimum = diff;
                     match = mode;
                 }
-            } else {
+            }
+            else {
                 match = mode;
                 break;
             }
@@ -1417,21 +1430,26 @@ vg_get_current_display_mode(VG_DISPLAY_MODE * current_display, int *bpp)
     if (temp == DC3_DCFG_DISP_MODE_8BPP) {
         iflags |= VG_SUPPORTFLAG_8BPP;
         *bpp = 8;
-    } else if (temp == DC3_DCFG_DISP_MODE_24BPP) {
+    }
+    else if (temp == DC3_DCFG_DISP_MODE_24BPP) {
         iflags |= VG_SUPPORTFLAG_24BPP;
         *bpp = 24;
-    } else if (temp == DC3_DCFG_DISP_MODE_32BPP) {
+    }
+    else if (temp == DC3_DCFG_DISP_MODE_32BPP) {
         iflags |= VG_SUPPORTFLAG_32BPP;
         *bpp = 32;
-    } else if (temp == DC3_DCFG_DISP_MODE_16BPP) {
+    }
+    else if (temp == DC3_DCFG_DISP_MODE_16BPP) {
         temp = READ_REG32(DC3_DISPLAY_CFG) & DC3_DCFG_16BPP_MODE_MASK;
         if (temp == DC3_DCFG_16BPP) {
             iflags |= VG_SUPPORTFLAG_16BPP;
             *bpp = 16;
-        } else if (temp == DC3_DCFG_15BPP) {
+        }
+        else if (temp == DC3_DCFG_15BPP) {
             iflags |= VG_SUPPORTFLAG_15BPP;
             *bpp = 15;
-        } else if (temp == DC3_DCFG_12BPP) {
+        }
+        else if (temp == DC3_DCFG_12BPP) {
             iflags |= VG_SUPPORTFLAG_12BPP;
             *bpp = 12;
         }
@@ -1488,8 +1506,7 @@ vg_get_current_display_mode(VG_DISPLAY_MODE * current_display, int *bpp)
         p = msr_value.high & 0xF;
         n = (msr_value.high >> 4) & 0xFF;
         m = (msr_value.high >> 12) & 0x7;
-        current_display->frequency =
-            (0x300000 * (n + 1)) / ((p + 1) * (m + 1));
+        current_display->frequency = (0x300000 * (n + 1)) / ((p + 1) * (m + 1));
 
         return CIM_STATUS_INEXACTMATCH;
     }
@@ -1572,13 +1589,14 @@ vg_set_scaler_filter_coefficients(long h_taps[][5], long v_taps[][3])
         if (!h_taps) {
             temp0 = CimarronHorizontalGraphicsFilter[i][0];
             temp1 = CimarronHorizontalGraphicsFilter[i][1];
-        } else {
-            temp0 = ((unsigned long)h_taps[i][0] & 0x3FF) |
-                (((unsigned long)h_taps[i][1] & 0x3FF) << 10) |
-                (((unsigned long)h_taps[i][2] & 0x3FF) << 20);
+        }
+        else {
+            temp0 = ((unsigned long) h_taps[i][0] & 0x3FF) |
+                (((unsigned long) h_taps[i][1] & 0x3FF) << 10) |
+                (((unsigned long) h_taps[i][2] & 0x3FF) << 20);
 
-            temp1 = ((unsigned long)h_taps[i][3] & 0x3FF) |
-                (((unsigned long)h_taps[i][4] & 0x3FF) << 10);
+            temp1 = ((unsigned long) h_taps[i][3] & 0x3FF) |
+                (((unsigned long) h_taps[i][4] & 0x3FF) << 10);
         }
         WRITE_REG32(DC3_FILT_COEFF1, temp0);
         WRITE_REG32(DC3_FILT_COEFF2, temp1);
@@ -1595,10 +1613,11 @@ vg_set_scaler_filter_coefficients(long h_taps[][5], long v_taps[][3])
 
         if (!v_taps) {
             temp0 = CimarronVerticalGraphicsFilter[i];
-        } else {
-            temp0 = ((unsigned long)v_taps[i][0] & 0x3FF) |
-                (((unsigned long)v_taps[i][1] & 0x3FF) << 10) |
-                (((unsigned long)v_taps[i][2] & 0x3FF) << 20);
+        }
+        else {
+            temp0 = ((unsigned long) v_taps[i][0] & 0x3FF) |
+                (((unsigned long) v_taps[i][1] & 0x3FF) << 10) |
+                (((unsigned long) v_taps[i][2] & 0x3FF) << 20);
         }
 
         WRITE_REG32(DC3_FILT_COEFF1, temp0);
@@ -1636,7 +1655,7 @@ vg_configure_flicker_filter(unsigned long flicker_strength, int flicker_alpha)
 
     unlock = READ_REG32(DC3_UNLOCK);
     genlk_ctl = READ_REG32(DC3_GENLK_CTL) & ~(DC3_GC_FLICKER_FILTER_MASK |
-        DC3_GC_ALPHA_FLICK_ENABLE);
+                                              DC3_GC_ALPHA_FLICK_ENABLE);
     genlk_ctl |= flicker_strength;
     if (flicker_alpha)
         genlk_ctl |= DC3_GC_ALPHA_FLICK_ENABLE;
@@ -1674,13 +1693,13 @@ vg_set_clock_frequency(unsigned long frequency, unsigned long pll_flags)
 
     pll_low = 0;
     if (!(pll_flags & VG_PLL_MANUAL)) {
-        min = (long)CimarronPLLFrequencies[0].frequency - (long)frequency;
+        min = (long) CimarronPLLFrequencies[0].frequency - (long) frequency;
         if (min < 0L)
             min = -min;
 
         for (i = 1; i < NUM_CIMARRON_PLL_FREQUENCIES; i++) {
-            diff = (long)CimarronPLLFrequencies[i].frequency -
-                (long)frequency;
+            diff = (long) CimarronPLLFrequencies[i].frequency -
+                (long) frequency;
             if (diff < 0L)
                 diff = -diff;
 
@@ -1691,7 +1710,8 @@ vg_set_clock_frequency(unsigned long frequency, unsigned long pll_flags)
         }
 
         pll_high = CimarronPLLFrequencies[index].pll_value & 0x00007FFF;
-    } else {
+    }
+    else {
         pll_high = frequency;
     }
 
@@ -1713,7 +1733,7 @@ vg_set_clock_frequency(unsigned long frequency, unsigned long pll_flags)
 
     if ((msr_value.low & GLCP_DOTPLL_LOCK) &&
         ((msr_value.low & (GLCP_DOTPLL_HALFPIX | GLCP_DOTPLL_BYPASS)) ==
-            pll_low) && (msr_value.high == pll_high)) {
+         pll_low) && (msr_value.high == pll_high)) {
         return CIM_STATUS_OK;
     }
 
@@ -1851,8 +1871,8 @@ vg_set_cursor_position(long xpos, long ypos, VG_PANNING_COORDINATES * panning)
     long y, yoffset;
 
     memoffset = vg3_cursor_offset;
-    x = xpos - (long)vg3_x_hotspot;
-    y = ypos - (long)vg3_y_hotspot;
+    x = xpos - (long) vg3_x_hotspot;
+    y = ypos - (long) vg3_y_hotspot;
 
     /* HANDLE NEGATIVE COORDINATES                                      */
     /* This routine supports operating systems that use negative        */
@@ -1873,9 +1893,10 @@ vg_set_cursor_position(long xpos, long ypos, VG_PANNING_COORDINATES * panning)
         if ((vg3_mode_width > vg3_panel_width)
             || (vg3_mode_height > vg3_panel_height)) {
             vg_pan_desktop(xpos, ypos, panning);
-            x = x - (unsigned short)vg3_delta_x;
-            y = y - (unsigned short)vg3_delta_y;
-        } else {
+            x = x - (unsigned short) vg3_delta_x;
+            y = y - (unsigned short) vg3_delta_y;
+        }
+        else {
             panning->start_x = 0;
             panning->start_y = 0;
             panning->start_updated = 0;
@@ -1891,21 +1912,23 @@ vg_set_cursor_position(long xpos, long ypos, VG_PANNING_COORDINATES * panning)
     if (x < 0) {
         xoffset = -x;
         x = 0;
-    } else {
+    }
+    else {
         xoffset = 0;
     }
     if (y < 0) {
         yoffset = -y;
         y = 0;
-    } else {
+    }
+    else {
         yoffset = 0;
     }
 
     if (vg3_color_cursor)
-        memoffset += (unsigned long)yoffset *192;
+        memoffset += (unsigned long) yoffset *192;
 
     else
-        memoffset += (unsigned long)yoffset << 4;
+        memoffset += (unsigned long) yoffset << 4;
 
     /* SET COLOR CURSOR BIT */
 
@@ -1921,10 +1944,10 @@ vg_set_cursor_position(long xpos, long ypos, VG_PANNING_COORDINATES * panning)
     WRITE_REG32(DC3_UNLOCK, DC3_UNLOCK_VALUE);
     WRITE_REG32(DC3_CURS_ST_OFFSET, memoffset);
     WRITE_REG32(DC3_GENERAL_CFG, gcfg);
-    WRITE_REG32(DC3_CURSOR_X, (unsigned long)x |
-        (((unsigned long)xoffset) << 11));
-    WRITE_REG32(DC3_CURSOR_Y, (unsigned long)y |
-        (((unsigned long)yoffset) << 11));
+    WRITE_REG32(DC3_CURSOR_X, (unsigned long) x |
+                (((unsigned long) xoffset) << 11));
+    WRITE_REG32(DC3_CURSOR_Y, (unsigned long) y |
+                (((unsigned long) yoffset) << 11));
     WRITE_REG32(DC3_UNLOCK, unlock);
 
     return CIM_STATUS_OK;
@@ -1940,7 +1963,8 @@ vg_set_cursor_position(long xpos, long ypos, VG_PANNING_COORDINATES * panning)
 
 int
 vg_set_mono_cursor_shape32(unsigned long memoffset, unsigned long *andmask,
-    unsigned long *xormask, unsigned long x_hotspot, unsigned long y_hotspot)
+                           unsigned long *xormask, unsigned long x_hotspot,
+                           unsigned long y_hotspot)
 {
     int i;
 
@@ -1990,7 +2014,8 @@ vg_set_mono_cursor_shape32(unsigned long memoffset, unsigned long *andmask,
 
 int
 vg_set_mono_cursor_shape64(unsigned long memoffset, unsigned long *andmask,
-    unsigned long *xormask, unsigned long x_hotspot, unsigned long y_hotspot)
+                           unsigned long *xormask, unsigned long x_hotspot,
+                           unsigned long y_hotspot)
 {
     int i;
 
@@ -2032,8 +2057,8 @@ vg_set_mono_cursor_shape64(unsigned long memoffset, unsigned long *andmask,
 
 int
 vg_set_color_cursor_shape(unsigned long memoffset, unsigned char *data,
-    unsigned long width, unsigned long height, long pitch,
-    unsigned long x_hotspot, unsigned long y_hotspot)
+                          unsigned long width, unsigned long height, long pitch,
+                          unsigned long x_hotspot, unsigned long y_hotspot)
 {
     unsigned long y;
 
@@ -2081,7 +2106,7 @@ vg_set_color_cursor_shape(unsigned long memoffset, unsigned char *data,
 
 int
 vg_pan_desktop(unsigned long x, unsigned long y,
-    VG_PANNING_COORDINATES * panning)
+               VG_PANNING_COORDINATES * panning)
 {
     unsigned long modeShiftPerPixel;
     unsigned long modeBytesPerScanline;
@@ -2162,7 +2187,7 @@ vg_set_display_offset(unsigned long address)
         if (READ_REG32(DC3_GENERAL_CFG) & DC3_GCFG_CMPE) {
             gcfg = READ_REG32(DC3_GENERAL_CFG);
             WRITE_REG32(DC3_GENERAL_CFG,
-                (gcfg & ~(DC3_GCFG_CMPE | DC3_GCFG_DECE)));
+                        (gcfg & ~(DC3_GCFG_CMPE | DC3_GCFG_DECE)));
         }
     }
 
@@ -2203,24 +2228,28 @@ vg_set_display_pitch(unsigned long pitch)
 
     if (pitch > 4096) {
         dvsize = DC3_DV_LINE_SIZE_8192;
-    } else if (pitch > 2048) {
+    }
+    else if (pitch > 2048) {
         dvsize = DC3_DV_LINE_SIZE_4096;
-    } else if (pitch > 1024) {
+    }
+    else if (pitch > 1024) {
         dvsize = DC3_DV_LINE_SIZE_2048;
-    } else {
+    }
+    else {
         dvsize = DC3_DV_LINE_SIZE_1024;
     }
 
     temp = READ_REG32(DC3_DV_CTL);
     WRITE_REG32(DC3_DV_CTL,
-        (temp & ~DC3_DV_LINE_SIZE_MASK) | dvsize | 0x00000001);
+                (temp & ~DC3_DV_LINE_SIZE_MASK) | dvsize | 0x00000001);
 
     value = READ_REG32(DC3_GENERAL_CFG);
 
     if (pitch == 1024 || pitch == 2048 || pitch == 4096 || pitch == 8192) {
         value &= ~DC3_GCFG_FDTY;
         dvtop = 0;
-    } else {
+    }
+    else {
         value |= DC3_GCFG_FDTY;
 
         dvtop = (READ_REG32(DC3_FB_ACTIVE) & 0xFFF) + 1;
@@ -2339,7 +2368,8 @@ vg_set_compression_enable(int enable)
         /* ENABLE COMPRESSION BITS */
 
         gcfg |= DC3_GCFG_CMPE | DC3_GCFG_DECE;
-    } else {
+    }
+    else {
         gcfg &= ~(DC3_GCFG_CMPE | DC3_GCFG_DECE);
     }
 
@@ -2442,8 +2472,8 @@ int
 vg_wait_vertical_blank(void)
 {
     if (vg_test_timing_active()) {
-        while (!vg_test_vertical_active()) ;
-        while (vg_test_vertical_active()) ;
+        while (!vg_test_vertical_active());
+        while (vg_test_vertical_active());
     }
     return CIM_STATUS_OK;
 }
@@ -2494,7 +2524,8 @@ vg_configure_line_interrupt(VG_INTERRUPT_PARAMS * interrupt_info)
     if (interrupt_info->enable) {
         WRITE_REG32(DC3_IRQ_FILT_CTL, irq_line);
         WRITE_REG32(DC3_IRQ, ((irq_enable & ~DC3_IRQ_MASK) | DC3_IRQ_STATUS));
-    } else {
+    }
+    else {
         WRITE_REG32(DC3_IRQ, (irq_enable | DC3_IRQ_MASK));
         WRITE_REG32(DC3_IRQ_FILT_CTL, irq_line);
     }
@@ -2680,17 +2711,15 @@ vg_save_state(VG_SAVE_RESTORE * vg_state)
 
     /* READ ALL VG MSRS */
 
-    msr_read64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_CAP,
-        &(vg_state->msr_cap));
+    msr_read64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_CAP, &(vg_state->msr_cap));
     msr_read64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_CONFIG,
-        &(vg_state->msr_config));
-    msr_read64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_SMI,
-        &(vg_state->msr_smi));
+               &(vg_state->msr_config));
+    msr_read64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_SMI, &(vg_state->msr_smi));
     msr_read64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_ERROR,
-        &(vg_state->msr_error));
+               &(vg_state->msr_error));
     msr_read64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_PM, &(vg_state->msr_pm));
     msr_read64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_DIAG,
-        &(vg_state->msr_diag));
+               &(vg_state->msr_diag));
     msr_read64(MSR_DEVICE_GEODELX_VG, DC3_SPARE_MSR, &(vg_state->msr_spare));
     msr_read64(MSR_DEVICE_GEODELX_VG, DC3_RAM_CTL, &(vg_state->msr_ram_ctl));
 
@@ -2799,8 +2828,8 @@ vg_restore_state(VG_SAVE_RESTORE * vg_state)
     /* RESTORE THE CURSOR DATA */
 
     memoffset = READ_REG32(DC3_CURS_ST_OFFSET) & 0x0FFFFFFF;
-    WRITE_FB_STRING32(memoffset, (unsigned char *)&(vg_state->cursor_data[0]),
-        3072);
+    WRITE_FB_STRING32(memoffset, (unsigned char *) &(vg_state->cursor_data[0]),
+                      3072);
 
     /* RESTORE THE PLL */
     /* Use a common routine to use common code to poll for lock bit */
@@ -2809,17 +2838,15 @@ vg_restore_state(VG_SAVE_RESTORE * vg_state)
 
     /* RESTORE ALL VG MSRS */
 
-    msr_write64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_CAP,
-        &(vg_state->msr_cap));
+    msr_write64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_CAP, &(vg_state->msr_cap));
     msr_write64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_CONFIG,
-        &(vg_state->msr_config));
-    msr_write64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_SMI,
-        &(vg_state->msr_smi));
+                &(vg_state->msr_config));
+    msr_write64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_SMI, &(vg_state->msr_smi));
     msr_write64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_ERROR,
-        &(vg_state->msr_error));
+                &(vg_state->msr_error));
     msr_write64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_PM, &(vg_state->msr_pm));
     msr_write64(MSR_DEVICE_GEODELX_VG, MSR_GEODELINK_DIAG,
-        &(vg_state->msr_diag));
+                &(vg_state->msr_diag));
     msr_write64(MSR_DEVICE_GEODELX_VG, DC3_SPARE_MSR, &(vg_state->msr_spare));
     msr_write64(MSR_DEVICE_GEODELX_VG, DC3_RAM_CTL, &(vg_state->msr_ram_ctl));
 
@@ -2901,9 +2928,10 @@ vg_read_graphics_crc(int crc_source)
         do {
             line = READ_REG32(DC3_LINE_CNT_STATUS);
         } while ((line & DC3_LNCNT_EVEN_FIELD) != field ||
-            ((line & DC3_LNCNT_V_LINE_CNT) >> 16) < 10 ||
-            ((line & DC3_LNCNT_V_LINE_CNT) >> 16) > 15);
-    } else {
+                 ((line & DC3_LNCNT_V_LINE_CNT) >> 16) < 10 ||
+                 ((line & DC3_LNCNT_V_LINE_CNT) >> 16) > 15);
+    }
+    else {
         /* NON-INTERLACED - EVEN FIELD CRCS ARE INVALID */
 
         if (crc_source & VG_CRC_SOURCE_EVEN)
@@ -2917,7 +2945,7 @@ vg_read_graphics_crc(int crc_source)
 
     /* WAIT FOR THE CRC TO BE COMPLETED */
 
-    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_SIGC)) ;
+    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_SIGC));
 
     /* READ THE COMPLETED CRC */
 
@@ -2941,7 +2969,7 @@ vg_read_graphics_crc(int crc_source)
 
 unsigned long
 vg_read_window_crc(int crc_source, unsigned long x, unsigned long y,
-    unsigned long width, unsigned long height)
+                   unsigned long width, unsigned long height)
 {
     Q_WORD msr_value;
     unsigned long crc = 0;
@@ -3242,8 +3270,9 @@ vg_read_window_crc(int crc_source, unsigned long x, unsigned long y,
         msr_value.high = 0x00000000;
         msr_value.low = 0x002055AA;
         msr_write64(MSR_DEVICE_GEODELX_GLCP, GLCP_H0CTL + 3, &msr_value);
-    } else if (crc_source == VG_CRC_SOURCE_PREFLICKER
-        || crc_source == VG_CRC_SOURCE_PREFLICKER_EVEN) {
+    }
+    else if (crc_source == VG_CRC_SOURCE_PREFLICKER
+             || crc_source == VG_CRC_SOURCE_PREFLICKER_EVEN) {
         diag = 0x801F8032;
 
         /* ENABLE HW CLOCK GATING AND SET GLCP CLOCK TO GEODELINK CLOCK */
@@ -3276,7 +3305,8 @@ vg_read_window_crc(int crc_source, unsigned long x, unsigned long y,
         msr_value.high = 0x00000000;
         msr_value.low = 0x002D55AA;
         msr_write64(MSR_DEVICE_GEODELX_GLCP, GLCP_H0CTL + 3, &msr_value);
-    } else {
+    }
+    else {
         /* PREFILTER CRC */
 
         diag = 0x80138048;
@@ -3335,9 +3365,10 @@ vg_read_window_crc(int crc_source, unsigned long x, unsigned long y,
         do {
             line = READ_REG32(DC3_LINE_CNT_STATUS);
         } while ((line & DC3_LNCNT_EVEN_FIELD) != field ||
-            ((line & DC3_LNCNT_V_LINE_CNT) >> 16) < 1 ||
-            ((line & DC3_LNCNT_V_LINE_CNT) >> 16) > 5);
-    } else {
+                 ((line & DC3_LNCNT_V_LINE_CNT) >> 16) < 1 ||
+                 ((line & DC3_LNCNT_V_LINE_CNT) >> 16) > 5);
+    }
+    else {
         /* NON-INTERLACED - EVEN FIELD CRCS ARE INVALID */
 
         if (crc_source & VG_CRC_SOURCE_EVEN)
@@ -3362,11 +3393,11 @@ vg_read_window_crc(int crc_source, unsigned long x, unsigned long y,
 
     /* DELAY TWO FRAMES */
 
-    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA) ;
-    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA)) ;
-    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA) ;
-    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA)) ;
-    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA) ;
+    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA);
+    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA));
+    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA);
+    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA));
+    while (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_VNA);
 
     /* VERIFY THAT XSTATE = 11 */
 
@@ -3468,8 +3499,7 @@ vg_get_scaler_filter_coefficients(long h_taps[][5], long v_taps[][3])
  *--------------------------------------------------------------------------*/
 
 int
-vg_get_flicker_filter_configuration(unsigned long *strength,
-    int *flicker_alpha)
+vg_get_flicker_filter_configuration(unsigned long *strength, int *flicker_alpha)
 {
     unsigned long genlk_ctl;
 
@@ -3530,7 +3560,7 @@ vg_get_current_vline(void)
         current_line = READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_V_LINE_CNT;
     }
     while (current_line !=
-        (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_V_LINE_CNT));
+           (READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_V_LINE_CNT));
 
     return (current_line >> 16);
 }
@@ -3661,7 +3691,7 @@ vg_get_compression_info(VG_COMPRESSION_DATA * comp_data)
     comp_data->compression_offset = READ_REG32(DC3_CB_ST_OFFSET) & 0x0FFFFFFF;
     comp_data->pitch = (READ_REG32(DC3_GFX_PITCH) >> 13) & 0x7FFF8;
     comp_data->size = ((READ_REG32(DC3_LINE_SIZE) >> (DC3_LINE_SIZE_CB_SHIFT -
-                3)) & 0x3F8) + 24;
+                                                      3)) & 0x3F8) + 24;
 
     return CIM_STATUS_OK;
 }
diff --git a/src/cim/cim_vip.c b/src/cim/cim_vip.c
index 025449b..9ecfad3 100644
--- a/src/cim/cim_vip.c
+++ b/src/cim/cim_vip.c
@@ -66,13 +66,15 @@ vip_initialize(VIPSETMODEBUFFER * buffer)
 
         if (buffer->planar_capture == VIP_420CAPTURE_EVERYLINE) {
             vip_control1 |= VIP_CONTROL1_DISABLE_DECIMATION;
-        } else if (buffer->planar_capture == VIP_420CAPTURE_ALTERNATINGFIELDS) {
+        }
+        else if (buffer->planar_capture == VIP_420CAPTURE_ALTERNATINGFIELDS) {
             if (buffer->flags & VIP_MODEFLAG_PROGRESSIVE)
                 return CIM_STATUS_INVALIDPARAMS;
 
             vip_control1 |= VIP_CONTROL1_DISABLE_DECIMATION;
             vip_control3 |= VIP_CONTROL3_DECIMATE_EVEN;
-        } else if (buffer->planar_capture != VIP_420CAPTURE_ALTERNATINGLINES)
+        }
+        else if (buffer->planar_capture != VIP_420CAPTURE_ALTERNATINGLINES)
             return CIM_STATUS_INVALIDPARAMS;
 
         /* CONFIGURE THE VIDEO FIFO THRESHOLD BASED ON THE FIFO DEPTH */
@@ -80,7 +82,8 @@ vip_initialize(VIPSETMODEBUFFER * buffer)
         vip_control2 |= VIP_CONTROL2_DEFAULT_VIDTH_420 <<
             VIP_CONTROL2_VIDTH_SHIFT;
 
-    } else {
+    }
+    else {
         vip_control2 |= VIP_CONTROL2_DEFAULT_VIDTH_422 <<
             VIP_CONTROL2_VIDTH_SHIFT;
     }
@@ -104,13 +107,13 @@ vip_initialize(VIPSETMODEBUFFER * buffer)
     }
 
     if ((buffer->operating_mode == VIP_MODE_MSG ||
-            buffer->operating_mode == VIP_MODE_DATA) &&
+         buffer->operating_mode == VIP_MODE_DATA) &&
         (buffer->flags & VIP_MODEFLAG_FLIPMESSAGEWHENFULL)) {
         vip_control1 |= VIP_CONTROL1_MSG_STRM_CTRL;
     }
 
     else if (buffer->operating_mode == VIP_MODE_VIP2_8BIT ||
-        buffer->operating_mode == VIP_MODE_VIP2_16BIT) {
+             buffer->operating_mode == VIP_MODE_VIP2_16BIT) {
         if (buffer->flags & VIP_MODEFLAG_ENABLEREPEATFLAG)
             vip_control2 |= VIP_CONTROL2_REPEAT_ENABLE;
         if (buffer->flags & VIP_MODEFLAG_INVERTTASKPOLARITY)
@@ -172,13 +175,13 @@ vip_update_601_params(VIP_601PARAMS * buffer)
     WRITE_VIP32(VIP_601_VBI_START, buffer->vbi_start);
     WRITE_VIP32(VIP_601_VBI_END, buffer->vbi_start + buffer->vbi_height - 1);
     WRITE_VIP32(VIP_601_EVEN_START_STOP,
-        buffer->vert_start_even | ((buffer->vert_start_even +
-                buffer->even_height - 1) << 16));
+                buffer->vert_start_even | ((buffer->vert_start_even +
+                                            buffer->even_height - 1) << 16));
     WRITE_VIP32(VIP_601_ODD_START_STOP,
-        buffer->vert_start_odd | ((buffer->vert_start_odd +
-                buffer->odd_height - 1) << 16));
+                buffer->vert_start_odd | ((buffer->vert_start_odd +
+                                           buffer->odd_height - 1) << 16));
     WRITE_VIP32(VIP_ODD_FIELD_DETECT,
-        buffer->odd_detect_start | (buffer->odd_detect_end << 16));
+                buffer->odd_detect_start | (buffer->odd_detect_end << 16));
 
     /* SPECIAL CASE FOR HORIZONTAL DATA
      * 601 horizontal parameters are based on the number of clocks and not
@@ -187,7 +190,7 @@ vip_update_601_params(VIP_601PARAMS * buffer)
 
     if ((vip_control1 & VIP_CONTROL1_MODE_MASK) == VIP_MODE_16BIT601)
         WRITE_VIP32(VIP_601_HORZ_END,
-            buffer->horz_start + (buffer->width << 1) + 3);
+                    buffer->horz_start + (buffer->width << 1) + 3);
     else
         WRITE_VIP32(VIP_601_HORZ_END, buffer->horz_start + buffer->width + 3);
 
@@ -225,24 +228,22 @@ vip_configure_capture_buffers(int buffer_type, VIPINPUTBUFFER * buffer)
         /* SET VIDEO PITCH */
 
         WRITE_VIP32(VIP_TASKA_VID_PITCH,
-            offsets->y_pitch | (offsets->uv_pitch << 16));
+                    offsets->y_pitch | (offsets->uv_pitch << 16));
 
         /* SET BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY) {
-            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE,
-                offsets->even_base[cur_buffer]);
-            WRITE_VIP32(VIP_TASKA_VID_EVEN_BASE,
-                offsets->odd_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE, offsets->even_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKA_VID_EVEN_BASE, offsets->odd_base[cur_buffer]);
             if (buffer->flags & VIP_INPUTFLAG_VBI) {
                 WRITE_VIP32(VIP_TASKA_VBI_ODD_BASE, offsets->vbi_even_base);
                 WRITE_VIP32(VIP_TASKA_VBI_EVEN_BASE, offsets->vbi_odd_base);
             }
-        } else {
-            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE,
-                offsets->odd_base[cur_buffer]);
+        }
+        else {
+            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE, offsets->odd_base[cur_buffer]);
             WRITE_VIP32(VIP_TASKA_VID_EVEN_BASE,
-                offsets->even_base[cur_buffer]);
+                        offsets->even_base[cur_buffer]);
             if (buffer->flags & VIP_INPUTFLAG_VBI) {
                 WRITE_VIP32(VIP_TASKA_VBI_ODD_BASE, offsets->vbi_odd_base);
                 WRITE_VIP32(VIP_TASKA_VBI_EVEN_BASE, offsets->vbi_even_base);
@@ -257,30 +258,29 @@ vip_configure_capture_buffers(int buffer_type, VIPINPUTBUFFER * buffer)
             WRITE_VIP32(VIP_TASKA_U_EVEN_OFFSET, offsets->even_uoffset);
             WRITE_VIP32(VIP_TASKA_V_EVEN_OFFSET, offsets->even_voffset);
         }
-    } else if (buffer_type == VIP_BUFFER_B) {
+    }
+    else if (buffer_type == VIP_BUFFER_B) {
         offsets = &buffer->offsets[VIP_BUFFER_TASK_B];
 
         /* SET VIDEO PITCH */
 
         WRITE_VIP32(VIP_TASKB_VID_PITCH,
-            offsets->y_pitch | (offsets->uv_pitch << 16));
+                    offsets->y_pitch | (offsets->uv_pitch << 16));
 
         /* SET BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY) {
-            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE,
-                offsets->even_base[cur_buffer]);
-            WRITE_VIP32(VIP_TASKB_VID_EVEN_BASE,
-                offsets->odd_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE, offsets->even_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKB_VID_EVEN_BASE, offsets->odd_base[cur_buffer]);
             if (buffer->flags & VIP_INPUTFLAG_VBI) {
                 WRITE_VIP32(VIP_TASKB_VBI_ODD_BASE, offsets->vbi_even_base);
                 WRITE_VIP32(VIP_TASKB_VBI_EVEN_BASE, offsets->vbi_odd_base);
             }
-        } else {
-            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE,
-                offsets->odd_base[cur_buffer]);
+        }
+        else {
+            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE, offsets->odd_base[cur_buffer]);
             WRITE_VIP32(VIP_TASKB_VID_EVEN_BASE,
-                offsets->even_base[cur_buffer]);
+                        offsets->even_base[cur_buffer]);
             if (buffer->flags & VIP_INPUTFLAG_VBI) {
                 WRITE_VIP32(VIP_TASKB_VBI_ODD_BASE, offsets->vbi_odd_base);
                 WRITE_VIP32(VIP_TASKB_VBI_EVEN_BASE, offsets->vbi_even_base);
@@ -293,11 +293,13 @@ vip_configure_capture_buffers(int buffer_type, VIPINPUTBUFFER * buffer)
             WRITE_VIP32(VIP_TASKB_U_OFFSET, offsets->odd_uoffset);
             WRITE_VIP32(VIP_TASKB_V_OFFSET, offsets->odd_voffset);
         }
-    } else if (buffer_type == VIP_BUFFER_ANC || buffer_type == VIP_BUFFER_MSG) {
+    }
+    else if (buffer_type == VIP_BUFFER_ANC || buffer_type == VIP_BUFFER_MSG) {
         WRITE_VIP32(VIP_ANC_MSG1_BASE, buffer->ancillaryData.msg1_base);
         WRITE_VIP32(VIP_ANC_MSG2_BASE, buffer->ancillaryData.msg2_base);
         WRITE_VIP32(VIP_ANC_MSG_SIZE, buffer->ancillaryData.msg_size);
-    } else {
+    }
+    else {
         return CIM_STATUS_INVALIDPARAMS;
     }
 
@@ -325,77 +327,73 @@ vip_toggle_video_offsets(int buffer_type, VIPINPUTBUFFER * buffer)
         /* SET BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY) {
-            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE,
-                offsets->even_base[cur_buffer]);
-            WRITE_VIP32(VIP_TASKA_VID_EVEN_BASE,
-                offsets->odd_base[cur_buffer]);
-        } else {
-            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE,
-                offsets->odd_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE, offsets->even_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKA_VID_EVEN_BASE, offsets->odd_base[cur_buffer]);
+        }
+        else {
+            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE, offsets->odd_base[cur_buffer]);
             WRITE_VIP32(VIP_TASKA_VID_EVEN_BASE,
-                offsets->even_base[cur_buffer]);
+                        offsets->even_base[cur_buffer]);
         }
-    } else if (buffer_type == VIP_BUFFER_B) {
+    }
+    else if (buffer_type == VIP_BUFFER_B) {
         offsets = &buffer->offsets[VIP_BUFFER_TASK_B];
 
         /* SET BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY) {
-            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE,
-                offsets->even_base[cur_buffer]);
-            WRITE_VIP32(VIP_TASKB_VID_EVEN_BASE,
-                offsets->odd_base[cur_buffer]);
-        } else {
-            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE,
-                offsets->odd_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE, offsets->even_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKB_VID_EVEN_BASE, offsets->odd_base[cur_buffer]);
+        }
+        else {
+            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE, offsets->odd_base[cur_buffer]);
             WRITE_VIP32(VIP_TASKB_VID_EVEN_BASE,
-                offsets->even_base[cur_buffer]);
+                        offsets->even_base[cur_buffer]);
         }
-    } else if (buffer_type == VIP_BUFFER_A_ODD) {
+    }
+    else if (buffer_type == VIP_BUFFER_A_ODD) {
         offsets = &buffer->offsets[VIP_BUFFER_TASK_A];
 
         /* SET BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY)
-            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE,
-                offsets->even_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE, offsets->even_base[cur_buffer]);
         else
-            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE,
-                offsets->odd_base[cur_buffer]);
-    } else if (buffer_type == VIP_BUFFER_A_EVEN) {
+            WRITE_VIP32(VIP_TASKA_VID_ODD_BASE, offsets->odd_base[cur_buffer]);
+    }
+    else if (buffer_type == VIP_BUFFER_A_EVEN) {
         offsets = &buffer->offsets[VIP_BUFFER_TASK_A];
 
         /* SET BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY)
-            WRITE_VIP32(VIP_TASKA_VID_EVEN_BASE,
-                offsets->odd_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKA_VID_EVEN_BASE, offsets->odd_base[cur_buffer]);
         else
             WRITE_VIP32(VIP_TASKA_VID_EVEN_BASE,
-                offsets->even_base[cur_buffer]);
-    } else if (buffer_type == VIP_BUFFER_B_ODD) {
+                        offsets->even_base[cur_buffer]);
+    }
+    else if (buffer_type == VIP_BUFFER_B_ODD) {
         offsets = &buffer->offsets[VIP_BUFFER_TASK_B];
 
         /* SET BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY)
-            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE,
-                offsets->even_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE, offsets->even_base[cur_buffer]);
         else
-            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE,
-                offsets->odd_base[cur_buffer]);
-    } else if (buffer_type == VIP_BUFFER_B_EVEN) {
+            WRITE_VIP32(VIP_TASKB_VID_ODD_BASE, offsets->odd_base[cur_buffer]);
+    }
+    else if (buffer_type == VIP_BUFFER_B_EVEN) {
         offsets = &buffer->offsets[VIP_BUFFER_TASK_B];
 
         /* SET BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY)
-            WRITE_VIP32(VIP_TASKB_VID_EVEN_BASE,
-                offsets->odd_base[cur_buffer]);
+            WRITE_VIP32(VIP_TASKB_VID_EVEN_BASE, offsets->odd_base[cur_buffer]);
         else
             WRITE_VIP32(VIP_TASKB_VID_EVEN_BASE,
-                offsets->even_base[cur_buffer]);
-    } else
+                        offsets->even_base[cur_buffer]);
+    }
+    else
         return CIM_STATUS_INVALIDPARAMS;
 
     return CIM_STATUS_OK;
@@ -450,8 +448,7 @@ vip_terminate(void)
 
     /* DISABLE AND CLEAR ALL VIP INTERRUPTS */
 
-    WRITE_VIP32(VIP_INTERRUPT, VIP_ALL_INTERRUPTS |
-        (VIP_ALL_INTERRUPTS >> 16));
+    WRITE_VIP32(VIP_INTERRUPT, VIP_ALL_INTERRUPTS | (VIP_ALL_INTERRUPTS >> 16));
 
     /* DISABLE VIP CAPTURE */
     /* We will try to let the VIP FIFO flush before shutting it down. */
@@ -575,7 +572,7 @@ vip_set_interrupt_enable(unsigned long mask, int enable)
 
 int
 vip_set_vsync_error(unsigned long vertical_count, unsigned long window_before,
-    unsigned long window_after, int enable)
+                    unsigned long window_after, int enable)
 {
     unsigned long vip_control2 = READ_VIP32(VIP_CONTROL2);
     unsigned long temp;
@@ -589,14 +586,15 @@ vip_set_vsync_error(unsigned long vertical_count, unsigned long window_before,
          */
 
         temp = ((window_before +
-                window_after) << VIP_VSYNC_ERR_WINDOW_SHIFT) &
+                 window_after) << VIP_VSYNC_ERR_WINDOW_SHIFT) &
             VIP_VSYNC_ERR_WINDOW_MASK;
         temp |= (vertical_count - window_before) & VIP_VSYNC_ERR_COUNT_MASK;
 
         vip_control2 |= VIP_CONTROL2_VERTERROR_ENABLE;
 
         WRITE_VIP32(VIP_VSYNC_ERR_COUNT, temp);
-    } else {
+    }
+    else {
         vip_control2 &= ~VIP_CONTROL2_VERTERROR_ENABLE;
     }
     WRITE_VIP32(VIP_CONTROL2, vip_control2);
@@ -624,7 +622,8 @@ vip_max_address_enable(unsigned long max_address, int enable)
         vip_control2 |= VIP_CONTROL2_ADD_ERROR_ENABLE;
 
         WRITE_VIP32(VIP_MAX_ADDRESS, max_address & VIP_MAXADDR_MASK);
-    } else {
+    }
+    else {
         /* DISABLE DETECTION */
 
         vip_control2 &= ~VIP_CONTROL2_ADD_ERROR_ENABLE;
@@ -792,12 +791,13 @@ vip_set_priority_characteristics(VIPPRIORITYBUFFER * buffer)
     q_word.low = q_word.high = 0;
 
     q_word.low |= (buffer->secondary <<
-        VIP_MSR_MCR_SECOND_PRIORITY_SHIFT) & VIP_MSR_MCR_SECOND_PRIORITY_MASK;
-    q_word.low |= (buffer->primary <<
-        VIP_MSR_MCR_PRIMARY_PRIORITY_SHIFT) &
+                   VIP_MSR_MCR_SECOND_PRIORITY_SHIFT) &
+        VIP_MSR_MCR_SECOND_PRIORITY_MASK;
+    q_word.low |=
+        (buffer->
+         primary << VIP_MSR_MCR_PRIMARY_PRIORITY_SHIFT) &
         VIP_MSR_MCR_PRIMARY_PRIORITY_MASK;
-    q_word.low |= (buffer->pid << VIP_MSR_MCR_PID_SHIFT) &
-        VIP_MSR_MCR_PID_MASK;
+    q_word.low |= (buffer->pid << VIP_MSR_MCR_PID_SHIFT) & VIP_MSR_MCR_PID_MASK;
 
     msr_write64(MSR_DEVICE_GEODELX_VIP, MSR_GEODELINK_CONFIG, &q_word);
 
@@ -822,12 +822,10 @@ vip_set_debug_characteristics(VIPDEBUGBUFFER * buffer)
 
     q_word.high |= (buffer->bist << VIP_MSR_DIAG_BIST_SHIFT) &
         VIP_MSR_DIAG_BIST_WMASK;
-    q_word.low |= (buffer->enable_upper ?
-        VIP_MSR_DIAG_MSB_ENABLE : 0x00000000);
+    q_word.low |= (buffer->enable_upper ? VIP_MSR_DIAG_MSB_ENABLE : 0x00000000);
     q_word.low |= (buffer->select_upper << VIP_MSR_DIAG_SEL_UPPER_SHIFT) &
         VIP_MSR_DIAG_SEL_UPPER_MASK;
-    q_word.low |= (buffer->enable_lower ?
-        VIP_MSR_DIAG_LSB_ENABLE : 0x00000000);
+    q_word.low |= (buffer->enable_lower ? VIP_MSR_DIAG_LSB_ENABLE : 0x00000000);
     q_word.low |= (buffer->select_lower << VIP_MSR_DIAG_SEL_LOWER_SHIFT) &
         VIP_MSR_DIAG_SEL_LOWER_MASK;
 
@@ -871,7 +869,7 @@ int
 vip_set_interrupt_line(int line)
 {
     WRITE_VIP32(VIP_CURRENT_TARGET,
-        (line << VIP_CTARGET_TLINE_SHIFT) & VIP_CTARGET_TLINE_MASK);
+                (line << VIP_CTARGET_TLINE_SHIFT) & VIP_CTARGET_TLINE_MASK);
 
     return CIM_STATUS_OK;
 }
@@ -922,14 +920,17 @@ vip_set_subwindow_enable(VIPSUBWINDOWBUFFER * buffer)
         /* WRITE THE WINDOW VALUE */
 
         WRITE_VIP32(VIP_VERTICAL_START_STOP, ((buffer->stop <<
-                    VIP_VSTART_VERTEND_SHIFT) &
-                VIP_VSTART_VERTEND_MASK) | ((buffer->start <<
-                    VIP_VSTART_VERTSTART_SHIFT) & VIP_VSTART_VERTSTART_MASK));
+                                               VIP_VSTART_VERTEND_SHIFT) &
+                                              VIP_VSTART_VERTEND_MASK) |
+                    ((buffer->
+                      start << VIP_VSTART_VERTSTART_SHIFT) &
+                     VIP_VSTART_VERTSTART_MASK));
 
         /* ENABLE IN THE CONTROL REGISTER */
 
         vip_control2 |= VIP_CONTROL2_SWC_ENABLE;
-    } else {
+    }
+    else {
         /* DISABLE SUBWINDOW CAPTURE IN THE CONTROL REGISTER */
 
         vip_control2 &= ~VIP_CONTROL2_SWC_ENABLE;
@@ -1009,13 +1010,13 @@ vip_save_state(VIPSTATEBUFFER * save_buffer)
     /* READ ALL VIP MSRS */
 
     msr_read64(MSR_DEVICE_GEODELX_VIP, MSR_GEODELINK_CONFIG,
-        &(save_buffer->msr_config));
+               &(save_buffer->msr_config));
     msr_read64(MSR_DEVICE_GEODELX_VIP, MSR_GEODELINK_SMI,
-        &(save_buffer->msr_smi));
+               &(save_buffer->msr_smi));
     msr_read64(MSR_DEVICE_GEODELX_VIP, MSR_GEODELINK_PM,
-        &(save_buffer->msr_pm));
+               &(save_buffer->msr_pm));
     msr_read64(MSR_DEVICE_GEODELX_VIP, MSR_GEODELINK_DIAG,
-        &(save_buffer->msr_diag));
+               &(save_buffer->msr_diag));
 
     return CIM_STATUS_OK;
 }
@@ -1064,13 +1065,13 @@ vip_restore_state(VIPSTATEBUFFER * restore_buffer)
     /* RESTORE THE VIP MSRS */
 
     msr_write64(MSR_DEVICE_GEODELX_VIP, MSR_GEODELINK_CONFIG,
-        &(restore_buffer->msr_config));
+                &(restore_buffer->msr_config));
     msr_write64(MSR_DEVICE_GEODELX_VIP, MSR_GEODELINK_SMI,
-        &(restore_buffer->msr_smi));
+                &(restore_buffer->msr_smi));
     msr_write64(MSR_DEVICE_GEODELX_VIP, MSR_GEODELINK_PM,
-        &(restore_buffer->msr_pm));
+                &(restore_buffer->msr_pm));
     msr_write64(MSR_DEVICE_GEODELX_VIP, MSR_GEODELINK_DIAG,
-        &(restore_buffer->msr_diag));
+                &(restore_buffer->msr_diag));
 
     /* RESTORE THE CONTROL WORDS LAST */
 
@@ -1185,7 +1186,8 @@ vip_get_current_mode(VIPSETMODEBUFFER * buffer)
                 buffer->planar_capture = VIP_420CAPTURE_ALTERNATINGFIELDS;
             else
                 buffer->planar_capture = VIP_420CAPTURE_EVERYLINE;
-        } else
+        }
+        else
             buffer->planar_capture = VIP_420CAPTURE_ALTERNATINGLINES;
     }
 
@@ -1257,10 +1259,9 @@ vip_get_601_configuration(VIP_601PARAMS * buffer)
 
     if ((vip_control1 & VIP_CONTROL1_MODE_MASK) == VIP_MODE_16BIT601)
         buffer->width = (READ_VIP32(VIP_601_HORZ_END) -
-            buffer->horz_start - 3) >> 1;
+                         buffer->horz_start - 3) >> 1;
     else
-        buffer->width = (READ_VIP32(VIP_601_HORZ_END) -
-            buffer->horz_start - 3);
+        buffer->width = (READ_VIP32(VIP_601_HORZ_END) - buffer->horz_start - 3);
 
     return CIM_STATUS_OK;
 }
@@ -1293,20 +1294,18 @@ vip_get_buffer_configuration(int buffer_type, VIPINPUTBUFFER * buffer)
         /* READ BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY) {
-            offsets->even_base[cur_buffer] =
-                READ_VIP32(VIP_TASKA_VID_ODD_BASE);
-            offsets->odd_base[cur_buffer] =
-                READ_VIP32(VIP_TASKA_VID_EVEN_BASE);
+            offsets->even_base[cur_buffer] = READ_VIP32(VIP_TASKA_VID_ODD_BASE);
+            offsets->odd_base[cur_buffer] = READ_VIP32(VIP_TASKA_VID_EVEN_BASE);
 
             if (buffer->flags & VIP_INPUTFLAG_VBI) {
                 offsets->vbi_even_base = READ_VIP32(VIP_TASKA_VBI_ODD_BASE);
                 offsets->vbi_odd_base = READ_VIP32(VIP_TASKA_VBI_EVEN_BASE);
             }
-        } else {
+        }
+        else {
             offsets->even_base[cur_buffer] =
                 READ_VIP32(VIP_TASKA_VID_EVEN_BASE);
-            offsets->odd_base[cur_buffer] =
-                READ_VIP32(VIP_TASKA_VID_ODD_BASE);
+            offsets->odd_base[cur_buffer] = READ_VIP32(VIP_TASKA_VID_ODD_BASE);
 
             if (buffer->flags & VIP_INPUTFLAG_VBI) {
                 offsets->vbi_even_base = READ_VIP32(VIP_TASKA_VBI_EVEN_BASE);
@@ -1322,7 +1321,8 @@ vip_get_buffer_configuration(int buffer_type, VIPINPUTBUFFER * buffer)
             offsets->even_uoffset = READ_VIP32(VIP_TASKA_U_EVEN_OFFSET);
             offsets->even_voffset = READ_VIP32(VIP_TASKA_V_EVEN_OFFSET);
         }
-    } else if (buffer_type == VIP_BUFFER_B) {
+    }
+    else if (buffer_type == VIP_BUFFER_B) {
         offsets = &buffer->offsets[VIP_BUFFER_TASK_B];
 
         /* READ VIDEO PITCH */
@@ -1333,20 +1333,18 @@ vip_get_buffer_configuration(int buffer_type, VIPINPUTBUFFER * buffer)
         /* READ BASE OFFSETS */
 
         if (buffer->flags & VIP_INPUTFLAG_INVERTPOLARITY) {
-            offsets->even_base[cur_buffer] =
-                READ_VIP32(VIP_TASKB_VID_ODD_BASE);
-            offsets->odd_base[cur_buffer] =
-                READ_VIP32(VIP_TASKB_VID_EVEN_BASE);
+            offsets->even_base[cur_buffer] = READ_VIP32(VIP_TASKB_VID_ODD_BASE);
+            offsets->odd_base[cur_buffer] = READ_VIP32(VIP_TASKB_VID_EVEN_BASE);
 
             if (buffer->flags & VIP_INPUTFLAG_VBI) {
                 offsets->vbi_even_base = READ_VIP32(VIP_TASKB_VBI_ODD_BASE);
                 offsets->vbi_odd_base = READ_VIP32(VIP_TASKB_VBI_EVEN_BASE);
             }
-        } else {
+        }
+        else {
             offsets->even_base[cur_buffer] =
                 READ_VIP32(VIP_TASKB_VID_EVEN_BASE);
-            offsets->odd_base[cur_buffer] =
-                READ_VIP32(VIP_TASKB_VID_ODD_BASE);
+            offsets->odd_base[cur_buffer] = READ_VIP32(VIP_TASKB_VID_ODD_BASE);
 
             if (buffer->flags & VIP_INPUTFLAG_VBI) {
                 offsets->vbi_even_base = READ_VIP32(VIP_TASKB_VBI_EVEN_BASE);
@@ -1360,11 +1358,13 @@ vip_get_buffer_configuration(int buffer_type, VIPINPUTBUFFER * buffer)
             offsets->odd_uoffset = READ_VIP32(VIP_TASKB_U_OFFSET);
             offsets->odd_voffset = READ_VIP32(VIP_TASKB_V_OFFSET);
         }
-    } else if (buffer_type == VIP_BUFFER_ANC || buffer_type == VIP_BUFFER_MSG) {
+    }
+    else if (buffer_type == VIP_BUFFER_ANC || buffer_type == VIP_BUFFER_MSG) {
         buffer->ancillaryData.msg1_base = READ_VIP32(VIP_ANC_MSG1_BASE);
         buffer->ancillaryData.msg2_base = READ_VIP32(VIP_ANC_MSG2_BASE);
         buffer->ancillaryData.msg_size = READ_VIP32(VIP_ANC_MSG_SIZE);
-    } else {
+    }
+    else {
         return CIM_STATUS_INVALIDPARAMS;
     }
 
@@ -1450,7 +1450,7 @@ unsigned long
 vip_get_capture_state(void)
 {
     return ((READ_VIP32(VIP_CONTROL1) & VIP_CONTROL1_RUNMODE_MASK) >>
-        VIP_CONTROL1_RUNMODE_SHIFT);
+            VIP_CONTROL1_RUNMODE_SHIFT);
 }
 
 /*---------------------------------------------------------------------------
@@ -1569,8 +1569,8 @@ vip_get_power_characteristics(VIPPOWERBUFFER * buffer)
 
     /* DECODE THE CLOCK GATING BITS */
 
-    buffer->glink_clock_mode = (int)(q_word.low & VIP_MSR_POWER_GLINK);
-    buffer->vip_clock_mode = (int)(q_word.low & VIP_MSR_POWER_CLOCK);
+    buffer->glink_clock_mode = (int) (q_word.low & VIP_MSR_POWER_GLINK);
+    buffer->vip_clock_mode = (int) (q_word.low & VIP_MSR_POWER_CLOCK);
 
     return CIM_STATUS_OK;
 }
diff --git a/src/cim/cim_vop.c b/src/cim/cim_vop.c
index 4b83c03..fe73e98 100644
--- a/src/cim/cim_vop.c
+++ b/src/cim/cim_vop.c
@@ -73,11 +73,12 @@ vop_set_vbi_window(VOPVBIWINDOWBUFFER * buffer)
             return CIM_STATUS_INVALIDPARAMS;
 
         hstart = buffer->horz_start + hsyncstart;
-    } else {
+    }
+    else {
         /* VERIFY THAT THE INPUT IS VALID */
 
-        if (buffer->horz_start < ((long)hsyncstart - (long)htotal) ||
-            buffer->horz_start > (long)hsyncstart ||
+        if (buffer->horz_start < ((long) hsyncstart - (long) htotal) ||
+            buffer->horz_start > (long) hsyncstart ||
             buffer->vbi_width > htotal) {
             return CIM_STATUS_INVALIDPARAMS;
         }
@@ -93,17 +94,24 @@ vop_set_vbi_window(VOPVBIWINDOWBUFFER * buffer)
     hstart--;
     hstop--;
     WRITE_REG32(DC3_VBI_HOR, ((hstop << DC3_VBI_HOR_END_SHIFT) &
-            DC3_VBI_HOR_END_MASK) | (hstart & DC3_VBI_HOR_START_MASK));
+                              DC3_VBI_HOR_END_MASK) | (hstart &
+                                                       DC3_VBI_HOR_START_MASK));
 
     /* WRITE LINE CAPTURE MASKS */
 
     WRITE_REG32(DC3_VBI_LN_ODD, ((buffer->odd_line_offset <<
-                DC3_VBI_ODD_LINE_SHIFT) & DC3_VBI_ODD_LINE_MASK) |
-        (buffer->odd_line_capture_mask & DC3_VBI_ODD_ENABLE_MASK));
+                                  DC3_VBI_ODD_LINE_SHIFT) &
+                                 DC3_VBI_ODD_LINE_MASK) | (buffer->
+                                                           odd_line_capture_mask
+                                                           &
+                                                           DC3_VBI_ODD_ENABLE_MASK));
 
     WRITE_REG32(DC3_VBI_LN_EVEN, ((buffer->even_line_offset <<
-                DC3_VBI_EVEN_LINE_SHIFT) & DC3_VBI_EVEN_LINE_MASK) |
-        (buffer->even_line_capture_mask & DC3_VBI_EVEN_ENABLE_MASK));
+                                   DC3_VBI_EVEN_LINE_SHIFT) &
+                                  DC3_VBI_EVEN_LINE_MASK) | (buffer->
+                                                             even_line_capture_mask
+                                                             &
+                                                             DC3_VBI_EVEN_ENABLE_MASK));
 
     /* PROGRAM SOURCE OFFSETS
      * Start with the even offsets.  Note that we always enable 16-bit VBI,
@@ -115,18 +123,18 @@ vop_set_vbi_window(VOPVBIWINDOWBUFFER * buffer)
     if (buffer->enable_upscale)
         temp |= DC3_VBI_EVEN_CTL_UPSCALE;
     WRITE_REG32(DC3_VBI_EVEN_CTL, temp |
-        (buffer->even_address_offset & DC3_VBI_EVEN_CTL_OFFSET_MASK));
+                (buffer->even_address_offset & DC3_VBI_EVEN_CTL_OFFSET_MASK));
 
     /* ODD OFFSET */
 
     temp = READ_REG32(DC3_VBI_ODD_CTL) & ~DC3_VBI_ODD_CTL_OFFSET_MASK;
     WRITE_REG32(DC3_VBI_ODD_CTL, temp |
-        (buffer->odd_address_offset & DC3_VBI_ODD_CTL_OFFSET_MASK));
+                (buffer->odd_address_offset & DC3_VBI_ODD_CTL_OFFSET_MASK));
 
     /* PITCH */
 
     temp = ((buffer->data_size >> 3) << 16) | ((buffer->data_pitch >> 3) &
-        0x0000FFFF);
+                                               0x0000FFFF);
     WRITE_REG32(DC3_VBI_PITCH, temp);
 
     WRITE_REG32(DC3_UNLOCK, unlock);
@@ -221,10 +229,11 @@ vop_set_configuration(VOPCONFIGURATIONBUFFER * config)
 
         if (config->vop601.vsync_shift == VOP_VSYNC_LATER_BY_X) {
             delta |= (config->vop601.vsync_shift_count &
-                DC3_601_VSYNC_SHIFT_MASK);
+                      DC3_601_VSYNC_SHIFT_MASK);
             delta |= DC3_601_VSYNC_SHIFT_ENABLE;
         }
-    } else {
+    }
+    else {
         if (config->flags & VOP_FLAG_VBI)
             vop_config |= VOP_CONFIG_VBI;
         if (config->flags & VOP_FLAG_TASK)
@@ -275,7 +284,8 @@ vop_set_configuration(VOPCONFIGURATIONBUFFER * config)
             alpha |= DF_CSC_VOP_RGB_TO_YUV;
         else
             alpha &= ~DF_CSC_VOP_RGB_TO_YUV;
-    } else {
+    }
+    else {
         /* YUV OUTPUT FROM THE MIXER */
         /* As there is no YUV->RGB VOP conversion, we simply disable the */
         /* VOP CSC and trust that the user is competent.                 */
@@ -384,14 +394,14 @@ vop_get_current_mode(VOPCONFIGURATIONBUFFER * config)
     /* READ 601 SETTINGS */
 
     config->vop601.flags = vop_config & (VOP_CONFIG_INVERT_DISPE |
-        VOP_CONFIG_INVERT_HSYNC | VOP_CONFIG_INVERT_VSYNC);
+                                         VOP_CONFIG_INVERT_HSYNC |
+                                         VOP_CONFIG_INVERT_VSYNC);
 
     config->vop601.vsync_shift = vop_config & VOP_CONFIG_VSYNC_MASK;
     config->vop601.vsync_shift_count =
         READ_REG32(DC3_VID_DS_DELTA) & DC3_601_VSYNC_SHIFT_MASK;
 
-    if ((alpha & DF_CSC_GRAPHICS_RGB_TO_YUV) ||
-        (alpha & DF_CSC_VOP_RGB_TO_YUV)) {
+    if ((alpha & DF_CSC_GRAPHICS_RGB_TO_YUV) || (alpha & DF_CSC_VOP_RGB_TO_YUV)) {
         /* YUV OUTPUT */
 
         if (vop_config & VOP_CONFIG_DISABLE_DECIMATE)
@@ -400,7 +410,8 @@ vop_get_current_mode(VOPCONFIGURATIONBUFFER * config)
             config->vop601.output_mode = VOP_601_YUV_16BIT;
         else
             config->vop601.output_mode = VOP_601_YUV_8BIT;
-    } else {
+    }
+    else {
         config->vop601.output_mode = VOP_601_RGB_8_8_8;
     }
 
@@ -455,11 +466,12 @@ vop_get_vbi_configuration(VOPVBIWINDOWBUFFER * buffer)
     hstop = ((temp & DC3_VBI_HOR_END_MASK) >> DC3_VBI_HOR_END_SHIFT) + 1;
     if (buffer->horz_from_hsync) {
         buffer->horz_start = hstart + htotal - hsyncstart;
-        if (buffer->horz_start >= (long)htotal)
+        if (buffer->horz_start >= (long) htotal)
             buffer->horz_start -= htotal;
-    } else {
+    }
+    else {
         if (hstart > hsyncstart)
-            buffer->horz_start = (long)hstart - (long)htotal;
+            buffer->horz_start = (long) hstart - (long) htotal;
         else
             buffer->horz_start = hstart;
     }
@@ -547,7 +559,7 @@ vop_get_crc(void)
 
     /* WAIT UNTIL NOT ACTIVE, THEN ACTIVE, NOT ACTIVE, THEN ACTIVE */
 
-    while (!(READ_VOP32(VOP_CONFIGURATION) & VOP_CONFIG_SIGVAL)) ;
+    while (!(READ_VOP32(VOP_CONFIGURATION) & VOP_CONFIG_SIGVAL));
 
     crc = READ_VOP32(VOP_SIGNATURE);
 
@@ -586,7 +598,7 @@ vop_read_vbi_crc(void)
 
     /* WAIT FOR THE CRC TO BE COMPLETED */
 
-    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_SIGC)) ;
+    while (!(READ_REG32(DC3_LINE_CNT_STATUS) & DC3_LNCNT_SIGC));
 
     /* READ THE COMPLETED CRC */
 
diff --git a/src/cim_dev.h b/src/cim_dev.h
index f491eaf..45b397d 100644
--- a/src/cim_dev.h
+++ b/src/cim_dev.h
@@ -32,13 +32,12 @@
 #define CIMDEV_MINOR_DEV 156
 
 /* Block flags */
-#define CIM_F_FREE    0x01	       /* This block is marked as free */
-#define CIM_F_CMDBUF  0x02	       /* GP command buffer flag */
-#define CIM_F_PRIVATE 0x04	       /* This block is reserved only for its owner */
-#define CIM_F_PUBLIC  0x08	       /* This block can be used by the world */
+#define CIM_F_FREE    0x01      /* This block is marked as free */
+#define CIM_F_CMDBUF  0x02      /* GP command buffer flag */
+#define CIM_F_PRIVATE 0x04      /* This block is reserved only for its owner */
+#define CIM_F_PUBLIC  0x08      /* This block can be used by the world */
 
-typedef struct
-{
+typedef struct {
     /* These fields get populated by the client */
     char owner[10];
     char name[15];
@@ -49,8 +48,7 @@ typedef struct
     unsigned long offset;
 } cim_mem_req_t;
 
-typedef struct
-{
+typedef struct {
     char owner[10];
     unsigned long offset;
 } cim_mem_free_t;
diff --git a/src/cimarron.c b/src/cimarron.c
index b6986fe..e4376a9 100644
--- a/src/cimarron.c
+++ b/src/cimarron.c
@@ -166,13 +166,13 @@
 /* registers of their respective blocks.                                */
 /*----------------------------------------------------------------------*/
 
-unsigned char *cim_gp_ptr = (unsigned char *)0;
-unsigned char *cim_fb_ptr = (unsigned char *)0;
-unsigned char *cim_cmd_base_ptr = (unsigned char *)0;
-unsigned char *cim_cmd_ptr = (unsigned char *)0;
-unsigned char *cim_vid_ptr = (unsigned char *)0;
-unsigned char *cim_vip_ptr = (unsigned char *)0;
-unsigned char *cim_vg_ptr = (unsigned char *)0;
+unsigned char *cim_gp_ptr = (unsigned char *) 0;
+unsigned char *cim_fb_ptr = (unsigned char *) 0;
+unsigned char *cim_cmd_base_ptr = (unsigned char *) 0;
+unsigned char *cim_cmd_ptr = (unsigned char *) 0;
+unsigned char *cim_vid_ptr = (unsigned char *) 0;
+unsigned char *cim_vip_ptr = (unsigned char *) 0;
+unsigned char *cim_vg_ptr = (unsigned char *) 0;
 
 /* Define hooks for reading and writing MSRs - this is a major hack
  * to share the MSR code with the GX code */
diff --git a/src/durango.c b/src/durango.c
index 8795d41..fbca7b2 100644
--- a/src/durango.c
+++ b/src/durango.c
@@ -35,49 +35,49 @@
 #include <unistd.h>
 #include <errno.h>
 #include <compiler.h>
-#include <os.h>			       /* ErrorF() */
+#include <os.h>                 /* ErrorF() */
 
 /* Compiler options */
 
-#define GFX_DISPLAY_GU1	       0       /* 1st generation display controller */
-#define GFX_DISPLAY_GU2	       1       /* 2nd generation display controller */
+#define GFX_DISPLAY_GU1	       0        /* 1st generation display controller */
+#define GFX_DISPLAY_GU2	       1        /* 2nd generation display controller */
 
-#define GFX_INIT_DYNAMIC       0       /* runtime selection */
-#define GFX_INIT_GU1           0       /* SC1200/GX1        */
-#define GFX_INIT_GU2           1       /* GX                */
+#define GFX_INIT_DYNAMIC       0        /* runtime selection */
+#define GFX_INIT_GU1           0        /* SC1200/GX1        */
+#define GFX_INIT_GU2           1        /* GX                */
 
-#define GFX_MSR_DYNAMIC        0       /* runtime selection */
-#define GFX_MSR_REDCLOUD       1       /* GX */
+#define GFX_MSR_DYNAMIC        0        /* runtime selection */
+#define GFX_MSR_REDCLOUD       1        /* GX */
 
-#define GFX_2DACCEL_DYNAMIC    0       /* runtime selection                                */
-#define GFX_2DACCEL_GU1	       0       /* 1st generation 2D accelerator    */
-#define GFX_2DACCEL_GU2	       1       /* 2nd generation 2D accelerator    */
+#define GFX_2DACCEL_DYNAMIC    0        /* runtime selection                                */
+#define GFX_2DACCEL_GU1	       0        /* 1st generation 2D accelerator    */
+#define GFX_2DACCEL_GU2	       1        /* 2nd generation 2D accelerator    */
 
-#define GFX_VIDEO_DYNAMIC      0       /* runtime selection  */
-#define GFX_VIDEO_CS5530       0       /* support for CS5530 */
-#define GFX_VIDEO_SC1200       0       /* support for SC1200 */
-#define GFX_VIDEO_REDCLOUD     1       /* support for GX */
+#define GFX_VIDEO_DYNAMIC      0        /* runtime selection  */
+#define GFX_VIDEO_CS5530       0        /* support for CS5530 */
+#define GFX_VIDEO_SC1200       0        /* support for SC1200 */
+#define GFX_VIDEO_REDCLOUD     1        /* support for GX */
 
-#define GFX_VIP_DYNAMIC	       0       /* runtime selection  */
-#define GFX_VIP_SC1200	       0       /* support for SC1200 */
+#define GFX_VIP_DYNAMIC	       0        /* runtime selection  */
+#define GFX_VIP_SC1200	       0        /* support for SC1200 */
 
-#define GFX_DECODER_DYNAMIC    0       /* runtime selection */
-#define GFX_DECODER_SAA7114    0       /* Philips SAA7114 decoder */
+#define GFX_DECODER_DYNAMIC    0        /* runtime selection */
+#define GFX_DECODER_SAA7114    0        /* Philips SAA7114 decoder */
 
-#define GFX_TV_DYNAMIC	       0       /* runtime selection */
-#define GFX_TV_FS451	       0       /* Focus Enhancements FS450  */
-#define GFX_TV_SC1200	       0       /* SC1200 integrated TV encoder */
+#define GFX_TV_DYNAMIC	       0        /* runtime selection */
+#define GFX_TV_FS451	       0        /* Focus Enhancements FS450  */
+#define GFX_TV_SC1200	       0        /* SC1200 integrated TV encoder */
 
-#define GFX_I2C_DYNAMIC	       0       /* runtime selection  */
-#define GFX_I2C_ACCESS	       0       /* support for ACCESS.BUS  */
-#define GFX_I2C_GPIO	       0       /* support for CS5530 GPIOs */
+#define GFX_I2C_DYNAMIC	       0        /* runtime selection  */
+#define GFX_I2C_ACCESS	       0        /* support for ACCESS.BUS  */
+#define GFX_I2C_GPIO	       0        /* support for CS5530 GPIOs */
 
-#define GFX_VGA_DYNAMIC	       0       /* runtime selection */
-#define GFX_VGA_GU1	       0       /* 1st generation graphics unit */
+#define GFX_VGA_DYNAMIC	       0        /* runtime selection */
+#define GFX_VGA_GU1	       0        /* 1st generation graphics unit */
 
-#define FB4MB		       1       /* Set to use 4Mb vid ram for Pyramid */
+#define FB4MB		       1        /* Set to use 4Mb vid ram for Pyramid */
 
-#define GFX_NO_IO_IN_WAIT_MACROS    1  /* Set to remove I/O accesses in GP */
+#define GFX_NO_IO_IN_WAIT_MACROS    1   /* Set to remove I/O accesses in GP */
 #define GFX_READ_ROUTINES  1
 
 #include "gfx_rtns.h"
@@ -85,17 +85,17 @@
 #include "gfx_regs.h"
 #include "gfx_defs.h"
 
-unsigned char *gfx_virt_regptr = (unsigned char *)0x40000000;
-unsigned char *gfx_virt_fbptr = (unsigned char *)0x40800000;
-unsigned char *gfx_virt_vidptr = (unsigned char *)0x40010000;
-unsigned char *gfx_virt_vipptr = (unsigned char *)0x40015000;
-unsigned char *gfx_virt_spptr = (unsigned char *)0x40000000;
-unsigned char *gfx_virt_gpptr = (unsigned char *)0x40000000;
+unsigned char *gfx_virt_regptr = (unsigned char *) 0x40000000;
+unsigned char *gfx_virt_fbptr = (unsigned char *) 0x40800000;
+unsigned char *gfx_virt_vidptr = (unsigned char *) 0x40010000;
+unsigned char *gfx_virt_vipptr = (unsigned char *) 0x40015000;
+unsigned char *gfx_virt_spptr = (unsigned char *) 0x40000000;
+unsigned char *gfx_virt_gpptr = (unsigned char *) 0x40000000;
 
-unsigned char *gfx_phys_regptr = (unsigned char *)0x40000000;
-unsigned char *gfx_phys_fbptr = (unsigned char *)0x40800000;
-unsigned char *gfx_phys_vidptr = (unsigned char *)0x40010000;
-unsigned char *gfx_phys_vipptr = (unsigned char *)0x40015000;
+unsigned char *gfx_phys_regptr = (unsigned char *) 0x40000000;
+unsigned char *gfx_phys_fbptr = (unsigned char *) 0x40800000;
+unsigned char *gfx_phys_vidptr = (unsigned char *) 0x40010000;
+unsigned char *gfx_phys_vipptr = (unsigned char *) 0x40015000;
 
 #define INB(port) inb(port)
 #define INW(port) inw(port)
@@ -186,15 +186,15 @@ extern int GeodeReadMSR(unsigned long, unsigned long *, unsigned long *);
 
 void
 gfx_msr_asm_write(unsigned short reg, unsigned long addr,
-    unsigned long *hi, unsigned long *lo)
+                  unsigned long *hi, unsigned long *lo)
 {
     static int msr_method = 0;
 
     if (msr_method == 0) {
-	if (!GeodeWriteMSR(addr | reg, *lo, *hi))
-	    return;
+        if (!GeodeWriteMSR(addr | reg, *lo, *hi))
+            return;
 
-	msr_method = 1;
+        msr_method = 1;
     }
 
     /* This is the fallback VSA method - not preferred */
@@ -203,16 +203,16 @@ gfx_msr_asm_write(unsigned short reg, unsigned long addr,
 
 void
 gfx_msr_asm_read(unsigned short reg, unsigned long addr,
-    unsigned long *hi, unsigned long *lo)
+                 unsigned long *hi, unsigned long *lo)
 {
     static int msr_method = 0;
 
     if (msr_method == 0) {
-	if (!GeodeReadMSR(addr | reg, lo, hi))
-	    return;
+        if (!GeodeReadMSR(addr | reg, lo, hi))
+            return;
 
-	ErrorF("Unable to read the MSR - reverting to the VSA method.\n");
-	msr_method = 1;
+        ErrorF("Unable to read the MSR - reverting to the VSA method.\n");
+        msr_method = 1;
     }
 
     /* This is the fallback VSA method - not preferred */
diff --git a/src/geode.h b/src/geode.h
index ebf8abb..4a86b38 100644
--- a/src/geode.h
+++ b/src/geode.h
@@ -74,7 +74,7 @@
 #ifdef HAVE_GX
 #define GX_FILL_RECT_SUPPORT 1
 #define GX_BRES_LINE_SUPPORT 1
-#define GX_DASH_LINE_SUPPORT 0	       /* does not do dashed lines */
+#define GX_DASH_LINE_SUPPORT 0  /* does not do dashed lines */
 #define GX_MONO_8X8_PAT_SUPPORT 1
 #define GX_CLREXP_8X8_PAT_SUPPORT 1
 #define GX_SCR2SCREXP_SUPPORT 1
@@ -116,8 +116,7 @@ extern void cim_outd(unsigned short port, unsigned long data);
 
 #include "cim_rtns.h"
 
-typedef struct _CIM_DISPLAYTIMING
-{
+typedef struct _CIM_DISPLAYTIMING {
     unsigned short wPitch;
     unsigned short wBpp;
     VG_DISPLAY_MODE vgDisplayMode;
@@ -145,8 +144,7 @@ extern void gfx_outd(unsigned short port, unsigned long data);
 #undef Q_WORD
 #include "panel.h"
 
-typedef struct tag_GFX_DISPLAYTIMING
-{
+typedef struct tag_GFX_DISPLAYTIMING {
     unsigned int dwDotClock;
     unsigned short wPitch;
     unsigned short wBpp;
@@ -167,13 +165,11 @@ typedef struct tag_GFX_DISPLAYTIMING
 
 #endif
 
-typedef struct _VESARec
-{
+typedef struct _VESARec {
     xf86Int10InfoPtr pInt;
 } VESARec;
 
-typedef struct _GeodeMemRec
-{
+typedef struct _GeodeMemRec {
     struct _GeodeMemRec *next;
     struct _GeodeMemRec *prev;
     unsigned int offset;
@@ -186,14 +182,13 @@ typedef struct _GeodeMemRec
 #define OUTPUT_VOP   0x08
 #define OUTPUT_DCON  0x10
 
-typedef struct _geodeRec
-{
+typedef struct _geodeRec {
     /* Common for both GX and LX */
-    int Output;			       /* Bitmask indicating the valid output options */
+    int Output;                 /* Bitmask indicating the valid output options */
     Bool HWCursor;
     Bool NoAccel;
     Bool useVGA;
-    Bool VGAActive;		       /* Flag indicating if LX VGA is active */
+    Bool VGAActive;             /* Flag indicating if LX VGA is active */
     Bool Compression;
     Bool useEXA;
 
@@ -203,12 +198,12 @@ typedef struct _geodeRec
     Bool tryCompression;
     Bool tryHWCursor;
 
-    int mm_width, mm_height;           /* physical display size */
+    int mm_width, mm_height;    /* physical display size */
 
     unsigned long CursorStartOffset;
 
-    int Pitch;			       /* display FB pitch */
-    int displaySize;		       /* The size of the visibile area */
+    int Pitch;                  /* display FB pitch */
+    int displaySize;            /* The size of the visibile area */
 
     ExaOffscreenArea *shadowArea;
 
@@ -226,7 +221,7 @@ typedef struct _geodeRec
     /* Other structures */
 
     EntityInfoPtr pEnt;
-    ScreenBlockHandlerProcPtr BlockHandler;	/* needed for video */
+    ScreenBlockHandlerProcPtr BlockHandler;     /* needed for video */
     XF86VideoAdaptorPtr adaptor;
 
     /* State save structures */
@@ -247,14 +242,14 @@ typedef struct _geodeRec
 
     void (*PointerMoved) (int index, int x, int y);
     CloseScreenProcPtr CloseScreen;
-        Bool(*CreateScreenResources) (ScreenPtr);
+    Bool (*CreateScreenResources) (ScreenPtr);
 
     /* ===== LX specific items ===== */
 
     /* Flags */
     Bool Scale;
 
-    DisplayModePtr panelMode;	       /* The mode for the panel (if attached) */
+    DisplayModePtr panelMode;   /* The mode for the panel (if attached) */
 
     /* Command buffer information */
     unsigned long CmdBfrOffset;
@@ -278,8 +273,8 @@ typedef struct _geodeRec
     int PanelX;
     int PanelY;
 
-    int displayPitch;		       /* The pitch ofthe visible area */
-    int displayOffset;		       /* The offset of the visible area */
+    int displayPitch;           /* The pitch ofthe visible area */
+    int displayOffset;          /* The offset of the visible area */
 
     DisplayModePtr curMode;
 
@@ -314,8 +309,8 @@ typedef struct _geodeRec
 
     /* Hooks */
     void (*WritePixmap) (ScrnInfoPtr pScrni, int x, int y, int w, int h,
-	unsigned char *src, int srcwidth, int rop,
-	unsigned int planemask, int trans, int bpp, int depth);
+                         unsigned char *src, int srcwidth, int rop,
+                         unsigned int planemask, int trans, int bpp, int depth);
 
     /* Video information */
     int video_x;
@@ -330,13 +325,11 @@ typedef struct _geodeRec
     int video_offset;
     ScrnInfoPtr video_scrnptr;
     BOOL OverlayON;
-}
-GeodeRec, *GeodePtr;
+} GeodeRec, *GeodePtr;
 
 /* option flags are self-explanatory */
 #ifdef HAVE_LX
-enum
-{
+enum {
     LX_OPTION_SW_CURSOR,
     LX_OPTION_HW_CURSOR,
     LX_OPTION_NOCOMPRESSION,
@@ -350,13 +343,11 @@ enum
     LX_OPTION_FBSIZE,
     LX_OPTION_PANEL_MODE,
     LX_OPTION_DONT_PROGRAM
-}
-LX_GeodeOpts;
+} LX_GeodeOpts;
 #endif
 
 #ifdef HAVE_GX
-enum
-{
+enum {
     GX_OPTION_SW_CURSOR,
     GX_OPTION_HW_CURSOR,
     GX_OPTION_NOCOMPRESSION,
@@ -373,8 +364,7 @@ enum
     GX_OPTION_FBSIZE,
     GX_OPTION_PANEL_GEOMETRY,
     GX_OPTION_DONT_PROGRAM
-}
-GX_GeodeOpts;
+} GX_GeodeOpts;
 #endif
 
 /* geode_dcon.c */
@@ -384,7 +374,7 @@ extern int DCONDPMSSet(ScrnInfoPtr pScrni, int mode);
 /* geode_common.c */
 
 void geode_memory_to_screen_blt(unsigned long, unsigned long,
-    unsigned long, unsigned long, long, long, int);
+                                unsigned long, unsigned long, long, long, int);
 int GeodeGetRefreshRate(DisplayModePtr);
 void GeodeCopyGreyscale(unsigned char *, unsigned char *, int, int, int, int);
 int GeodeGetSizeFromFB(unsigned int *);
@@ -392,8 +382,9 @@ int GeodeGetSizeFromFB(unsigned int *);
 /* gx_video.c */
 
 int
+
 GeodeQueryImageAttributes(ScrnInfoPtr, int id, unsigned short *w,
-    unsigned short *h, int *pitches, int *offsets);
+                          unsigned short *h, int *pitches, int *offsets);
 
 Bool RegionsEqual(RegionPtr A, RegionPtr B);
 
@@ -423,7 +414,7 @@ void GXShowCursor(ScrnInfoPtr pScrni);
 Rotation GXGetRotation(ScreenPtr pScreen);
 Bool GXRandRInit(ScreenPtr pScreen, int rotation);
 extern _X_EXPORT Bool GXRandRSetConfig(ScreenPtr pScreen, Rotation rotation,
-				       int rate, RRScreenSizePtr pSize);
+                                       int rate, RRScreenSizePtr pSize);
 
 /* gx_rotate.c */
 Bool GXRotate(ScrnInfoPtr pScrni, DisplayModePtr mode);
diff --git a/src/geode_common.c b/src/geode_common.c
index 2e02af1..7d85592 100644
--- a/src/geode_common.c
+++ b/src/geode_common.c
@@ -30,7 +30,7 @@
 #include "config.h"
 #endif
 
-#include <string.h>		       /* memcmp() */
+#include <string.h>             /* memcmp() */
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -74,7 +74,8 @@
 
 void
 geode_memory_to_screen_blt(unsigned long src, unsigned long dst,
-    unsigned long sp, unsigned long dp, long w, long h, int bpp)
+                           unsigned long sp, unsigned long dp, long w, long h,
+                           int bpp)
 {
     int d0, d1, d2;
     int n = w * (bpp >> 3);
@@ -82,33 +83,33 @@ geode_memory_to_screen_blt(unsigned long src, unsigned long dst,
 
     switch (n & 3) {
     case 0:
-	while (--h >= 0) {
-	    move0(dst, src, m);
-	    src += sp;
-	    dst += dp;
-	}
-	break;
+        while (--h >= 0) {
+            move0(dst, src, m);
+            src += sp;
+            dst += dp;
+        }
+        break;
     case 1:
-	while (--h >= 0) {
-	    move1(dst, src, m);
-	    src += sp;
-	    dst += dp;
-	}
-	break;
+        while (--h >= 0) {
+            move1(dst, src, m);
+            src += sp;
+            dst += dp;
+        }
+        break;
     case 2:
-	while (--h >= 0) {
-	    move2(dst, src, m);
-	    src += sp;
-	    dst += dp;
-	}
-	break;
+        while (--h >= 0) {
+            move2(dst, src, m);
+            src += sp;
+            dst += dp;
+        }
+        break;
     case 3:
-	while (--h >= 0) {
-	    move3(dst, src, m);
-	    src += sp;
-	    dst += dp;
-	}
-	break;
+        while (--h >= 0) {
+            move3(dst, src, m);
+            src += sp;
+            dst += dp;
+        }
+        break;
     }
 }
 
@@ -120,9 +121,9 @@ int
 GeodeGetRefreshRate(DisplayModePtr pMode)
 {
     if (pMode->VRefresh)
-	return (int)(pMode->VRefresh + 0.5);
+        return (int) (pMode->VRefresh + 0.5);
 
-    return (int)(pMode->Clock * 1000.0 / pMode->HTotal / pMode->VTotal + 0.5);
+    return (int) (pMode->Clock * 1000.0 / pMode->HTotal / pMode->VTotal + 0.5);
 }
 
 /* This is used by both GX and LX.  It could be accelerated for LX, probably, but
@@ -133,7 +134,7 @@ GeodeGetRefreshRate(DisplayModePtr pMode)
 
 void
 GeodeCopyGreyscale(unsigned char *src, unsigned char *dst,
-    int dstPitch, int srcPitch, int h, int w)
+                   int dstPitch, int srcPitch, int h, int w)
 {
     int i;
     unsigned char *src2 = src;
@@ -144,21 +145,21 @@ GeodeCopyGreyscale(unsigned char *src, unsigned char *dst,
     dstPitch <<= 1;
 
     while (h--) {
-	dst3 = dst2;
-	src3 = src2;
-	for (i = 0; i < w; i++) {
-	    *dst3++ = *src3++;	       /* Copy Y data */
-	    *dst3++ = 0x80;	       /* Fill UV with 0x80 - greyscale */
-	}
-
-	src3 = src2;
-	for (i = 0; i < w; i++) {
-	    *dst3++ = *src3++;	       /* Copy Y data */
-	    *dst3++ = 0x80;	       /* Fill UV with 0x80 - greyscale */
-	}
-
-	dst2 += dstPitch;
-	src2 += srcPitch;
+        dst3 = dst2;
+        src3 = src2;
+        for (i = 0; i < w; i++) {
+            *dst3++ = *src3++;  /* Copy Y data */
+            *dst3++ = 0x80;     /* Fill UV with 0x80 - greyscale */
+        }
+
+        src3 = src2;
+        for (i = 0; i < w; i++) {
+            *dst3++ = *src3++;  /* Copy Y data */
+            *dst3++ = 0x80;     /* Fill UV with 0x80 - greyscale */
+        }
+
+        dst2 += dstPitch;
+        src2 += srcPitch;
     }
 }
 
@@ -174,16 +175,16 @@ GeodeGetSizeFromFB(unsigned int *size)
     int fd = open("/dev/fb0", O_RDONLY);
 
     if (fd == -1)
-	return -1;
+        return -1;
 
     ret = ioctl(fd, FBIOGET_FSCREENINFO, &fix);
     close(fd);
 
     if (!ret) {
-	if (!memcmp(fix.id, "Geode", 5)) {
-	    *size = fix.smem_len;
-	    return 0;
-	}
+        if (!memcmp(fix.id, "Geode", 5)) {
+            *size = fix.smem_len;
+            return 0;
+        }
     }
 
     return -1;
diff --git a/src/geode_dcon.c b/src/geode_dcon.c
index 9009293..5580c96 100644
--- a/src/geode_dcon.c
+++ b/src/geode_dcon.c
@@ -45,7 +45,7 @@ dcon_present(void)
     static int _dval = -1;
 
     if (_dval == -1)
-	_dval = (access("/sys/class/power_supply/olpc-ac", F_OK) == 0);
+        _dval = (access("/sys/class/power_supply/olpc-ac", F_OK) == 0);
 
     return (Bool) _dval;
 }
@@ -59,10 +59,10 @@ DCONDPMSSet(ScrnInfoPtr pScrni, int mode)
     char value[1];
 
     if (failed == -1)
-	failed = !dcon_present();
+        failed = !dcon_present();
 
     if (failed)
-	return 0;
+        return 0;
 
     /* If the DCON is frozen, don't power it down, it was probably frozen
      * for a reason and powering it down would corrupt the display.
@@ -72,41 +72,41 @@ DCONDPMSSet(ScrnInfoPtr pScrni, int mode)
      * that no mode change is needed and the display power is untouched. */
     fd = open(DCON_FREEZE_FILE, O_RDONLY);
     if (fd < 0) {
-	failed = 1;
-	return 0;
+        failed = 1;
+        return 0;
     }
 
     ret = read(fd, value, 1);
     close(fd);
     if (ret == 1) {
-	if (value[0] == '1')
-	    return 0;
+        if (value[0] == '1')
+            return 0;
     }
 
     fd = open(DCON_SLEEP_FILE, O_WRONLY);
 
     if (fd < 0) {
-	failed = 1;
-	return 0;
+        failed = 1;
+        return 0;
     }
 
     switch (mode) {
     case DPMSModeOn:
-	value[0] = '0';
-	break;
+        value[0] = '0';
+        break;
     case DPMSModeStandby:
     case DPMSModeSuspend:
     case DPMSModeOff:
-	value[0] = '1';
-	break;
+        value[0] = '1';
+        break;
     }
 
     ret = write(fd, value, sizeof(value));
     close(fd);
 
     if (ret < 0) {
-	failed = 1;
-	return 0;
+        failed = 1;
+        return 0;
     }
 
     return 1;
@@ -121,17 +121,17 @@ dcon_init(ScrnInfoPtr pScrni)
     pGeode->mm_height = 0;
 
     if (!dcon_present()) {
-	xf86DrvMsg(pScrni->scrnIndex, X_DEFAULT, "No DCON is present\n");
-	return FALSE;
+        xf86DrvMsg(pScrni->scrnIndex, X_DEFAULT, "No DCON is present\n");
+        return FALSE;
     }
 
     pGeode->panelMode = xnfcalloc(1, sizeof(DisplayModeRec));
     if (pGeode->panelMode == NULL)
-	return FALSE;
+        return FALSE;
 
     /* Set up the panel mode structure automagically */
 
-    pGeode->panelMode->type = M_T_DRIVER|M_T_PREFERRED;
+    pGeode->panelMode->type = M_T_DRIVER | M_T_PREFERRED;
     pGeode->panelMode->Clock = 57275;
     pGeode->panelMode->HDisplay = 1200;
     pGeode->panelMode->HSyncStart = 1208;
diff --git a/src/geode_ddc.c b/src/geode_ddc.c
index 4691d12..8f1c605 100644
--- a/src/geode_ddc.c
+++ b/src/geode_ddc.c
@@ -70,13 +70,13 @@ geode_gpio_iobase(void)
     pci = pci_device_find_by_slot(0, 0, 0xF, 0x0);
 
     if (pci == NULL)
-	return 0;
+        return 0;
 
     if (pci_device_probe(pci) != 0)
         return 0;
 
     /* The GPIO I/O address is in resource 1 */
-    return (unsigned short)pci->regions[1].base_addr;
+    return (unsigned short) pci->regions[1].base_addr;
 #else
     PCITAG Tag;
 
@@ -86,18 +86,18 @@ geode_gpio_iobase(void)
         Tag = pciFindFirst(CS5535_ISA_DEVICE, 0xFFFFFFFF);
 
         if (Tag == PCI_NOT_FOUND)
-	    return 0;
+            return 0;
     }
 
     /* The GPIO I/O address is in resource 1 */
-    return (unsigned short)(pciReadLong(Tag, 0x14) & ~1);
+    return (unsigned short) (pciReadLong(Tag, 0x14) & ~1);
 #endif
 }
 
 static void
 geode_ddc_putbits(I2CBusPtr b, int scl, int sda)
 {
-    unsigned long iobase = (unsigned long)b->DriverPrivate.ptr;
+    unsigned long iobase = (unsigned long) b->DriverPrivate.ptr;
     unsigned long dat;
 
     dat = scl ? DDC_CLK_HIGH : DDC_CLK_LOW;
@@ -109,7 +109,7 @@ geode_ddc_putbits(I2CBusPtr b, int scl, int sda)
 static void
 geode_ddc_getbits(I2CBusPtr b, int *scl, int *sda)
 {
-    unsigned long iobase = (unsigned long)b->DriverPrivate.ptr;
+    unsigned long iobase = (unsigned long) b->DriverPrivate.ptr;
     unsigned long dat = inl(iobase + GPIO_IN);
 
     *scl = (dat & DDC_CLK_HIGH) ? 1 : 0;
@@ -125,9 +125,9 @@ GeodeI2CInit(ScrnInfoPtr pScrni, I2CBusPtr * ptr, char *name)
     ddciobase = geode_gpio_iobase();
 
     if (ddciobase == 0) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "Could not find the GPIO I/O base\n");
-	return FALSE;
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "Could not find the GPIO I/O base\n");
+        return FALSE;
     }
 
     /* The GPIO pins for DDC are multiplexed with a
@@ -136,10 +136,10 @@ GeodeI2CInit(ScrnInfoPtr pScrni, I2CBusPtr * ptr, char *name)
      */
 
     if ((inl(ddciobase + GPIO_IN_AUX1) & DDC_CLK_HIGH) ||
-	(inl(ddciobase + GPIO_OUT_AUX1) & DDC_DATA_HIGH)) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "GPIO pins are in serial mode.  Assuming no DDC\n");
-	return FALSE;
+        (inl(ddciobase + GPIO_OUT_AUX1) & DDC_DATA_HIGH)) {
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "GPIO pins are in serial mode.  Assuming no DDC\n");
+        return FALSE;
     }
 
     outl(ddciobase + GPIO_OUT_ENABLE, DDC_DATA_HIGH | DDC_CLK_HIGH);
@@ -148,17 +148,17 @@ GeodeI2CInit(ScrnInfoPtr pScrni, I2CBusPtr * ptr, char *name)
     bus = xf86CreateI2CBusRec();
 
     if (!bus)
-	return FALSE;
+        return FALSE;
 
     bus->BusName = name;
     bus->scrnIndex = pScrni->scrnIndex;
 
     bus->I2CGetBits = geode_ddc_getbits;
     bus->I2CPutBits = geode_ddc_putbits;
-    bus->DriverPrivate.ptr = (void *)(unsigned long)(ddciobase);
+    bus->DriverPrivate.ptr = (void *) (unsigned long) (ddciobase);
 
     if (!xf86I2CBusInit(bus))
-	return FALSE;
+        return FALSE;
 
     *ptr = bus;
     return TRUE;
@@ -171,13 +171,13 @@ GeodeGetDDC(ScrnInfoPtr pScrni)
     I2CBusPtr bus;
 
     if (!GeodeI2CInit(pScrni, &bus, "CS5536 DDC BUS"))
-	return NULL;
+        return NULL;
 
     mon = xf86DoEDID_DDC2(pScrni->scrnIndex, bus);
 
 #if (XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,4,99,0,0))
     if (mon)
-	xf86DDCApplyQuirks(pScrni->scrnIndex, mon);
+        xf86DDCApplyQuirks(pScrni->scrnIndex, mon);
 #endif
 
     xf86DestroyI2CBusRec(bus, FALSE, FALSE);
diff --git a/src/geode_driver.c b/src/geode_driver.c
index ff12fee..a8cc944 100644
--- a/src/geode_driver.c
+++ b/src/geode_driver.c
@@ -74,7 +74,7 @@
 #include <X11/extensions/dpms.h>
 #endif
 
-#endif /* DPMSExtension */
+#endif                          /* DPMSExtension */
 
 /* A few things all drivers should have */
 #define GEODE_NAME        "GEODE"
@@ -97,12 +97,12 @@ static Bool AmdProbe(DriverPtr, int);
 #ifdef XSERVER_LIBPCIACCESS
 static const struct pci_id_match amdDeviceMatch[] = {
     {PCI_VENDOR_ID_NS, PCI_CHIP_GEODEGX, PCI_MATCH_ANY, PCI_MATCH_ANY, 0, 0,
-	0},
+     0},
     {PCI_VENDOR_ID_AMD, PCI_CHIP_GEODELX, PCI_MATCH_ANY, PCI_MATCH_ANY, 0, 0,
-	0},
+     0},
     {0, 0, 0}
 };
-#endif /* XSERVER_LIBPCIACCESS */
+#endif                          /* XSERVER_LIBPCIACCESS */
 
 /* driver record contains the functions needed by the server after loading
  * the driver module.
@@ -146,12 +146,10 @@ _X_EXPORT DriverRec GEODE = {
 };
 
 /* Advanced Micro Devices Chip Models */
-typedef struct _DEVICE_MODEL
-{
+typedef struct _DEVICE_MODEL {
     int DeviceId;
     int Model;
-}
-DeviceModel;
+} DeviceModel;
 
 DeviceModel ChipModel[] = {
 #ifdef HAVE_LX
@@ -242,7 +240,7 @@ static XF86ModuleVersionInfo AmdVersionRec = {
     MODINFOSTRING2,
     XORG_VERSION_CURRENT,
     GEODE_VERSION_MAJOR, GEODE_VERSION_MINOR, GEODE_VERSION_PATCH,
-    ABI_CLASS_VIDEODRV,		       /* This is a video driver */
+    ABI_CLASS_VIDEODRV,         /* This is a video driver */
     ABI_VIDEODRV_VERSION,
     MOD_CLASS_VIDEODRV,
     {0, 0, 0, 0}
@@ -255,7 +253,7 @@ static XF86ModuleVersionInfo GeodeVersionRec = {
     MODINFOSTRING2,
     XORG_VERSION_CURRENT,
     GEODE_VERSION_MAJOR, GEODE_VERSION_MINOR, GEODE_VERSION_PATCH,
-    ABI_CLASS_VIDEODRV,		       /* This is a video driver */
+    ABI_CLASS_VIDEODRV,         /* This is a video driver */
     ABI_VIDEODRV_VERSION,
     MOD_CLASS_VIDEODRV,
     {0, 0, 0, 0}
@@ -271,8 +269,8 @@ GeodeSetup(pointer Module, pointer Options, int *ErrorMajor, int *ErrorMinor)
     flag = HaveDriverFuncs;
 #endif
     if (init) {
-	*ErrorMajor = LDR_ONCEONLY;
-	return (pointer) NULL;
+        *ErrorMajor = LDR_ONCEONLY;
+        return (pointer) NULL;
     }
 
     init = TRUE;
@@ -287,21 +285,21 @@ AmdSetup(pointer Module, pointer Options, int *ErrorMajor, int *ErrorMinor)
     static Bool Initialised = FALSE;
 
     if (!Initialised) {
-	Initialised = TRUE;
-	xf86AddDriver(&AMD, Module,
+        Initialised = TRUE;
+        xf86AddDriver(&AMD, Module,
 #ifdef XSERVER_LIBPCIACCESS
-	    HaveDriverFuncs
+                      HaveDriverFuncs
 #else
-	    0
+                      0
 #endif
-	    );
+            );
 
-	return (pointer) TRUE;
+        return (pointer) TRUE;
     }
 
     /*The return value must be non-NULL on success */
     if (ErrorMajor)
-	*ErrorMajor = LDR_ONCEONLY;
+        *ErrorMajor = LDR_ONCEONLY;
     return NULL;
 }
 
@@ -309,7 +307,7 @@ _X_EXPORT XF86ModuleData amdModuleData = { &AmdVersionRec, AmdSetup, NULL };
 _X_EXPORT XF86ModuleData geodeModuleData =
     { &GeodeVersionRec, GeodeSetup, NULL };
 
-#endif /*End of XFree86Loader */
+#endif                          /*End of XFree86Loader */
 
 /*-------------------------------------------------------------------------
  * AmdIdentify.
@@ -330,7 +328,7 @@ static void
 AmdIdentify(int flags)
 {
     xf86PrintChipsets(GEODE_NAME, "Driver for AMD Geode Chipsets",
-	GeodeChipsets);
+                      GeodeChipsets);
 }
 
 /*----------------------------------------------------------------------------
@@ -354,11 +352,11 @@ AmdAvailableOptions(int chipid, int busid)
     switch (chipid) {
 #ifdef HAVE_LX
     case PCI_CHIP_GEODELX:
-	return LX_GeodeOptions;
+        return LX_GeodeOptions;
 #endif
 #ifdef HAVE_GX
     case PCI_CHIP_GEODEGX:
-	return GX_GeodeOptions;
+        return GX_GeodeOptions;
 #endif
     }
     return no_GeodeOptions;
@@ -368,7 +366,7 @@ AmdAvailableOptions(int chipid, int busid)
 
 static Bool
 AmdPciProbe(DriverPtr driver,
-    int entity_num, struct pci_device *device, intptr_t match_data)
+            int entity_num, struct pci_device *device, intptr_t match_data)
 {
     ScrnInfoPtr scrn = NULL;
     int cpu_detected;
@@ -376,39 +374,39 @@ AmdPciProbe(DriverPtr driver,
     ErrorF("AmdPciProbe: Probing for supported devices!\n");
 
     scrn = xf86ConfigPciEntity(scrn, 0, entity_num, GeodePCIchipsets,
-	NULL, NULL, NULL, NULL, NULL);
+                               NULL, NULL, NULL, NULL, NULL);
 
     if (scrn != NULL) {
-	scrn->driverName = GEODE_DRIVER_NAME;
-	scrn->driverVersion = GEODE_VERSION;
-	scrn->name = GEODE_NAME;
-	scrn->Probe = NULL;
+        scrn->driverName = GEODE_DRIVER_NAME;
+        scrn->driverVersion = GEODE_VERSION;
+        scrn->name = GEODE_NAME;
+        scrn->Probe = NULL;
 
-	switch (device->device_id) {
+        switch (device->device_id) {
 #ifdef HAVE_LX
-	case PCI_CHIP_GEODELX:
-	    cpu_detected = LX;
-	    LXSetupChipsetFPtr(scrn);
-	    break;
+        case PCI_CHIP_GEODELX:
+            cpu_detected = LX;
+            LXSetupChipsetFPtr(scrn);
+            break;
 #endif
 #ifdef HAVE_GX
-	case PCI_CHIP_GEODEGX:
-	    cpu_detected = GX;
-	    GXSetupChipsetFPtr(scrn);
-	    break;
+        case PCI_CHIP_GEODEGX:
+            cpu_detected = GX;
+            GXSetupChipsetFPtr(scrn);
+            break;
 #endif
-	default:
-	    ErrorF("AmdPciProbe: unknown device ID\n");
-	    return FALSE;
-	}
+        default:
+            ErrorF("AmdPciProbe: unknown device ID\n");
+            return FALSE;
+        }
 
-	DEBUGMSG(1, (0, X_INFO, "AmdPciProbe: CPUDetected %d!\n",
-		cpu_detected));
+        DEBUGMSG(1, (0, X_INFO, "AmdPciProbe: CPUDetected %d!\n",
+                     cpu_detected));
     }
     return scrn != NULL;
 }
 
-#else /* XSERVER_LIBPCIACCESS */
+#else                           /* XSERVER_LIBPCIACCESS */
 
 /*----------------------------------------------------------------------------
  * AmdProbe.
@@ -446,85 +444,88 @@ AmdProbe(DriverPtr drv, int flags)
      * * driver, and return if there are none.
      */
     if ((numDevSections = xf86MatchDevice(GEODE_NAME, &devSections)) <= 0) {
-	DEBUGMSG(1, (0, X_INFO, "AmdProbe: failed 1!\n"));
-	return FALSE;
+        DEBUGMSG(1, (0, X_INFO, "AmdProbe: failed 1!\n"));
+        return FALSE;
     }
     DEBUGMSG(1, (0, X_INFO, "AmdProbe: Before MatchPciInstances!\n"));
     /* PCI BUS */
     if (xf86GetPciVideoInfo()) {
-	numUsed = xf86MatchPciInstances(GEODE_NAME, PCI_VENDOR_ID_NS,
-	    GeodeChipsets, GeodePCIchipsets,
-	    devSections, numDevSections, drv, &usedChips);
-
-	if (numUsed <= 0)
-	    numUsed = xf86MatchPciInstances(GEODE_NAME, PCI_VENDOR_ID_AMD,
-		GeodeChipsets, GeodePCIchipsets,
-		devSections, numDevSections, drv, &usedChips);
-
-	DEBUGMSG(1, (0, X_INFO, "AmdProbe: MatchPCI (%d)!\n", numUsed));
-
-	if (numUsed > 0) {
-	    if (flags & PROBE_DETECT)
-		foundScreen = TRUE;
-	    else {
-		/* Durango only supports one instance, */
-		/* so take the first one */
-		for (i = 0; i < numUsed; i++) {
-		    /* Allocate a ScrnInfoRec  */
-		    ScrnInfoPtr pScrni = NULL;
-		    EntityInfoPtr pEnt = xf86GetEntityInfo(usedChips[i]);
-		    PciChipsets *p_id;
-
-		    pScrni = xf86ConfigPciEntity(pScrni, 0, usedChips[i],
-						 GeodePCIchipsets, NULL, NULL, NULL, NULL, NULL);
-		    for (p_id = GeodePCIchipsets; p_id->numChipset != -1;
-			p_id++) {
-			if (pEnt->chipset == p_id->numChipset) {
-			    switch (pEnt->chipset) {
+        numUsed = xf86MatchPciInstances(GEODE_NAME, PCI_VENDOR_ID_NS,
+                                        GeodeChipsets, GeodePCIchipsets,
+                                        devSections, numDevSections, drv,
+                                        &usedChips);
+
+        if (numUsed <= 0)
+            numUsed = xf86MatchPciInstances(GEODE_NAME, PCI_VENDOR_ID_AMD,
+                                            GeodeChipsets, GeodePCIchipsets,
+                                            devSections, numDevSections, drv,
+                                            &usedChips);
+
+        DEBUGMSG(1, (0, X_INFO, "AmdProbe: MatchPCI (%d)!\n", numUsed));
+
+        if (numUsed > 0) {
+            if (flags & PROBE_DETECT)
+                foundScreen = TRUE;
+            else {
+                /* Durango only supports one instance, */
+                /* so take the first one */
+                for (i = 0; i < numUsed; i++) {
+                    /* Allocate a ScrnInfoRec  */
+                    ScrnInfoPtr pScrni = NULL;
+                    EntityInfoPtr pEnt = xf86GetEntityInfo(usedChips[i]);
+                    PciChipsets *p_id;
+
+                    pScrni = xf86ConfigPciEntity(pScrni, 0, usedChips[i],
+                                                 GeodePCIchipsets, NULL, NULL,
+                                                 NULL, NULL, NULL);
+                    for (p_id = GeodePCIchipsets; p_id->numChipset != -1;
+                         p_id++) {
+                        if (pEnt->chipset == p_id->numChipset) {
+                            switch (pEnt->chipset) {
 #ifdef HAVE_LX
-			    case PCI_CHIP_GEODELX:
-				CPUDetected = LX;
-				drvr_setup = &LXSetupChipsetFPtr;
-				break;
+                            case PCI_CHIP_GEODELX:
+                                CPUDetected = LX;
+                                drvr_setup = &LXSetupChipsetFPtr;
+                                break;
 #endif
 #ifdef HAVE_GX
-			    case PCI_CHIP_GEODEGX:
-				CPUDetected = GX;
-				drvr_setup = &GXSetupChipsetFPtr;
-				break;
+                            case PCI_CHIP_GEODEGX:
+                                CPUDetected = GX;
+                                drvr_setup = &GXSetupChipsetFPtr;
+                                break;
 #endif
-			    default:
-				break;
-			    }
-			    break;
-			}
-		    }
-		    free(pEnt);
-		    if (drvr_setup == NULL)
-			return FALSE;
-
-		    DEBUGMSG(1, (0, X_INFO, "AmdProbe: CPUDetected %d!\n",
-			    CPUDetected));
-
-		    pScrni->driverName = GEODE_DRIVER_NAME;
-		    pScrni->driverVersion = GEODE_VERSION;
-		    pScrni->name = GEODE_NAME;
-		    pScrni->Probe = AmdProbe;
-		    drvr_setup(pScrni);
-
-		    foundScreen = TRUE;
-
-		}
-	    }
-	}
+                            default:
+                                break;
+                            }
+                            break;
+                        }
+                    }
+                    free(pEnt);
+                    if (drvr_setup == NULL)
+                        return FALSE;
+
+                    DEBUGMSG(1, (0, X_INFO, "AmdProbe: CPUDetected %d!\n",
+                                 CPUDetected));
+
+                    pScrni->driverName = GEODE_DRIVER_NAME;
+                    pScrni->driverVersion = GEODE_VERSION;
+                    pScrni->name = GEODE_NAME;
+                    pScrni->Probe = AmdProbe;
+                    drvr_setup(pScrni);
+
+                    foundScreen = TRUE;
+
+                }
+            }
+        }
     }
 
     if (usedChips)
-	free(usedChips);
+        free(usedChips);
     if (devSections)
-	free(devSections);
+        free(devSections);
     DEBUGMSG(1, (0, X_INFO, "AmdProbe: result (%d)!\n", foundScreen));
     return foundScreen;
 }
 
-#endif /* else XSERVER_LIBPCIACCESS */
+#endif                          /* else XSERVER_LIBPCIACCESS */
diff --git a/src/geode_msr.c b/src/geode_msr.c
index 26fd78f..d3a72c4 100644
--- a/src/geode_msr.c
+++ b/src/geode_msr.c
@@ -16,9 +16,9 @@ _msr_open(void)
     static int msrfd = 0;
 
     if (msrfd == 0) {
-	msrfd = open("/dev/cpu/0/msr", O_RDWR);
-	if (msrfd == -1)
-	    ErrorF("Unable to open /dev/cpu/0/msr: %d\n", errno);
+        msrfd = open("/dev/cpu/0/msr", O_RDWR);
+        if (msrfd == -1)
+            ErrorF("Unable to open /dev/cpu/0/msr: %d\n", errno);
     }
 
     return msrfd;
@@ -32,17 +32,17 @@ GeodeReadMSR(unsigned long addr, unsigned long *lo, unsigned long *hi)
     int ret;
 
     if (fd == -1)
-	return -1;
+        return -1;
 
     ret = lseek(fd, (off_t) addr, SEEK_SET);
 
     if (ret == -1)
-	return -1;
+        return -1;
 
-    ret = read(fd, (void *)data, sizeof(data));
+    ret = read(fd, (void *) data, sizeof(data));
 
     if (ret != 8)
-	return -1;
+        return -1;
 
     *hi = data[1];
     *lo = data[0];
@@ -57,16 +57,16 @@ GeodeWriteMSR(unsigned long addr, unsigned long lo, unsigned long hi)
     int fd = _msr_open();
 
     if (fd == -1)
-	return -1;
+        return -1;
 
     if (lseek(fd, (off_t) addr, SEEK_SET) == -1)
-	return -1;
+        return -1;
 
     data[0] = lo;
     data[1] = hi;
 
-    if (write(fd, (void *)data, 8) != 8)
-	return -1;
+    if (write(fd, (void *) data, 8) != 8)
+        return -1;
 
     return 0;
 }
diff --git a/src/geode_pcirename.h b/src/geode_pcirename.h
index 145cc01..fe4d65b 100644
--- a/src/geode_pcirename.h
+++ b/src/geode_pcirename.h
@@ -29,8 +29,7 @@
 #ifndef CIRPCIRENAME_H
 #define CIRPCIRENAME_H
 
-enum region_type
-{
+enum region_type {
     REGION_MEM,
     REGION_IO
 };
@@ -78,7 +77,7 @@ enum region_type
 #define PCI_WRITE_LONG(_pcidev, _value, _offset) \
     pciWriteLong(PCI_CFG_TAG(_pcidev), (_offset), (_value))
 
-#else /* XSERVER_LIBPCIACCESS */
+#else                           /* XSERVER_LIBPCIACCESS */
 
 typedef struct pci_device *pciVideoPtr;
 
@@ -118,6 +117,6 @@ typedef struct pci_device *pciVideoPtr;
 #define PCI_WRITE_LONG(_pcidev, _value, _offset) \
     pci_device_cfg_write_u32((_pcidev), (_value), (_offset))
 
-#endif /* XSERVER_LIBPCIACCESS */
+#endif                          /* XSERVER_LIBPCIACCESS */
 
-#endif /* CIRPCIRENAME_H */
+#endif                          /* CIRPCIRENAME_H */
diff --git a/src/gfx/disp_gu1.c b/src/gfx/disp_gu1.c
index 58e42ee..2cb1ed5 100644
--- a/src/gfx/disp_gu1.c
+++ b/src/gfx/disp_gu1.c
@@ -23,9 +23,9 @@
  * software without specific prior written permission.
  */
 
-void gu1_enable_compression(void);     /* private routine definition */
-void gu1_disable_compression(void);    /* private routine definition */
-void gfx_reset_video(void);            /* private routine definition */
+void gu1_enable_compression(void);      /* private routine definition */
+void gu1_disable_compression(void);     /* private routine definition */
+void gfx_reset_video(void);     /* private routine definition */
 int gfx_set_display_control(int sync_polarities);       /* private routine
                                                          * definition */
 int gu1_set_specified_mode(DISPLAYMODE * pMode, int bpp);
@@ -83,9 +83,9 @@ gu1_delay_precise(unsigned long milliseconds)
     else
         total_ticks = 1000 * milliseconds;      /* timer resolution is 1 MHz */
 
-    if (total_ticks > ((unsigned long)0xffffffff - timer_start))
+    if (total_ticks > ((unsigned long) 0xffffffff - timer_start))
         /* wrap-around */
-        timer_end = total_ticks - ((unsigned long)0xffffffff - timer_start);
+        timer_end = total_ticks - ((unsigned long) 0xffffffff - timer_start);
     else
         timer_end = timer_start + total_ticks;
 
@@ -110,7 +110,7 @@ gu1_delay_precise(unsigned long milliseconds)
         if (IND(SC1200_CB_BASE_ADDR + SC1200_CB_TMVALUE) > timer_end)
             break;
     }
-#endif /* GFX_VIDEO_SC1200 */
+#endif                          /* GFX_VIDEO_SC1200 */
 }
 
 /*----------------------------------------------------------------------------
@@ -152,7 +152,7 @@ gfx_delay_milliseconds(unsigned long milliseconds)
 #if GFX_VIDEO_DYNAMIC
     }
 #endif
-#endif /* GFX_VIDEO_SC1200 */
+#endif                          /* GFX_VIDEO_SC1200 */
     gu1_delay_approximate(milliseconds);
 }
 
@@ -201,7 +201,7 @@ gu1_video_shutdown(void)
     tcfg = READ_REG32(DC_TIMING_CFG);
 
     /* BLANK THE GX DISPLAY AND DISABLE THE TIMING GENERATOR */
-    tcfg &= ~((unsigned long)DC_TCFG_BLKE | (unsigned long)DC_TCFG_TGEN);
+    tcfg &= ~((unsigned long) DC_TCFG_BLKE | (unsigned long) DC_TCFG_TGEN);
     WRITE_REG32(DC_TIMING_CFG, tcfg);
 
     /* DELAY: WAIT FOR PENDING MEMORY REQUESTS */
@@ -210,7 +210,7 @@ gu1_video_shutdown(void)
     gfx_delay_milliseconds(1);
 
     /* DISABLE DISPLAY FIFO LOAD AND DISABLE COMPRESSION */
-    gcfg &= ~(unsigned long)(DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);
+    gcfg &= ~(unsigned long) (DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);
     WRITE_REG32(DC_GENERAL_CFG, gcfg);
     WRITE_REG32(DC_UNLOCK, unlock);
     return;
@@ -295,7 +295,7 @@ gu1_set_specified_mode(DISPLAYMODE * pMode, int bpp)
     tcfg = READ_REG32(DC_TIMING_CFG);
 
     /* BLANK THE GX DISPLAY AND DISABLE THE TIMING GENERATOR */
-    tcfg &= ~((unsigned long)DC_TCFG_BLKE | (unsigned long)DC_TCFG_TGEN);
+    tcfg &= ~((unsigned long) DC_TCFG_BLKE | (unsigned long) DC_TCFG_TGEN);
     WRITE_REG32(DC_TIMING_CFG, tcfg);
 
     /* DELAY: WAIT FOR PENDING MEMORY REQUESTS 
@@ -305,12 +305,12 @@ gu1_set_specified_mode(DISPLAYMODE * pMode, int bpp)
     gfx_delay_milliseconds(1);
 
     /* DISABLE DISPLAY FIFO LOAD AND DISABLE COMPRESSION */
-    gcfg &= ~(unsigned long)(DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);
+    gcfg &= ~(unsigned long) (DC_GCFG_DFLE | DC_GCFG_CMPE | DC_GCFG_DECE);
     WRITE_REG32(DC_GENERAL_CFG, gcfg);
 
     /* CLEAR THE "DCLK_MUL" FIELD */
-    gcfg &= ~(unsigned long)(DC_GCFG_DDCK | DC_GCFG_DPCK | DC_GCFG_DFCK);
-    gcfg &= ~(unsigned long)DC_GCFG_DCLK_MASK;
+    gcfg &= ~(unsigned long) (DC_GCFG_DDCK | DC_GCFG_DPCK | DC_GCFG_DFCK);
+    gcfg &= ~(unsigned long) DC_GCFG_DCLK_MASK;
     WRITE_REG32(DC_GENERAL_CFG, gcfg);
 
     /* SET THE DOT CLOCK FREQUENCY */
@@ -363,7 +363,8 @@ gu1_set_specified_mode(DISPLAYMODE * pMode, int bpp)
         /* requires a pitch of 2048.                               */
         if ((pMode->flags & GFX_MODE_LINE_DOUBLE) && bpp > 8)
             pitch <<= 1;
-    } else {
+    }
+    else {
         if (gfx_cpu_version == GFX_CPU_PYRAMID)
             pitch = (size <= 2048) ? 2048 : 4096;
         else
@@ -397,8 +398,7 @@ gu1_set_specified_mode(DISPLAYMODE * pMode, int bpp)
 
     /* SET FIFO PRIORITY, DCLK MULTIPLIER, AND FIFO ENABLE */
     /* Default 6/5 for FIFO, 2x for DCLK multiplier. */
-    gcfg =
-        (6 << DC_GCFG_DFHPEL_POS) | (5 << DC_GCFG_DFHPSL_POS) | DC_GCFG_DFLE;
+    gcfg = (6 << DC_GCFG_DFHPEL_POS) | (5 << DC_GCFG_DFHPSL_POS) | DC_GCFG_DFLE;
 
     /* INCREASE FIFO PRIORITY FOR LARGE MODES */
     if (pMode->hactive == 1280 && pMode->vactive == 1024) {
@@ -460,32 +460,32 @@ gu1_set_specified_mode(DISPLAYMODE * pMode, int bpp)
 
     /* COMBINE AND SET TIMING VALUES */
 
-    value = (unsigned long)(hactive - 1) |
-        (((unsigned long)(pMode->htotal - 1)) << 16);
+    value = (unsigned long) (hactive - 1) |
+        (((unsigned long) (pMode->htotal - 1)) << 16);
     WRITE_REG32(DC_H_TIMING_1, value);
-    value = (unsigned long)(pMode->hblankstart - 1) |
-        (((unsigned long)(pMode->hblankend - 1)) << 16);
+    value = (unsigned long) (pMode->hblankstart - 1) |
+        (((unsigned long) (pMode->hblankend - 1)) << 16);
     WRITE_REG32(DC_H_TIMING_2, value);
-    value = (unsigned long)(pMode->hsyncstart - 1) |
-        (((unsigned long)(pMode->hsyncend - 1)) << 16);
+    value = (unsigned long) (pMode->hsyncstart - 1) |
+        (((unsigned long) (pMode->hsyncend - 1)) << 16);
     WRITE_REG32(DC_H_TIMING_3, value);
     WRITE_REG32(DC_FP_H_TIMING, value);
-    value = (unsigned long)(vactive - 1) |
-        (((unsigned long)(pMode->vtotal - 1)) << 16);
+    value = (unsigned long) (vactive - 1) |
+        (((unsigned long) (pMode->vtotal - 1)) << 16);
     WRITE_REG32(DC_V_TIMING_1, value);
-    value = (unsigned long)(pMode->vblankstart - 1) |
-        (((unsigned long)(pMode->vblankend - 1)) << 16);
+    value = (unsigned long) (pMode->vblankstart - 1) |
+        (((unsigned long) (pMode->vblankend - 1)) << 16);
     WRITE_REG32(DC_V_TIMING_2, value);
-    value = (unsigned long)(pMode->vsyncstart - 1) |
-        (((unsigned long)(pMode->vsyncend - 1)) << 16);
+    value = (unsigned long) (pMode->vsyncstart - 1) |
+        (((unsigned long) (pMode->vsyncend - 1)) << 16);
     WRITE_REG32(DC_V_TIMING_3, value);
-    value = (unsigned long)(pMode->vsyncstart - 2) |
-        (((unsigned long)(pMode->vsyncend - 2)) << 16);
+    value = (unsigned long) (pMode->vsyncstart - 2) |
+        (((unsigned long) (pMode->vsyncend - 2)) << 16);
     WRITE_REG32(DC_FP_V_TIMING, value);
 
     WRITE_REG32(DC_OUTPUT_CFG, ocfg);
     WRITE_REG32(DC_TIMING_CFG, tcfg);
-    gfx_delay_milliseconds(1);         /* delay after TIMING_CFG */
+    gfx_delay_milliseconds(1);  /* delay after TIMING_CFG */
     WRITE_REG32(DC_GENERAL_CFG, gcfg);
 
     /* ENABLE FLAT PANEL CENTERING */
@@ -496,13 +496,13 @@ gu1_set_specified_mode(DISPLAYMODE * pMode, int bpp)
             tcfg = READ_REG32(DC_TIMING_CFG);
             tcfg = tcfg | DC_TCFG_FCEN;
             WRITE_REG32(DC_TIMING_CFG, tcfg);
-            gfx_delay_milliseconds(1); /* delay after TIMING_CFG */
+            gfx_delay_milliseconds(1);  /* delay after TIMING_CFG */
         }
     }
 
     /* CONFIGURE DISPLAY OUTPUT FROM VIDEO PROCESSOR */
     gfx_set_display_control(((pMode->flags & GFX_MODE_NEG_HSYNC) ? 1 : 0) |
-        ((pMode->flags & GFX_MODE_NEG_VSYNC) ? 2 : 0));
+                            ((pMode->flags & GFX_MODE_NEG_VSYNC) ? 2 : 0));
 
     /* RESTORE VALUE OF DC_UNLOCK */
     WRITE_REG32(DC_UNLOCK, unlock);
@@ -517,10 +517,10 @@ gu1_set_specified_mode(DISPLAYMODE * pMode, int bpp)
     else if (pitch > 1024)
         value |= BC_FB_WIDTH_2048;
 
-    WRITE_REG16(GP_BLIT_STATUS, (unsigned short)value);
+    WRITE_REG16(GP_BLIT_STATUS, (unsigned short) value);
 
     return GFX_STATUS_OK;
-}                                      /* end gfx_set_specified_mode() */
+}                               /* end gfx_set_specified_mode() */
 
 /*----------------------------------------------------------------------------
  * GFX_IS_DISPLAY_MODE_SUPPORTED
@@ -571,13 +571,13 @@ gfx_is_display_mode_supported(int xres, int yres, int bpp, int hz)
     /* ONLY PYRAMID SUPPORTS 4K PITCH */
     if (gfx_cpu_version != GFX_CPU_PYRAMID && xres > 1024) {
         if (bpp > 8)
-            return (-1);               /* return with mode not found */
+            return (-1);        /* return with mode not found */
     }
 
     /* LOOP THROUGH THE AVAILABLE MODES TO FIND A MATCH */
     for (mode = 0; mode < NUM_GX_DISPLAY_MODES; mode++) {
-        if ((DisplayParams[mode].hactive == (unsigned short)xres) &&
-            (DisplayParams[mode].vactive == (unsigned short)yres) &&
+        if ((DisplayParams[mode].hactive == (unsigned short) xres) &&
+            (DisplayParams[mode].vactive == (unsigned short) yres) &&
             (DisplayParams[mode].flags & hz_flag) &&
             (DisplayParams[mode].flags & bpp_flag)) {
 
@@ -613,8 +613,7 @@ gfx_set_display_mode(int xres, int yres, int bpp, int hz)
 
     mode = gfx_is_display_mode_supported(xres, yres, bpp, hz);
     if (mode >= 0) {
-        if (gu1_set_specified_mode(&DisplayParams[mode],
-                bpp) == GFX_STATUS_OK)
+        if (gu1_set_specified_mode(&DisplayParams[mode], bpp) == GFX_STATUS_OK)
             return (1);
     }
     return (0);
@@ -632,21 +631,23 @@ gfx_set_display_mode(int xres, int yres, int bpp, int hz)
 #if GFX_DISPLAY_DYNAMIC
 int
 gu1_set_display_timings(unsigned short bpp, unsigned short flags,
-    unsigned short hactive, unsigned short hblankstart,
-    unsigned short hsyncstart, unsigned short hsyncend,
-    unsigned short hblankend, unsigned short htotal,
-    unsigned short vactive, unsigned short vblankstart,
-    unsigned short vsyncstart, unsigned short vsyncend,
-    unsigned short vblankend, unsigned short vtotal, unsigned long frequency)
+                        unsigned short hactive, unsigned short hblankstart,
+                        unsigned short hsyncstart, unsigned short hsyncend,
+                        unsigned short hblankend, unsigned short htotal,
+                        unsigned short vactive, unsigned short vblankstart,
+                        unsigned short vsyncstart, unsigned short vsyncend,
+                        unsigned short vblankend, unsigned short vtotal,
+                        unsigned long frequency)
 #else
 int
 gfx_set_display_timings(unsigned short bpp, unsigned short flags,
-    unsigned short hactive, unsigned short hblankstart,
-    unsigned short hsyncstart, unsigned short hsyncend,
-    unsigned short hblankend, unsigned short htotal,
-    unsigned short vactive, unsigned short vblankstart,
-    unsigned short vsyncstart, unsigned short vsyncend,
-    unsigned short vblankend, unsigned short vtotal, unsigned long frequency)
+                        unsigned short hactive, unsigned short hblankstart,
+                        unsigned short hsyncstart, unsigned short hsyncend,
+                        unsigned short hblankend, unsigned short htotal,
+                        unsigned short vactive, unsigned short vblankstart,
+                        unsigned short vsyncstart, unsigned short vsyncend,
+                        unsigned short vblankend, unsigned short vtotal,
+                        unsigned long frequency)
 #endif
 {
     /* SET MODE STRUCTURE WITH SPECIFIED VALUES */
@@ -711,13 +712,13 @@ gfx_set_vtotal(unsigned short vtotal)
     timing2 = READ_REG32(DC_V_TIMING_2);
 
     /* DISABLE THE TIMING GENERATOR */
-    WRITE_REG32(DC_TIMING_CFG, tcfg & ~(unsigned long)DC_TCFG_TGEN);
+    WRITE_REG32(DC_TIMING_CFG, tcfg & ~(unsigned long) DC_TCFG_TGEN);
 
     /* WRITE NEW TIMING VALUES */
     WRITE_REG32(DC_V_TIMING_1,
-        (timing1 & 0xffff) | (unsigned long)(vtotal - 1) << 16);
+                (timing1 & 0xffff) | (unsigned long) (vtotal - 1) << 16);
     WRITE_REG32(DC_V_TIMING_2,
-        (timing2 & 0xffff) | (unsigned long)(vtotal - 1) << 16);
+                (timing2 & 0xffff) | (unsigned long) (vtotal - 1) << 16);
 
     /* RESTORE GX VALUES */
     WRITE_REG32(DC_TIMING_CFG, tcfg);
@@ -751,7 +752,7 @@ gfx_set_display_pitch(unsigned short pitch)
 
     /* ALSO UPDATE PITCH IN GRAPHICS ENGINE */
     /* Pyramid alone supports 4K line pitch */
-    value = (unsigned long)READ_REG16(GP_BLIT_STATUS);
+    value = (unsigned long) READ_REG16(GP_BLIT_STATUS);
     value &= ~(BC_FB_WIDTH_2048 | BC_FB_WIDTH_4096);
 
     if ((gfx_cpu_version == GFX_CPU_PYRAMID) && (pitch > 2048))
@@ -760,7 +761,7 @@ gfx_set_display_pitch(unsigned short pitch)
     else if (pitch > 1024)
         value |= BC_FB_WIDTH_2048;
 
-    WRITE_REG16(GP_BLIT_STATUS, (unsigned short)value);
+    WRITE_REG16(GP_BLIT_STATUS, (unsigned short) value);
     return;
 }
 
@@ -800,7 +801,8 @@ gfx_set_display_offset(unsigned long offset)
             gfx_wait_vertical_blank();
             gu1_enable_compression();
         }
-    } else {
+    }
+    else {
         /* ONLY DISABLE COMPRESSION ONCE */
         if (gfx_compression_active)
             gu1_disable_compression();
@@ -933,7 +935,7 @@ gfx_set_cursor_colors(unsigned long bkcolor, unsigned long fgcolor)
 
 #if GFX_VIDEO_SC1200
     if (gfx_test_timing_active())
-        while ((gfx_get_vline()) > gfx_get_vactive()) ;
+        while ((gfx_get_vline()) > gfx_get_vactive());
 #endif
     /* SET CURSOR COLORS */
     WRITE_REG32(DC_PAL_ADDRESS, 0x100);
@@ -958,13 +960,13 @@ gfx_set_cursor_colors(unsigned long bkcolor, unsigned long fgcolor)
 #if GFX_DISPLAY_DYNAMIC
 void
 gu1_set_cursor_position(unsigned long memoffset,
-    unsigned short xpos, unsigned short ypos,
-    unsigned short xhotspot, unsigned short yhotspot)
+                        unsigned short xpos, unsigned short ypos,
+                        unsigned short xhotspot, unsigned short yhotspot)
 #else
 void
 gfx_set_cursor_position(unsigned long memoffset,
-    unsigned short xpos, unsigned short ypos,
-    unsigned short xhotspot, unsigned short yhotspot)
+                        unsigned short xpos, unsigned short ypos,
+                        unsigned short xhotspot, unsigned short yhotspot)
 #endif
 {
     unsigned long unlock;
@@ -981,8 +983,8 @@ gfx_set_cursor_position(unsigned long memoffset,
     if (gfx_line_double)
         ypos <<= 1;
 
-    x = (short)xpos - (short)xhotspot;
-    y = (short)ypos - (short)yhotspot;
+    x = (short) xpos - (short) xhotspot;
+    y = (short) ypos - (short) yhotspot;
     if (x < -31)
         return;
 
@@ -999,13 +1001,13 @@ gfx_set_cursor_position(unsigned long memoffset,
         y = 0;
     }
 
-    memoffset += (unsigned long)yoffset << 3;
+    memoffset += (unsigned long) yoffset << 3;
 
     if (PanelEnable) {
         if ((ModeWidth > PanelWidth) || (ModeHeight > PanelHeight)) {
             gfx_enable_panning(xpos, ypos);
-            x = x - (short)panelLeft;
-            y = y - (short)panelTop;
+            x = x - (short) panelLeft;
+            y = y - (short) panelTop;
         }
     }
 
@@ -1013,10 +1015,10 @@ gfx_set_cursor_position(unsigned long memoffset,
     unlock = READ_REG32(DC_UNLOCK);
     WRITE_REG32(DC_UNLOCK, DC_UNLOCK_VALUE);
     WRITE_REG32(DC_CURS_ST_OFFSET, memoffset);
-    WRITE_REG32(DC_CURSOR_X, (unsigned long)x |
-        (((unsigned long)xoffset) << 11));
-    WRITE_REG32(DC_CURSOR_Y, (unsigned long)y |
-        (((unsigned long)yoffset) << 11));
+    WRITE_REG32(DC_CURSOR_X, (unsigned long) x |
+                (((unsigned long) xoffset) << 11));
+    WRITE_REG32(DC_CURSOR_Y, (unsigned long) y |
+                (((unsigned long) yoffset) << 11));
     WRITE_REG32(DC_UNLOCK, unlock);
 }
 
@@ -1030,11 +1032,11 @@ gfx_set_cursor_position(unsigned long memoffset,
 #if GFX_DISPLAY_DYNAMIC
 void
 gu1_set_cursor_shape32(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask)
+                       unsigned long *andmask, unsigned long *xormask)
 #else
 void
 gfx_set_cursor_shape32(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask)
+                       unsigned long *andmask, unsigned long *xormask)
 #endif
 {
     int i;
@@ -1190,7 +1192,7 @@ gfx_set_compression_pitch(unsigned short pitch)
     /* SET REGISTER VALUE */
     lock = READ_REG32(DC_UNLOCK);
     line_delta = READ_REG32(DC_LINE_DELTA) & 0xFF800FFF;
-    line_delta |= ((unsigned long)pitch << 10l) & 0x007FF000;
+    line_delta |= ((unsigned long) pitch << 10l) & 0x007FF000;
     WRITE_REG32(DC_UNLOCK, DC_UNLOCK_VALUE);
     WRITE_REG32(DC_LINE_DELTA, line_delta);
     WRITE_REG32(DC_UNLOCK, lock);
@@ -1293,7 +1295,7 @@ gfx_set_display_video_size(unsigned short width, unsigned short height)
 {
     unsigned long lock, size, value;
 
-    size = (unsigned long)(width << 1) * (unsigned long)height;
+    size = (unsigned long) (width << 1) * (unsigned long) height;
 
     /* STORE THE VIDEO BUFFER SIZE AS A GLOBAL */
     vid_buf_size = ((size + 63) >> 6) << 16;
@@ -1410,8 +1412,8 @@ gfx_wait_vertical_blank(void)
 #endif
 {
     if (gfx_test_timing_active()) {
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
     }
 
     return (0);
@@ -1441,8 +1443,8 @@ gfx_enable_panning(int x, int y)
         (((ModeWidth + 1023) / 1024) * 1024) * modeBytesPerPixel;
 
     /* TEST FOR NO-WORK */
-    if (x >= DeltaX && (unsigned short)x < (PanelWidth + DeltaX) &&
-        y >= DeltaY && (unsigned short)y < (PanelHeight + DeltaY))
+    if (x >= DeltaX && (unsigned short) x < (PanelWidth + DeltaX) &&
+        y >= DeltaY && (unsigned short) y < (PanelHeight + DeltaY))
         return;
 
     /* ADJUST PANNING VARIABLES WHEN CURSOR EXCEEDS BOUNDARY       */
@@ -1450,12 +1452,12 @@ gfx_enable_panning(int x, int y)
     /* all variables and the starting offset accordingly.          */
     if (x < DeltaX)
         DeltaX = x;
-    else if ((unsigned short)x >= (DeltaX + PanelWidth))
+    else if ((unsigned short) x >= (DeltaX + PanelWidth))
         DeltaX = x - PanelWidth + 1;
 
     if (y < DeltaY)
         DeltaY = y;
-    else if ((unsigned short)y >= (DeltaY + PanelHeight))
+    else if ((unsigned short) y >= (DeltaY + PanelHeight))
         DeltaY = y - PanelHeight + 1;
 
     /* CALCULATE THE START OFFSET */
@@ -1483,19 +1485,19 @@ gfx_enable_panning(int x, int y)
 #if GFX_DISPLAY_DYNAMIC
 int
 gu1_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 #else
 int
 gfx_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 #endif
 {
     unsigned int mode;
 
     ModeWidth = width;
     ModeHeight = height;
-    PanelWidth = (unsigned short)panelResX;
-    PanelHeight = (unsigned short)panelResY;
+    PanelWidth = (unsigned short) panelResX;
+    PanelHeight = (unsigned short) panelResY;
     PanelEnable = 1;
 
     /* LOOP THROUGH THE AVAILABLE MODES TO FIND A MATCH */
@@ -1509,14 +1511,16 @@ gfx_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
             FIXEDTIMINGS *fmode = &FixedParams[mode];
 
             gfx_set_display_timings(bpp, 3, fmode->hactive,
-                fmode->hblankstart, fmode->hsyncstart, fmode->hsyncend,
-                fmode->hblankend, fmode->htotal, fmode->vactive,
-                fmode->vblankstart, fmode->vsyncstart, fmode->vsyncend,
-                fmode->vblankend, fmode->vtotal, fmode->frequency);
+                                    fmode->hblankstart, fmode->hsyncstart,
+                                    fmode->hsyncend, fmode->hblankend,
+                                    fmode->htotal, fmode->vactive,
+                                    fmode->vblankstart, fmode->vsyncstart,
+                                    fmode->vsyncend, fmode->vblankend,
+                                    fmode->vtotal, fmode->frequency);
 
             return (1);
-        }                              /* end if() */
-    }                                  /* end for() */
+        }                       /* end if() */
+    }                           /* end for() */
 
     return (-1);
 }
@@ -1528,11 +1532,11 @@ gfx_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
 #if GFX_DISPLAY_DYNAMIC
 int
 gu1_set_panel_present(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 #else
 int
 gfx_set_panel_present(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 #endif
 {
     /* SET VALID BPP         */
@@ -1549,8 +1553,8 @@ gfx_set_panel_present(int panelResX, int panelResY, unsigned short width,
 
     ModeWidth = width;
     ModeHeight = height;
-    PanelWidth = (unsigned short)panelResX;
-    PanelHeight = (unsigned short)panelResY;
+    PanelWidth = (unsigned short) panelResX;
+    PanelHeight = (unsigned short) panelResY;
     PanelEnable = 1;
     gbpp = bpp;
 
@@ -1590,11 +1594,12 @@ gfx_get_display_pitch(void)
     if (gfx_cpu_version == GFX_CPU_PYRAMID) {
         /* Pyramid update for 4KB line pitch */
         value = (READ_REG32(DC_LINE_DELTA) & 0x07FF) << 2;
-    } else {
+    }
+    else {
         value = (READ_REG32(DC_LINE_DELTA) & 0x03FF) << 2;
     }
 
-    return ((unsigned short)value);
+    return ((unsigned short) value);
 }
 
 /*----------------------------------------------------------------------------
@@ -1680,11 +1685,11 @@ gfx_get_frame_buffer_line_size(void)
 #if GFX_DISPLAY_DYNAMIC
 int
 gu1_mode_frequency_supported(int xres, int yres, int bpp,
-    unsigned long frequency)
+                             unsigned long frequency)
 #else
 int
 gfx_mode_frequency_supported(int xres, int yres, int bpp,
-    unsigned long frequency)
+                             unsigned long frequency)
 #endif
 {
     unsigned int index;
@@ -1696,8 +1701,8 @@ gfx_mode_frequency_supported(int xres, int yres, int bpp,
         bpp_flag = GFX_MODE_16BPP;
 
     for (index = 0; index < NUM_GX_DISPLAY_MODES; index++) {
-        if ((DisplayParams[index].hactive == (unsigned short)xres) &&
-            (DisplayParams[index].vactive == (unsigned short)yres) &&
+        if ((DisplayParams[index].hactive == (unsigned short) xres) &&
+            (DisplayParams[index].vactive == (unsigned short) yres) &&
             (DisplayParams[index].flags & bpp_flag) &&
             (DisplayParams[index].frequency == frequency)) {
             int hz = 0;
@@ -1732,11 +1737,11 @@ gfx_mode_frequency_supported(int xres, int yres, int bpp,
 #if GFX_DISPLAY_DYNAMIC
 int
 gu1_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                                   unsigned long frequency)
 #else
 int
 gfx_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                                   unsigned long frequency)
 #endif
 {
     unsigned int index, closematch = 0;
@@ -1754,10 +1759,10 @@ gfx_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
     /* Search the table for the closest frequency (16.16 format). */
     min = 0x7fffffff;
     for (index = 0; index < NUM_GX_DISPLAY_MODES; index++) {
-        if ((DisplayParams[index].htotal == (unsigned short)xres) &&
-            (DisplayParams[index].vtotal == (unsigned short)yres) &&
+        if ((DisplayParams[index].htotal == (unsigned short) xres) &&
+            (DisplayParams[index].vtotal == (unsigned short) yres) &&
             (DisplayParams[index].flags & bpp_flag)) {
-            diff = (long)frequency - (long)DisplayParams[index].frequency;
+            diff = (long) frequency - (long) DisplayParams[index].frequency;
             if (diff < 0)
                 diff = -diff;
 
@@ -1797,11 +1802,11 @@ gfx_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
 #if GFX_DISPLAY_DYNAMIC
 int
 gu1_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                              unsigned long frequency)
 #else
 int
 gfx_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                              unsigned long frequency)
 #endif
 {
     unsigned int index, closematch = 0;
@@ -1819,10 +1824,10 @@ gfx_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
     /* Search the table for the closest frequency (16.16 format). */
     min = 0x7fffffff;
     for (index = 0; index < NUM_GX_DISPLAY_MODES; index++) {
-        if ((DisplayParams[index].hactive == (unsigned short)xres) &&
-            (DisplayParams[index].vactive == (unsigned short)yres) &&
+        if ((DisplayParams[index].hactive == (unsigned short) xres) &&
+            (DisplayParams[index].vactive == (unsigned short) yres) &&
             (DisplayParams[index].flags & bpp_flag)) {
-            diff = (long)frequency - (long)DisplayParams[index].frequency;
+            diff = (long) frequency - (long) DisplayParams[index].frequency;
             if (diff < 0)
                 diff = -diff;
 
@@ -1860,11 +1865,11 @@ gfx_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
 #if GFX_DISPLAY_DYNAMIC
 int
 gu1_get_frequency_from_refreshrate(int xres, int yres, int bpp, int hz,
-    int *frequency)
+                                   int *frequency)
 #else
 int
 gfx_get_frequency_from_refreshrate(int xres, int yres, int bpp, int hz,
-    int *frequency)
+                                   int *frequency)
 #endif
 {
     unsigned int index;
@@ -1894,8 +1899,8 @@ gfx_get_frequency_from_refreshrate(int xres, int yres, int bpp, int hz,
     /* FIND THE REGISTER VALUES FOR THE DESIRED FREQUENCY */
 
     for (index = 0; index < NUM_GX_DISPLAY_MODES; index++) {
-        if ((DisplayParams[index].hactive == (unsigned short)xres) &&
-            (DisplayParams[index].vactive == (unsigned short)yres) &&
+        if ((DisplayParams[index].hactive == (unsigned short) xres) &&
+            (DisplayParams[index].vactive == (unsigned short) yres) &&
             (DisplayParams[index].flags & bpp_flag) &&
             (DisplayParams[index].flags & hz_flag)) {
             *frequency = DisplayParams[index].frequency;
@@ -1962,8 +1967,8 @@ gfx_get_display_mode(int *xres, int *yres, int *bpp, int *hz)
         bpp_flag = GFX_MODE_16BPP;
 
     for (mode = 0; mode < NUM_GX_DISPLAY_MODES; mode++) {
-        if ((DisplayParams[mode].hactive == (unsigned short)*xres) &&
-            (DisplayParams[mode].vactive == (unsigned short)*yres) &&
+        if ((DisplayParams[mode].hactive == (unsigned short) *xres) &&
+            (DisplayParams[mode].vactive == (unsigned short) *yres) &&
             (DisplayParams[mode].frequency == pll_freq) &&
             (DisplayParams[mode].flags & bpp_flag)) {
 
@@ -2000,7 +2005,7 @@ unsigned short
 gfx_get_hactive(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(DC_H_TIMING_1) & 0x07F8) + 8));
+    return ((unsigned short) ((READ_REG32(DC_H_TIMING_1) & 0x07F8) + 8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2015,7 +2020,7 @@ unsigned short
 gfx_get_hsync_start(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(DC_H_TIMING_3) & 0x07F8) + 8));
+    return ((unsigned short) ((READ_REG32(DC_H_TIMING_3) & 0x07F8) + 8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2030,8 +2035,8 @@ unsigned short
 gfx_get_hsync_end(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(DC_H_TIMING_3) >> 16) & 0x07F8) +
-            8));
+    return ((unsigned short) (((READ_REG32(DC_H_TIMING_3) >> 16) & 0x07F8) +
+                              8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2046,8 +2051,8 @@ unsigned short
 gfx_get_htotal(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(DC_H_TIMING_1) >> 16) & 0x07F8) +
-            8));
+    return ((unsigned short) (((READ_REG32(DC_H_TIMING_1) >> 16) & 0x07F8) +
+                              8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2062,7 +2067,7 @@ unsigned short
 gfx_get_vactive(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(DC_V_TIMING_1) & 0x07FF) + 1));
+    return ((unsigned short) ((READ_REG32(DC_V_TIMING_1) & 0x07FF) + 1));
 }
 
 /*---------------------------------------------------------------------------
@@ -2077,8 +2082,8 @@ unsigned short
 gfx_get_vsync_end(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(DC_V_TIMING_3) >> 16) & 0x07FF) +
-            1));
+    return ((unsigned short) (((READ_REG32(DC_V_TIMING_3) >> 16) & 0x07FF) +
+                              1));
 }
 
 /*---------------------------------------------------------------------------
@@ -2093,8 +2098,8 @@ unsigned short
 gfx_get_vtotal(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(DC_V_TIMING_1) >> 16) & 0x07FF) +
-            1));
+    return ((unsigned short) (((READ_REG32(DC_V_TIMING_1) >> 16) & 0x07FF) +
+                              1));
 }
 
 /*-----------------------------------------------------------------------------
@@ -2136,10 +2141,9 @@ gfx_get_vline(void)
 
     /* Read similar value twice to ensure that the value is not transitioning */
     do {
-        current_scan_line =
-            (unsigned short)READ_REG32(DC_V_LINE_CNT) & 0x07FF;
+        current_scan_line = (unsigned short) READ_REG32(DC_V_LINE_CNT) & 0x07FF;
     } while (current_scan_line !=
-        (unsigned short)(READ_REG32(DC_V_LINE_CNT) & 0x07FF));
+             (unsigned short) (READ_REG32(DC_V_LINE_CNT) & 0x07FF));
 
     return (current_scan_line);
 }
@@ -2192,7 +2196,7 @@ unsigned short
 gfx_get_hblank_start(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(DC_H_TIMING_2) & 0x07F8) + 8));
+    return ((unsigned short) ((READ_REG32(DC_H_TIMING_2) & 0x07F8) + 8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2207,8 +2211,8 @@ unsigned short
 gfx_get_hblank_end(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(DC_H_TIMING_2) >> 16) & 0x07F8) +
-            8));
+    return ((unsigned short) (((READ_REG32(DC_H_TIMING_2) >> 16) & 0x07F8) +
+                              8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2223,7 +2227,7 @@ unsigned short
 gfx_get_vblank_start(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(DC_V_TIMING_2) & 0x07FF) + 1));
+    return ((unsigned short) ((READ_REG32(DC_V_TIMING_2) & 0x07FF) + 1));
 }
 
 /*---------------------------------------------------------------------------
@@ -2238,7 +2242,7 @@ unsigned short
 gfx_get_vsync_start(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(DC_V_TIMING_3) & 0x07FF) + 1));
+    return ((unsigned short) ((READ_REG32(DC_V_TIMING_3) & 0x07FF) + 1));
 }
 
 /*---------------------------------------------------------------------------
@@ -2253,8 +2257,8 @@ unsigned short
 gfx_get_vblank_end(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(DC_V_TIMING_2) >> 16) & 0x07FF) +
-            1));
+    return ((unsigned short) (((READ_REG32(DC_V_TIMING_2) >> 16) & 0x07FF) +
+                              1));
 }
 
 /*-----------------------------------------------------------------------------
@@ -2334,7 +2338,7 @@ gfx_get_cursor_position(void)
 #endif
 {
     return ((READ_REG32(DC_CURSOR_X) & 0x07FF) |
-        ((READ_REG32(DC_CURSOR_Y) << 16) & 0x03FF0000));
+            ((READ_REG32(DC_CURSOR_Y) << 16) & 0x03FF0000));
 }
 
 /*-----------------------------------------------------------------------------
@@ -2350,7 +2354,7 @@ gfx_get_cursor_clip(void)
 #endif
 {
     return (((READ_REG32(DC_CURSOR_X) >> 11) & 0x01F) |
-        ((READ_REG32(DC_CURSOR_Y) << 5) & 0x1F0000));
+            ((READ_REG32(DC_CURSOR_Y) << 5) & 0x1F0000));
 }
 
 /*-----------------------------------------------------------------------------
@@ -2369,7 +2373,8 @@ gfx_get_cursor_color(int color)
 
     if (color) {
         WRITE_REG32(DC_PAL_ADDRESS, 0x101);
-    } else {
+    }
+    else {
         WRITE_REG32(DC_PAL_ADDRESS, 0x100);
     }
     data = READ_REG32(DC_PAL_DATA);
@@ -2431,7 +2436,7 @@ gfx_get_compression_pitch(void)
 {
     unsigned short pitch;
 
-    pitch = (unsigned short)(READ_REG32(DC_LINE_DELTA) >> 12) & 0x03FF;
+    pitch = (unsigned short) (READ_REG32(DC_LINE_DELTA) >> 12) & 0x03FF;
     return (pitch << 2);
 }
 
@@ -2449,7 +2454,7 @@ gfx_get_compression_size(void)
 {
     unsigned short size;
 
-    size = (unsigned short)((READ_REG32(DC_BUF_SIZE) >> 9) & 0x7F) - 1;
+    size = (unsigned short) ((READ_REG32(DC_BUF_SIZE) >> 9) & 0x7F) - 1;
     return ((size << 2) + 16);
 }
 
@@ -2468,7 +2473,7 @@ gfx_get_valid_bit(int line)
     int valid;
 
     WRITE_REG32(MC_DR_ADD, line);
-    valid = (int)READ_REG32(MC_DR_ACC) & 1;
+    valid = (int) READ_REG32(MC_DR_ACC) & 1;
     return (valid);
 }
 
@@ -2527,6 +2532,6 @@ gfx_get_display_priority_high(void)
         return (0);
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
 /* END OF FILE */
diff --git a/src/gfx/disp_gu2.c b/src/gfx/disp_gu2.c
index 403a72a..f105cc1 100644
--- a/src/gfx/disp_gu2.c
+++ b/src/gfx/disp_gu2.c
@@ -27,8 +27,8 @@
  * This file contains routines for the second generation display controller.
  * */
 
-void gu2_enable_compression(void);     /* private routine definition */
-void gu2_disable_compression(void);    /* private routine definition */
+void gu2_enable_compression(void);      /* private routine definition */
+void gu2_disable_compression(void);     /* private routine definition */
 int gfx_set_display_control(int sync_polarities);       /* private routine
                                                          * definition */
 void gfx_reset_video(void);
@@ -98,7 +98,7 @@ gfx_set_display_bpp(unsigned short bpp)
 
     dcfg =
         READ_REG32(MDC_DISPLAY_CFG) & ~(MDC_DCFG_DISP_MODE_MASK |
-        MDC_DCFG_16BPP_MODE_MASK);
+                                        MDC_DCFG_16BPP_MODE_MASK);
     lock = READ_REG32(MDC_UNLOCK);
 
     switch (bpp) {
@@ -207,7 +207,7 @@ gu2_set_specified_mode(DISPLAYMODE * pMode, int bpp)
     gfx_set_crt_enable(0);
 
     /* DISABLE THE TIMING GENERATOR */
-    dcfg &= ~(unsigned long)MDC_DCFG_TGEN;
+    dcfg &= ~(unsigned long) MDC_DCFG_TGEN;
     WRITE_REG32(MDC_DISPLAY_CFG, dcfg);
 
     /* DELAY: WAIT FOR PENDING MEMORY REQUESTS                            */
@@ -216,11 +216,11 @@ gu2_set_specified_mode(DISPLAYMODE * pMode, int bpp)
     gfx_delay_milliseconds(5);
 
     /* DISABLE DISPLAY FIFO LOAD */
-    gcfg &= ~(unsigned long)MDC_GCFG_DFLE;
+    gcfg &= ~(unsigned long) MDC_GCFG_DFLE;
     WRITE_REG32(MDC_GENERAL_CFG, gcfg);
 
     /* PRESERVE VIDEO INFORMATION */
-    gcfg &= (unsigned long)(MDC_GCFG_YUVM | MDC_GCFG_VDSE);
+    gcfg &= (unsigned long) (MDC_GCFG_YUVM | MDC_GCFG_VDSE);
     dcfg = 0;
 
     /* SET THE DOT CLOCK FREQUENCY             */
@@ -297,7 +297,7 @@ gu2_set_specified_mode(DISPLAYMODE * pMode, int bpp)
     /* ALWAYS ENABLE VIDEO AND GRAPHICS DATA            */
     /* These bits are relics from a previous design and */
     /* should always be enabled.                        */
-    dcfg |= (unsigned long)(MDC_DCFG_VDEN | MDC_DCFG_GDEN);
+    dcfg |= (unsigned long) (MDC_DCFG_VDEN | MDC_DCFG_GDEN);
 
     /* SET PIXEL FORMAT */
     dcfg |= bpp_mask;
@@ -305,8 +305,8 @@ gu2_set_specified_mode(DISPLAYMODE * pMode, int bpp)
     /* ENABLE TIMING GENERATOR, TIM. REG. UPDATES, PALETTE BYPASS */
     /* AND VERT. INT. SELECT                                      */
     dcfg |=
-        (unsigned long)(MDC_DCFG_TGEN | MDC_DCFG_TRUP | MDC_DCFG_PALB |
-        MDC_DCFG_VISL);
+        (unsigned long) (MDC_DCFG_TGEN | MDC_DCFG_TRUP | MDC_DCFG_PALB |
+                         MDC_DCFG_VISL);
 
     /* DISABLE ADDRESS MASKS */
     dcfg |= MDC_DCFG_A20M;
@@ -326,23 +326,23 @@ gu2_set_specified_mode(DISPLAYMODE * pMode, int bpp)
         dcfg |= MDC_DCFG_DCEN;
 
     /* COMBINE AND SET TIMING VALUES */
-    value = (unsigned long)(pMode->hactive - 1) |
-        (((unsigned long)(pMode->htotal - 1)) << 16);
+    value = (unsigned long) (pMode->hactive - 1) |
+        (((unsigned long) (pMode->htotal - 1)) << 16);
     WRITE_REG32(MDC_H_ACTIVE_TIMING, value);
-    value = (unsigned long)(pMode->hblankstart - 1) |
-        (((unsigned long)(pMode->hblankend - 1)) << 16);
+    value = (unsigned long) (pMode->hblankstart - 1) |
+        (((unsigned long) (pMode->hblankend - 1)) << 16);
     WRITE_REG32(MDC_H_BLANK_TIMING, value);
-    value = (unsigned long)(pMode->hsyncstart - 1) |
-        (((unsigned long)(pMode->hsyncend - 1)) << 16);
+    value = (unsigned long) (pMode->hsyncstart - 1) |
+        (((unsigned long) (pMode->hsyncend - 1)) << 16);
     WRITE_REG32(MDC_H_SYNC_TIMING, value);
-    value = (unsigned long)(pMode->vactive - 1) |
-        (((unsigned long)(pMode->vtotal - 1)) << 16);
+    value = (unsigned long) (pMode->vactive - 1) |
+        (((unsigned long) (pMode->vtotal - 1)) << 16);
     WRITE_REG32(MDC_V_ACTIVE_TIMING, value);
-    value = (unsigned long)(pMode->vblankstart - 1) |
-        (((unsigned long)(pMode->vblankend - 1)) << 16);
+    value = (unsigned long) (pMode->vblankstart - 1) |
+        (((unsigned long) (pMode->vblankend - 1)) << 16);
     WRITE_REG32(MDC_V_BLANK_TIMING, value);
-    value = (unsigned long)(pMode->vsyncstart - 1) |
-        (((unsigned long)(pMode->vsyncend - 1)) << 16);
+    value = (unsigned long) (pMode->vsyncstart - 1) |
+        (((unsigned long) (pMode->vsyncend - 1)) << 16);
     WRITE_REG32(MDC_V_SYNC_TIMING, value);
 
     WRITE_REG32(MDC_DISPLAY_CFG, dcfg);
@@ -350,15 +350,15 @@ gu2_set_specified_mode(DISPLAYMODE * pMode, int bpp)
 
     /* CONFIGURE DISPLAY OUTPUT FROM VIDEO PROCESSOR */
     gfx_set_display_control(((pMode->flags & GFX_MODE_NEG_HSYNC) ? 1 : 0) |
-        ((pMode->flags & GFX_MODE_NEG_VSYNC) ? 2 : 0));
+                            ((pMode->flags & GFX_MODE_NEG_VSYNC) ? 2 : 0));
 
     /* RESTORE VALUE OF MDC_UNLOCK */
     WRITE_REG32(MDC_UNLOCK, unlock);
 
     /* RESET THE PITCH VALUES IN THE GP */
-    gfx_reset_pitch((unsigned short)pitch);
+    gfx_reset_pitch((unsigned short) pitch);
 
-    gfx_set_bpp((unsigned short)bpp);
+    gfx_set_bpp((unsigned short) bpp);
 
     return GFX_STATUS_OK;
 }
@@ -388,8 +388,8 @@ gfx_is_display_mode_supported(int xres, int yres, int bpp, int hz)
         gfx_mode_bpp_conversion
         /* LOOP THROUGH THE AVAILABLE MODES TO FIND A MATCH */
         for (mode = 0; mode < NUM_RC_DISPLAY_MODES; mode++) {
-        if ((DisplayParams[mode].hactive == (unsigned short)xres) &&
-            (DisplayParams[mode].vactive == (unsigned short)yres) &&
+        if ((DisplayParams[mode].hactive == (unsigned short) xres) &&
+            (DisplayParams[mode].vactive == (unsigned short) yres) &&
             (DisplayParams[mode].flags & hz_flag) &&
             (DisplayParams[mode].flags & bpp_flag)) {
 
@@ -431,8 +431,7 @@ gfx_set_display_mode(int xres, int yres, int bpp, int hz)
 
     mode = gfx_is_display_mode_supported(xres, yres, bpp, hz);
     if (mode >= 0) {
-        if (gu2_set_specified_mode(&DisplayParams[mode],
-                bpp) == GFX_STATUS_OK)
+        if (gu2_set_specified_mode(&DisplayParams[mode], bpp) == GFX_STATUS_OK)
             return (1);
     }
     return (0);
@@ -450,21 +449,23 @@ gfx_set_display_mode(int xres, int yres, int bpp, int hz)
 #if GFX_DISPLAY_DYNAMIC
 int
 gu2_set_display_timings(unsigned short bpp, unsigned short flags,
-    unsigned short hactive, unsigned short hblankstart,
-    unsigned short hsyncstart, unsigned short hsyncend,
-    unsigned short hblankend, unsigned short htotal,
-    unsigned short vactive, unsigned short vblankstart,
-    unsigned short vsyncstart, unsigned short vsyncend,
-    unsigned short vblankend, unsigned short vtotal, unsigned long frequency)
+                        unsigned short hactive, unsigned short hblankstart,
+                        unsigned short hsyncstart, unsigned short hsyncend,
+                        unsigned short hblankend, unsigned short htotal,
+                        unsigned short vactive, unsigned short vblankstart,
+                        unsigned short vsyncstart, unsigned short vsyncend,
+                        unsigned short vblankend, unsigned short vtotal,
+                        unsigned long frequency)
 #else
 int
 gfx_set_display_timings(unsigned short bpp, unsigned short flags,
-    unsigned short hactive, unsigned short hblankstart,
-    unsigned short hsyncstart, unsigned short hsyncend,
-    unsigned short hblankend, unsigned short htotal,
-    unsigned short vactive, unsigned short vblankstart,
-    unsigned short vsyncstart, unsigned short vsyncend,
-    unsigned short vblankend, unsigned short vtotal, unsigned long frequency)
+                        unsigned short hactive, unsigned short hblankstart,
+                        unsigned short hsyncstart, unsigned short hsyncend,
+                        unsigned short hblankend, unsigned short htotal,
+                        unsigned short vactive, unsigned short vblankstart,
+                        unsigned short vsyncstart, unsigned short vsyncend,
+                        unsigned short vblankend, unsigned short vtotal,
+                        unsigned long frequency)
 #endif
 {
     /* SET MODE STRUCTURE WITH SPECIFIED VALUES */
@@ -531,13 +532,15 @@ gfx_set_vtotal(unsigned short vtotal)
     vblank = READ_REG32(MDC_V_BLANK_TIMING);
 
     /* DISABLE TIMING REGISTER UPDATES */
-    WRITE_REG32(MDC_DISPLAY_CFG, dcfg & ~(unsigned long)MDC_DCFG_TRUP);
+    WRITE_REG32(MDC_DISPLAY_CFG, dcfg & ~(unsigned long) MDC_DCFG_TRUP);
 
     /* WRITE NEW TIMING VALUES */
     WRITE_REG32(MDC_V_ACTIVE_TIMING,
-        (vactive & MDC_VAT_VA_MASK) | (unsigned long)(vtotal - 1) << 16);
+                (vactive & MDC_VAT_VA_MASK) | (unsigned long) (vtotal -
+                                                               1) << 16);
     WRITE_REG32(MDC_V_BLANK_TIMING,
-        (vblank & MDC_VBT_VBS_MASK) | (unsigned long)(vtotal - 1) << 16);
+                (vblank & MDC_VBT_VBS_MASK) | (unsigned long) (vtotal -
+                                                               1) << 16);
 
     /* RESTORE OLD RC VALUES */
     WRITE_REG32(MDC_DISPLAY_CFG, dcfg);
@@ -579,9 +582,9 @@ gfx_set_display_pitch(unsigned short pitch)
     value = READ_REG32(MDC_GENERAL_CFG);
 
     if (pitch == 1024 || pitch == 2048 || pitch == 4096 || pitch == 8192)
-        value &= ~(unsigned long)(MDC_GCFG_FDTY);
+        value &= ~(unsigned long) (MDC_GCFG_FDTY);
     else
-        value |= (unsigned long)(MDC_GCFG_FDTY);
+        value |= (unsigned long) (MDC_GCFG_FDTY);
 
     WRITE_REG32(MDC_GENERAL_CFG, value);
     WRITE_REG32(MDC_UNLOCK, lock);
@@ -622,7 +625,8 @@ gfx_set_display_offset(unsigned long offset)
             gfx_wait_vertical_blank();
             gu2_enable_compression();
         }
-    } else {
+    }
+    else {
         /* ONLY DISABLE COMPRESSION ONCE */
         if (gfx_compression_active)
             gu2_disable_compression();
@@ -766,19 +770,19 @@ gfx_set_cursor_colors(unsigned long bkcolor, unsigned long fgcolor)
 #if GFX_DISPLAY_DYNAMIC
 void
 gu2_set_cursor_position(unsigned long memoffset,
-    unsigned short xpos, unsigned short ypos,
-    unsigned short xhotspot, unsigned short yhotspot)
+                        unsigned short xpos, unsigned short ypos,
+                        unsigned short xhotspot, unsigned short yhotspot)
 #else
 void
 gfx_set_cursor_position(unsigned long memoffset,
-    unsigned short xpos, unsigned short ypos,
-    unsigned short xhotspot, unsigned short yhotspot)
+                        unsigned short xpos, unsigned short ypos,
+                        unsigned short xhotspot, unsigned short yhotspot)
 #endif
 {
     unsigned long unlock;
 
-    short x = (short)xpos - (short)xhotspot;
-    short y = (short)ypos - (short)yhotspot;
+    short x = (short) xpos - (short) xhotspot;
+    short y = (short) ypos - (short) yhotspot;
     short xoffset = 0;
     short yoffset = 0;
 
@@ -790,8 +794,8 @@ gfx_set_cursor_position(unsigned long memoffset,
     if (PanelEnable) {
         if ((ModeWidth > PanelWidth) || (ModeHeight > PanelHeight)) {
             gfx_enable_panning(xpos, ypos);
-            x = x - (unsigned short)panelLeft;
-            y = y - (unsigned short)panelTop;
+            x = x - (unsigned short) panelLeft;
+            y = y - (unsigned short) panelTop;
         }
     }
 
@@ -809,16 +813,16 @@ gfx_set_cursor_position(unsigned long memoffset,
         yoffset = -y;
         y = 0;
     }
-    memoffset += (unsigned long)yoffset << 4;
+    memoffset += (unsigned long) yoffset << 4;
 
     /* SET CURSOR POSITION */
     unlock = READ_REG32(MDC_UNLOCK);
     WRITE_REG32(MDC_UNLOCK, MDC_UNLOCK_VALUE);
     WRITE_REG32(MDC_CURS_ST_OFFSET, memoffset);
-    WRITE_REG32(MDC_CURSOR_X, (unsigned long)x |
-        (((unsigned long)xoffset) << 11));
-    WRITE_REG32(MDC_CURSOR_Y, (unsigned long)y |
-        (((unsigned long)yoffset) << 11));
+    WRITE_REG32(MDC_CURSOR_X, (unsigned long) x |
+                (((unsigned long) xoffset) << 11));
+    WRITE_REG32(MDC_CURSOR_Y, (unsigned long) y |
+                (((unsigned long) yoffset) << 11));
     WRITE_REG32(MDC_UNLOCK, unlock);
 }
 
@@ -834,11 +838,11 @@ gfx_set_cursor_position(unsigned long memoffset,
 #if GFX_DISPLAY_DYNAMIC
 void
 gu2_set_cursor_shape32(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask)
+                       unsigned long *andmask, unsigned long *xormask)
 #else
 void
 gfx_set_cursor_shape32(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask)
+                       unsigned long *andmask, unsigned long *xormask)
 #endif
 {
     int i;
@@ -876,11 +880,11 @@ gfx_set_cursor_shape32(unsigned long memoffset,
 #if GFX_DISPLAY_DYNAMIC
 void
 gu2_set_cursor_shape64(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask)
+                       unsigned long *andmask, unsigned long *xormask)
 #else
 void
 gfx_set_cursor_shape64(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask)
+                       unsigned long *andmask, unsigned long *xormask)
 #endif
 {
     int i;
@@ -943,11 +947,11 @@ gfx_set_icon_enable(int enable)
 #if GFX_DISPLAY_DYNAMIC
 void
 gu2_set_icon_colors(unsigned long color0, unsigned long color1,
-    unsigned long color2)
+                    unsigned long color2)
 #else
 void
 gfx_set_icon_colors(unsigned long color0, unsigned long color1,
-    unsigned long color2)
+                    unsigned long color2)
 #endif
 {
     /* ICON COLORS LOCATED AT PALETTE INDEXES 102-104h */
@@ -981,7 +985,7 @@ gfx_set_icon_position(unsigned long memoffset, unsigned short xpos)
     WRITE_REG32(MDC_ICON_ST_OFFSET, memoffset & 0x0FFFFFFF);
 
     /* PROGRAM THE XCOORDINATE */
-    WRITE_REG32(MDC_ICON_X, (unsigned long)(xpos & 0x07FF));
+    WRITE_REG32(MDC_ICON_X, (unsigned long) (xpos & 0x07FF));
 
     WRITE_REG32(MDC_UNLOCK, lock);
 }
@@ -995,11 +999,11 @@ gfx_set_icon_position(unsigned long memoffset, unsigned short xpos)
 #if GFX_DISPLAY_DYNAMIC
 void
 gu2_set_icon_shape64(unsigned long memoffset, unsigned long *andmask,
-    unsigned long *xormask, unsigned int lines)
+                     unsigned long *xormask, unsigned int lines)
 #else
 void
 gfx_set_icon_shape64(unsigned long memoffset, unsigned long *andmask,
-    unsigned long *xormask, unsigned int lines)
+                     unsigned long *xormask, unsigned int lines)
 #endif
 {
     unsigned short i, height;
@@ -1160,7 +1164,7 @@ gfx_set_compression_pitch(unsigned short pitch)
     /* SET REGISTER VALUE */
 
     line_delta = READ_REG32(MDC_GFX_PITCH) & 0x0000FFFF;
-    line_delta |= (((unsigned long)pitch << 13) & 0xFFFF0000);
+    line_delta |= (((unsigned long) pitch << 13) & 0xFFFF0000);
     WRITE_REG32(MDC_UNLOCK, MDC_UNLOCK_VALUE);
     WRITE_REG32(MDC_GFX_PITCH, line_delta);
     WRITE_REG32(MDC_UNLOCK, lock);
@@ -1196,7 +1200,7 @@ gfx_set_compression_size(unsigned short size)
 
     lock = READ_REG32(MDC_UNLOCK);
     buf_size = READ_REG32(MDC_LINE_SIZE) & 0xFF80FFFF;
-    buf_size |= ((((unsigned long)size >> 3) + 1) & 0x7F) << 16;
+    buf_size |= ((((unsigned long) size >> 3) + 1) & 0x7F) << 16;
     WRITE_REG32(MDC_UNLOCK, MDC_UNLOCK_VALUE);
     WRITE_REG32(MDC_LINE_SIZE, buf_size);
     WRITE_REG32(MDC_UNLOCK, lock);
@@ -1307,14 +1311,15 @@ gfx_set_display_video_size(unsigned short width, unsigned short height)
     if (yuv_420) {
         width >>= 1;
         width = (width + 7) & 0xFFF8;
-    } else {
+    }
+    else {
         width <<= 1;
         width = (width + 31) & 0xFFE0;
     }
 
     /* ONLY THE LINE SIZE IS PROGRAMMED IN THE DISPLAY CONTROLLER */
 
-    value |= ((unsigned long)width << 21);
+    value |= ((unsigned long) width << 21);
 
     /* WRITE THE REGISTER */
 
@@ -1357,11 +1362,11 @@ gfx_set_display_video_offset(unsigned long offset)
 #if GFX_DISPLAY_DYNAMIC
 void
 gu2_set_display_video_yuv_offsets(unsigned long yoffset,
-    unsigned long uoffset, unsigned long voffset)
+                                  unsigned long uoffset, unsigned long voffset)
 #else
 void
 gfx_set_display_video_yuv_offsets(unsigned long yoffset,
-    unsigned long uoffset, unsigned long voffset)
+                                  unsigned long uoffset, unsigned long voffset)
 #endif
 {
     unsigned long lock;
@@ -1431,7 +1436,7 @@ gfx_set_display_video_downscale(unsigned short srch, unsigned short dsth)
     if (dsth > srch || dsth <= (srch >> 1))
         delta = 0;
     else
-        delta = (((unsigned long)srch << 14) / (unsigned long)dsth) << 18;
+        delta = (((unsigned long) srch << 14) / (unsigned long) dsth) << 18;
 
     WRITE_REG32(MDC_UNLOCK, MDC_UNLOCK_VALUE);
     WRITE_REG32(MDC_VID_DS_DELTA, delta);
@@ -1518,8 +1523,8 @@ gfx_wait_vertical_blank(void)
 #endif
 {
     if (gfx_test_timing_active()) {
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
     }
     return (0);
 }
@@ -1549,8 +1554,8 @@ gfx_enable_panning(int x, int y)
 
     /* TEST FOR NO-WORK */
 
-    if (x >= DeltaX && x < ((int)PanelWidth + DeltaX) &&
-        y >= DeltaY && y < ((int)PanelHeight + DeltaY))
+    if (x >= DeltaX && x < ((int) PanelWidth + DeltaX) &&
+        y >= DeltaY && y < ((int) PanelHeight + DeltaY))
         return;
 
     /* ADJUST PANNING VARIABLES WHEN CURSOR EXCEEDS BOUNDARY       */
@@ -1560,14 +1565,14 @@ gfx_enable_panning(int x, int y)
     if (x < DeltaX)
         DeltaX = x;
 
-    else if (x >= (DeltaX + (int)PanelWidth))
-        DeltaX = x - (int)PanelWidth + 1;
+    else if (x >= (DeltaX + (int) PanelWidth))
+        DeltaX = x - (int) PanelWidth + 1;
 
     if (y < DeltaY)
         DeltaY = y;
 
-    else if (y >= (DeltaY + (int)PanelHeight))
-        DeltaY = y - (int)PanelHeight + 1;
+    else if (y >= (DeltaY + (int) PanelHeight))
+        DeltaY = y - (int) PanelHeight + 1;
 
     /* CALCULATE THE START OFFSET */
 
@@ -1596,11 +1601,13 @@ gfx_enable_panning(int x, int y)
 #if GFX_DISPLAY_DYNAMIC
 int
 gu2_is_panel_mode_supported(int panelResX, int panelResY,
-    unsigned short width, unsigned short height, unsigned short bpp)
+                            unsigned short width, unsigned short height,
+                            unsigned short bpp)
 #else
 int
 gfx_is_panel_mode_supported(int panelResX, int panelResY,
-    unsigned short width, unsigned short height, unsigned short bpp)
+                            unsigned short width, unsigned short height,
+                            unsigned short bpp)
 #endif
 {
     unsigned int mode;
@@ -1611,7 +1618,7 @@ gfx_is_panel_mode_supported(int panelResX, int panelResY,
             (FixedParams[mode].yres == height) &&
             (FixedParams[mode].panelresx == panelResX) &&
             (FixedParams[mode].panelresy == panelResY)) {
-            return ((int)mode);
+            return ((int) mode);
         }
     }
 
@@ -1626,19 +1633,19 @@ gfx_is_panel_mode_supported(int panelResX, int panelResY,
 #if GFX_DISPLAY_DYNAMIC
 int
 gu2_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 #else
 int
 gfx_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 #endif
 {
     unsigned int mode;
 
     ModeWidth = width;
     ModeHeight = height;
-    PanelWidth = (unsigned short)panelResX;
-    PanelHeight = (unsigned short)panelResY;
+    PanelWidth = (unsigned short) panelResX;
+    PanelHeight = (unsigned short) panelResY;
     PanelEnable = 1;
 
     /* LOOP THROUGH THE AVAILABLE MODES TO FIND A MATCH */
@@ -1652,14 +1659,16 @@ gfx_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
             FIXEDTIMINGS *fmode = &FixedParams[mode];
 
             gfx_set_display_timings(bpp, 3, fmode->hactive,
-                fmode->hblankstart, fmode->hsyncstart, fmode->hsyncend,
-                fmode->hblankend, fmode->htotal, fmode->vactive,
-                fmode->vblankstart, fmode->vsyncstart, fmode->vsyncend,
-                fmode->vblankend, fmode->vtotal, fmode->frequency);
+                                    fmode->hblankstart, fmode->hsyncstart,
+                                    fmode->hsyncend, fmode->hblankend,
+                                    fmode->htotal, fmode->vactive,
+                                    fmode->vblankstart, fmode->vsyncstart,
+                                    fmode->vsyncend, fmode->vblankend,
+                                    fmode->vtotal, fmode->frequency);
 
             return (1);
-        }                              /* end if() */
-    }                                  /* end for() */
+        }                       /* end if() */
+    }                           /* end for() */
 
     return (-1);
 }
@@ -1671,11 +1680,11 @@ gfx_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
 #if GFX_DISPLAY_DYNAMIC
 int
 gu2_set_panel_present(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 #else
 int
 gfx_set_panel_present(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 #endif
 {
     /* SET VALID BPP         */
@@ -1693,8 +1702,8 @@ gfx_set_panel_present(int panelResX, int panelResY, unsigned short width,
 
     ModeWidth = width;
     ModeHeight = height;
-    PanelWidth = (unsigned short)panelResX;
-    PanelHeight = (unsigned short)panelResY;
+    PanelWidth = (unsigned short) panelResX;
+    PanelHeight = (unsigned short) panelResY;
     PanelEnable = 1;
     gbpp = bpp;
 
@@ -1721,7 +1730,7 @@ unsigned short
 gfx_get_display_pitch(void)
 #endif
 {
-    return ((unsigned short)(READ_REG32(MDC_GFX_PITCH) & 0x0000FFFF) << 3);
+    return ((unsigned short) (READ_REG32(MDC_GFX_PITCH) & 0x0000FFFF) << 3);
 }
 
 /*----------------------------------------------------------------------------
@@ -1736,11 +1745,11 @@ gfx_get_display_pitch(void)
 #if GFX_DISPLAY_DYNAMIC
 int
 gu2_mode_frequency_supported(int xres, int yres, int bpp,
-    unsigned long frequency)
+                             unsigned long frequency)
 #else
 int
 gfx_mode_frequency_supported(int xres, int yres, int bpp,
-    unsigned long frequency)
+                             unsigned long frequency)
 #endif
 {
     unsigned int index;
@@ -1750,8 +1759,8 @@ gfx_mode_frequency_supported(int xres, int yres, int bpp,
     gfx_mode_bpp_conversion_def(bpp)
 
         for (index = 0; index < NUM_RC_DISPLAY_MODES; index++) {
-        if ((DisplayParams[index].hactive == (unsigned int)xres) &&
-            (DisplayParams[index].vactive == (unsigned int)yres) &&
+        if ((DisplayParams[index].hactive == (unsigned int) xres) &&
+            (DisplayParams[index].vactive == (unsigned int) yres) &&
             (DisplayParams[index].flags & bpp_flag) &&
             (DisplayParams[index].frequency == frequency)) {
             int hz = 0;
@@ -1790,11 +1799,11 @@ gfx_mode_frequency_supported(int xres, int yres, int bpp,
 #if GFX_DISPLAY_DYNAMIC
 int
 gu2_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                                   unsigned long frequency)
 #else
 int
 gfx_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                                   unsigned long frequency)
 #endif
 {
     unsigned int index, closematch = 0;
@@ -1810,10 +1819,10 @@ gfx_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
         /* Search the table for the closest frequency (16.16 format). */
         min = 0x7fffffff;
     for (index = 0; index < NUM_RC_DISPLAY_MODES; index++) {
-        if ((DisplayParams[index].htotal == (unsigned int)xres) &&
-            (DisplayParams[index].vtotal == (unsigned int)yres) &&
+        if ((DisplayParams[index].htotal == (unsigned int) xres) &&
+            (DisplayParams[index].vtotal == (unsigned int) yres) &&
             (DisplayParams[index].flags & bpp_flag)) {
-            diff = (long)frequency - (long)DisplayParams[index].frequency;
+            diff = (long) frequency - (long) DisplayParams[index].frequency;
             if (diff < 0)
                 diff = -diff;
 
@@ -1857,11 +1866,11 @@ gfx_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
 #if GFX_DISPLAY_DYNAMIC
 int
 gu2_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                              unsigned long frequency)
 #else
 int
 gfx_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                              unsigned long frequency)
 #endif
 {
     unsigned int index, closematch = 0;
@@ -1877,10 +1886,10 @@ gfx_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
         /* Search the table for the closest frequency (16.16 format). */
         min = 0x7fffffff;
     for (index = 0; index < NUM_RC_DISPLAY_MODES; index++) {
-        if ((DisplayParams[index].hactive == (unsigned int)xres) &&
-            (DisplayParams[index].vactive == (unsigned int)yres) &&
+        if ((DisplayParams[index].hactive == (unsigned int) xres) &&
+            (DisplayParams[index].vactive == (unsigned int) yres) &&
             (DisplayParams[index].flags & bpp_flag)) {
-            diff = (long)frequency - (long)DisplayParams[index].frequency;
+            diff = (long) frequency - (long) DisplayParams[index].frequency;
             if (diff < 0)
                 diff = -diff;
 
@@ -1922,11 +1931,11 @@ gfx_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
 #if GFX_DISPLAY_DYNAMIC
 int
 gu2_get_frequency_from_refreshrate(int xres, int yres, int bpp, int hz,
-    int *frequency)
+                                   int *frequency)
 #else
 int
 gfx_get_frequency_from_refreshrate(int xres, int yres, int bpp, int hz,
-    int *frequency)
+                                   int *frequency)
 #endif
 {
     unsigned int index;
@@ -1940,9 +1949,9 @@ gfx_get_frequency_from_refreshrate(int xres, int yres, int bpp, int hz,
 
         /* FIND THE REGISTER VALUES FOR THE DESIRED FREQUENCY */
         /* Search the table for the closest frequency (16.16 format). */
-        for (index = 0; index < NUM_RC_DISPLAY_MODES; index++) {
-        if ((DisplayParams[index].hactive == (unsigned short)xres) &&
-            (DisplayParams[index].vactive == (unsigned short)yres) &&
+    for (index = 0; index < NUM_RC_DISPLAY_MODES; index++) {
+        if ((DisplayParams[index].hactive == (unsigned short) xres) &&
+            (DisplayParams[index].vactive == (unsigned short) yres) &&
             (DisplayParams[index].flags & bpp_flag) &&
             (DisplayParams[index].flags & hz_flag)) {
             *frequency = DisplayParams[index].frequency;
@@ -1999,8 +2008,8 @@ gfx_get_display_mode(int *xres, int *yres, int *bpp, int *hz)
     gfx_mode_bpp_conversion_def(*bpp)
 
         for (mode = 0; mode < NUM_RC_DISPLAY_MODES; mode++) {
-        if ((DisplayParams[mode].hactive == (unsigned int)*xres) &&
-            (DisplayParams[mode].vactive == (unsigned int)*yres) &&
+        if ((DisplayParams[mode].hactive == (unsigned int) *xres) &&
+            (DisplayParams[mode].vactive == (unsigned int) *yres) &&
             (DisplayParams[mode].frequency == pll_freq) &&
             (DisplayParams[mode].flags & bpp_flag)) {
 
@@ -2122,7 +2131,7 @@ unsigned short
 gfx_get_hactive(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(MDC_H_ACTIVE_TIMING) & 0x0FF8) + 8));
+    return ((unsigned short) ((READ_REG32(MDC_H_ACTIVE_TIMING) & 0x0FF8) + 8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2137,7 +2146,7 @@ unsigned short
 gfx_get_hsync_start(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(MDC_H_SYNC_TIMING) & 0x0FF8) + 8));
+    return ((unsigned short) ((READ_REG32(MDC_H_SYNC_TIMING) & 0x0FF8) + 8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2152,8 +2161,8 @@ unsigned short
 gfx_get_hsync_end(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(MDC_H_SYNC_TIMING) >> 16) & 0x0FF8)
-            + 8));
+    return ((unsigned short) (((READ_REG32(MDC_H_SYNC_TIMING) >> 16) & 0x0FF8)
+                              + 8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2168,8 +2177,8 @@ unsigned short
 gfx_get_htotal(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(MDC_H_ACTIVE_TIMING) >> 16) &
-                0x0FF8) + 8));
+    return ((unsigned short) (((READ_REG32(MDC_H_ACTIVE_TIMING) >> 16) &
+                               0x0FF8) + 8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2184,7 +2193,7 @@ unsigned short
 gfx_get_vactive(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(MDC_V_ACTIVE_TIMING) & 0x07FF) + 1));
+    return ((unsigned short) ((READ_REG32(MDC_V_ACTIVE_TIMING) & 0x07FF) + 1));
 }
 
 /*---------------------------------------------------------------------------
@@ -2199,8 +2208,8 @@ unsigned short
 gfx_get_vsync_end(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(MDC_V_SYNC_TIMING) >> 16) & 0x07FF)
-            + 1));
+    return ((unsigned short) (((READ_REG32(MDC_V_SYNC_TIMING) >> 16) & 0x07FF)
+                              + 1));
 }
 
 /*---------------------------------------------------------------------------
@@ -2215,8 +2224,8 @@ unsigned short
 gfx_get_vtotal(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(MDC_V_ACTIVE_TIMING) >> 16) &
-                0x07FF) + 1));
+    return ((unsigned short) (((READ_REG32(MDC_V_ACTIVE_TIMING) >> 16) &
+                               0x07FF) + 1));
 }
 
 /*----------------------------------------------------------------------------
@@ -2275,11 +2284,11 @@ gfx_get_vline(void)
      * transitioning */
     do
         current_scan_line =
-            (unsigned short)(READ_REG32(MDC_LINE_CNT_STATUS) &
-            MDC_LNCNT_V_LINE_CNT);
+            (unsigned short) (READ_REG32(MDC_LINE_CNT_STATUS) &
+                              MDC_LNCNT_V_LINE_CNT);
     while (current_scan_line !=
-        (unsigned short)(READ_REG32(MDC_LINE_CNT_STATUS) &
-            MDC_LNCNT_V_LINE_CNT));
+           (unsigned short) (READ_REG32(MDC_LINE_CNT_STATUS) &
+                             MDC_LNCNT_V_LINE_CNT));
 
     return (current_scan_line >> 16);
 }
@@ -2332,7 +2341,7 @@ unsigned short
 gfx_get_hblank_start(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(MDC_H_BLANK_TIMING) & 0x0FF8) + 8));
+    return ((unsigned short) ((READ_REG32(MDC_H_BLANK_TIMING) & 0x0FF8) + 8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2347,8 +2356,8 @@ unsigned short
 gfx_get_hblank_end(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(MDC_H_BLANK_TIMING) >> 16) & 0x0FF8)
-            + 8));
+    return ((unsigned short) (((READ_REG32(MDC_H_BLANK_TIMING) >> 16) & 0x0FF8)
+                              + 8));
 }
 
 /*---------------------------------------------------------------------------
@@ -2363,7 +2372,7 @@ unsigned short
 gfx_get_vblank_start(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(MDC_V_BLANK_TIMING) & 0x07FF) + 1));
+    return ((unsigned short) ((READ_REG32(MDC_V_BLANK_TIMING) & 0x07FF) + 1));
 }
 
 /*---------------------------------------------------------------------------
@@ -2378,7 +2387,7 @@ unsigned short
 gfx_get_vsync_start(void)
 #endif
 {
-    return ((unsigned short)((READ_REG32(MDC_V_SYNC_TIMING) & 0x07FF) + 1));
+    return ((unsigned short) ((READ_REG32(MDC_V_SYNC_TIMING) & 0x07FF) + 1));
 }
 
 /*---------------------------------------------------------------------------
@@ -2393,8 +2402,8 @@ unsigned short
 gfx_get_vblank_end(void)
 #endif
 {
-    return ((unsigned short)(((READ_REG32(MDC_V_BLANK_TIMING) >> 16) & 0x07FF)
-            + 1));
+    return ((unsigned short) (((READ_REG32(MDC_V_BLANK_TIMING) >> 16) & 0x07FF)
+                              + 1));
 }
 
 /*----------------------------------------------------------------------------
@@ -2466,7 +2475,7 @@ gfx_get_cursor_position(void)
 #endif
 {
     return ((READ_REG32(MDC_CURSOR_X) & 0x07FF) |
-        ((READ_REG32(MDC_CURSOR_Y) << 16) & 0x07FF0000));
+            ((READ_REG32(MDC_CURSOR_Y) << 16) & 0x07FF0000));
 }
 
 /*----------------------------------------------------------------------------
@@ -2482,7 +2491,7 @@ gfx_get_cursor_clip(void)
 #endif
 {
     return (((READ_REG32(MDC_CURSOR_X) >> 11) & 0x03F) |
-        ((READ_REG32(MDC_CURSOR_Y) << 5) & 0x3F0000));
+            ((READ_REG32(MDC_CURSOR_Y) << 5) & 0x3F0000));
 }
 
 /*----------------------------------------------------------------------------
@@ -2499,7 +2508,8 @@ gfx_get_cursor_color(int color)
 {
     if (color) {
         WRITE_REG32(MDC_PAL_ADDRESS, 0x101);
-    } else {
+    }
+    else {
         WRITE_REG32(MDC_PAL_ADDRESS, 0x100);
     }
     return READ_REG32(MDC_PAL_DATA);
@@ -2617,7 +2627,7 @@ gfx_get_compression_pitch(void)
 {
     unsigned short pitch;
 
-    pitch = (unsigned short)(READ_REG32(MDC_GFX_PITCH) >> 16);
+    pitch = (unsigned short) (READ_REG32(MDC_GFX_PITCH) >> 16);
     return (pitch << 3);
 }
 
@@ -2635,7 +2645,7 @@ gfx_get_compression_size(void)
 {
     unsigned short size;
 
-    size = (unsigned short)((READ_REG32(MDC_LINE_SIZE) >> 16) & 0x7F) - 1;
+    size = (unsigned short) ((READ_REG32(MDC_LINE_SIZE) >> 16) & 0x7F) - 1;
     return ((size << 3) + 32);
 }
 
@@ -2658,7 +2668,7 @@ gfx_get_valid_bit(int line)
     offset |= line;
 
     WRITE_REG32(MDC_PHY_MEM_OFFSET, offset);
-    valid = (int)READ_REG32(MDC_DV_ACC) & 2;
+    valid = (int) READ_REG32(MDC_DV_ACC) & 2;
 
     if (valid)
         return 1;
@@ -2693,11 +2703,13 @@ gfx_get_display_video_offset(void)
 #if GFX_DISPLAY_DYNAMIC
 void
 gu2_get_display_video_yuv_offsets(unsigned long *yoffset,
-    unsigned long *uoffset, unsigned long *voffset)
+                                  unsigned long *uoffset,
+                                  unsigned long *voffset)
 #else
 void
 gfx_get_display_video_yuv_offsets(unsigned long *yoffset,
-    unsigned long *uoffset, unsigned long *voffset)
+                                  unsigned long *uoffset,
+                                  unsigned long *voffset)
 #endif
 {
     *yoffset = (READ_REG32(MDC_VID_Y_ST_OFFSET) & 0x0FFFFFFF);
@@ -2760,7 +2772,7 @@ int
 gfx_get_display_video_downscale_enable(void)
 #endif
 {
-    return ((int)((READ_REG32(MDC_GENERAL_CFG) >> 19) & 1));
+    return ((int) ((READ_REG32(MDC_GENERAL_CFG) >> 19) & 1));
 }
 
 /*---------------------------------------------------------------------------
@@ -2783,6 +2795,6 @@ gfx_get_display_video_size(void)
     return ((READ_REG32(MDC_LINE_SIZE) >> 21) & 0x000007FF);
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
 /* END OF FILE */
diff --git a/src/gfx/gfx_dcdr.c b/src/gfx/gfx_dcdr.c
index 57abe37..40a4b47 100644
--- a/src/gfx/gfx_dcdr.c
+++ b/src/gfx/gfx_dcdr.c
@@ -219,7 +219,7 @@ gfx_set_decoder_output_size(unsigned short width, unsigned short height)
  */
 int
 gfx_set_decoder_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                      unsigned short dstw, unsigned short dsth)
 {
     int status = GFX_STATUS_UNSUPPORTED;
 
@@ -409,7 +409,7 @@ gfx_get_decoder_hue(void)
     if (gfx_decoder_type == GFX_DECODER_SAA7114)
         hue = saa7114_get_decoder_hue();
 #endif
-    return ((char)hue);
+    return ((char) hue);
 }
 
 /*----------------------------------------------------------------------------
@@ -492,8 +492,8 @@ gfx_get_decoder_vbi_format(int line)
     return (format);
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
-#endif /* GFX_DECODER_DYNAMIC */
+#endif                          /* GFX_DECODER_DYNAMIC */
 
 /* END OF FILE */
diff --git a/src/gfx/gfx_defs.h b/src/gfx/gfx_defs.h
index dde8385..045128c 100644
--- a/src/gfx/gfx_defs.h
+++ b/src/gfx/gfx_defs.h
@@ -112,9 +112,9 @@
 /* ACCESS TO MSRS */
 
 void gfx_msr_asm_write(unsigned short msrReg, unsigned long msrAddr,
-    unsigned long *ptrHigh, unsigned long *ptrLow);
+                       unsigned long *ptrHigh, unsigned long *ptrLow);
 void gfx_msr_asm_read(unsigned short msrReg, unsigned long msrAddr,
-    unsigned long *ptrHigh, unsigned long *ptrLow);
+                      unsigned long *ptrHigh, unsigned long *ptrLow);
 
 #define MSR_READ( MBD_MSR_CAP, address, valueHigh_ptr, valueLow_ptr ) 	\
 	gfx_msr_asm_read( ((unsigned short)(MBD_MSR_CAP)), address, 		\
diff --git a/src/gfx/gfx_disp.c b/src/gfx/gfx_disp.c
index a1cd78f..62238b2 100644
--- a/src/gfx/gfx_disp.c
+++ b/src/gfx/gfx_disp.c
@@ -117,513 +117,513 @@ DISPLAYMODE DisplayParams[] = {
 /* 320 x 200 */
 
     {
-            GFX_MODE_70HZ |            /* refresh rate = 60  */
-            GFX_MODE_8BPP | GFX_MODE_16BPP |    /* 8 and 16 BPP valid */
-            GFX_MODE_NEG_HSYNC |       /* negative HSYNC     */
-            GFX_MODE_PIXEL_DOUBLE |    /* Double width       */
-            GFX_MODE_LINE_DOUBLE,      /* Double height      */
-            0x140, 0x288, 0x290, 0x2F0, 0x318, 0x320,   /* horizontal timings */
-            0x0C8, 0x197, 0x19C, 0x19E, 0x1BA, 0x1C1,   /* vertical timings   */
-            0x00192CCC,                /* freq = 25.175 MHz  */
-        },
+     GFX_MODE_70HZ |            /* refresh rate = 60  */
+     GFX_MODE_8BPP | GFX_MODE_16BPP |   /* 8 and 16 BPP valid */
+     GFX_MODE_NEG_HSYNC |       /* negative HSYNC     */
+     GFX_MODE_PIXEL_DOUBLE |    /* Double width       */
+     GFX_MODE_LINE_DOUBLE,      /* Double height      */
+     0x140, 0x288, 0x290, 0x2F0, 0x318, 0x320,  /* horizontal timings */
+     0x0C8, 0x197, 0x19C, 0x19E, 0x1BA, 0x1C1,  /* vertical timings   */
+     0x00192CCC,                /* freq = 25.175 MHz  */
+     },
 
 /* 320 x 240 */
 
     {
-            GFX_MODE_75HZ |            /* refresh rate = 75  */
-            GFX_MODE_8BPP | GFX_MODE_16BPP |    /* 8 and 16 BPP valid */
-            GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC |   /* negative syncs     */
-            GFX_MODE_PIXEL_DOUBLE |    /* Double width       */
-            GFX_MODE_LINE_DOUBLE,      /* Double height      */
-            0x0140, 0x0280, 0x0290, 0x02D0, 0x0348, 0x0348,
-            /* horizontal timings */
-            0x00F0, 0x01E0, 0x01E1, 0x01E4, 0x01F4, 0x01F4,
-            /* vertical timings   */
-            0x001F8000,                /* freq = 31.5 MHz    */
-        },
+     GFX_MODE_75HZ |            /* refresh rate = 75  */
+     GFX_MODE_8BPP | GFX_MODE_16BPP |   /* 8 and 16 BPP valid */
+     GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC |  /* negative syncs     */
+     GFX_MODE_PIXEL_DOUBLE |    /* Double width       */
+     GFX_MODE_LINE_DOUBLE,      /* Double height      */
+     0x0140, 0x0280, 0x0290, 0x02D0, 0x0348, 0x0348,
+     /* horizontal timings */
+     0x00F0, 0x01E0, 0x01E1, 0x01E4, 0x01F4, 0x01F4,
+     /* vertical timings   */
+     0x001F8000,                /* freq = 31.5 MHz    */
+     },
 
 /* 400 x 300 */
 
     {
-            GFX_MODE_75HZ |            /* refresh rate = 75  */
-            GFX_MODE_8BPP | GFX_MODE_16BPP |    /* 8 and 16 BPP valid */
-            GFX_MODE_PIXEL_DOUBLE |    /* Double width       */
-            GFX_MODE_LINE_DOUBLE,      /* Double height      */
-            0x0190, 0x0320, 0x0330, 0x0380, 0x0420, 0x0420,
-            /* horizontal timings */
-            0x012C, 0x0258, 0x0259, 0x025C, 0x0271, 0x0271,
-            /* vertical timings   */
-            0x00318000,                /* freq = 49.5 MHz    */
-        },
+     GFX_MODE_75HZ |            /* refresh rate = 75  */
+     GFX_MODE_8BPP | GFX_MODE_16BPP |   /* 8 and 16 BPP valid */
+     GFX_MODE_PIXEL_DOUBLE |    /* Double width       */
+     GFX_MODE_LINE_DOUBLE,      /* Double height      */
+     0x0190, 0x0320, 0x0330, 0x0380, 0x0420, 0x0420,
+     /* horizontal timings */
+     0x012C, 0x0258, 0x0259, 0x025C, 0x0271, 0x0271,
+     /* vertical timings   */
+     0x00318000,                /* freq = 49.5 MHz    */
+     },
 
 /* 512 x 384 */
 
     {
-            GFX_MODE_75HZ |            /* refresh rate = 75  */
-            GFX_MODE_8BPP | GFX_MODE_16BPP |    /* 8 and 16 BPP valid */
-            GFX_MODE_PIXEL_DOUBLE |    /* Double width       */
-            GFX_MODE_LINE_DOUBLE,      /* Double height      */
-            0x0200, 0x0400, 0x0410, 0x0470, 0x0520, 0x0520,
-            /* horizontal timings */
-            0x0180, 0x0300, 0x0301, 0x0304, 0x0320, 0x0320,
-            /* vertical timings   */
-            0x004EC000,                /* freq = 78.75 MHz   */
-        },
+     GFX_MODE_75HZ |            /* refresh rate = 75  */
+     GFX_MODE_8BPP | GFX_MODE_16BPP |   /* 8 and 16 BPP valid */
+     GFX_MODE_PIXEL_DOUBLE |    /* Double width       */
+     GFX_MODE_LINE_DOUBLE,      /* Double height      */
+     0x0200, 0x0400, 0x0410, 0x0470, 0x0520, 0x0520,
+     /* horizontal timings */
+     0x0180, 0x0300, 0x0301, 0x0304, 0x0320, 0x0320,
+     /* vertical timings   */
+     0x004EC000,                /* freq = 78.75 MHz   */
+     },
 
 /* 640 x 400 */
 
     {
-            GFX_MODE_70HZ |            /* refresh rate = 60  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC,
-            /* negative HSYNC     */
-            0x280, 0x288, 0x290, 0x2F0, 0x318, 0x320,   /* horizontal timings */
-            0x190, 0x197, 0x19C, 0x19E, 0x1BA, 0x1C1,   /* vertical timings   */
-            0x00192CCC,                /* freq = 25.175 MHz  */
-        },
+     GFX_MODE_70HZ |            /* refresh rate = 60  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC,
+     /* negative HSYNC     */
+     0x280, 0x288, 0x290, 0x2F0, 0x318, 0x320,  /* horizontal timings */
+     0x190, 0x197, 0x19C, 0x19E, 0x1BA, 0x1C1,  /* vertical timings   */
+     0x00192CCC,                /* freq = 25.175 MHz  */
+     },
 
 /* 640x480 */
 
     {
-            GFX_MODE_60HZ |            /* refresh rate = 60  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC,  /* negative syncs     */
-            0x0280, 0x0288, 0x0290, 0x02E8, 0x0318, 0x0320,
-            /* horizontal timings */
-            0x01E0, 0x01E8, 0x01EA, 0x01EC, 0x0205, 0x020D,
-            /* vertical timings   */
-            0x00192CCC,                /* freq = 25.175 MHz  */
-        },
+     GFX_MODE_60HZ |            /* refresh rate = 60  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC, /* negative syncs     */
+     0x0280, 0x0288, 0x0290, 0x02E8, 0x0318, 0x0320,
+     /* horizontal timings */
+     0x01E0, 0x01E8, 0x01EA, 0x01EC, 0x0205, 0x020D,
+     /* vertical timings   */
+     0x00192CCC,                /* freq = 25.175 MHz  */
+     },
 
     {
-            GFX_MODE_70HZ |            /* refresh rate = 60  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0280, 0x0280, 0x0298, 0x02D8, 0x0330, 0x0330,
-            /* horizontal timings */
-            0x01E0, 0x01E0, 0x01E2, 0x01E5, 0x01F4, 0x01F4,
-            /* vertical timings   */
-            0x001C8F5C,                /* freq = 28.560 MHz  */
-        },
+     GFX_MODE_70HZ |            /* refresh rate = 60  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0280, 0x0280, 0x0298, 0x02D8, 0x0330, 0x0330,
+     /* horizontal timings */
+     0x01E0, 0x01E0, 0x01E2, 0x01E5, 0x01F4, 0x01F4,
+     /* vertical timings   */
+     0x001C8F5C,                /* freq = 28.560 MHz  */
+     },
 
     {
-            GFX_MODE_72HZ |            /* refresh rate = 72  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC,  /* negative syncs     */
-            0x0280, 0x0288, 0x0298, 0x02c0, 0x0338, 0x0340,
-            /* horizontal timings */
-            0x01e0, 0x01e8, 0x01e9, 0x01ec, 0x0200, 0x0208,
-            /* vertical timings   */
-            0x001F8000,                /* freq = 31.5 MHz    */
-        },
+     GFX_MODE_72HZ |            /* refresh rate = 72  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC, /* negative syncs     */
+     0x0280, 0x0288, 0x0298, 0x02c0, 0x0338, 0x0340,
+     /* horizontal timings */
+     0x01e0, 0x01e8, 0x01e9, 0x01ec, 0x0200, 0x0208,
+     /* vertical timings   */
+     0x001F8000,                /* freq = 31.5 MHz    */
+     },
 
     {
-            GFX_MODE_75HZ |            /* refresh rate = 75  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC,  /* negative syncs     */
-            0x0280, 0x0280, 0x0290, 0x02D0, 0x0348, 0x0348,
-            /* horizontal timings */
-            0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01F4, 0x01F4,
-            /* vertical timings   */
-            0x001F8000,                /* freq = 31.5 MHz    */
-        },
+     GFX_MODE_75HZ |            /* refresh rate = 75  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC, /* negative syncs     */
+     0x0280, 0x0280, 0x0290, 0x02D0, 0x0348, 0x0348,
+     /* horizontal timings */
+     0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01F4, 0x01F4,
+     /* vertical timings   */
+     0x001F8000,                /* freq = 31.5 MHz    */
+     },
 
     {
-            GFX_MODE_85HZ |            /* refresh rate = 85  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC,  /* negative syncs     */
-            0x0280, 0x0280, 0x02B8, 0x02F0, 0x0340, 0x0340,
-            /* horizontal timings */
-            0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FD, 0x01FD,
-            /* vertical timings   */
-            0x00240000,                /* freq = 36.0 MHz    */
-        },
+     GFX_MODE_85HZ |            /* refresh rate = 85  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC, /* negative syncs     */
+     0x0280, 0x0280, 0x02B8, 0x02F0, 0x0340, 0x0340,
+     /* horizontal timings */
+     0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FD, 0x01FD,
+     /* vertical timings   */
+     0x00240000,                /* freq = 36.0 MHz    */
+     },
 
     {
-            GFX_MODE_90HZ |            /* refresh rate = 90  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0280, 0x0280, 0x02A0, 0x02E0, 0x0340, 0x0340,
-            /* horizontal timings */
-            0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FA, 0x01FA,
-            /* vertical timings   */
-            0x0025E395,                /* freq = 37.889 MHz  */
-        },
+     GFX_MODE_90HZ |            /* refresh rate = 90  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0280, 0x0280, 0x02A0, 0x02E0, 0x0340, 0x0340,
+     /* horizontal timings */
+     0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FA, 0x01FA,
+     /* vertical timings   */
+     0x0025E395,                /* freq = 37.889 MHz  */
+     },
 
     {
-            GFX_MODE_100HZ |           /* refresh rate = 100 */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0280, 0x0280, 0x02A8, 0x02E8, 0x0350, 0x0350,
-            /* horizontal timings */
-            0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FD, 0x01FD,
-            /* vertical timings   */
-            0x002B29BA,                /* freq = 43.163 MHz  */
-        },
+     GFX_MODE_100HZ |           /* refresh rate = 100 */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0280, 0x0280, 0x02A8, 0x02E8, 0x0350, 0x0350,
+     /* horizontal timings */
+     0x01E0, 0x01E0, 0x01E1, 0x01E4, 0x01FD, 0x01FD,
+     /* vertical timings   */
+     0x002B29BA,                /* freq = 43.163 MHz  */
+     },
 
 /* 800x600 */
 
     {
-            GFX_MODE_56HZ |            /* refresh rate = 56  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0320, 0x0320, 0x0338, 0x0380, 0x0400, 0x0400,
-            /* horizontal timings */
-            0x0258, 0x0258, 0x0259, 0x025B, 0x0271, 0x0271,
-            /* vertical timings   */
-            0x00240000,                /* freq = 36.00 MHz   */
-        },
+     GFX_MODE_56HZ |            /* refresh rate = 56  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0320, 0x0320, 0x0338, 0x0380, 0x0400, 0x0400,
+     /* horizontal timings */
+     0x0258, 0x0258, 0x0259, 0x025B, 0x0271, 0x0271,
+     /* vertical timings   */
+     0x00240000,                /* freq = 36.00 MHz   */
+     },
 
     {
-            GFX_MODE_60HZ |            /* refresh rate = 60  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0320, 0x0328, 0x0348, 0x03D0, 0x0418, 0x0420,
-            /* horizontal timings */
-            0x0258, 0x0258, 0x0259, 0x025D, 0x0274, 0x0274,
-            /* vertical timings   */
-            0x00280000,                /* freq = 40.00 MHz   */
-        },
+     GFX_MODE_60HZ |            /* refresh rate = 60  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0320, 0x0328, 0x0348, 0x03D0, 0x0418, 0x0420,
+     /* horizontal timings */
+     0x0258, 0x0258, 0x0259, 0x025D, 0x0274, 0x0274,
+     /* vertical timings   */
+     0x00280000,                /* freq = 40.00 MHz   */
+     },
 
     {
-            GFX_MODE_70HZ |            /* refresh rate = 70  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0320, 0x0320, 0x0348, 0x0398, 0x0410, 0x0410,
-            /* horizontal timings */
-            0x0258, 0x0258, 0x025c, 0x025F, 0x0274, 0x0274,
-            /* vertical timings   */
-            0x002DB851,                /* freq = 45.72 MHz   */
-        },
+     GFX_MODE_70HZ |            /* refresh rate = 70  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0320, 0x0320, 0x0348, 0x0398, 0x0410, 0x0410,
+     /* horizontal timings */
+     0x0258, 0x0258, 0x025c, 0x025F, 0x0274, 0x0274,
+     /* vertical timings   */
+     0x002DB851,                /* freq = 45.72 MHz   */
+     },
 
     {
-            GFX_MODE_72HZ |            /* refresh rate = 72  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0320, 0x0320, 0x0358, 0x03D0, 0x0410, 0x0410,
-            /* horizontal timings */
-            0x0258, 0x0258, 0x027D, 0x0283, 0x029A, 0x029A,
-            /* vertical timings   */
-            0x00320000,                /* freq = 49.5 MHz    */
-        },
+     GFX_MODE_72HZ |            /* refresh rate = 72  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0320, 0x0320, 0x0358, 0x03D0, 0x0410, 0x0410,
+     /* horizontal timings */
+     0x0258, 0x0258, 0x027D, 0x0283, 0x029A, 0x029A,
+     /* vertical timings   */
+     0x00320000,                /* freq = 49.5 MHz    */
+     },
 
     {
-            GFX_MODE_75HZ |            /* refresh rate = 75  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0320, 0x0320, 0x0330, 0x0380, 0x0420, 0x0420,
-            /* horizontal timings */
-            0x0258, 0x0258, 0x0259, 0x025C, 0x0271, 0x0271,
-            /* vertical timings   */
-            0x00318000,                /* freq = 49.5 MHz    */
-        },
+     GFX_MODE_75HZ |            /* refresh rate = 75  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0320, 0x0320, 0x0330, 0x0380, 0x0420, 0x0420,
+     /* horizontal timings */
+     0x0258, 0x0258, 0x0259, 0x025C, 0x0271, 0x0271,
+     /* vertical timings   */
+     0x00318000,                /* freq = 49.5 MHz    */
+     },
 
     {
-            GFX_MODE_85HZ |            /* refresh rate = 85  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0320, 0x0320, 0x0340, 0x0380, 0x0418, 0x0418,
-            /* horizontal timings */
-            0x0258, 0x0258, 0x0259, 0x025C, 0x0277, 0x0277,
-            /* vertical timings   */
-            0x00384000,                /* freq = 56.25 MHz   */
-        },
+     GFX_MODE_85HZ |            /* refresh rate = 85  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0320, 0x0320, 0x0340, 0x0380, 0x0418, 0x0418,
+     /* horizontal timings */
+     0x0258, 0x0258, 0x0259, 0x025C, 0x0277, 0x0277,
+     /* vertical timings   */
+     0x00384000,                /* freq = 56.25 MHz   */
+     },
 
     {
-            GFX_MODE_90HZ |            /* refresh rate = 90  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0320, 0x0320, 0x0348, 0x03A0, 0x0420, 0x0420,
-            /* horizontal timings */
-            0x0258, 0x0258, 0x0259, 0x025C, 0x0278, 0x0278,
-            /* vertical timings   */
-            0x003C10A3,                /* freq = 60.065 MHz   */
-        },
+     GFX_MODE_90HZ |            /* refresh rate = 90  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0320, 0x0320, 0x0348, 0x03A0, 0x0420, 0x0420,
+     /* horizontal timings */
+     0x0258, 0x0258, 0x0259, 0x025C, 0x0278, 0x0278,
+     /* vertical timings   */
+     0x003C10A3,                /* freq = 60.065 MHz   */
+     },
 
     {
-            GFX_MODE_100HZ |           /* refresh rate = 100 */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0320, 0x0320, 0x0350, 0x03A8, 0x0430, 0x0430,
-            /* horizontal timings */
-            0x0258, 0x0258, 0x0259, 0x025C, 0x0277, 0x027C,
-            /* vertical timings   */
-            0x00442DD2,                /* freq = 68.179 MHz  */
-        },
+     GFX_MODE_100HZ |           /* refresh rate = 100 */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0320, 0x0320, 0x0350, 0x03A8, 0x0430, 0x0430,
+     /* horizontal timings */
+     0x0258, 0x0258, 0x0259, 0x025C, 0x0277, 0x027C,
+     /* vertical timings   */
+     0x00442DD2,                /* freq = 68.179 MHz  */
+     },
 
 /* 1024x768 */
 
     {
-            GFX_MODE_60HZ |            /* refresh rate = 60  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC,  /* negative syncs     */
-            0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
-            /* horizontal timings */
-            0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
-            /* vertical timings   */
-            0x00410000,                /* freq = 65.00 MHz   */
-        },
+     GFX_MODE_60HZ |            /* refresh rate = 60  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC, /* negative syncs     */
+     0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
+     /* horizontal timings */
+     0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
+     /* vertical timings   */
+     0x00410000,                /* freq = 65.00 MHz   */
+     },
 
     {
-            GFX_MODE_70HZ |            /* refresh rate = 70  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC,  /* negative syncs     */
-            0x0400, 0x0400, 0x0418, 0x04A0, 0x0530, 0x0530,
-            /* horizontal timings */
-            0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
-            /* vertical timings   */
-            0x004B0000,                /* freq = 75.00 MHz   */
-        },
+     GFX_MODE_70HZ |            /* refresh rate = 70  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP | GFX_MODE_NEG_HSYNC | GFX_MODE_NEG_VSYNC, /* negative syncs     */
+     0x0400, 0x0400, 0x0418, 0x04A0, 0x0530, 0x0530,
+     /* horizontal timings */
+     0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
+     /* vertical timings   */
+     0x004B0000,                /* freq = 75.00 MHz   */
+     },
 
     {
-            GFX_MODE_72HZ |            /* refresh rate = 72  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0400, 0x0400, 0x0438, 0x04A8, 0x0550, 0x0550,
-            /* horizontal timings */
-            0x0300, 0x0300, 0x0304, 0x0307, 0x0324, 0x0324,
-            /* vertical timings   */
-            0x004EC000,                /* freq = 78.75 MHz   */
-        },
+     GFX_MODE_72HZ |            /* refresh rate = 72  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0400, 0x0400, 0x0438, 0x04A8, 0x0550, 0x0550,
+     /* horizontal timings */
+     0x0300, 0x0300, 0x0304, 0x0307, 0x0324, 0x0324,
+     /* vertical timings   */
+     0x004EC000,                /* freq = 78.75 MHz   */
+     },
 
     {
-            GFX_MODE_75HZ |            /* refresh rate = 75  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0400, 0x0400, 0x0410, 0x0470, 0x0520, 0x0520,
-            /* horizontal timings */
-            0x0300, 0x0300, 0x0301, 0x0304, 0x0320, 0x0320,
-            /* vertical timings   */
-            0x004EC000,                /* freq = 78.75 MHz   */
-        },
+     GFX_MODE_75HZ |            /* refresh rate = 75  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0400, 0x0400, 0x0410, 0x0470, 0x0520, 0x0520,
+     /* horizontal timings */
+     0x0300, 0x0300, 0x0301, 0x0304, 0x0320, 0x0320,
+     /* vertical timings   */
+     0x004EC000,                /* freq = 78.75 MHz   */
+     },
 
     {
-            GFX_MODE_85HZ |            /* refresh rate = 85  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0400, 0x0400, 0x0430, 0x0490, 0x0560, 0x0560,
-            /* horizontal timings */
-            0x0300, 0x0300, 0x0301, 0x0304, 0x0328, 0x0328,
-            /* vertical timings   */
-            0x005E8000,                /* freq = 94.50 MHz   */
-        },
+     GFX_MODE_85HZ |            /* refresh rate = 85  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0400, 0x0400, 0x0430, 0x0490, 0x0560, 0x0560,
+     /* horizontal timings */
+     0x0300, 0x0300, 0x0301, 0x0304, 0x0328, 0x0328,
+     /* vertical timings   */
+     0x005E8000,                /* freq = 94.50 MHz   */
+     },
 
     {
-            GFX_MODE_90HZ |            /* refresh rate = 90  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0400, 0x0400, 0x0440, 0x04B0, 0x0560, 0x0560,
-            /* horizontal timings */
-            0x0300, 0x0300, 0x0301, 0x0304, 0x0329, 0x0329,
-            /* vertical timings   */
-            0x00642FDF,                /* freq = 100.187 MHz */
-        },
+     GFX_MODE_90HZ |            /* refresh rate = 90  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0400, 0x0400, 0x0440, 0x04B0, 0x0560, 0x0560,
+     /* horizontal timings */
+     0x0300, 0x0300, 0x0301, 0x0304, 0x0329, 0x0329,
+     /* vertical timings   */
+     0x00642FDF,                /* freq = 100.187 MHz */
+     },
 
     {
-            GFX_MODE_100HZ |           /* refresh rate = 100 */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0400, 0x0400, 0x0448, 0x04B8, 0x0570, 0x0570,
-            /* horizontal timings */
-            0x0300, 0x0300, 0x0301, 0x0304, 0x032E, 0x032E,
-            /* vertical timings   */
-            0x00714F1A,                /* freq = 113.309 MHz */
-        },
+     GFX_MODE_100HZ |           /* refresh rate = 100 */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0400, 0x0400, 0x0448, 0x04B8, 0x0570, 0x0570,
+     /* horizontal timings */
+     0x0300, 0x0300, 0x0301, 0x0304, 0x032E, 0x032E,
+     /* vertical timings   */
+     0x00714F1A,                /* freq = 113.309 MHz */
+     },
 
 /* 1152x864 */
 
     {
-            GFX_MODE_60HZ |            /* refresh rate = 60  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0480, 0x0480, 0x04C0, 0x0538, 0x05F0, 0x05F0,
-            /* horizontal timings */
-            0x0360, 0x0360, 0x0361, 0x0364, 0x037F, 0x037F,
-            /* vertical timings   */
-            0x00519999,                /* freq = 81.60 MHz  */
-        },
+     GFX_MODE_60HZ |            /* refresh rate = 60  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0480, 0x0480, 0x04C0, 0x0538, 0x05F0, 0x05F0,
+     /* horizontal timings */
+     0x0360, 0x0360, 0x0361, 0x0364, 0x037F, 0x037F,
+     /* vertical timings   */
+     0x00519999,                /* freq = 81.60 MHz  */
+     },
 
     {
-            GFX_MODE_70HZ |            /* refresh rate = 70  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0480, 0x0480, 0x04C8, 0x0540, 0x0600, 0x0600,
-            /* horizontal timings */
-            0x0360, 0x0360, 0x0368, 0x036B, 0x038B, 0x038B,
-            /* vertical timings   */
-            0x00618560,                /* freq = 97.521 MHz  */
-        },
+     GFX_MODE_70HZ |            /* refresh rate = 70  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0480, 0x0480, 0x04C8, 0x0540, 0x0600, 0x0600,
+     /* horizontal timings */
+     0x0360, 0x0360, 0x0368, 0x036B, 0x038B, 0x038B,
+     /* vertical timings   */
+     0x00618560,                /* freq = 97.521 MHz  */
+     },
 
     {
-            GFX_MODE_72HZ |            /* refresh rate = 70  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0480, 0x0480, 0x04C8, 0x0548, 0x0610, 0x0610,
-            /* horizontal timings */
-            0x0360, 0x0360, 0x0367, 0x036A, 0x038B, 0x038B,
-            /* vertical timings   */
-            0x00656B85,                /* freq = 101.42 MHz  */
-        },
+     GFX_MODE_72HZ |            /* refresh rate = 70  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0480, 0x0480, 0x04C8, 0x0548, 0x0610, 0x0610,
+     /* horizontal timings */
+     0x0360, 0x0360, 0x0367, 0x036A, 0x038B, 0x038B,
+     /* vertical timings   */
+     0x00656B85,                /* freq = 101.42 MHz  */
+     },
 
     {
-            GFX_MODE_75HZ |            /* refresh rate = 75  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0480, 0x0480, 0x04C0, 0x0540, 0x0640, 0x0640,
-            /* horizontal timings */
-            0x0360, 0x0360, 0x0361, 0x0364, 0x0384, 0x0384,
-            /* vertical timings   */
-            0x006C0000,                /* freq = 108.00 MHz  */
-        },
+     GFX_MODE_75HZ |            /* refresh rate = 75  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0480, 0x0480, 0x04C0, 0x0540, 0x0640, 0x0640,
+     /* horizontal timings */
+     0x0360, 0x0360, 0x0361, 0x0364, 0x0384, 0x0384,
+     /* vertical timings   */
+     0x006C0000,                /* freq = 108.00 MHz  */
+     },
 
     {
-            GFX_MODE_85HZ |            /* refresh rate = 85  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0480, 0x0480, 0x04C8, 0x0548, 0x0610, 0x0610,
-            /* horizontal timings */
-            0x0360, 0x0360, 0x0363, 0x0366, 0x038B, 0x038B,
-            /* vertical timings   */
-            0x0077A666,                /* freq = 119.65 MHz  */
-        },
+     GFX_MODE_85HZ |            /* refresh rate = 85  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0480, 0x0480, 0x04C8, 0x0548, 0x0610, 0x0610,
+     /* horizontal timings */
+     0x0360, 0x0360, 0x0363, 0x0366, 0x038B, 0x038B,
+     /* vertical timings   */
+     0x0077A666,                /* freq = 119.65 MHz  */
+     },
 
     {
-            GFX_MODE_90HZ |            /* refresh rate = 90  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0480, 0x0480, 0x04D0, 0x0550, 0x0620, 0x0620,
-            /* horizontal timings */
-            0x0360, 0x0360, 0x0363, 0x0366, 0x038E, 0x038E,
-            /* vertical timings   */
-            0x00806666,                /* freq = 128.40 MHz  */
-        },
+     GFX_MODE_90HZ |            /* refresh rate = 90  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0480, 0x0480, 0x04D0, 0x0550, 0x0620, 0x0620,
+     /* horizontal timings */
+     0x0360, 0x0360, 0x0363, 0x0366, 0x038E, 0x038E,
+     /* vertical timings   */
+     0x00806666,                /* freq = 128.40 MHz  */
+     },
 
     {
-            GFX_MODE_100HZ |           /* refresh rate = 100 */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0480, 0x0480, 0x04D0, 0x0550, 0x0620, 0x0620,
-            /* horizontal timings */
-            0x0360, 0x0360, 0x0365, 0x0368, 0x0398, 0x0398,
-            /* vertical timings   */
-            0x00906147,                /* freq = 144.38 MHz  */
-        },
+     GFX_MODE_100HZ |           /* refresh rate = 100 */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0480, 0x0480, 0x04D0, 0x0550, 0x0620, 0x0620,
+     /* horizontal timings */
+     0x0360, 0x0360, 0x0365, 0x0368, 0x0398, 0x0398,
+     /* vertical timings   */
+     0x00906147,                /* freq = 144.38 MHz  */
+     },
 
 /* 1280x1024 */
 
     {
-            GFX_MODE_60HZ |            /* refresh rate = 60  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0500, 0x0500, 0x0530, 0x05A0, 0x0698, 0x0698,
-            /* horizontal timings */
-            0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,
-            /* vertical timings   */
-            0x006C0000,                /* freq = 108.0 MHz   */
-        },
+     GFX_MODE_60HZ |            /* refresh rate = 60  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0500, 0x0500, 0x0530, 0x05A0, 0x0698, 0x0698,
+     /* horizontal timings */
+     0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,
+     /* vertical timings   */
+     0x006C0000,                /* freq = 108.0 MHz   */
+     },
 
     {
-            GFX_MODE_70HZ |            /* refresh rate = 70  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0500, 0x0500, 0x0558, 0x05E0, 0x06C0, 0x06C0,
-            /* horizontal timings */
-            0x0400, 0x0400, 0x040A, 0x040D, 0x0433, 0x0433,
-            /* vertical timings   */
-            0x00821999,                /* freq = 130.1 MHz   */
-        },
+     GFX_MODE_70HZ |            /* refresh rate = 70  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0500, 0x0500, 0x0558, 0x05E0, 0x06C0, 0x06C0,
+     /* horizontal timings */
+     0x0400, 0x0400, 0x040A, 0x040D, 0x0433, 0x0433,
+     /* vertical timings   */
+     0x00821999,                /* freq = 130.1 MHz   */
+     },
 
     {
-            GFX_MODE_72HZ |            /* refresh rate = 72  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0500, 0x0500, 0x0558, 0x05E0, 0x06C0, 0x06C0,
-            /* horizontal timings */
-            0x0400, 0x0400, 0x0407, 0x040A, 0x0431, 0x0431,
-            /* vertical timings   */
-            0x00858000,                /* freq = 133.5 MHz   */
-        },
+     GFX_MODE_72HZ |            /* refresh rate = 72  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0500, 0x0500, 0x0558, 0x05E0, 0x06C0, 0x06C0,
+     /* horizontal timings */
+     0x0400, 0x0400, 0x0407, 0x040A, 0x0431, 0x0431,
+     /* vertical timings   */
+     0x00858000,                /* freq = 133.5 MHz   */
+     },
 
     {
-            GFX_MODE_75HZ |            /* refresh rate = 75  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0500, 0x0500, 0x0510, 0x05A0, 0x0698, 0x0698,
-            /* horizontal timings */
-            0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,
-            /* vertical timings   */
-            0x00870000,                /* freq = 135.0 MHz   */
-        },
+     GFX_MODE_75HZ |            /* refresh rate = 75  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0500, 0x0500, 0x0510, 0x05A0, 0x0698, 0x0698,
+     /* horizontal timings */
+     0x0400, 0x0400, 0x0401, 0x0404, 0x042A, 0x042A,
+     /* vertical timings   */
+     0x00870000,                /* freq = 135.0 MHz   */
+     },
 
     {
-            GFX_MODE_85HZ |            /* refresh rate = 85  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0500, 0x0500, 0x0540, 0x05E0, 0x06C0, 0x06C0,
-            /* horizontal timings */
-            0x0400, 0x0400, 0x0401, 0x0404, 0x0430, 0x0430,
-            /* vertical timings   */
-            0x009D8000,                /* freq = 157.5 MHz   */
-        },
+     GFX_MODE_85HZ |            /* refresh rate = 85  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0500, 0x0500, 0x0540, 0x05E0, 0x06C0, 0x06C0,
+     /* horizontal timings */
+     0x0400, 0x0400, 0x0401, 0x0404, 0x0430, 0x0430,
+     /* vertical timings   */
+     0x009D8000,                /* freq = 157.5 MHz   */
+     },
 
     {
-            GFX_MODE_90HZ |            /* refresh rate = 90  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0500, 0x0500, 0x0560, 0x05E8, 0x06D0, 0x06D0,
-            /* horizontal timings */
-            0x0400, 0x0400, 0x0401, 0x0404, 0x0436, 0x0436,
-            /* vertical timings   */
-            0x00A933F7,                /* freq = 169.203 MHz */
-        },
+     GFX_MODE_90HZ |            /* refresh rate = 90  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0500, 0x0500, 0x0560, 0x05E8, 0x06D0, 0x06D0,
+     /* horizontal timings */
+     0x0400, 0x0400, 0x0401, 0x0404, 0x0436, 0x0436,
+     /* vertical timings   */
+     0x00A933F7,                /* freq = 169.203 MHz */
+     },
 
     {
-            GFX_MODE_100HZ |           /* refresh rate = 100 */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0500, 0x0500, 0x0560, 0x05F0, 0x06E0, 0x06E0,
-            /* horizontal timings */
-            0x0400, 0x0400, 0x0401, 0x0404, 0x043D, 0x043D,
-            /* vertical timings   */
-            0x00BEF5C2,                /* freq = 190.96 MHz  */
-        },
+     GFX_MODE_100HZ |           /* refresh rate = 100 */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0500, 0x0500, 0x0560, 0x05F0, 0x06E0, 0x06E0,
+     /* horizontal timings */
+     0x0400, 0x0400, 0x0401, 0x0404, 0x043D, 0x043D,
+     /* vertical timings   */
+     0x00BEF5C2,                /* freq = 190.96 MHz  */
+     },
 
 /*********************************/
 /* BEGIN REDCLOUD-SPECIFIC MODES */
@@ -632,64 +632,64 @@ DISPLAYMODE DisplayParams[] = {
 /* 1600 x 1200 */
 
     {
-            GFX_MODE_60HZ |            /* refresh rate = 60  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,
-            /* horizontal timings */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,
-            /* vertical timings   */
-            0x00A20000,                /* freq = 162.0 MHz   */
-        },
+     GFX_MODE_60HZ |            /* refresh rate = 60  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,
+     /* horizontal timings */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,
+     /* vertical timings   */
+     0x00A20000,                /* freq = 162.0 MHz   */
+     },
 
     {
-            GFX_MODE_70HZ |            /* refresh rate = 70  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,
-            /* horizontal timings */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,
-            /* vertical timings   */
-            0x00BD0000,                /* freq = 189.0 MHz   */
-        },
+     GFX_MODE_70HZ |            /* refresh rate = 70  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,
+     /* horizontal timings */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,
+     /* vertical timings   */
+     0x00BD0000,                /* freq = 189.0 MHz   */
+     },
 
     {
-            GFX_MODE_72HZ |            /* refresh rate = 72  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0640, 0x0640, 0x06B0, 0x0760, 0x0880, 0x0880,
-            /* horizontal timings */
-            0x04B0, 0x04B0, 0x04BD, 0x04C0, 0x04EF, 0x04EF,
-            /* vertical timings   */
-            0x00C60000,                /* freq = 198.0 MHz   */
-        },
+     GFX_MODE_72HZ |            /* refresh rate = 72  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0640, 0x0640, 0x06B0, 0x0760, 0x0880, 0x0880,
+     /* horizontal timings */
+     0x04B0, 0x04B0, 0x04BD, 0x04C0, 0x04EF, 0x04EF,
+     /* vertical timings   */
+     0x00C60000,                /* freq = 198.0 MHz   */
+     },
 
     {
-            GFX_MODE_75HZ |            /* refresh rate = 75  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,
-            /* horizontal timings */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,
-            /* vertical timings   */
-            0x00CA8000,                /* freq = 202.5 MHz   */
-        },
+     GFX_MODE_75HZ |            /* refresh rate = 75  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,
+     /* horizontal timings */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,
+     /* vertical timings   */
+     0x00CA8000,                /* freq = 202.5 MHz   */
+     },
 
     {
-            GFX_MODE_85HZ |            /* refresh rate = 85  */
-            GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
-            /* all BPP valid      */
-            GFX_MODE_16BPP | GFX_MODE_24BPP,
-            0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,
-            /* horizontal timings */
-            0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,
-            /* vertical timings   */
-            0x00E58000,                /* freq = 229.5 MHz   */
-        },
+     GFX_MODE_85HZ |            /* refresh rate = 85  */
+     GFX_MODE_8BPP | GFX_MODE_12BPP | GFX_MODE_15BPP |
+     /* all BPP valid      */
+     GFX_MODE_16BPP | GFX_MODE_24BPP,
+     0x0640, 0x0640, 0x0680, 0x0740, 0x0870, 0x0870,
+     /* horizontal timings */
+     0x04B0, 0x04B0, 0x04B1, 0x04B4, 0x04E2, 0x04E2,
+     /* vertical timings   */
+     0x00E58000,                /* freq = 229.5 MHz   */
+     },
 };
 
 /* UPDATE THIS VARIABLE WHENEVER NEW REDCLOUD-SPECIFIC MODES ARE ADDED */
@@ -702,145 +702,145 @@ DISPLAYMODE DisplayParams[] = {
 FIXEDTIMINGS FixedParams[] = {
 /* 640x480 Panel */
     {640, 480, 640, 480,
-            0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
-            0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
-            0x00192CCC,
-        },
+     0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
+     0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
+     0x00192CCC,
+     },
 
     {640, 480, 800, 600,
-            0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
-            0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
-            0x00192CCC,
-        },
+     0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
+     0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
+     0x00192CCC,
+     },
 
     {640, 480, 1024, 768,
-            0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
-            0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
-            0x00192CCC,
-        },
+     0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
+     0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
+     0x00192CCC,
+     },
 
     {640, 480, 1152, 864,
-            0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
-            0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
-            0x00192CCC,
-        },
+     0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
+     0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
+     0x00192CCC,
+     },
 
     {640, 480, 1280, 1024,
-            0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
-            0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
-            0x00192CCC,
-        },
+     0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
+     0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
+     0x00192CCC,
+     },
 
     {640, 480, 1600, 1200,
-            0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
-            0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
-            0x00192CCC,
-        },
+     0x0280, 0x0280, 0x0290, 0x02E8, 0x0318, 0x0320,
+     0x01E0, 0x01E0, 0x01EA, 0x01EC, 0x0205, 0x020D,
+     0x00192CCC,
+     },
 
 /* 800x600 Panel */
     {800, 600, 640, 480,
-            0x0280, 0x2d0, 0x2f8, 0x378, 0x3d0, 0x420,
-            0x1e0, 0x21c, 0x21d, 0x221, 0x238, 0x274,
-            0x00280000,
-        },
+     0x0280, 0x2d0, 0x2f8, 0x378, 0x3d0, 0x420,
+     0x1e0, 0x21c, 0x21d, 0x221, 0x238, 0x274,
+     0x00280000,
+     },
 
     {800, 600, 800, 600,
-            0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
-            0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
-            0x00280000,
-        },
+     0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
+     0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
+     0x00280000,
+     },
 
     {800, 600, 1024, 768,
-            0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
-            0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
-            0x00280000,
-        },
+     0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
+     0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
+     0x00280000,
+     },
 
     {800, 600, 1152, 864,
-            0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
-            0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
-            0x00280000,
-        },
+     0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
+     0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
+     0x00280000,
+     },
 
     {800, 600, 1280, 1024,
-            0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
-            0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
-            0x00280000,
-        },
+     0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
+     0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
+     0x00280000,
+     },
 
     {800, 600, 1600, 1200,
-            0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
-            0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
-            0x00280000,
-        },
+     0x320, 0x320, 0x348, 0x3c8, 0x420, 0x420,
+     0x258, 0x258, 0x259, 0x25d, 0x274, 0x274,
+     0x00280000,
+     },
 
 /* 1024x768 panel */
     {1024, 768, 640, 480,
-            0x0280, 0x340, 0x368, 0x3e8, 0x480, 0x540,
-            0x1e0, 0x270, 0x271, 0x275, 0x296, 0x326,
-            0x00410000,
-        },
+     0x0280, 0x340, 0x368, 0x3e8, 0x480, 0x540,
+     0x1e0, 0x270, 0x271, 0x275, 0x296, 0x326,
+     0x00410000,
+     },
 
     {1024, 768, 800, 600,
-            0x0320, 0x390, 0x3b8, 0x438, 0x4D0, 0x540,
-            0x258, 0x2ac, 0x2ad, 0x2b1, 0x2D2, 0x326,
-            0x00410000,
-        },
+     0x0320, 0x390, 0x3b8, 0x438, 0x4D0, 0x540,
+     0x258, 0x2ac, 0x2ad, 0x2b1, 0x2D2, 0x326,
+     0x00410000,
+     },
 
     {1024, 768, 1024, 768,
-            0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
-            0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
-            0x00410000,
-        },
+     0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
+     0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
+     0x00410000,
+     },
 
     {1024, 768, 1152, 864,
-            0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
-            0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
-            0x00410000,
-        },
+     0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
+     0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
+     0x00410000,
+     },
 
     {1024, 768, 1280, 1024,
-            0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
-            0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
-            0x00410000,
-        },
+     0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
+     0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
+     0x00410000,
+     },
 
     {1024, 768, 1600, 1200,
-            0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
-            0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
-            0x00410000,
-        },
+     0x0400, 0x0400, 0x0418, 0x04A0, 0x0540, 0x0540,
+     0x0300, 0x0300, 0x0303, 0x0309, 0x0326, 0x0326,
+     0x00410000,
+     },
 
 /* 1280x1024 panel */
     {1280, 1024, 640, 480,
-            640, 960, 1008, 1120, 1368, 1688,
-            480, 752, 753, 756, 794, 1066,
-            0x006C0000,
-        },
+     640, 960, 1008, 1120, 1368, 1688,
+     480, 752, 753, 756, 794, 1066,
+     0x006C0000,
+     },
 
     {1280, 1024, 800, 600,
-            800, 1040, 1088, 1200, 1448, 1688,
-            600, 812, 813, 816, 854, 1066,
-            0x006C0000,
-        },
+     800, 1040, 1088, 1200, 1448, 1688,
+     600, 812, 813, 816, 854, 1066,
+     0x006C0000,
+     },
 
     {1280, 1024, 1024, 768,
-            1024, 1152, 1200, 1312, 1560, 1688,
-            768, 896, 897, 900, 938, 1066,
-            0x006C0000,
-        },
+     1024, 1152, 1200, 1312, 1560, 1688,
+     768, 896, 897, 900, 938, 1066,
+     0x006C0000,
+     },
 
     {1280, 1024, 1152, 864,
-            1152, 1216, 1264, 1376, 1624, 1688,
-            864, 944, 945, 948, 986, 1066,
-            0x006C0000,
-        },
+     1152, 1216, 1264, 1376, 1624, 1688,
+     864, 944, 945, 948, 986, 1066,
+     0x006C0000,
+     },
 
     {1280, 1024, 1280, 1024,
-            1280, 1280, 1328, 1440, 1688, 1688,
-            1024, 1024, 1025, 1028, 1066, 1066,
-            0x006C0000,
-        },
+     1280, 1280, 1328, 1440, 1688, 1688,
+     1024, 1024, 1025, 1028, 1066, 1066,
+     0x006C0000,
+     },
 
 };
 
@@ -944,28 +944,31 @@ gfx_set_display_mode(int xres, int yres, int bpp, int hz)
  */
 int
 gfx_set_display_timings(unsigned short bpp, unsigned short flags,
-    unsigned short hactive, unsigned short hblankstart,
-    unsigned short hsyncstart, unsigned short hsyncend,
-    unsigned short hblankend, unsigned short htotal,
-    unsigned short vactive, unsigned short vblankstart,
-    unsigned short vsyncstart, unsigned short vsyncend,
-    unsigned short vblankend, unsigned short vtotal, unsigned long frequency)
+                        unsigned short hactive, unsigned short hblankstart,
+                        unsigned short hsyncstart, unsigned short hsyncend,
+                        unsigned short hblankend, unsigned short htotal,
+                        unsigned short vactive, unsigned short vblankstart,
+                        unsigned short vsyncstart, unsigned short vsyncend,
+                        unsigned short vblankend, unsigned short vtotal,
+                        unsigned long frequency)
 {
     int retval = 0;
 
 #if GFX_DISPLAY_GU1
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU1)
         retval = gu1_set_display_timings(bpp, flags,
-            hactive, hblankstart, hsyncstart, hsyncend, hblankend, htotal,
-            vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal,
-            frequency);
+                                         hactive, hblankstart, hsyncstart,
+                                         hsyncend, hblankend, htotal, vactive,
+                                         vblankstart, vsyncstart, vsyncend,
+                                         vblankend, vtotal, frequency);
 #endif
 #if GFX_DISPLAY_GU2
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU2)
         retval = gu2_set_display_timings(bpp, flags,
-            hactive, hblankstart, hsyncstart, hsyncend, hblankend, htotal,
-            vactive, vblankstart, vsyncstart, vsyncend, vblankend, vtotal,
-            frequency);
+                                         hactive, hblankstart, hsyncstart,
+                                         hsyncend, hblankend, htotal, vactive,
+                                         vblankstart, vsyncstart, vsyncend,
+                                         vblankend, vtotal, frequency);
 #endif
     return (retval);
 }
@@ -1084,8 +1087,8 @@ gfx_set_cursor_colors(unsigned long bkcolor, unsigned long fgcolor)
  */
 void
 gfx_set_cursor_position(unsigned long memoffset,
-    unsigned short xpos, unsigned short ypos,
-    unsigned short xhotspot, unsigned short yhotspot)
+                        unsigned short xpos, unsigned short ypos,
+                        unsigned short xhotspot, unsigned short yhotspot)
 {
 #if GFX_DISPLAY_GU1
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU1)
@@ -1103,7 +1106,7 @@ gfx_set_cursor_position(unsigned long memoffset,
  */
 void
 gfx_set_cursor_shape32(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask)
+                       unsigned long *andmask, unsigned long *xormask)
 {
 #if GFX_DISPLAY_GU1
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU1)
@@ -1121,7 +1124,7 @@ gfx_set_cursor_shape32(unsigned long memoffset,
  */
 void
 gfx_set_cursor_shape64(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask)
+                       unsigned long *andmask, unsigned long *xormask)
 {
 #if GFX_DISPLAY_GU2
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU2)
@@ -1148,7 +1151,7 @@ gfx_set_icon_enable(int enable)
  */
 void
 gfx_set_icon_colors(unsigned long color0, unsigned long color1,
-    unsigned long color2)
+                    unsigned long color2)
 {
 #if GFX_DISPLAY_GU2
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU2)
@@ -1175,7 +1178,8 @@ gfx_set_icon_position(unsigned long memoffset, unsigned short xpos)
  */
 void
 gfx_set_icon_shape64(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask, unsigned int lines)
+                     unsigned long *andmask, unsigned long *xormask,
+                     unsigned int lines)
 {
 #if GFX_DISPLAY_GU2
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU2)
@@ -1362,7 +1366,7 @@ gfx_set_display_video_offset(unsigned long offset)
  */
 void
 gfx_set_display_video_yuv_offsets(unsigned long yoffset,
-    unsigned long uoffset, unsigned long voffset)
+                                  unsigned long uoffset, unsigned long voffset)
 {
 #if GFX_DISPLAY_GU2
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU2)
@@ -1538,7 +1542,8 @@ gfx_enable_panning(int x, int y)
  */
 int
 gfx_is_panel_mode_supported(int panelResX, int panelResY,
-    unsigned short width, unsigned short height, unsigned short bpp)
+                            unsigned short width, unsigned short height,
+                            unsigned short bpp)
 {
     int status = -1;
 
@@ -1546,7 +1551,7 @@ gfx_is_panel_mode_supported(int panelResX, int panelResY,
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU2)
         status =
             gu2_is_panel_mode_supported(panelResX, panelResY, width, height,
-            bpp);
+                                        bpp);
 #endif
 
     return (status);
@@ -1558,7 +1563,7 @@ gfx_is_panel_mode_supported(int panelResX, int panelResY,
  */
 int
 gfx_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 {
     int status = 0;
 
@@ -1581,7 +1586,7 @@ gfx_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
  */
 int
 gfx_set_panel_present(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp)
+                      unsigned short height, unsigned short bpp)
 {
     int status = 0;
 
@@ -1635,7 +1640,7 @@ gfx_set_vtotal(unsigned short vtotal)
  */
 int
 gfx_mode_frequency_supported(int xres, int yres, int bpp,
-    unsigned long frequency)
+                             unsigned long frequency)
 {
     int freq = 0;
 
@@ -1656,7 +1661,7 @@ gfx_mode_frequency_supported(int xres, int yres, int bpp,
  */
 int
 gfx_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                                   unsigned long frequency)
 {
 #if GFX_DISPLAY_GU1
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU1)
@@ -1676,7 +1681,7 @@ gfx_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
  */
 int
 gfx_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency)
+                              unsigned long frequency)
 {
 #if GFX_DISPLAY_GU1
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU1)
@@ -1696,21 +1701,19 @@ gfx_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
  */
 int
 gfx_get_frequency_from_refreshrate(int xres, int yres, int bpp, int hz,
-    int *frequency)
+                                   int *frequency)
 {
     int retval = -1;
 
 #if GFX_DISPLAY_GU1
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU1)
         retval =
-            gu1_get_frequency_from_refreshrate(xres, yres, bpp, hz,
-            frequency);
+            gu1_get_frequency_from_refreshrate(xres, yres, bpp, hz, frequency);
 #endif
 #if GFX_DISPLAY_GU2
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU2)
         retval =
-            gu2_get_frequency_from_refreshrate(xres, yres, bpp, hz,
-            frequency);
+            gu2_get_frequency_from_refreshrate(xres, yres, bpp, hz, frequency);
 #endif
 
     return retval;
@@ -2475,6 +2478,7 @@ unsigned long
 gfx_get_display_video_color_key(void)
 {
     unsigned long value = 0;
+
     return (value);
 }
 
@@ -2504,7 +2508,8 @@ gfx_get_display_video_offset(void)
  */
 void
 gfx_get_display_video_yuv_offsets(unsigned long *yoffset,
-    unsigned long *uoffset, unsigned long *voffset)
+                                  unsigned long *uoffset,
+                                  unsigned long *voffset)
 {
 #if GFX_DISPLAY_GU2
     if (gfx_display_type & GFX_DISPLAY_TYPE_GU2)
@@ -2587,9 +2592,10 @@ unsigned long
 gfx_get_display_video_color_key_mask(void)
 {
     unsigned long mask = 0;
+
     return (mask);
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
-#endif /* GFX_DISPLAY_DYNAMIC */
+#endif                          /* GFX_DISPLAY_DYNAMIC */
diff --git a/src/gfx/gfx_i2c.c b/src/gfx/gfx_i2c.c
index 7a3ad42..0ceb460 100644
--- a/src/gfx/gfx_i2c.c
+++ b/src/gfx/gfx_i2c.c
@@ -90,7 +90,7 @@ gfx_i2c_select_gpio(int clock, int data)
  */
 int
 gfx_i2c_write(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data)
+              unsigned char subadr, unsigned char bytes, unsigned char *data)
 {
     int status = -1;
 
@@ -111,7 +111,7 @@ gfx_i2c_write(unsigned char busnum, unsigned char chipadr,
  */
 int
 gfx_i2c_read(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data)
+             unsigned char subadr, unsigned char bytes, unsigned char *data)
 {
     int status = -1;
 
@@ -163,6 +163,6 @@ gfx_i2c_cleanup(void)
 #endif
 }
 
-#endif /* GFX_I2C_DYNAMIC */
+#endif                          /* GFX_I2C_DYNAMIC */
 
 /* END OF FILE */
diff --git a/src/gfx/gfx_init.c b/src/gfx/gfx_init.c
index 469c70f..648d9cb 100644
--- a/src/gfx/gfx_init.c
+++ b/src/gfx/gfx_init.c
@@ -122,7 +122,8 @@ gfx_detect_chip(void)
         }
         if (rev > 0x6)
             gfx_chip_revision = SC1200_FUTURE_REV;
-    } else if (pid == 0x5) {
+    }
+    else if (pid == 0x5) {
         if (rev == 0x6)
             gfx_chip_revision = SC1200_REV_D2_MVE;
         else if (rev > 0x6)
@@ -184,12 +185,13 @@ gfx_detect_cpu(void)
                 /* Major version is one less than what appears in DIR1 */
                 if ((dir1 & 0xF0) < 0x70) {
 
-                    version = GFX_CPU_GXLV | (((((unsigned long)dir1 >> 4) - 1) << 8)) |        /* major - 1 */
-                        ((((unsigned long)dir1 & 0x0F)) << 16); /* minor */
-                } else {
-                    version = GFX_CPU_GXLV | ((((unsigned long)dir1 >> 4))
-                        << 8) |        /* major */
-                        ((((unsigned long)dir1 & 0x0F)) << 16); /* minor */
+                    version = GFX_CPU_GXLV | (((((unsigned long) dir1 >> 4) - 1) << 8)) |       /* major - 1 */
+                        ((((unsigned long) dir1 & 0x0F)) << 16);        /* minor */
+                }
+                else {
+                    version = GFX_CPU_GXLV | ((((unsigned long) dir1 >> 4))
+                                              << 8) |   /* major */
+                        ((((unsigned long) dir1 & 0x0F)) << 16);        /* minor */
                 }
                 /* Currently always CS5530 for video overlay. */
 
@@ -207,13 +209,14 @@ gfx_detect_cpu(void)
                 gfx_tv_type = GFX_TV_TYPE_FS451;
 #endif
             }
-        } else if (dir0 == 0xB0) {
+        }
+        else if (dir0 == 0xB0) {
             /* CHECK FOR SC1200 */
 
             if ((dir1 == 0x70) || (dir1 == 0x81)) {
-                version = GFX_CPU_SC1200 | ((((unsigned long)dir1 >> 4))
-                    << 8) |            /* major */
-                    ((((unsigned long)dir1 & 0x0F)) << 16);     /* minor */
+                version = GFX_CPU_SC1200 | ((((unsigned long) dir1 >> 4))
+                                            << 8) |     /* major */
+                    ((((unsigned long) dir1 & 0x0F)) << 16);    /* minor */
 
                 /* Detect SC1200 revision */
 
@@ -356,12 +359,12 @@ gfx_detect_cpu(void)
                     ((msr_value.low & 0x0F) << 16);     /* MINOR */
 
                 /* READ THE CORE FREQUENCY  */
-				/* I can't find GX implementations that need
-				 * this - we're trying to avoid virtual reads
-				 * anyway, so bail on it
-				 */
+                /* I can't find GX implementations that need
+                 * this - we're trying to avoid virtual reads
+                 * anyway, so bail on it
+                 */
 
-				/* gfx_cpu_frequency = gfx_get_core_freq(); */
+                /* gfx_cpu_frequency = gfx_get_core_freq(); */
 
                 /* SET THE GP SCRATCH AREA */
                 /* Color bitmap BLTs use the last 16K of frame buffer space */
diff --git a/src/gfx/gfx_mode.h b/src/gfx/gfx_mode.h
index f9b42b0..a38bc73 100644
--- a/src/gfx/gfx_mode.h
+++ b/src/gfx/gfx_mode.h
@@ -127,8 +127,7 @@
 
 /* STRUCTURE DEFINITION */
 
-typedef struct tagDISPLAYMODE
-{
+typedef struct tagDISPLAYMODE {
     /* DISPLAY MODE FLAGS */
     /* Specify valid color depths and the refresh rate. */
 
@@ -157,8 +156,7 @@ typedef struct tagDISPLAYMODE
 } DISPLAYMODE;
 
 /* For Fixed timings */
-typedef struct tagFIXEDTIMINGS
-{
+typedef struct tagFIXEDTIMINGS {
     /* DISPLAY MODE FLAGS */
     /* Specify valid color depths and the refresh rate. */
 
@@ -189,6 +187,6 @@ typedef struct tagFIXEDTIMINGS
 
 } FIXEDTIMINGS;
 
-#endif /* !_gfx_mode_h */
+#endif                          /* !_gfx_mode_h */
 
 /* END OF FILE */
diff --git a/src/gfx/gfx_msr.c b/src/gfx/gfx_msr.c
index 1705acb..a779971 100644
--- a/src/gfx/gfx_msr.c
+++ b/src/gfx/gfx_msr.c
@@ -140,8 +140,7 @@ gfx_msr_read(unsigned int device, unsigned int msrRegister, Q_WORD * msrValue)
  *----------------------------------------------------------------------------
  */
 DEV_STATUS
-gfx_msr_write(unsigned int device, unsigned int msrRegister,
-    Q_WORD * msrValue)
+gfx_msr_write(unsigned int device, unsigned int msrRegister, Q_WORD * msrValue)
 {
     DEV_STATUS ret_value = NOT_KNOWN;
 
diff --git a/src/gfx/gfx_priv.h b/src/gfx/gfx_priv.h
index 5647af8..6a2218e 100644
--- a/src/gfx/gfx_priv.h
+++ b/src/gfx/gfx_priv.h
@@ -89,13 +89,13 @@ DEV_STATUS redcloud_find_msr_device(MSR * pDev);
 int redcloud_msr_init(void);
 DEV_STATUS redcloud_id_msr_device(MSR * pDev, unsigned long address);
 DEV_STATUS redcloud_get_msr_dev_address(unsigned int device,
-    unsigned long *address);
+                                        unsigned long *address);
 DEV_STATUS redcloud_get_glink_id_at_address(unsigned int *device,
-    unsigned long address);
+                                            unsigned long address);
 DEV_STATUS redcloud_msr_read(unsigned int device, unsigned int msrRegister,
-    Q_WORD * msrValue);
+                             Q_WORD * msrValue);
 DEV_STATUS redcloud_msr_write(unsigned int device, unsigned int msrRegister,
-    Q_WORD * msrValue);
+                              Q_WORD * msrValue);
 #endif
 
 #endif
@@ -131,13 +131,14 @@ int gu1_set_display_bpp(unsigned short bpp);
 int gu1_is_display_mode_supported(int xres, int yres, int bpp, int hz);
 int gu1_set_display_mode(int xres, int yres, int bpp, int hz);
 int gu1_set_display_timings(unsigned short bpp, unsigned short flags,
-    unsigned short hactive, unsigned short hblank_start,
-    unsigned short hsync_start, unsigned short hsync_end,
-    unsigned short hblank_end, unsigned short htotal,
-    unsigned short vactive, unsigned short vblank_start,
-    unsigned short vsync_start, unsigned short vsync_end,
-    unsigned short vblank_end, unsigned short vtotal,
-    unsigned long frequency);
+                            unsigned short hactive, unsigned short hblank_start,
+                            unsigned short hsync_start,
+                            unsigned short hsync_end, unsigned short hblank_end,
+                            unsigned short htotal, unsigned short vactive,
+                            unsigned short vblank_start,
+                            unsigned short vsync_start,
+                            unsigned short vsync_end, unsigned short vblank_end,
+                            unsigned short vtotal, unsigned long frequency);
 int gu1_set_vtotal(unsigned short vtotal);
 void gu1_set_display_pitch(unsigned short pitch);
 void gu1_set_display_offset(unsigned long offset);
@@ -147,10 +148,10 @@ void gu1_video_shutdown(void);
 void gu1_set_cursor_enable(int enable);
 void gu1_set_cursor_colors(unsigned long bkcolor, unsigned long fgcolor);
 void gu1_set_cursor_position(unsigned long memoffset,
-    unsigned short xpos, unsigned short ypos,
-    unsigned short xhotspot, unsigned short yhotspot);
+                             unsigned short xpos, unsigned short ypos,
+                             unsigned short xhotspot, unsigned short yhotspot);
 void gu1_set_cursor_shape32(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask);
+                            unsigned long *andmask, unsigned long *xormask);
 int gu1_set_compression_enable(int enable);
 int gu1_set_compression_offset(unsigned long offset);
 int gu1_set_compression_pitch(unsigned short pitch);
@@ -163,21 +164,21 @@ void gu1_delay_milliseconds(unsigned long milliseconds);
 void gu1_delay_microseconds(unsigned long microseconds);
 void gu1_enable_panning(int x, int y);
 int gu1_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp);
+                          unsigned short height, unsigned short bpp);
 int gu1_set_panel_present(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp);
+                          unsigned short height, unsigned short bpp);
 void gu1_reset_timing_lock(void);
 int gu1_get_display_details(unsigned int mode, int *xres, int *yres, int *hz);
 unsigned short gu1_get_display_pitch(void);
 unsigned long gu1_get_max_supported_pixel_clock(void);
 int gu1_mode_frequency_supported(int xres, int yres, int bpp,
-    unsigned long frequency);
+                                 unsigned long frequency);
 int gu1_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency);
+                                       unsigned long frequency);
 int gu1_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency);
+                                  unsigned long frequency);
 int gu1_get_frequency_from_refreshrate(int xres, int yres, int bpp, int hz,
-    int *frequency);
+                                       int *frequency);
 int gu1_get_display_mode_count(void);
 int gu1_get_display_mode(int *xres, int *yres, int *bpp, int *hz);
 unsigned long gu1_get_frame_buffer_line_size(void);
@@ -196,8 +197,7 @@ unsigned short gu1_get_vblank_end(void);
 unsigned short gu1_get_vtotal(void);
 unsigned short gu1_get_display_bpp(void);
 unsigned long gu1_get_display_offset(void);
-int gu1_get_display_palette_entry(unsigned long index,
-    unsigned long *palette);
+int gu1_get_display_palette_entry(unsigned long index, unsigned long *palette);
 void gu1_get_display_palette(unsigned long *palette);
 unsigned long gu1_get_cursor_enable(void);
 unsigned long gu1_get_cursor_offset(void);
@@ -220,16 +220,17 @@ int gu1_get_valid_bit(int line);
 
 void gfx_set_display_video_format(unsigned long format);
 void gfx_set_display_video_yuv_offsets(unsigned long yoffset,
-    unsigned long uoffset, unsigned long voffset);
+                                       unsigned long uoffset,
+                                       unsigned long voffset);
 void gfx_set_display_video_yuv_pitch(unsigned long ypitch,
-    unsigned long uvpitch);
-void gfx_set_display_video_downscale(unsigned short srch,
-    unsigned short dsth);
+                                     unsigned long uvpitch);
+void gfx_set_display_video_downscale(unsigned short srch, unsigned short dsth);
 void gfx_set_display_video_vertical_downscale_enable(int enable);
 void gfx_get_display_video_yuv_offsets(unsigned long *yoffset,
-    unsigned long *uoffset, unsigned long *voffset);
+                                       unsigned long *uoffset,
+                                       unsigned long *voffset);
 void gfx_get_display_video_yuv_pitch(unsigned long *ypitch,
-    unsigned long *uvpitch);
+                                     unsigned long *uvpitch);
 unsigned long gfx_get_display_video_downscale_delta(void);
 int gfx_get_display_video_downscale_enable(void);
 
@@ -248,18 +249,19 @@ void gu2_disable_compression(void);
 
 #if GFX_DISPLAY_DYNAMIC
 void gu2_get_display_video_yuv_offsets(unsigned long *yoffset,
-    unsigned long *uoffset, unsigned long *voffset);
+                                       unsigned long *uoffset,
+                                       unsigned long *voffset);
 void gu2_get_display_video_yuv_pitch(unsigned long *ypitch,
-    unsigned long *uvpitch);
+                                     unsigned long *uvpitch);
 unsigned long gu2_get_display_video_downscale_delta(void);
 int gu2_get_display_video_downscale_enable(void);
 void gu2_set_display_video_yuv_offsets(unsigned long yoffset,
-    unsigned long uoffset, unsigned long voffset);
+                                       unsigned long uoffset,
+                                       unsigned long voffset);
 void gu2_set_display_video_format(unsigned long format);
 void gu2_set_display_video_yuv_pitch(unsigned long ypitch,
-    unsigned long uvpitch);
-void gu2_set_display_video_downscale(unsigned short srch,
-    unsigned short dsth);
+                                     unsigned long uvpitch);
+void gu2_set_display_video_downscale(unsigned short srch, unsigned short dsth);
 void gu2_set_display_video_vertical_downscale_enable(int enable);
 void gu2_set_display_video_enable(int enable);
 void gu2_set_display_video_size(unsigned short width, unsigned short height);
@@ -270,13 +272,14 @@ int gu2_set_display_bpp(unsigned short bpp);
 int gu2_is_display_mode_supported(int xres, int yres, int bpp, int hz);
 int gu2_set_display_mode(int xres, int yres, int bpp, int hz);
 int gu2_set_display_timings(unsigned short bpp, unsigned short flags,
-    unsigned short hactive, unsigned short hblank_start,
-    unsigned short hsync_start, unsigned short hsync_end,
-    unsigned short hblank_end, unsigned short htotal,
-    unsigned short vactive, unsigned short vblank_start,
-    unsigned short vsync_start, unsigned short vsync_end,
-    unsigned short vblank_end, unsigned short vtotal,
-    unsigned long frequency);
+                            unsigned short hactive, unsigned short hblank_start,
+                            unsigned short hsync_start,
+                            unsigned short hsync_end, unsigned short hblank_end,
+                            unsigned short htotal, unsigned short vactive,
+                            unsigned short vblank_start,
+                            unsigned short vsync_start,
+                            unsigned short vsync_end, unsigned short vblank_end,
+                            unsigned short vtotal, unsigned long frequency);
 int gu2_set_vtotal(unsigned short vtotal);
 void gu2_set_display_pitch(unsigned short pitch);
 void gu2_set_display_offset(unsigned long offset);
@@ -285,18 +288,18 @@ int gu2_set_display_palette(unsigned long *palette);
 void gu2_set_cursor_enable(int enable);
 void gu2_set_cursor_colors(unsigned long bkcolor, unsigned long fgcolor);
 void gu2_set_cursor_position(unsigned long memoffset,
-    unsigned short xpos, unsigned short ypos,
-    unsigned short xhotspot, unsigned short yhotspot);
+                             unsigned short xpos, unsigned short ypos,
+                             unsigned short xhotspot, unsigned short yhotspot);
 void gu2_set_cursor_shape32(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask);
+                            unsigned long *andmask, unsigned long *xormask);
 void gu2_set_cursor_shape64(unsigned long memoffset,
-    unsigned long *andmask, unsigned long *xormask);
+                            unsigned long *andmask, unsigned long *xormask);
 void gu2_set_icon_enable(int enable);
 void gu2_set_icon_colors(unsigned long color0, unsigned long color1,
-    unsigned long color2);
+                         unsigned long color2);
 void gu2_set_icon_position(unsigned long memoffset, unsigned short xpos);
 void gu2_set_icon_shape64(unsigned long memoffset, unsigned long *andmask,
-    unsigned long *xormask, unsigned int lines);
+                          unsigned long *xormask, unsigned int lines);
 int gu2_set_compression_enable(int enable);
 int gu2_set_compression_offset(unsigned long offset);
 int gu2_set_compression_pitch(unsigned short pitch);
@@ -309,23 +312,24 @@ void gu2_delay_milliseconds(unsigned long milliseconds);
 void gu2_delay_microseconds(unsigned long microseconds);
 void gu2_enable_panning(int x, int y);
 int gu2_is_panel_mode_supported(int panelResX, int panelResY,
-    unsigned short width, unsigned short height, unsigned short bpp);
+                                unsigned short width, unsigned short height,
+                                unsigned short bpp);
 int gu2_set_fixed_timings(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp);
+                          unsigned short height, unsigned short bpp);
 int gu2_set_panel_present(int panelResX, int panelResY, unsigned short width,
-    unsigned short height, unsigned short bpp);
+                          unsigned short height, unsigned short bpp);
 void gu2_reset_timing_lock(void);
 int gu2_get_display_details(unsigned int mode, int *xres, int *yres, int *hz);
 unsigned short gu2_get_display_pitch(void);
 unsigned long gu2_get_max_supported_pixel_clock(void);
 int gu2_mode_frequency_supported(int xres, int yres, int bpp,
-    unsigned long frequency);
+                                 unsigned long frequency);
 int gu2_get_refreshrate_from_frequency(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency);
+                                       unsigned long frequency);
 int gu2_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
-    unsigned long frequency);
+                                  unsigned long frequency);
 int gu2_get_frequency_from_refreshrate(int xres, int yres, int bpp, int hz,
-    int *frequency);
+                                       int *frequency);
 int gu2_get_display_mode_count(void);
 int gu2_get_display_mode(int *xres, int *yres, int *bpp, int *hz);
 unsigned long gu2_get_frame_buffer_line_size(void);
@@ -344,8 +348,7 @@ unsigned short gu2_get_vblank_end(void);
 unsigned short gu2_get_vtotal(void);
 unsigned short gu2_get_display_bpp(void);
 unsigned long gu2_get_display_offset(void);
-int gu2_get_display_palette_entry(unsigned long index,
-    unsigned long *palette);
+int gu2_get_display_palette_entry(unsigned long index, unsigned long *palette);
 void gu2_get_display_palette(unsigned long *palette);
 unsigned long gu2_get_cursor_enable(void);
 unsigned long gu2_get_cursor_offset(void);
@@ -374,7 +377,8 @@ int gu2_get_valid_bit(int line);
 /* PRIVATE ROUTINES */
 
 void gu1_solid_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, unsigned long color);
+                    unsigned short width, unsigned short height,
+                    unsigned long color);
 void gu1_detect_blt_buffer_base(void);
 
 /* DYNAMIC ROUTINES */
@@ -383,41 +387,50 @@ void gu1_detect_blt_buffer_base(void);
 void gu1_set_bpp(unsigned short bpp);
 void gu1_set_solid_pattern(unsigned long color);
 void gu1_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned char transparency);
+                          unsigned long data0, unsigned long data1,
+                          unsigned char transparency);
 void gu1_set_color_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned long data2,
-    unsigned long data3, unsigned char transparency);
+                           unsigned long data0, unsigned long data1,
+                           unsigned long data2, unsigned long data3,
+                           unsigned char transparency);
 void gu1_load_color_pattern_line(short y, unsigned long *pattern_8x8);
 void gu1_set_solid_source(unsigned long color);
 void gu1_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned short transparent);
+                         unsigned short transparent);
 void gu1_set_pattern_flags(unsigned short flags);
 void gu1_set_raster_operation(unsigned char rop);
 void gu1_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height);
+                      unsigned short width, unsigned short height);
 void gu1_color_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, unsigned long *pattern);
+                            unsigned short width, unsigned short height,
+                            unsigned long *pattern);
 void gu1_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height);
+                              unsigned short dstx, unsigned short dsty,
+                              unsigned short width, unsigned short height);
 void gu1_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned long color);
+                               unsigned short dstx, unsigned short dsty,
+                               unsigned short width, unsigned short height,
+                               unsigned long color);
 void gu1_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch);
+                                    unsigned short dstx, unsigned short dsty,
+                                    unsigned short width, unsigned short height,
+                                    unsigned char *data, long pitch);
 void gu1_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch,
-    unsigned long color);
+                                     unsigned short dstx, unsigned short dsty,
+                                     unsigned short width,
+                                     unsigned short height, unsigned char *data,
+                                     long pitch, unsigned long color);
 void gu1_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch);
+                                   unsigned short dstx, unsigned short dsty,
+                                   unsigned short width, unsigned short height,
+                                   unsigned char *data, short pitch);
 void gu1_text_blt(unsigned short dstx, unsigned short dsty,
-    unsigned short width, unsigned short height, unsigned char *data);
+                  unsigned short width, unsigned short height,
+                  unsigned char *data);
 void gu1_bresenham_line(unsigned short x, unsigned short y,
-    unsigned short length, unsigned short initerr, unsigned short axialerr,
-    unsigned short diagerr, unsigned short flags);
+                        unsigned short length, unsigned short initerr,
+                        unsigned short axialerr, unsigned short diagerr,
+                        unsigned short flags);
 void gu1_wait_until_idle(void);
 int gu1_test_blt_pending(void);
 #endif
@@ -438,41 +451,50 @@ void gu2_reset_pitch(unsigned short pitch);
 void gu2_set_bpp(unsigned short bpp);
 void gu2_set_solid_pattern(unsigned long color);
 void gu2_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned char transparency);
+                          unsigned long data0, unsigned long data1,
+                          unsigned char transparency);
 void gu2_set_color_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned long data2,
-    unsigned long data3, unsigned char transparency);
+                           unsigned long data0, unsigned long data1,
+                           unsigned long data2, unsigned long data3,
+                           unsigned char transparency);
 void gu2_load_color_pattern_line(short y, unsigned long *pattern_8x8);
 void gu2_set_solid_source(unsigned long color);
 void gu2_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned short transparent);
+                         unsigned short transparent);
 void gu2_set_pattern_flags(unsigned short flags);
 void gu2_set_raster_operation(unsigned char rop);
 void gu2_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height);
+                      unsigned short width, unsigned short height);
 void gu2_color_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, unsigned long *pattern);
+                            unsigned short width, unsigned short height,
+                            unsigned long *pattern);
 void gu2_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height);
+                              unsigned short dstx, unsigned short dsty,
+                              unsigned short width, unsigned short height);
 void gu2_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned long color);
+                               unsigned short dstx, unsigned short dsty,
+                               unsigned short width, unsigned short height,
+                               unsigned long color);
 void gu2_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch);
+                                    unsigned short dstx, unsigned short dsty,
+                                    unsigned short width, unsigned short height,
+                                    unsigned char *data, long pitch);
 void gu2_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch,
-    unsigned long color);
+                                     unsigned short dstx, unsigned short dsty,
+                                     unsigned short width,
+                                     unsigned short height, unsigned char *data,
+                                     long pitch, unsigned long color);
 void gu2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch);
+                                   unsigned short dstx, unsigned short dsty,
+                                   unsigned short width, unsigned short height,
+                                   unsigned char *data, short pitch);
 void gu2_text_blt(unsigned short dstx, unsigned short dsty,
-    unsigned short width, unsigned short height, unsigned char *data);
+                  unsigned short width, unsigned short height,
+                  unsigned char *data);
 void gu2_bresenham_line(unsigned short x, unsigned short y,
-    unsigned short length, unsigned short initerr, unsigned short axialerr,
-    unsigned short diagerr, unsigned short flags);
+                        unsigned short length, unsigned short initerr,
+                        unsigned short axialerr, unsigned short diagerr,
+                        unsigned short flags);
 void gu2_wait_until_idle(void);
 int gu2_test_blt_pending(void);
 
@@ -483,26 +505,30 @@ void gu22_set_source_transparency(unsigned long color, unsigned long mask);
 void gu22_set_alpha_mode(int mode);
 void gu22_set_alpha_value(unsigned char value);
 void gu22_pattern_fill(unsigned long dstoffset, unsigned short width,
-    unsigned short height);
+                       unsigned short height);
 void gu22_color_pattern_fill(unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned long *pattern);
+                             unsigned short height, unsigned long *pattern);
 void gu22_screen_to_screen_blt(unsigned long srcoffset,
-    unsigned long dstoffset, unsigned short width, unsigned short height,
-    int flags);
+                               unsigned long dstoffset, unsigned short width,
+                               unsigned short height, int flags);
 void gu22_mono_expand_blt(unsigned long srcbase, unsigned short srcx,
-    unsigned short srcy, unsigned long dstoffset, unsigned short width,
-    unsigned short height, int byte_packed);
+                          unsigned short srcy, unsigned long dstoffset,
+                          unsigned short width, unsigned short height,
+                          int byte_packed);
 void gu22_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned long dstoffset, unsigned short width, unsigned short height,
-    unsigned char *data, short pitch);
+                                     unsigned long dstoffset,
+                                     unsigned short width,
+                                     unsigned short height, unsigned char *data,
+                                     short pitch);
 void gu22_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned long dstoffset, unsigned short width, unsigned short height,
-    unsigned char *data, short pitch);
+                                    unsigned long dstoffset,
+                                    unsigned short width, unsigned short height,
+                                    unsigned char *data, short pitch);
 void gu22_text_blt(unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned char *data);
+                   unsigned short height, unsigned char *data);
 void gu22_bresenham_line(unsigned long dstoffset, unsigned short length,
-    unsigned short initerr, unsigned short axialerr, unsigned short diagerr,
-    unsigned short flags);
+                         unsigned short initerr, unsigned short axialerr,
+                         unsigned short diagerr, unsigned short flags);
 void gu22_sync_to_vblank(void);
 #endif
 
@@ -535,12 +561,12 @@ int cs5530_set_video_format(unsigned long format);
 int cs5530_set_video_size(unsigned short width, unsigned short height);
 int cs5530_set_video_offset(unsigned long offset);
 int cs5530_set_video_window(short x, short y, unsigned short w,
-    unsigned short h);
+                            unsigned short h);
 int cs5530_set_video_left_crop(unsigned short x);
 int cs5530_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth);
+                           unsigned short dstw, unsigned short dsth);
 int cs5530_set_video_color_key(unsigned long key, unsigned long mask,
-    int bluescreen);
+                               int bluescreen);
 int cs5530_set_video_filter(int xfilter, int yfilter);
 int cs5530_set_video_palette(unsigned long *palette);
 int cs5530_set_video_palette_entry(unsigned long index, unsigned long color);
@@ -562,8 +588,7 @@ unsigned long cs5530_get_video_dst_size(void);
 unsigned long cs5530_get_video_position(void);
 unsigned long cs5530_get_video_color_key(void);
 unsigned long cs5530_get_video_color_key_mask(void);
-int cs5530_get_video_palette_entry(unsigned long index,
-    unsigned long *palette);
+int cs5530_get_video_palette_entry(unsigned long index, unsigned long *palette);
 int cs5530_get_video_color_key_src(void);
 int cs5530_get_video_filter(void);
 unsigned long cs5530_read_crc(void);
@@ -594,21 +619,23 @@ int sc1200_set_video_format(unsigned long format);
 int sc1200_set_video_size(unsigned short width, unsigned short height);
 int sc1200_set_video_offset(unsigned long offset);
 int sc1200_set_video_window(short x, short y, unsigned short w,
-    unsigned short h);
+                            unsigned short h);
 int sc1200_set_video_left_crop(unsigned short x);
 int sc1200_set_video_upscale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth);
+                             unsigned short dstw, unsigned short dsth);
 int sc1200_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth);
+                           unsigned short dstw, unsigned short dsth);
 int sc1200_set_video_downscale_config(unsigned short type, unsigned short m);
 int sc1200_set_video_color_key(unsigned long key, unsigned long mask,
-    int bluescreen);
+                               int bluescreen);
 int sc1200_set_video_filter(int xfilter, int yfilter);
 int sc1200_set_video_palette(unsigned long *palette);
 int sc1200_set_video_palette_bypass(int enable);
 int sc1200_set_video_palette_entry(unsigned long index, unsigned long color);
 int sc1200_set_video_downscale_coefficients(unsigned short coef1,
-    unsigned short coef2, unsigned short coef3, unsigned short coef4);
+                                            unsigned short coef2,
+                                            unsigned short coef3,
+                                            unsigned short coef4);
 int sc1200_set_video_downscale_enable(int enable);
 int sc1200_set_video_source(VideoSourceType source);
 int sc1200_set_vbi_source(VbiSourceType source);
@@ -621,13 +648,14 @@ int sc1200_set_top_line_in_odd(int enable);
 int sc1200_set_genlock_delay(unsigned long delay);
 int sc1200_set_genlock_enable(int flags);
 int sc1200_set_video_cursor(unsigned long key, unsigned long mask,
-    unsigned short select_color2, unsigned long color1, unsigned long color2);
+                            unsigned short select_color2, unsigned long color1,
+                            unsigned long color2);
 int sc1200_set_video_request(short x, short y);
 
 int sc1200_select_alpha_region(int region);
 int sc1200_set_alpha_enable(int enable);
 int sc1200_set_alpha_window(short x, short y,
-    unsigned short width, unsigned short height);
+                            unsigned short width, unsigned short height);
 int sc1200_set_alpha_value(unsigned char alpha, char delta);
 int sc1200_set_alpha_priority(int priority);
 int sc1200_set_alpha_color(unsigned long color);
@@ -648,17 +676,17 @@ unsigned long sc1200_get_video_xclip(void);
 unsigned long sc1200_get_video_offset(void);
 unsigned long sc1200_get_video_upscale(void);
 unsigned long sc1200_get_video_scale(void);
-int sc1200_get_video_downscale_config(unsigned short *type,
-    unsigned short *m);
+int sc1200_get_video_downscale_config(unsigned short *type, unsigned short *m);
 void sc1200_get_video_downscale_coefficients(unsigned short *coef1,
-    unsigned short *coef2, unsigned short *coef3, unsigned short *coef4);
+                                             unsigned short *coef2,
+                                             unsigned short *coef3,
+                                             unsigned short *coef4);
 void sc1200_get_video_downscale_enable(int *enable);
 unsigned long sc1200_get_video_dst_size(void);
 unsigned long sc1200_get_video_position(void);
 unsigned long sc1200_get_video_color_key(void);
 unsigned long sc1200_get_video_color_key_mask(void);
-int sc1200_get_video_palette_entry(unsigned long index,
-    unsigned long *palette);
+int sc1200_get_video_palette_entry(unsigned long index, unsigned long *palette);
 int sc1200_get_video_color_key_src(void);
 int sc1200_get_video_filter(void);
 int sc1200_get_video_request(short *x, short *y);
@@ -672,14 +700,14 @@ int sc1200_get_vertical_scaler_offset(char *offset);
 unsigned long sc1200_get_genlock_delay(void);
 int sc1200_get_genlock_enable(void);
 int sc1200_get_video_cursor(unsigned long *key, unsigned long *mask,
-    unsigned short *select_color2, unsigned long *color1,
-    unsigned short *color2);
+                            unsigned short *select_color2,
+                            unsigned long *color1, unsigned short *color2);
 unsigned long sc1200_read_crc(void);
 int sc1200_get_macrovision_enable(void);
 
 void sc1200_get_alpha_enable(int *enable);
 void sc1200_get_alpha_size(unsigned short *x, unsigned short *y,
-    unsigned short *width, unsigned short *height);
+                           unsigned short *width, unsigned short *height);
 void sc1200_get_alpha_value(unsigned char *alpha, char *delta);
 void sc1200_get_alpha_priority(int *priority);
 void sc1200_get_alpha_color(unsigned long *color);
@@ -709,38 +737,40 @@ int redcloud_set_video_size(unsigned short width, unsigned short height);
 int redcloud_set_video_yuv_pitch(unsigned long ypitch, unsigned long uvpitch);
 int redcloud_set_video_offset(unsigned long offset);
 int redcloud_set_video_yuv_offsets(unsigned long yoffset,
-    unsigned long uoffset, unsigned long voffset);
+                                   unsigned long uoffset,
+                                   unsigned long voffset);
 int redcloud_set_video_window(short x, short y, unsigned short w,
-    unsigned short h);
+                              unsigned short h);
 int redcloud_set_video_left_crop(unsigned short x);
 int redcloud_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth);
+                             unsigned short dstw, unsigned short dsth);
 int redcloud_set_video_vertical_downscale(unsigned short srch,
-    unsigned short dsth);
+                                          unsigned short dsth);
 void redcloud_set_video_vertical_downscale_enable(int enable);
-int redcloud_set_video_downscale_config(unsigned short type,
-    unsigned short m);
+int redcloud_set_video_downscale_config(unsigned short type, unsigned short m);
 int redcloud_set_video_color_key(unsigned long key, unsigned long mask,
-    int bluescreen);
+                                 int bluescreen);
 int redcloud_set_video_filter(int xfilter, int yfilter);
 int redcloud_set_video_palette(unsigned long *palette);
 int redcloud_set_graphics_palette(unsigned long *palette);
 int redcloud_set_video_palette_bypass(int enable);
-int redcloud_set_video_palette_entry(unsigned long index,
-    unsigned long color);
+int redcloud_set_video_palette_entry(unsigned long index, unsigned long color);
 int redcloud_set_graphics_palette_entry(unsigned long index,
-    unsigned long color);
+                                        unsigned long color);
 int redcloud_set_video_downscale_coefficients(unsigned short coef1,
-    unsigned short coef2, unsigned short coef3, unsigned short coef4);
+                                              unsigned short coef2,
+                                              unsigned short coef3,
+                                              unsigned short coef4);
 int redcloud_set_video_downscale_enable(int enable);
 int redcloud_set_video_cursor(unsigned long key, unsigned long mask,
-    unsigned short select_color2, unsigned long color1, unsigned long color2);
+                              unsigned short select_color2,
+                              unsigned long color1, unsigned long color2);
 int redcloud_set_video_cursor_enable(int enable);
 
 int redcloud_select_alpha_region(int region);
 int redcloud_set_alpha_enable(int enable);
 int redcloud_set_alpha_window(short x, short y,
-    unsigned short width, unsigned short height);
+                              unsigned short width, unsigned short height);
 int redcloud_set_alpha_value(unsigned char alpha, char delta);
 int redcloud_set_alpha_priority(int priority);
 int redcloud_set_alpha_color(unsigned long color);
@@ -757,36 +787,40 @@ unsigned long redcloud_get_video_line_size(void);
 unsigned long redcloud_get_video_xclip(void);
 unsigned long redcloud_get_video_offset(void);
 void redcloud_get_video_yuv_offsets(unsigned long *yoffset,
-    unsigned long *uoffset, unsigned long *voffset);
+                                    unsigned long *uoffset,
+                                    unsigned long *voffset);
 void redcloud_get_video_yuv_pitch(unsigned long *ypitch,
-    unsigned long *uvpitch);
+                                  unsigned long *uvpitch);
 unsigned long redcloud_get_video_scale(void);
 unsigned long redcloud_get_video_downscale_delta(void);
 int redcloud_get_video_vertical_downscale_enable(void);
 int redcloud_get_video_downscale_config(unsigned short *type,
-    unsigned short *m);
+                                        unsigned short *m);
 void redcloud_get_video_downscale_coefficients(unsigned short *coef1,
-    unsigned short *coef2, unsigned short *coef3, unsigned short *coef4);
+                                               unsigned short *coef2,
+                                               unsigned short *coef3,
+                                               unsigned short *coef4);
 void redcloud_get_video_downscale_enable(int *enable);
 unsigned long redcloud_get_video_dst_size(void);
 unsigned long redcloud_get_video_position(void);
 unsigned long redcloud_get_video_color_key(void);
 unsigned long redcloud_get_video_color_key_mask(void);
 int redcloud_get_video_palette_entry(unsigned long index,
-    unsigned long *palette);
+                                     unsigned long *palette);
 int redcloud_get_video_color_key_src(void);
 int redcloud_get_video_filter(void);
 int redcloud_get_video_cursor(unsigned long *key, unsigned long *mask,
-    unsigned short *select_color2, unsigned long *color1,
-    unsigned short *color2);
+                              unsigned short *select_color2,
+                              unsigned long *color1, unsigned short *color2);
 unsigned long redcloud_read_crc(void);
 unsigned long redcloud_read_crc32(void);
 unsigned long redcloud_read_window_crc(int source, unsigned short x,
-    unsigned short y, unsigned short width, unsigned short height, int crc32);
+                                       unsigned short y, unsigned short width,
+                                       unsigned short height, int crc32);
 
 void redcloud_get_alpha_enable(int *enable);
 void redcloud_get_alpha_size(unsigned short *x, unsigned short *y,
-    unsigned short *width, unsigned short *height);
+                             unsigned short *width, unsigned short *height);
 void redcloud_get_alpha_value(unsigned char *alpha, char *delta);
 void redcloud_get_alpha_priority(int *priority);
 void redcloud_get_alpha_color(unsigned long *color);
@@ -853,12 +887,11 @@ int saa7114_set_decoder_contrast(unsigned char contrast);
 int saa7114_set_decoder_hue(char hue);
 int saa7114_set_decoder_saturation(unsigned char saturation);
 int saa7114_set_decoder_input_offset(unsigned short x, unsigned short y);
-int saa7114_set_decoder_input_size(unsigned short width,
-    unsigned short height);
+int saa7114_set_decoder_input_size(unsigned short width, unsigned short height);
 int saa7114_set_decoder_output_size(unsigned short width,
-    unsigned short height);
+                                    unsigned short height);
 int saa7114_set_decoder_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth);
+                              unsigned short dstw, unsigned short dsth);
 int saa7114_set_decoder_vbi_format(int start, int end, int format);
 int saa7114_set_decoder_vbi_enable(int enable);
 int saa7114_set_decoder_vbi_upscale(void);
@@ -885,9 +918,11 @@ int saa7114_get_decoder_vbi_format(int line);
 #if GFX_I2C_DYNAMIC
 int acc_i2c_reset(unsigned char busnum, short adr, char freq);
 int acc_i2c_write(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data);
+                  unsigned char subadr, unsigned char bytes,
+                  unsigned char *data);
 int acc_i2c_read(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data);
+                 unsigned char subadr, unsigned char bytes,
+                 unsigned char *data);
 int acc_i2c_select_gpio(int clock, int data);
 int acc_i2c_init(void);
 void acc_i2c_cleanup(void);
@@ -901,9 +936,11 @@ void acc_i2c_cleanup(void);
 #if GFX_I2C_DYNAMIC
 int gpio_i2c_reset(unsigned char busnum, short adr, char freq);
 int gpio_i2c_write(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data);
+                   unsigned char subadr, unsigned char bytes,
+                   unsigned char *data);
 int gpio_i2c_read(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data);
+                  unsigned char subadr, unsigned char bytes,
+                  unsigned char *data);
 int gpio_i2c_select_gpio(int clock, int data);
 int gpio_i2c_init(void);
 void gpio_i2c_cleanup(void);
@@ -935,9 +972,11 @@ int sc1200_get_tv_output(void);
 int sc1200_get_tv_mode_count(TVStandardType format);
 int sc1200_get_tv_display_mode(int *width, int *height, int *bpp, int *hz);
 int sc1200_get_tv_display_mode_frequency(unsigned short width,
-    unsigned short height, TVStandardType format, int *frequency);
+                                         unsigned short height,
+                                         TVStandardType format, int *frequency);
 int sc1200_is_tv_display_mode_supported(unsigned short width,
-    unsigned short height, TVStandardType format);
+                                        unsigned short height,
+                                        TVStandardType format);
 unsigned char cc_add_parity_bit(unsigned char data);
 
 #endif
diff --git a/src/gfx/gfx_regs.h b/src/gfx/gfx_regs.h
index 2326f61..c43f294 100644
--- a/src/gfx/gfx_regs.h
+++ b/src/gfx/gfx_regs.h
@@ -184,17 +184,17 @@
 #define DC_GCFG_CMPE		0x00000010      /* compression enable       */
 #define DC_GCFG_DECE		0x00000020      /* decompression enable     */
 #define DC_GCFG_DCLK_MASK	0x000000C0      /* dotclock multiplier      */
-#define DC_GCFG_DCLK_POS	6      /* dotclock multiplier      */
+#define DC_GCFG_DCLK_POS	6       /* dotclock multiplier      */
 #define DC_GCFG_DFHPSL_MASK	0x00000F00      /* FIFO high-priority start */
-#define DC_GCFG_DFHPSL_POS	8      /* FIFO high-priority start */
+#define DC_GCFG_DFHPSL_POS	8       /* FIFO high-priority start */
 #define DC_GCFG_DFHPEL_MASK	0x0000F000      /* FIFO high-priority end   */
-#define DC_GCFG_DFHPEL_POS	12     /* FIFO high-priority end   */
+#define DC_GCFG_DFHPEL_POS	12      /* FIFO high-priority end   */
 #define DC_GCFG_CIM_MASK	0x00030000      /* compressor insert mode   */
-#define DC_GCFG_CIM_POS		16     /* compressor insert mode   */
+#define DC_GCFG_CIM_POS		16      /* compressor insert mode   */
 #define DC_GCFG_FDTY		0x00040000      /* frame dirty mode         */
 #define DC_GCFG_RTPM		0x00080000      /* real-time perf. monitor  */
 #define DC_GCFG_DAC_RS_MASK	0x00700000      /* DAC register selects     */
-#define DC_GCFG_DAC_RS_POS	20     /* DAC register selects     */
+#define DC_GCFG_DAC_RS_POS	20      /* DAC register selects     */
 #define DC_GCFG_CKWR		0x00800000      /* clock write              */
 #define DC_GCFG_LDBL		0x01000000      /* line double              */
 #define DC_GCFG_DIAG		0x02000000      /* FIFO diagnostic mode     */
@@ -229,7 +229,7 @@
 #define DC_TCFG_PXDB		0x00008000      /* pixel double             */
 #define DC_TCFG_BKRT		0x00010000      /* blink rate               */
 #define DC_TCFG_PSD_MASK	0x000E0000      /* power sequence delay     */
-#define DC_TCFG_PSD_POS		17     /* power sequence delay     */
+#define DC_TCFG_PSD_POS		17      /* power sequence delay     */
 #define DC_TCFG_DDCI		0x08000000      /* DDC input (RO)           */
 #define DC_TCFG_SENS		0x10000000      /* monitor sense (RO)       */
 #define DC_TCFG_DNA			0x20000000      /* display not active (RO)  */
@@ -261,7 +261,7 @@
 
 /* MC_MEM_CNTRL1 BIT DEFINITIONS */
 
-#define MC_XBUSARB          0x00000008 /* 0 = GP priority < CPU priority */
+#define MC_XBUSARB          0x00000008  /* 0 = GP priority < CPU priority */
                                                                                         /* 1 = GP priority = CPU priority */
                                                                                         /* GXm databook V2.0 is wrong ! */
 /*----------*/
@@ -1200,14 +1200,14 @@
 
 /* GEODELINK DEVICE MSR REGISTER SUMMARY */
 
-#define MBD_MSR_CAP         0x2000     /* Device Capabilities              */
-#define MBD_MSR_CONFIG      0x2001     /* Device Master Configuration          */
+#define MBD_MSR_CAP         0x2000      /* Device Capabilities              */
+#define MBD_MSR_CONFIG      0x2001      /* Device Master Configuration          */
                                                                                 /*      Register                                                */
-#define MBD_MSR_SMI         0x2002     /* MBus Device SMI Register         */
-#define MBD_MSR_ERROR       0x2003     /* MBus Device Error                */
-#define MBD_MSR_PM          0x2004     /* MBus Device Power Management         */
+#define MBD_MSR_SMI         0x2002      /* MBus Device SMI Register         */
+#define MBD_MSR_ERROR       0x2003      /* MBus Device Error                */
+#define MBD_MSR_PM          0x2004      /* MBus Device Power Management         */
                                                                                 /*      Register                                                */
-#define MBD_MSR_DIAG        0x2005     /* Mbus Device Diagnostic Register  */
+#define MBD_MSR_DIAG        0x2005      /* Mbus Device Diagnostic Register  */
 
 /* DISPLAY FILTER MBD_MSR_DIAG DEFINITIONS */
 
diff --git a/src/gfx/gfx_rndr.c b/src/gfx/gfx_rndr.c
index c5a46ac..09f88f0 100644
--- a/src/gfx/gfx_rndr.c
+++ b/src/gfx/gfx_rndr.c
@@ -128,7 +128,7 @@ gfx_set_solid_source(unsigned long color)
  */
 void
 gfx_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned short transparent)
+                    unsigned short transparent)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
@@ -169,7 +169,8 @@ gfx_set_solid_pattern(unsigned long color)
  */
 void
 gfx_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned char transparent)
+                     unsigned long data0, unsigned long data1,
+                     unsigned char transparent)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
@@ -187,18 +188,19 @@ gfx_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
  */
 void
 gfx_set_color_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1,
-    unsigned long data2, unsigned long data3, unsigned char transparent)
+                      unsigned long data0, unsigned long data1,
+                      unsigned long data2, unsigned long data3,
+                      unsigned char transparent)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
         gu1_set_color_pattern(bgcolor, fgcolor, data0, data1, data2, data3,
-            transparent);
+                              transparent);
 #endif
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
         gu2_set_color_pattern(bgcolor, fgcolor, data0, data1, data2, data3,
-            transparent);
+                              transparent);
 #endif
 }
 
@@ -242,7 +244,7 @@ gfx_set_raster_operation(unsigned char rop)
  */
 void
 gfx_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height)
+                 unsigned short width, unsigned short height)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
@@ -260,7 +262,8 @@ gfx_pattern_fill(unsigned short x, unsigned short y,
  */
 void
 gfx_color_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, unsigned long *pattern)
+                       unsigned short width, unsigned short height,
+                       unsigned long *pattern)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
@@ -278,8 +281,8 @@ gfx_color_pattern_fill(unsigned short x, unsigned short y,
  */
 void
 gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height)
+                         unsigned short dstx, unsigned short dsty,
+                         unsigned short width, unsigned short height)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
@@ -297,18 +300,17 @@ gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
  */
 void
 gfx_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned long color)
+                          unsigned short dstx, unsigned short dsty,
+                          unsigned short width, unsigned short height,
+                          unsigned long color)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
-        gu1_screen_to_screen_xblt(srcx, srcy, dstx, dsty, width, height,
-            color);
+        gu1_screen_to_screen_xblt(srcx, srcy, dstx, dsty, width, height, color);
 #endif
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
-        gu2_screen_to_screen_xblt(srcx, srcy, dstx, dsty, width, height,
-            color);
+        gu2_screen_to_screen_xblt(srcx, srcy, dstx, dsty, width, height, color);
 #endif
 }
 
@@ -318,18 +320,19 @@ gfx_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
  */
 void
 gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch)
+                               unsigned short dstx, unsigned short dsty,
+                               unsigned short width, unsigned short height,
+                               unsigned char *data, long pitch)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
         gu1_color_bitmap_to_screen_blt(srcx, srcy, dstx, dsty, width, height,
-            data, pitch);
+                                       data, pitch);
 #endif
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
         gu2_color_bitmap_to_screen_blt(srcx, srcy, dstx, dsty, width, height,
-            data, pitch);
+                                       data, pitch);
 #endif
 }
 
@@ -339,19 +342,20 @@ gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
  */
 void
 gfx_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch,
-    unsigned long color)
+                                unsigned short dstx, unsigned short dsty,
+                                unsigned short width, unsigned short height,
+                                unsigned char *data, long pitch,
+                                unsigned long color)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
         gu1_color_bitmap_to_screen_xblt(srcx, srcy, dstx, dsty, width, height,
-            data, pitch, color);
+                                        data, pitch, color);
 #endif
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
         gu2_color_bitmap_to_screen_xblt(srcx, srcy, dstx, dsty, width, height,
-            data, pitch, color);
+                                        data, pitch, color);
 #endif
 }
 
@@ -361,18 +365,19 @@ gfx_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
  */
 void
 gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch)
+                              unsigned short dstx, unsigned short dsty,
+                              unsigned short width, unsigned short height,
+                              unsigned char *data, short pitch)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
         gu1_mono_bitmap_to_screen_blt(srcx, srcy, dstx, dsty, width, height,
-            data, pitch);
+                                      data, pitch);
 #endif
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
         gu2_mono_bitmap_to_screen_blt(srcx, srcy, dstx, dsty, width, height,
-            data, pitch);
+                                      data, pitch);
 #endif
 }
 
@@ -382,7 +387,7 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
  */
 void
 gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data)
+             unsigned short height, unsigned char *data)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
@@ -400,8 +405,9 @@ gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
  */
 void
 gfx_bresenham_line(unsigned short x, unsigned short y,
-    unsigned short length, unsigned short initerr,
-    unsigned short axialerr, unsigned short diagerr, unsigned short flags)
+                   unsigned short length, unsigned short initerr,
+                   unsigned short axialerr, unsigned short diagerr,
+                   unsigned short flags)
 {
 #if GFX_2DACCEL_GU1
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU1)
@@ -539,7 +545,7 @@ gfx2_set_alpha_value(unsigned char value)
  */
 void
 gfx2_pattern_fill(unsigned long dstoffset, unsigned short width,
-    unsigned short height)
+                  unsigned short height)
 {
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
@@ -553,7 +559,7 @@ gfx2_pattern_fill(unsigned long dstoffset, unsigned short width,
  */
 void
 gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned long *pattern)
+                        unsigned short height, unsigned long *pattern)
 {
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
@@ -567,7 +573,8 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
  */
 void
 gfx2_screen_to_screen_blt(unsigned long srcoffset, unsigned long dstoffset,
-    unsigned short width, unsigned short height, int flags)
+                          unsigned short width, unsigned short height,
+                          int flags)
 {
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
@@ -581,13 +588,14 @@ gfx2_screen_to_screen_blt(unsigned long srcoffset, unsigned long dstoffset,
  */
 void
 gfx2_mono_expand_blt(unsigned long srcbase, unsigned short srcx,
-    unsigned short srcy, unsigned long dstoffset, unsigned short width,
-    unsigned short height, int byte_packed)
+                     unsigned short srcy, unsigned long dstoffset,
+                     unsigned short width, unsigned short height,
+                     int byte_packed)
 {
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
         gu22_mono_expand_blt(srcbase, srcx, srcy, dstoffset, width, height,
-            byte_packed);
+                             byte_packed);
 #endif
 }
 
@@ -597,13 +605,14 @@ gfx2_mono_expand_blt(unsigned long srcbase, unsigned short srcx,
  */
 void
 gfx2_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned long dstoffset, unsigned short width, unsigned short height,
-    unsigned char *data, short pitch)
+                                unsigned long dstoffset, unsigned short width,
+                                unsigned short height, unsigned char *data,
+                                short pitch)
 {
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
         gu22_color_bitmap_to_screen_blt(srcx, srcy, dstoffset, width, height,
-            data, pitch);
+                                        data, pitch);
 #endif
 }
 
@@ -613,7 +622,7 @@ gfx2_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
  */
 void
 gfx2_text_blt(unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned char *data)
+              unsigned short height, unsigned char *data)
 {
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
@@ -627,13 +636,14 @@ gfx2_text_blt(unsigned long dstoffset, unsigned short width,
  */
 void
 gfx2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned long dstoffset, unsigned short width, unsigned short height,
-    unsigned char *data, short pitch)
+                               unsigned long dstoffset, unsigned short width,
+                               unsigned short height, unsigned char *data,
+                               short pitch)
 {
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
         gu22_mono_bitmap_to_screen_blt(srcx, srcy, dstoffset, width, height,
-            data, pitch);
+                                       data, pitch);
 #endif
 }
 
@@ -643,13 +653,14 @@ gfx2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
  */
 void
 gfx2_bresenham_line(unsigned long dstoffset,
-    unsigned short length, unsigned short initerr,
-    unsigned short axialerr, unsigned short diagerr, unsigned short flags)
+                    unsigned short length, unsigned short initerr,
+                    unsigned short axialerr, unsigned short diagerr,
+                    unsigned short flags)
 {
 #if GFX_2DACCEL_GU2
     if (gfx_2daccel_type & GFX_2DACCEL_TYPE_GU2)
         gu22_bresenham_line(dstoffset, length, initerr, axialerr, diagerr,
-            flags);
+                            flags);
 #endif
 }
 
@@ -666,6 +677,6 @@ gfx2_sync_to_vblank(void)
 #endif
 }
 
-#endif /* GFX_2DACCEL_DYNAMIC */
+#endif                          /* GFX_2DACCEL_DYNAMIC */
 
 /* END OF FILE */
diff --git a/src/gfx/gfx_rtns.h b/src/gfx/gfx_rtns.h
index d7e001e..bfcfe9f 100644
--- a/src/gfx/gfx_rtns.h
+++ b/src/gfx/gfx_rtns.h
@@ -44,8 +44,7 @@
 /* COMPILER OPTION FOR C++ PROGRAMS */
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
 /* DURANGO MEMORY POINTERS */
@@ -126,13 +125,13 @@ extern "C"
     int gfx_msr_init(void);
     DEV_STATUS gfx_id_msr_device(MSR * pDev, unsigned long address);
     DEV_STATUS gfx_get_msr_dev_address(unsigned int device,
-        unsigned long *address);
+                                       unsigned long *address);
     DEV_STATUS gfx_get_glink_id_at_address(unsigned int *device,
-        unsigned long address);
+                                           unsigned long address);
     DEV_STATUS gfx_msr_read(unsigned int device, unsigned int msrRegister,
-        Q_WORD * msrValue);
+                            Q_WORD * msrValue);
     DEV_STATUS gfx_msr_write(unsigned int device, unsigned int msrRegister,
-        Q_WORD * msrValue);
+                             Q_WORD * msrValue);
 
 /* ROUTINES IN GFX_DISP.C */
 
@@ -140,18 +139,22 @@ extern "C"
     int gfx_is_display_mode_supported(int xres, int yres, int bpp, int hz);
     int gfx_set_display_mode(int xres, int yres, int bpp, int hz);
     int gfx_set_display_timings(unsigned short bpp, unsigned short flags,
-        unsigned short hactive, unsigned short hblank_start,
-        unsigned short hsync_start, unsigned short hsync_end,
-        unsigned short hblank_end, unsigned short htotal,
-        unsigned short vactive, unsigned short vblank_start,
-        unsigned short vsync_start, unsigned short vsync_end,
-        unsigned short vblank_end, unsigned short vtotal,
-        unsigned long frequency);
+                                unsigned short hactive,
+                                unsigned short hblank_start,
+                                unsigned short hsync_start,
+                                unsigned short hsync_end,
+                                unsigned short hblank_end,
+                                unsigned short htotal, unsigned short vactive,
+                                unsigned short vblank_start,
+                                unsigned short vsync_start,
+                                unsigned short vsync_end,
+                                unsigned short vblank_end,
+                                unsigned short vtotal, unsigned long frequency);
     int gfx_set_vtotal(unsigned short vtotal);
     void gfx_set_display_pitch(unsigned short pitch);
     void gfx_set_display_offset(unsigned long offset);
     int gfx_set_display_palette_entry(unsigned long index,
-        unsigned long palette);
+                                      unsigned long palette);
     int gfx_set_display_palette(unsigned long *palette);
     void gfx_video_shutdown(void);
     void gfx_set_clock_frequency(unsigned long frequency);
@@ -159,18 +162,19 @@ extern "C"
     void gfx_set_cursor_enable(int enable);
     void gfx_set_cursor_colors(unsigned long bkcolor, unsigned long fgcolor);
     void gfx_set_cursor_position(unsigned long memoffset,
-        unsigned short xpos, unsigned short ypos,
-        unsigned short xhotspot, unsigned short yhotspot);
-    void gfx_set_cursor_shape32(unsigned long memoffset,
-        unsigned long *andmask, unsigned long *xormask);
-    void gfx_set_cursor_shape64(unsigned long memoffset,
-        unsigned long *andmask, unsigned long *xormask);
+                                 unsigned short xpos, unsigned short ypos,
+                                 unsigned short xhotspot,
+                                 unsigned short yhotspot);
+    void gfx_set_cursor_shape32(unsigned long memoffset, unsigned long *andmask,
+                                unsigned long *xormask);
+    void gfx_set_cursor_shape64(unsigned long memoffset, unsigned long *andmask,
+                                unsigned long *xormask);
     void gfx_set_icon_enable(int enable);
     void gfx_set_icon_colors(unsigned long color0, unsigned long color1,
-        unsigned long color2);
+                             unsigned long color2);
     void gfx_set_icon_position(unsigned long memoffset, unsigned short xpos);
     void gfx_set_icon_shape64(unsigned long memoffset, unsigned long *andmask,
-        unsigned long *xormask, unsigned int lines);
+                              unsigned long *xormask, unsigned int lines);
 
     int gfx_set_compression_enable(int enable);
     int gfx_set_compression_offset(unsigned long offset);
@@ -184,30 +188,33 @@ extern "C"
     void gfx_delay_microseconds(unsigned long microseconds);
     void gfx_enable_panning(int x, int y);
     int gfx_is_panel_mode_supported(int panelResX, int panelResY,
-        unsigned short width, unsigned short height, unsigned short bpp);
+                                    unsigned short width, unsigned short height,
+                                    unsigned short bpp);
     int gfx_set_fixed_timings(int panelResX, int panelResY,
-        unsigned short width, unsigned short height, unsigned short bpp);
+                              unsigned short width, unsigned short height,
+                              unsigned short bpp);
     int gfx_set_panel_present(int panelResX, int panelResY,
-        unsigned short width, unsigned short height, unsigned short bpp);
+                              unsigned short width, unsigned short height,
+                              unsigned short bpp);
     void gfx_reset_timing_lock(void);
 
 /* "READ" ROUTINES IN GFX_DISP.C */
 
     int gfx_get_display_details(unsigned int mode, int *xres, int *yres,
-        int *hz);
+                                int *hz);
     unsigned short gfx_get_display_pitch(void);
     int gfx_get_vsa2_softvga_enable(void);
     int gfx_get_sync_polarities(void);
     unsigned long gfx_get_clock_frequency(void);
     unsigned long gfx_get_max_supported_pixel_clock(void);
     int gfx_mode_frequency_supported(int xres, int yres, int bpp,
-        unsigned long frequency);
+                                     unsigned long frequency);
     int gfx_get_refreshrate_from_frequency(int xres, int yres, int bpp,
-        int *hz, unsigned long frequency);
+                                           int *hz, unsigned long frequency);
     int gfx_get_refreshrate_from_mode(int xres, int yres, int bpp, int *hz,
-        unsigned long frequency);
+                                      unsigned long frequency);
     int gfx_get_frequency_from_refreshrate(int xres, int yres, int bpp,
-        int hz, int *frequency);
+                                           int hz, int *frequency);
     int gfx_get_display_mode_count(void);
     int gfx_get_display_mode(int *xres, int *yres, int *bpp, int *hz);
     unsigned long gfx_get_frame_buffer_line_size(void);
@@ -227,7 +234,7 @@ extern "C"
     unsigned short gfx_get_display_bpp(void);
     unsigned long gfx_get_display_offset(void);
     int gfx_get_display_palette_entry(unsigned long index,
-        unsigned long *palette);
+                                      unsigned long *palette);
     void gfx_get_display_palette(unsigned long *palette);
     unsigned long gfx_get_cursor_enable(void);
     unsigned long gfx_get_cursor_offset(void);
@@ -250,44 +257,57 @@ extern "C"
     void gfx_set_bpp(unsigned short bpp);
     void gfx_set_solid_pattern(unsigned long color);
     void gfx_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-        unsigned long data0, unsigned long data1, unsigned char transparency);
+                              unsigned long data0, unsigned long data1,
+                              unsigned char transparency);
     void gfx_set_color_pattern(unsigned long bgcolor, unsigned long fgcolor,
-        unsigned long data0, unsigned long data1, unsigned long data2,
-        unsigned long data3, unsigned char transparency);
+                               unsigned long data0, unsigned long data1,
+                               unsigned long data2, unsigned long data3,
+                               unsigned char transparency);
     void gfx_load_color_pattern_line(short y, unsigned long *pattern_8x8);
     void gfx_set_solid_source(unsigned long color);
     void gfx_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-        unsigned short transparent);
+                             unsigned short transparent);
     void gfx_set_pattern_flags(unsigned short flags);
     void gfx_set_raster_operation(unsigned char rop);
     void gfx_pattern_fill(unsigned short x, unsigned short y,
-        unsigned short width, unsigned short height);
+                          unsigned short width, unsigned short height);
     void gfx_color_pattern_fill(unsigned short x, unsigned short y,
-        unsigned short width, unsigned short height, unsigned long *pattern);
+                                unsigned short width, unsigned short height,
+                                unsigned long *pattern);
     void gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
-        unsigned short dstx, unsigned short dsty, unsigned short width,
-        unsigned short height);
+                                  unsigned short dstx, unsigned short dsty,
+                                  unsigned short width, unsigned short height);
     void gfx_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-        unsigned short dstx, unsigned short dsty, unsigned short width,
-        unsigned short height, unsigned long color);
+                                   unsigned short dstx, unsigned short dsty,
+                                   unsigned short width, unsigned short height,
+                                   unsigned long color);
     void gfx_color_bitmap_to_screen_blt(unsigned short srcx,
-        unsigned short srcy, unsigned short dstx, unsigned short dsty,
-        unsigned short width, unsigned short height, unsigned char *data,
-        long pitch);
+                                        unsigned short srcy,
+                                        unsigned short dstx,
+                                        unsigned short dsty,
+                                        unsigned short width,
+                                        unsigned short height,
+                                        unsigned char *data, long pitch);
     void gfx_color_bitmap_to_screen_xblt(unsigned short srcx,
-        unsigned short srcy, unsigned short dstx, unsigned short dsty,
-        unsigned short width, unsigned short height, unsigned char *data,
-        long pitch, unsigned long color);
-    void gfx_mono_bitmap_to_screen_blt(unsigned short srcx,
-        unsigned short srcy, unsigned short dstx, unsigned short dsty,
-        unsigned short width, unsigned short height, unsigned char *data,
-        short pitch);
+                                         unsigned short srcy,
+                                         unsigned short dstx,
+                                         unsigned short dsty,
+                                         unsigned short width,
+                                         unsigned short height,
+                                         unsigned char *data, long pitch,
+                                         unsigned long color);
+    void gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
+                                       unsigned short dstx, unsigned short dsty,
+                                       unsigned short width,
+                                       unsigned short height,
+                                       unsigned char *data, short pitch);
     void gfx_text_blt(unsigned short dstx, unsigned short dsty,
-        unsigned short width, unsigned short height, unsigned char *data);
+                      unsigned short width, unsigned short height,
+                      unsigned char *data);
     void gfx_bresenham_line(unsigned short x, unsigned short y,
-        unsigned short length, unsigned short initerr,
-        unsigned short axialerr, unsigned short diagerr,
-        unsigned short flags);
+                            unsigned short length, unsigned short initerr,
+                            unsigned short axialerr, unsigned short diagerr,
+                            unsigned short flags);
     void gfx_wait_until_idle(void);
     int gfx_test_blt_pending(void);
 
@@ -296,31 +316,39 @@ extern "C"
     void gfx2_set_source_stride(unsigned short stride);
     void gfx2_set_destination_stride(unsigned short stride);
     void gfx2_set_pattern_origin(int x, int y);
-    void gfx2_set_source_transparency(unsigned long color,
-        unsigned long mask);
+    void gfx2_set_source_transparency(unsigned long color, unsigned long mask);
     void gfx2_set_alpha_mode(int mode);
     void gfx2_set_alpha_value(unsigned char value);
     void gfx2_pattern_fill(unsigned long dstoffset, unsigned short width,
-        unsigned short height);
+                           unsigned short height);
     void gfx2_color_pattern_fill(unsigned long dstoffset,
-        unsigned short width, unsigned short height, unsigned long *pattern);
+                                 unsigned short width, unsigned short height,
+                                 unsigned long *pattern);
     void gfx2_screen_to_screen_blt(unsigned long srcoffset,
-        unsigned long dstoffset, unsigned short width, unsigned short height,
-        int flags);
+                                   unsigned long dstoffset,
+                                   unsigned short width, unsigned short height,
+                                   int flags);
     void gfx2_mono_expand_blt(unsigned long srcbase, unsigned short srcx,
-        unsigned short srcy, unsigned long dstoffset, unsigned short width,
-        unsigned short height, int byte_packed);
+                              unsigned short srcy, unsigned long dstoffset,
+                              unsigned short width, unsigned short height,
+                              int byte_packed);
     void gfx2_color_bitmap_to_screen_blt(unsigned short srcx,
-        unsigned short srcy, unsigned long dstoffset, unsigned short width,
-        unsigned short height, unsigned char *data, short pitch);
+                                         unsigned short srcy,
+                                         unsigned long dstoffset,
+                                         unsigned short width,
+                                         unsigned short height,
+                                         unsigned char *data, short pitch);
     void gfx2_mono_bitmap_to_screen_blt(unsigned short srcx,
-        unsigned short srcy, unsigned long dstoffset, unsigned short width,
-        unsigned short height, unsigned char *data, short pitch);
+                                        unsigned short srcy,
+                                        unsigned long dstoffset,
+                                        unsigned short width,
+                                        unsigned short height,
+                                        unsigned char *data, short pitch);
     void gfx2_text_blt(unsigned long dstoffset, unsigned short width,
-        unsigned short height, unsigned char *data);
+                       unsigned short height, unsigned char *data);
     void gfx2_bresenham_line(unsigned long dstoffset, unsigned short length,
-        unsigned short initerr, unsigned short axialerr,
-        unsigned short diagerr, unsigned short flags);
+                             unsigned short initerr, unsigned short axialerr,
+                             unsigned short diagerr, unsigned short flags);
     void gfx2_sync_to_vblank(void);
 
 /* ROUTINES IN GFX_VID.C */
@@ -331,29 +359,31 @@ extern "C"
     int gfx_set_video_yuv_pitch(unsigned long ypitch, unsigned long uvpitch);
     int gfx_set_video_offset(unsigned long offset);
     int gfx_set_video_yuv_offsets(unsigned long yoffset,
-        unsigned long uoffset, unsigned long voffset);
+                                  unsigned long uoffset, unsigned long voffset);
     int gfx_set_video_window(short x, short y, unsigned short w,
-        unsigned short h);
+                             unsigned short h);
     int gfx_set_video_left_crop(unsigned short x);
     int gfx_set_video_upscale(unsigned short srcw, unsigned short srch,
-        unsigned short dstw, unsigned short dsth);
+                              unsigned short dstw, unsigned short dsth);
     int gfx_set_video_scale(unsigned short srcw, unsigned short srch,
-        unsigned short dstw, unsigned short dsth);
+                            unsigned short dstw, unsigned short dsth);
     int gfx_set_video_vertical_downscale(unsigned short srch,
-        unsigned short dsth);
+                                         unsigned short dsth);
     void gfx_set_video_vertical_downscale_enable(int enable);
     int gfx_set_video_downscale_config(unsigned short type, unsigned short m);
     int gfx_set_video_color_key(unsigned long key, unsigned long mask,
-        int bluescreen);
+                                int bluescreen);
     int gfx_set_video_filter(int xfilter, int yfilter);
     int gfx_set_video_palette(unsigned long *palette);
     int gfx_set_graphics_palette(unsigned long *palette);
     int gfx_set_video_palette_bypass(int enable);
     int gfx_set_video_palette_entry(unsigned long index, unsigned long color);
     int gfx_set_graphics_palette_entry(unsigned long index,
-        unsigned long color);
+                                       unsigned long color);
     int gfx_set_video_downscale_coefficients(unsigned short coef1,
-        unsigned short coef2, unsigned short coef3, unsigned short coef4);
+                                             unsigned short coef2,
+                                             unsigned short coef3,
+                                             unsigned short coef4);
     int gfx_set_video_downscale_enable(int enable);
     int gfx_set_video_source(VideoSourceType source);
     int gfx_set_vbi_source(VbiSourceType source);
@@ -366,15 +396,15 @@ extern "C"
     int gfx_set_genlock_delay(unsigned long delay);
     int gfx_set_genlock_enable(int flags);
     int gfx_set_video_cursor(unsigned long key, unsigned long mask,
-        unsigned short select_color2, unsigned long color1,
-        unsigned long color2);
+                             unsigned short select_color2, unsigned long color1,
+                             unsigned long color2);
     int gfx_set_video_cursor_enable(int enable);
     int gfx_set_video_request(short x, short y);
 
     int gfx_select_alpha_region(int region);
     int gfx_set_alpha_enable(int enable);
     int gfx_set_alpha_window(short x, short y,
-        unsigned short width, unsigned short height);
+                             unsigned short width, unsigned short height);
     int gfx_set_alpha_value(unsigned char alpha, char delta);
     int gfx_set_alpha_priority(int priority);
     int gfx_set_alpha_color(unsigned long color);
@@ -394,24 +424,25 @@ extern "C"
     unsigned long gfx_get_video_xclip(void);
     unsigned long gfx_get_video_offset(void);
     void gfx_get_video_yuv_offsets(unsigned long *yoffset,
-        unsigned long *uoffset, unsigned long *voffset);
-    void gfx_get_video_yuv_pitch(unsigned long *ypitch,
-        unsigned long *uvpitch);
+                                   unsigned long *uoffset,
+                                   unsigned long *voffset);
+    void gfx_get_video_yuv_pitch(unsigned long *ypitch, unsigned long *uvpitch);
     unsigned long gfx_get_video_upscale(void);
     unsigned long gfx_get_video_scale(void);
     unsigned long gfx_get_video_downscale_delta(void);
     int gfx_get_video_vertical_downscale_enable(void);
-    int gfx_get_video_downscale_config(unsigned short *type,
-        unsigned short *m);
+    int gfx_get_video_downscale_config(unsigned short *type, unsigned short *m);
     void gfx_get_video_downscale_coefficients(unsigned short *coef1,
-        unsigned short *coef2, unsigned short *coef3, unsigned short *coef4);
+                                              unsigned short *coef2,
+                                              unsigned short *coef3,
+                                              unsigned short *coef4);
     void gfx_get_video_downscale_enable(int *enable);
     unsigned long gfx_get_video_dst_size(void);
     unsigned long gfx_get_video_position(void);
     unsigned long gfx_get_video_color_key(void);
     unsigned long gfx_get_video_color_key_mask(void);
     int gfx_get_video_palette_entry(unsigned long index,
-        unsigned long *palette);
+                                    unsigned long *palette);
     int gfx_get_video_color_key_src(void);
     int gfx_get_video_filter(void);
     int gfx_get_video_request(short *x, short *y);
@@ -425,18 +456,18 @@ extern "C"
     unsigned long gfx_get_genlock_delay(void);
     int gfx_get_genlock_enable(void);
     int gfx_get_video_cursor(unsigned long *key, unsigned long *mask,
-        unsigned short *select_color2, unsigned long *color1,
-        unsigned short *color2);
+                             unsigned short *select_color2,
+                             unsigned long *color1, unsigned short *color2);
     unsigned long gfx_read_crc(void);
     unsigned long gfx_read_crc32(void);
     unsigned long gfx_read_window_crc(int source, unsigned short x,
-        unsigned short y, unsigned short width, unsigned short height,
-        int crc32);
+                                      unsigned short y, unsigned short width,
+                                      unsigned short height, int crc32);
     int gfx_get_macrovision_enable(void);
 
     void gfx_get_alpha_enable(int *enable);
     void gfx_get_alpha_size(unsigned short *x, unsigned short *y,
-        unsigned short *width, unsigned short *height);
+                            unsigned short *width, unsigned short *height);
     void gfx_get_alpha_value(unsigned char *alpha, char *delta);
     void gfx_get_alpha_priority(int *priority);
     void gfx_get_alpha_color(unsigned long *color);
@@ -484,12 +515,11 @@ extern "C"
     int gfx_set_decoder_hue(char hue);
     int gfx_set_decoder_saturation(unsigned char saturation);
     int gfx_set_decoder_input_offset(unsigned short x, unsigned short y);
-    int gfx_set_decoder_input_size(unsigned short width,
-        unsigned short height);
+    int gfx_set_decoder_input_size(unsigned short width, unsigned short height);
     int gfx_set_decoder_output_size(unsigned short width,
-        unsigned short height);
+                                    unsigned short height);
     int gfx_set_decoder_scale(unsigned short srcw, unsigned short srch,
-        unsigned short dstw, unsigned short dsth);
+                              unsigned short dstw, unsigned short dsth);
     int gfx_set_decoder_vbi_format(int start, int end, int format);
     int gfx_set_decoder_vbi_enable(int enable);
     int gfx_set_decoder_vbi_upscale(void);
@@ -514,9 +544,11 @@ extern "C"
 
     int gfx_i2c_reset(unsigned char busnum, short adr, char freq);
     int gfx_i2c_write(unsigned char busnum, unsigned char chipadr,
-        unsigned char subadr, unsigned char bytes, unsigned char *data);
+                      unsigned char subadr, unsigned char bytes,
+                      unsigned char *data);
     int gfx_i2c_read(unsigned char busnum, unsigned char chipadr,
-        unsigned char subadr, unsigned char bytes, unsigned char *data);
+                     unsigned char subadr, unsigned char bytes,
+                     unsigned char *data);
     int gfx_i2c_select_gpio(int clock, int data);
     int gfx_i2c_init(void);
     void gfx_i2c_cleanup(void);
@@ -543,9 +575,12 @@ extern "C"
     int gfx_get_tv_mode_count(TVStandardType format);
     int gfx_get_tv_display_mode(int *width, int *height, int *bpp, int *hz);
     int gfx_get_tv_display_mode_frequency(unsigned short width,
-        unsigned short height, TVStandardType format, int *frequency);
+                                          unsigned short height,
+                                          TVStandardType format,
+                                          int *frequency);
     int gfx_is_tv_display_mode_supported(unsigned short width,
-        unsigned short height, TVStandardType format);
+                                         unsigned short height,
+                                         TVStandardType format);
 
     int gfx_get_tv_standard(unsigned long *p_standard);
     int gfx_get_available_tv_standards(unsigned long *p_standards);
@@ -582,8 +617,7 @@ extern "C"
     int gfx_vga_set_pci_command(unsigned char command);
     int gfx_vga_seq_reset(int reset);
     int gfx_vga_set_graphics_bits(void);
-    int gfx_vga_mode(gfx_vga_struct * vga, int xres, int yres, int bpp,
-        int hz);
+    int gfx_vga_mode(gfx_vga_struct * vga, int xres, int yres, int bpp, int hz);
     int gfx_vga_pitch(gfx_vga_struct * vga, unsigned short pitch);
     int gfx_vga_save(gfx_vga_struct * vga, int flags);
     int gfx_vga_restore(gfx_vga_struct * vga, int flags);
@@ -595,7 +629,5 @@ extern "C"
 #ifdef __cplusplus
 }
 #endif
-
-#endif                                 /* !_gfx_rtns_h */
-
+#endif                          /* !_gfx_rtns_h */
 /* END OF FILE */
diff --git a/src/gfx/gfx_tv.c b/src/gfx/gfx_tv.c
index fb34d60..3ee4a0c 100644
--- a/src/gfx/gfx_tv.c
+++ b/src/gfx/gfx_tv.c
@@ -50,42 +50,42 @@ DISPLAYMODE TVTimings[] = {
 
 /* NTSC resolution */
 
-    {0x3 |                             /* negative syncs       */
-            GFX_MODE_TV_NTSC,          /* NTSC format          */
-            640, 640, 656, 744, 792, 792,       /* horizontal timings   */
-            480, 480, 490, 492, 517, 525,       /* vertical timings     */
-            0x0018EC4D,                /* freq = 24.923052 MHz */
-        }
+    {0x3 |                      /* negative syncs       */
+     GFX_MODE_TV_NTSC,          /* NTSC format          */
+     640, 640, 656, 744, 792, 792,      /* horizontal timings   */
+     480, 480, 490, 492, 517, 525,      /* vertical timings     */
+     0x0018EC4D,                /* freq = 24.923052 MHz */
+     }
     ,
 
 /* PAL resolution */
 
-    {0x3 |                             /* negative syncs       */
-            GFX_MODE_TV_PAL,           /* PAL format           */
-            768, 768, 800, 848, 864, 864,       /* horizontal timings   */
-            576, 576, 586, 588, 625, 625,       /* vertical timings     */
-            0x001B0000,                /* freq = 27.00 MHz     */
-        }
+    {0x3 |                      /* negative syncs       */
+     GFX_MODE_TV_PAL,           /* PAL format           */
+     768, 768, 800, 848, 864, 864,      /* horizontal timings   */
+     576, 576, 586, 588, 625, 625,      /* vertical timings     */
+     0x001B0000,                /* freq = 27.00 MHz     */
+     }
     ,
 
 /* NTSC resolution non-square pixels */
 
-    {0x3 |                             /* negative syncs       */
-            GFX_MODE_TV_NTSC,          /* NTSC format          */
-            720, 720, 736, 752, 792, 792,       /* horizontal timings   */
-            480, 480, 490, 492, 517, 525,       /* vertical timings     */
-            0x0018EC4D,                /* freq = 24.923052 MHz */
-        }
+    {0x3 |                      /* negative syncs       */
+     GFX_MODE_TV_NTSC,          /* NTSC format          */
+     720, 720, 736, 752, 792, 792,      /* horizontal timings   */
+     480, 480, 490, 492, 517, 525,      /* vertical timings     */
+     0x0018EC4D,                /* freq = 24.923052 MHz */
+     }
     ,
 
 /* PAL resolution non-square pixels */
 
-    {0x3 |                             /* negative syncs       */
-            GFX_MODE_TV_PAL,           /* PAL format           */
-            720, 720, 752, 816, 864, 864,       /* horizontal timings   */
-            576, 576, 586, 588, 625, 625,       /* vertical timings     */
-            0x001B0000,                /* freq = 27.00 MHz     */
-        }
+    {0x3 |                      /* negative syncs       */
+     GFX_MODE_TV_PAL,           /* PAL format           */
+     720, 720, 752, 816, 864, 864,      /* horizontal timings   */
+     576, 576, 586, 588, 625, 625,      /* vertical timings     */
+     0x001B0000,                /* freq = 27.00 MHz     */
+     }
 };
 
 #define NUM_TV_MODES sizeof(TVTimings)/sizeof(DISPLAYMODE)
@@ -438,7 +438,7 @@ gfx_get_tv_display_mode(int *width, int *height, int *bpp, int *hz)
  */
 int
 gfx_get_tv_display_mode_frequency(unsigned short width, unsigned short height,
-    TVStandardType format, int *frequency)
+                                  TVStandardType format, int *frequency)
 {
     int retval = -1;
 
@@ -446,7 +446,7 @@ gfx_get_tv_display_mode_frequency(unsigned short width, unsigned short height,
     if (gfx_tv_type & GFX_TV_TYPE_SC1200)
         retval =
             sc1200_get_tv_display_mode_frequency(width, height, format,
-            frequency);
+                                                 frequency);
 #endif
     return (retval);
 }
@@ -457,7 +457,7 @@ gfx_get_tv_display_mode_frequency(unsigned short width, unsigned short height,
  */
 int
 gfx_is_tv_display_mode_supported(unsigned short width, unsigned short height,
-    TVStandardType format)
+                                 TVStandardType format)
 {
     int retval = -1;
 
@@ -831,6 +831,6 @@ gfx_set_aps_trigger_bits(unsigned int trigger_bits)
     return (retval);
 }
 
-#endif /* GFX_TV_DYNAMIC */
+#endif                          /* GFX_TV_DYNAMIC */
 
 /* END OF FILE */
diff --git a/src/gfx/gfx_type.h b/src/gfx/gfx_type.h
index 33b6cab..4492354 100644
--- a/src/gfx/gfx_type.h
+++ b/src/gfx/gfx_type.h
@@ -34,24 +34,21 @@
 /* MSR DEFINITIONS */
 
 typedef enum DevStatus
-{ FOUND, NOT_KNOWN, REQ_NOT_FOUND, REQ_NOT_INSTALLED } DEV_STATUS;
+    { FOUND, NOT_KNOWN, REQ_NOT_FOUND, REQ_NOT_INSTALLED } DEV_STATUS;
 
-typedef struct msr
-{
-    DEV_STATUS Present;                /* Node enumeration status          */
-    unsigned char Id;                  /* Device ID (from MSR specs)       */
-    unsigned long Address;             /* Address - 32-bit MBus address at     */
+typedef struct msr {
+    DEV_STATUS Present;         /* Node enumeration status          */
+    unsigned char Id;           /* Device ID (from MSR specs)       */
+    unsigned long Address;      /* Address - 32-bit MBus address at     */
     /* which 'Id' is found                          */
 } MSR;
 
-typedef struct mValue
-{
+typedef struct mValue {
     unsigned long high;
     unsigned long low;
 } Q_WORD;
 
-typedef struct mbusNode
-{
+typedef struct mbusNode {
     unsigned long address;
     unsigned int deviceId;
     unsigned int claimed;
@@ -126,14 +123,12 @@ typedef struct mbusNode
 
 /* TV DEFINITIONS */
 
-typedef enum TVStandardType
-{
+typedef enum TVStandardType {
     TV_STANDARD_NTSC = 1,
     TV_STANDARD_PAL
 } TVStandardType;
 
-typedef enum GfxOnTVType
-{
+typedef enum GfxOnTVType {
     GFX_ON_TV_SQUARE_PIXELS = 1,
     GFX_ON_TV_NO_SCALING
 } GfxOnTVType;
@@ -195,14 +190,12 @@ typedef enum GfxOnTVType
 #define VIDEO_DOWNSCALE_KEEP_1_OF 0x1
 #define VIDEO_DOWNSCALE_DROP_1_OF 0x2
 
-typedef enum VideoSourceType
-{                                      /* The source from which the video processor shows full screen video */
+typedef enum VideoSourceType {  /* The source from which the video processor shows full screen video */
     VIDEO_SOURCE_MEMORY = 1,
     VIDEO_SOURCE_DVIP
 } VideoSourceType;
 
-typedef enum VbiSourceType
-{                                      /* The source from which the video processor takes VBI */
+typedef enum VbiSourceType {    /* The source from which the video processor takes VBI */
     VBI_SOURCE_MEMORY = 1,
     VBI_SOURCE_DVIP
 } VbiSourceType;
@@ -281,8 +274,7 @@ typedef enum VbiSourceType
 #define GFX_APS_TRIGGER_AGC_2_LINE 2
 #define GFX_APS_TRIGGER_AGC_4_LINE 3
 
-typedef struct
-{
+typedef struct {
     int xsize;
     int ysize;
     int hz;
@@ -312,8 +304,7 @@ typedef struct
 
 /* CHIP NAME AND REVISION */
 
-typedef enum ChipType
-{
+typedef enum ChipType {
     CHIP_NOT_DETECTED,
     SC1200_REV_A,
     SC1200_REV_B1_B2,
@@ -321,9 +312,9 @@ typedef enum ChipType
     SC1200_REV_C1,
     SC1200_REV_D1,
     SC1200_REV_D1_1,
-    SC1200_REV_D2_MVD,                 /* Macrovision disabled */
-    SC1200_REV_D2_MVE,                 /* Macrovision enabled  */
+    SC1200_REV_D2_MVD,          /* Macrovision disabled */
+    SC1200_REV_D2_MVE,          /* Macrovision enabled  */
     SC1200_FUTURE_REV
 } ChipType;
 
-#endif /* !_gfx_type_h */
+#endif                          /* !_gfx_type_h */
diff --git a/src/gfx/gfx_vga.c b/src/gfx/gfx_vga.c
index 8ab9b6a..101c7a8 100644
--- a/src/gfx/gfx_vga.c
+++ b/src/gfx/gfx_vga.c
@@ -40,6 +40,6 @@
 
 #if GFX_VGA_DYNAMIC
 
-#endif /* GFX_DISPLAY_DYNAMIC */
+#endif                          /* GFX_DISPLAY_DYNAMIC */
 
 /* END OF FILE */
diff --git a/src/gfx/gfx_vid.c b/src/gfx/gfx_vid.c
index 41fef74..15f0048 100644
--- a/src/gfx/gfx_vid.c
+++ b/src/gfx/gfx_vid.c
@@ -129,23 +129,23 @@
 /* STATIC VARIABLES FOR VIDEO OVERLAY CONTROL */
 /* These are saved to allow these routines to do clipping. */
 
-unsigned long gfx_vid_offset = 0;      /* copy from last gfx_set_video_offset  */
-unsigned long gfx_vid_uoffset = 0;     /* copy from last 
-                                        * gfx_set_video_yuv_offsets                        */
-unsigned long gfx_vid_voffset = 0;     /* copy from last 
-                                        * gfx_set_video_yuv_offsets                        */
-unsigned long gfx_vid_srcw = 300;      /* copy from last gfx_set_video_scale       */
-unsigned long gfx_vid_srch = 300;      /* copy from last gfx_set_video_scale       */
-unsigned long gfx_vid_dstw = 300;      /* copy from last gfx_set_video_scale       */
-unsigned long gfx_vid_dsth = 300;      /* copy from last gfx_set_video_scale       */
-short gfx_vid_xpos = 0;                /* copy from last gfx_set_video_window      */
-short gfx_vid_ypos = 0;                /* copy from last gfx_set_video_window      */
-unsigned short gfx_vid_width = 0;      /* copy from last gfx_set_video_window      */
-unsigned short gfx_vid_height = 0;     /* copy from last gfx_set_video_window      */
-
-int gfx_alpha_select = 0;              /* currently selected alpha region          */
-
-int gfx_set_screen_enable(int enable); /* forward declaration                           */
+unsigned long gfx_vid_offset = 0;       /* copy from last gfx_set_video_offset  */
+unsigned long gfx_vid_uoffset = 0;      /* copy from last 
+                                         * gfx_set_video_yuv_offsets                        */
+unsigned long gfx_vid_voffset = 0;      /* copy from last 
+                                         * gfx_set_video_yuv_offsets                        */
+unsigned long gfx_vid_srcw = 300;       /* copy from last gfx_set_video_scale       */
+unsigned long gfx_vid_srch = 300;       /* copy from last gfx_set_video_scale       */
+unsigned long gfx_vid_dstw = 300;       /* copy from last gfx_set_video_scale       */
+unsigned long gfx_vid_dsth = 300;       /* copy from last gfx_set_video_scale       */
+short gfx_vid_xpos = 0;         /* copy from last gfx_set_video_window      */
+short gfx_vid_ypos = 0;         /* copy from last gfx_set_video_window      */
+unsigned short gfx_vid_width = 0;       /* copy from last gfx_set_video_window      */
+unsigned short gfx_vid_height = 0;      /* copy from last gfx_set_video_window      */
+
+int gfx_alpha_select = 0;       /* currently selected alpha region          */
+
+int gfx_set_screen_enable(int enable);  /* forward declaration                           */
 
 /* INCLUDE SUPPORT FOR CS5530, IF SPECIFIED. */
 
@@ -420,7 +420,7 @@ gfx_set_video_offset(unsigned long offset)
  */
 int
 gfx_set_video_yuv_offsets(unsigned long yoffset, unsigned long uoffset,
-    unsigned long voffset)
+                          unsigned long voffset)
 {
     int status = GFX_STATUS_UNSUPPORTED;
 
@@ -437,7 +437,7 @@ gfx_set_video_yuv_offsets(unsigned long yoffset, unsigned long uoffset,
  */
 int
 gfx_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                    unsigned short dstw, unsigned short dsth)
 {
     int status = GFX_STATUS_UNSUPPORTED;
 
@@ -462,7 +462,7 @@ gfx_set_video_scale(unsigned short srcw, unsigned short srch,
  */
 int
 gfx_set_video_upscale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                      unsigned short dstw, unsigned short dsth)
 {
     int status = GFX_STATUS_UNSUPPORTED;
 
@@ -528,21 +528,21 @@ gfx_set_video_downscale_config(unsigned short type, unsigned short m)
  */
 int
 gfx_set_video_downscale_coefficients(unsigned short coef1,
-    unsigned short coef2, unsigned short coef3, unsigned short coef4)
+                                     unsigned short coef2, unsigned short coef3,
+                                     unsigned short coef4)
 {
     int status = GFX_STATUS_UNSUPPORTED;
 
 #if GFX_VIDEO_SC1200
     if (gfx_video_type == GFX_VIDEO_TYPE_SC1200)
         status =
-            sc1200_set_video_downscale_coefficients(coef1, coef2, coef3,
-            coef4);
+            sc1200_set_video_downscale_coefficients(coef1, coef2, coef3, coef4);
 #endif
 #if GFX_VIDEO_REDCLOUD
     if (gfx_video_type == GFX_VIDEO_TYPE_REDCLOUD)
         status =
             redcloud_set_video_downscale_coefficients(coef1, coef2, coef3,
-            coef4);
+                                                      coef4);
 #endif
     return (status);
 }
@@ -951,7 +951,8 @@ gfx_set_genlock_enable(int flags)
  */
 int
 gfx_set_video_cursor(unsigned long key, unsigned long mask,
-    unsigned short select_color2, unsigned long color1, unsigned long color2)
+                     unsigned short select_color2, unsigned long color1,
+                     unsigned long color2)
 {
     int status = GFX_STATUS_UNSUPPORTED;
 
@@ -963,8 +964,7 @@ gfx_set_video_cursor(unsigned long key, unsigned long mask,
 #if GFX_VIDEO_REDCLOUD
     if (gfx_video_type == GFX_VIDEO_TYPE_REDCLOUD)
         status =
-            redcloud_set_video_cursor(key, mask, select_color2, color1,
-            color2);
+            redcloud_set_video_cursor(key, mask, select_color2, color1, color2);
 #endif
     return (status);
 }
@@ -1011,7 +1011,7 @@ gfx_set_alpha_enable(int enable)
  */
 int
 gfx_set_alpha_window(short x, short y,
-    unsigned short width, unsigned short height)
+                     unsigned short width, unsigned short height)
 {
     int status = GFX_STATUS_UNSUPPORTED;
 
@@ -1451,7 +1451,7 @@ gfx_get_video_offset(void)
  */
 void
 gfx_get_video_yuv_offsets(unsigned long *yoffset, unsigned long *uoffset,
-    unsigned long *voffset)
+                          unsigned long *voffset)
 {
 #if GFX_VIDEO_REDCLOUD
     if (gfx_video_type == GFX_VIDEO_TYPE_REDCLOUD)
@@ -1570,7 +1570,9 @@ gfx_get_video_downscale_config(unsigned short *type, unsigned short *m)
  */
 void
 gfx_get_video_downscale_coefficients(unsigned short *coef1,
-    unsigned short *coef2, unsigned short *coef3, unsigned short *coef4)
+                                     unsigned short *coef2,
+                                     unsigned short *coef3,
+                                     unsigned short *coef4)
 {
 #if GFX_VIDEO_SC1200
     if (gfx_video_type == GFX_VIDEO_TYPE_SC1200)
@@ -1802,7 +1804,7 @@ gfx_get_vbi_source(VbiSourceType * source)
 unsigned long
 gfx_get_vbi_lines(int odd)
 {
-    unsigned long lines = (unsigned long)GFX_STATUS_UNSUPPORTED;
+    unsigned long lines = (unsigned long) GFX_STATUS_UNSUPPORTED;
 
 #if GFX_VIDEO_SC1200
     if (gfx_video_type == GFX_VIDEO_TYPE_SC1200)
@@ -1818,7 +1820,7 @@ gfx_get_vbi_lines(int odd)
 unsigned long
 gfx_get_vbi_total(int odd)
 {
-    unsigned long total = (unsigned long)GFX_STATUS_UNSUPPORTED;
+    unsigned long total = (unsigned long) GFX_STATUS_UNSUPPORTED;
 
 #if GFX_VIDEO_SC1200
     if (gfx_video_type == GFX_VIDEO_TYPE_SC1200)
@@ -1882,7 +1884,7 @@ gfx_get_vertical_scaler_offset(char *offset)
 unsigned long
 gfx_get_genlock_delay(void)
 {
-    unsigned long delay = (unsigned long)GFX_STATUS_UNSUPPORTED;
+    unsigned long delay = (unsigned long) GFX_STATUS_UNSUPPORTED;
 
 #if GFX_VIDEO_SC1200
     if (gfx_video_type == GFX_VIDEO_TYPE_SC1200)
@@ -1913,8 +1915,8 @@ gfx_get_genlock_enable(void)
  */
 int
 gfx_get_video_cursor(unsigned long *key, unsigned long *mask,
-    unsigned short *select_color2, unsigned long *color1,
-    unsigned short *color2)
+                     unsigned short *select_color2, unsigned long *color1,
+                     unsigned short *color2)
 {
     int enable = GFX_STATUS_UNSUPPORTED;
 
@@ -1926,8 +1928,7 @@ gfx_get_video_cursor(unsigned long *key, unsigned long *mask,
 #if GFX_VIDEO_REDCLOUD
     if (gfx_video_type == GFX_VIDEO_TYPE_REDCLOUD)
         enable =
-            redcloud_get_video_cursor(key, mask, select_color2, color1,
-            color2);
+            redcloud_get_video_cursor(key, mask, select_color2, color1, color2);
 #endif
     return (enable);
 }
@@ -1978,7 +1979,7 @@ gfx_read_crc32(void)
  */
 unsigned long
 gfx_read_window_crc(int source, unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, int crc32)
+                    unsigned short width, unsigned short height, int crc32)
 {
     unsigned long crc = 0;
 
@@ -2029,7 +2030,7 @@ gfx_get_alpha_enable(int *enable)
  */
 void
 gfx_get_alpha_size(unsigned short *x, unsigned short *y,
-    unsigned short *width, unsigned short *height)
+                   unsigned short *width, unsigned short *height)
 {
 #if GFX_VIDEO_SC1200
     if (gfx_video_type == GFX_VIDEO_TYPE_SC1200)
@@ -2096,8 +2097,8 @@ gfx_get_alpha_color(unsigned long *color)
     return;
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
-#endif /* GFX_VIDEO_DYNAMIC */
+#endif                          /* GFX_VIDEO_DYNAMIC */
 
 /* END OF FILE */
diff --git a/src/gfx/gfx_vip.c b/src/gfx/gfx_vip.c
index e38c2f7..d3994a6 100644
--- a/src/gfx/gfx_vip.c
+++ b/src/gfx/gfx_vip.c
@@ -524,8 +524,8 @@ gfx_get_vip_bus_request_threshold_high(void)
     return (enable);
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
-#endif /* GFX_VIP_DYNAMIC */
+#endif                          /* GFX_VIP_DYNAMIC */
 
 /* END OF FILE */
diff --git a/src/gfx/i2c_acc.c b/src/gfx/i2c_acc.c
index a45a2c3..f6a0b2f 100644
--- a/src/gfx/i2c_acc.c
+++ b/src/gfx/i2c_acc.c
@@ -48,15 +48,15 @@ unsigned short index_reg, data_reg;
 
 /* ACCESS BUS DEFINITIONS */
 
-#define ACC_I2C_TIMEOUT 1000000        /* Number of reads before timing out */
-#define ACB1_BASE 	    0x810      /* ACCESS.bus base addresses         */
+#define ACC_I2C_TIMEOUT 1000000 /* Number of reads before timing out */
+#define ACB1_BASE 	    0x810       /* ACCESS.bus base addresses         */
 #define ACB2_BASE 	    0x820
-#define ACBSDA			0      /* ACB serial data                   */
-#define ACBST			1      /* ACB status                        */
-#define ACBCST			2      /* ACB control status                */
-#define ACBCTL1			3      /* ACB control 1                     */
-#define ACBADDR			4      /* ACB own address                   */
-#define ACBCTL2		    5          /* ACB control 2                     */
+#define ACBSDA			0       /* ACB serial data                   */
+#define ACBST			1       /* ACB status                        */
+#define ACBCST			2       /* ACB control status                */
+#define ACBCTL1			3       /* ACB control 1                     */
+#define ACBADDR			4       /* ACB own address                   */
+#define ACBCTL2		    5   /* ACB control 2                     */
 #define LDN				0x7     /* Logical Device Numbers            */
 #define ACB1_LDN		0x5
 #define ACB2_LDN		0x6
@@ -64,6 +64,7 @@ unsigned short index_reg, data_reg;
 /* INITIAL ACCESS.bus BASE ADDRESS VALUES */
 
 unsigned short base_address_array[3] = { 0, ACB1_BASE, ACB2_BASE };
+
 char Freq = 0x71;
 
 /* LOCAL ACCESS.bus FUNCTION DECLARATIONS */
@@ -88,7 +89,7 @@ unsigned short acc_i2c_set_base_address(unsigned char busnum, short adr);
 /* LOCAL HELPER ROUTINES */
 
 void OsPciReadDWord(int bus, int dev, int func, int address,
-    unsigned long *data);
+                    unsigned long *data);
 int sio_set_index_data_reg(void);
 void sio_write_reg(unsigned char reg, unsigned char data);
 unsigned char sio_read_reg(unsigned char reg);
@@ -112,8 +113,8 @@ OsPciReadDWord(int bus, int dev, int func, int address, unsigned long *data)
      * {10000000,bus[23:16],device[15:11],function[10:8],address[7:2],00}
      */
     long addr = (0x80000000 |
-        ((bus & 0xff) << 16) |
-        ((dev & 0x1f) << 11) | ((func & 0x7) << 8) | (address & 0xff));
+                 ((bus & 0xff) << 16) |
+                 ((dev & 0x1f) << 11) | ((func & 0x7) << 8) | (address & 0xff));
     OUTD(PCI_INDEX, addr);
     *data = IND(PCI_DATA);
 }
@@ -135,7 +136,7 @@ sio_set_index_data_reg(void)
 
     OsPciReadDWord(0, 0x12, 5, 0x10, &xbus_expention_bar);
     xbus_expention_bar = xbus_expention_bar & 0xfffffffe;
-    io_control_reg1 = IND((unsigned short)xbus_expention_bar);
+    io_control_reg1 = IND((unsigned short) xbus_expention_bar);
 
     if ((io_control_reg1) & (SIO_BASE_ADR_15C_15D)) {
         index_reg = INDEX_1;
@@ -240,11 +241,11 @@ gfx_i2c_select_gpio(int clock, int data)
 #if GFX_I2C_DYNAMIC
 int
 acc_i2c_write(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data)
+              unsigned char subadr, unsigned char bytes, unsigned char *data)
 #else
 int
 gfx_i2c_write(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data)
+              unsigned char subadr, unsigned char bytes, unsigned char *data)
 #endif
 {
     int loop = 0;
@@ -261,7 +262,7 @@ gfx_i2c_write(unsigned char busnum, unsigned char chipadr,
 
     acc_i2c_ack(busnum, 1, 0);
     acc_i2c_stall_after_start(busnum, 1);
-    acc_i2c_send_address(busnum, (unsigned char)(chipadr & 0xFE));
+    acc_i2c_send_address(busnum, (unsigned char) (chipadr & 0xFE));
     acc_i2c_stall_after_start(busnum, 0);
     if (!acc_i2c_ack(busnum, 0, 0))
         return (GFX_STATUS_ERROR);
@@ -297,11 +298,11 @@ gfx_i2c_write(unsigned char busnum, unsigned char chipadr,
 #if GFX_I2C_DYNAMIC
 int
 acc_i2c_read(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data)
+             unsigned char subadr, unsigned char bytes, unsigned char *data)
 #else
 int
 gfx_i2c_read(unsigned char busnum, unsigned char chipadr,
-    unsigned char subadr, unsigned char bytes, unsigned char *data)
+             unsigned char subadr, unsigned char bytes, unsigned char *data)
 #endif
 {
     unsigned char bytesRead;
@@ -321,7 +322,7 @@ gfx_i2c_read(unsigned char busnum, unsigned char chipadr,
 
     acc_i2c_ack(busnum, 1, 0);
     acc_i2c_stall_after_start(busnum, 1);
-    acc_i2c_send_address(busnum, (unsigned char)(chipadr & 0xFE));
+    acc_i2c_send_address(busnum, (unsigned char) (chipadr & 0xFE));
     acc_i2c_stall_after_start(busnum, 0);
     if (!acc_i2c_ack(busnum, 0, 0))
         return (GFX_STATUS_ERROR);
@@ -340,7 +341,7 @@ gfx_i2c_read(unsigned char busnum, unsigned char chipadr,
 
     acc_i2c_ack(busnum, 1, 1);
     acc_i2c_stall_after_start(busnum, 1);
-    acc_i2c_send_address(busnum, (unsigned char)(chipadr | 0x01));
+    acc_i2c_send_address(busnum, (unsigned char) (chipadr | 0x01));
 
     /* IF LAST BYTE */
 
@@ -360,11 +361,13 @@ gfx_i2c_read(unsigned char busnum, unsigned char chipadr,
         if (bytesRead < (bytes - 2)) {
             data[bytesRead] = acc_i2c_read_byte(busnum, 0);
             acc_i2c_ack(busnum, 1, 0);
-        } else if (bytesRead == (bytes - 2)) {  /* TWO BYTES LEFT */
+        }
+        else if (bytesRead == (bytes - 2)) {    /* TWO BYTES LEFT */
             acc_i2c_ack(busnum, 1, 1);
             data[bytesRead] = acc_i2c_read_byte(busnum, 0);
             acc_i2c_ack(busnum, 1, 1);
-        } else {                       /* LAST BYTE */
+        }
+        else {                  /* LAST BYTE */
 
             data[bytesRead] = acc_i2c_read_byte(busnum, 1);
             acc_i2c_stop(busnum);
@@ -432,32 +435,32 @@ acc_i2c_reset_bus(unsigned char busnum)
 
     /* Disable the ACCESS.bus device and */
     /* Configure the SCL frequency */
-    OUTB((unsigned short)(bus_base_address + ACBCTL2),
-        (unsigned char)(Freq & 0xFE));
+    OUTB((unsigned short) (bus_base_address + ACBCTL2),
+         (unsigned char) (Freq & 0xFE));
 
     /* Configure no interrupt mode (polling) and */
     /* Disable global call address */
-    OUTB((unsigned short)(bus_base_address + ACBCTL1), 0x0);
+    OUTB((unsigned short) (bus_base_address + ACBCTL1), 0x0);
 
     /* Disable slave address */
-    OUTB((unsigned short)(bus_base_address + ACBADDR), 0x0);
+    OUTB((unsigned short) (bus_base_address + ACBADDR), 0x0);
 
     /* Enable the ACCESS.bus device */
-    reg = INB((unsigned short)(bus_base_address + ACBCTL2));
+    reg = INB((unsigned short) (bus_base_address + ACBCTL2));
     reg |= 0x01;
-    OUTB((unsigned short)(bus_base_address + ACBCTL2), reg);
+    OUTB((unsigned short) (bus_base_address + ACBCTL2), reg);
 
     /* Issue STOP event */
 
     acc_i2c_stop(busnum);
 
     /* Clear NEGACK, STASTR and BER bits */
-    OUTB((unsigned short)(bus_base_address + ACBST), 0x38);
+    OUTB((unsigned short) (bus_base_address + ACBST), 0x38);
 
     /* Clear BB (BUS BUSY) bit */
-    reg = INB((unsigned short)(bus_base_address + ACBCST));
+    reg = INB((unsigned short) (bus_base_address + ACBCST));
     reg |= 0x02;
-    OUTB((unsigned short)(bus_base_address + ACBCST), reg);
+    OUTB((unsigned short) (bus_base_address + ACBCST), reg);
 }
 
 /*---------------------------------------------------------------------------
@@ -472,9 +475,9 @@ acc_i2c_start(unsigned char busnum)
     unsigned char reg;
     unsigned short bus_base_address = base_address_array[busnum];
 
-    reg = INB((unsigned short)(bus_base_address + ACBCTL1));
+    reg = INB((unsigned short) (bus_base_address + ACBCTL1));
     reg |= 0x01;
-    OUTB((unsigned short)(bus_base_address + ACBCTL1), reg);
+    OUTB((unsigned short) (bus_base_address + ACBCTL1), reg);
 }
 
 /*---------------------------------------------------------------------------
@@ -489,9 +492,9 @@ acc_i2c_stop(unsigned char busnum)
     unsigned char reg;
     unsigned short bus_base_address = base_address_array[busnum];
 
-    reg = INB((unsigned short)(bus_base_address + ACBCTL1));
+    reg = INB((unsigned short) (bus_base_address + ACBCTL1));
     reg |= 0x02;
-    OUTB((unsigned short)(bus_base_address + ACBCTL1), reg);
+    OUTB((unsigned short) (bus_base_address + ACBCTL1), reg);
 }
 
 /*---------------------------------------------------------------------------
@@ -505,9 +508,9 @@ acc_i2c_abort_data(unsigned char busnum)
     unsigned short bus_base_address = base_address_array[busnum];
 
     acc_i2c_stop(busnum);
-    reg = INB((unsigned short)(bus_base_address + ACBCTL1));
+    reg = INB((unsigned short) (bus_base_address + ACBCTL1));
     reg |= 0x10;
-    OUTB((unsigned short)(bus_base_address + ACBCTL1), reg);
+    OUTB((unsigned short) (bus_base_address + ACBCTL1), reg);
 }
 
 /*---------------------------------------------------------------------------
@@ -531,17 +534,17 @@ acc_i2c_stall_after_start(unsigned char busnum, int state)
     unsigned char reg;
     unsigned short bus_base_address = base_address_array[busnum];
 
-    reg = INB((unsigned short)(bus_base_address + ACBCTL1));
+    reg = INB((unsigned short) (bus_base_address + ACBCTL1));
     if (state)
         reg |= 0x80;
     else
         reg &= 0x7F;
-    OUTB((unsigned short)(bus_base_address + ACBCTL1), reg);
+    OUTB((unsigned short) (bus_base_address + ACBCTL1), reg);
 
     if (!state) {
-        reg = INB((unsigned short)(bus_base_address + ACBST));
+        reg = INB((unsigned short) (bus_base_address + ACBST));
         reg |= 0x08;
-        OUTB((unsigned short)(bus_base_address + ACBST), reg);
+        OUTB((unsigned short) (bus_base_address + ACBST), reg);
     }
 }
 
@@ -558,10 +561,10 @@ acc_i2c_send_address(unsigned char busnum, unsigned char cData)
 
     /* WRITE THE DATA */
 
-    OUTB((unsigned short)(bus_base_address + ACBSDA), cData);
+    OUTB((unsigned short) (bus_base_address + ACBSDA), cData);
     while (1) {
-        reg = INB((unsigned short)(bus_base_address + ACBST));
-        if ((reg & 0x38) != 0)         /* check STASTR, BER and NEGACK */
+        reg = INB((unsigned short) (bus_base_address + ACBST));
+        if ((reg & 0x38) != 0)  /* check STASTR, BER and NEGACK */
             break;
         if (timeout++ == ACC_I2C_TIMEOUT) {
             acc_i2c_bus_recovery(busnum);
@@ -598,23 +601,25 @@ acc_i2c_ack(unsigned char busnum, int fPut, int negAck)
     unsigned short bus_base_address = base_address_array[busnum];
     unsigned long timeout = 0;
 
-    if (fPut) {                        /* read operation */
+    if (fPut) {                 /* read operation */
         if (!negAck) {
             /* Push Ack onto I2C bus */
-            reg = INB((unsigned short)(bus_base_address + ACBCTL1));
+            reg = INB((unsigned short) (bus_base_address + ACBCTL1));
             reg &= 0xE7;
-            OUTB((unsigned short)(bus_base_address + ACBCTL1), reg);
-        } else {
+            OUTB((unsigned short) (bus_base_address + ACBCTL1), reg);
+        }
+        else {
             /* Push negAck onto I2C bus */
-            reg = INB((unsigned short)(bus_base_address + ACBCTL1));
+            reg = INB((unsigned short) (bus_base_address + ACBCTL1));
             reg |= 0x10;
-            OUTB((unsigned short)(bus_base_address + ACBCTL1), reg);
+            OUTB((unsigned short) (bus_base_address + ACBCTL1), reg);
         }
-    } else {                           /* write operation */
+    }
+    else {                      /* write operation */
         /* Receive Ack from I2C bus */
         while (1) {
-            reg = INB((unsigned short)(bus_base_address + ACBST));
-            if ((reg & 0x70) != 0)     /* check SDAST, BER and NEGACK */
+            reg = INB((unsigned short) (bus_base_address + ACBST));
+            if ((reg & 0x70) != 0)      /* check SDAST, BER and NEGACK */
                 break;
             if (timeout++ == ACC_I2C_TIMEOUT) {
                 acc_i2c_bus_recovery(busnum);
@@ -651,9 +656,9 @@ acc_i2c_stop_clock(unsigned char busnum)
     unsigned char reg;
     unsigned short bus_base_address = base_address_array[busnum];
 
-    reg = INB((unsigned short)(bus_base_address + ACBCTL2));
+    reg = INB((unsigned short) (bus_base_address + ACBCTL2));
     reg &= ~0x01;
-    OUTB((unsigned short)(bus_base_address + ACBCTL2), reg);
+    OUTB((unsigned short) (bus_base_address + ACBCTL2), reg);
 }
 
 /*---------------------------------------------------------------------------
@@ -668,9 +673,9 @@ acc_i2c_activate_clock(unsigned char busnum)
     unsigned char reg;
     unsigned short bus_base_address = base_address_array[busnum];
 
-    reg = INB((unsigned short)(bus_base_address + ACBCTL2));
+    reg = INB((unsigned short) (bus_base_address + ACBCTL2));
     reg |= 0x01;
-    OUTB((unsigned short)(bus_base_address + ACBCTL2), reg);
+    OUTB((unsigned short) (bus_base_address + ACBCTL2), reg);
 }
 
 /*---------------------------------------------------------------------------
@@ -687,7 +692,7 @@ acc_i2c_write_byte(unsigned char busnum, unsigned char cData)
     unsigned long timeout = 0;
 
     while (1) {
-        reg = INB((unsigned short)(bus_base_address + ACBST));
+        reg = INB((unsigned short) (bus_base_address + ACBST));
         if (reg & 0x70)
             break;
         if (timeout++ == ACC_I2C_TIMEOUT) {
@@ -712,7 +717,7 @@ acc_i2c_write_byte(unsigned char busnum, unsigned char cData)
 
     /* WRITE THE DATA */
 
-    OUTB((unsigned short)(bus_base_address + ACBSDA), cData);
+    OUTB((unsigned short) (bus_base_address + ACBSDA), cData);
 }
 
 /*---------------------------------------------------------------------------
@@ -729,7 +734,7 @@ acc_i2c_read_byte(unsigned char busnum, int last_byte)
     unsigned long timeout = 0;
 
     while (1) {
-        reg = INB((unsigned short)(bus_base_address + ACBST));
+        reg = INB((unsigned short) (bus_base_address + ACBST));
         if (reg & 0x60)
             break;
         if (timeout++ == ACC_I2C_TIMEOUT) {
@@ -748,7 +753,7 @@ acc_i2c_read_byte(unsigned char busnum, int last_byte)
     /* READ DATA */
     if (last_byte)
         acc_i2c_stop_clock(busnum);
-    cData = INB((unsigned short)(bus_base_address + ACBSDA));
+    cData = INB((unsigned short) (bus_base_address + ACBSDA));
     if (last_byte)
         acc_i2c_activate_clock(busnum);
 
@@ -768,7 +773,7 @@ acc_i2c_request_master(unsigned char busnum)
 
     acc_i2c_start(busnum);
     while (1) {
-        reg = INB((unsigned short)(bus_base_address + ACBST));
+        reg = INB((unsigned short) (bus_base_address + ACBST));
         if (reg & 0x60)
             break;
         if (timeout++ == ACC_I2C_TIMEOUT) {
@@ -821,7 +826,7 @@ acc_i2c_set_freq(unsigned char busnum, char freq)
 {
     unsigned short bus_base_address = base_address_array[busnum];
 
-    OUTB((unsigned short)(bus_base_address + ACBCTL2), 0x0);
+    OUTB((unsigned short) (bus_base_address + ACBCTL2), 0x0);
 
     if (freq == -1)
         freq = 0x71;
@@ -830,7 +835,7 @@ acc_i2c_set_freq(unsigned char busnum, char freq)
         freq |= 0x01;
     }
 
-    OUTB((unsigned short)(bus_base_address + ACBCTL2), freq);
+    OUTB((unsigned short) (bus_base_address + ACBCTL2), freq);
     return (freq);
 }
 
@@ -867,8 +872,8 @@ acc_i2c_set_base_address(unsigned char busnum, short adr)
     }
 
     /* Set ACCESS.bus base address */
-    sio_write_reg(BASE_ADR_LSB_REG, (unsigned char)(adr & 0xFF));
-    sio_write_reg(BASE_ADR_MSB_REG, (unsigned char)(adr >> 8));
+    sio_write_reg(BASE_ADR_LSB_REG, (unsigned char) (adr & 0xFF));
+    sio_write_reg(BASE_ADR_MSB_REG, (unsigned char) (adr >> 8));
 
     return adr;
 }
diff --git a/src/gfx/i2c_gpio.c b/src/gfx/i2c_gpio.c
index 7614cd0..9774a8d 100644
--- a/src/gfx/i2c_gpio.c
+++ b/src/gfx/i2c_gpio.c
@@ -35,11 +35,11 @@ int gpio_data = 0;
 
 static int g_initialized = 0;
 
-#define	I2CWRITE		0x00   /* Write address         */
-#define	I2CREAD			0x01   /* Read address          */
+#define	I2CWRITE		0x00    /* Write address         */
+#define	I2CREAD			0x01    /* Read address          */
 
-#define	I2CACK			0x00   /* Ack value             */
-#define	I2CNACK			0x01   /* Not - ack value       */
+#define	I2CACK			0x00    /* Ack value             */
+#define	I2CNACK			0x01    /* Not - ack value       */
 
 #define		CS5530_ID	(0x80000000 | (0x00<<16) | (0x12<<11) | (0<<8) | 0x00)
 #define		CS5530_GPIO	(0x80000000 | (0x00<<16) | (0x12<<11) | (0<<8) | 0x90)
@@ -52,9 +52,9 @@ int I2C_init(void);
 void I2C_cleanup(void);
 
 int I2C_Read(unsigned char address, unsigned int reg, unsigned long *p_value,
-    unsigned int bytes);
+             unsigned int bytes);
 int I2C_Write(unsigned char address, unsigned int reg, unsigned long value,
-    unsigned int bytes);
+              unsigned int bytes);
 int I2CAL_init(void);
 void I2CAL_cleanup(void);
 
@@ -123,11 +123,11 @@ gfx_i2c_select_gpio(int clock, int data)
 #if GFX_I2C_DYNAMIC
 int
 gpio_i2c_write(unsigned char busnum, unsigned char address, unsigned char reg,
-    unsigned char bytes, unsigned char *value)
+               unsigned char bytes, unsigned char *value)
 #else
 int
 gfx_i2c_write(unsigned char busnum, unsigned char address, unsigned char reg,
-    unsigned char bytes, unsigned char *value)
+              unsigned char bytes, unsigned char *value)
 #endif
 {
     /* ### ADD ### CODE TO WRITE BYTE TO I2B BUS */
@@ -139,13 +139,13 @@ gfx_i2c_write(unsigned char busnum, unsigned char address, unsigned char reg,
         /* The address is shifted left by one to make room for Read/Write 
          * bit */
         SendI2CStart();
-        SendI2CData((char)((address << 1) | I2CWRITE));
+        SendI2CData((char) ((address << 1) | I2CWRITE));
         if (!ReceiveI2CAck()) {
             SendI2CStop();
             gfx_delay_milliseconds(10);
             continue;
         }
-        SendI2CData((unsigned char)reg);
+        SendI2CData((unsigned char) reg);
         if (!ReceiveI2CAck()) {
             SendI2CStop();
             gfx_delay_milliseconds(10);
@@ -189,11 +189,11 @@ gfx_i2c_write(unsigned char busnum, unsigned char address, unsigned char reg,
 #if GFX_I2C_DYNAMIC
 int
 gpio_i2c_read(unsigned char busnum, unsigned char address, unsigned char reg,
-    unsigned char bytes, unsigned char *p_value)
+              unsigned char bytes, unsigned char *p_value)
 #else
 int
 gfx_i2c_read(unsigned char busnum, unsigned char address, unsigned char reg,
-    unsigned char bytes, unsigned char *p_value)
+             unsigned char bytes, unsigned char *p_value)
 #endif
 {
     /* ### ADD ### CODE TO WRITE BYTE TO I2B BUS */
@@ -209,18 +209,18 @@ gfx_i2c_read(unsigned char busnum, unsigned char address, unsigned char reg,
         /* The address is shifted left by one to make room for Read/Write 
          * bit  */
         SendI2CStart();
-        SendI2CData((char)((address << 1) | I2CWRITE));
+        SendI2CData((char) ((address << 1) | I2CWRITE));
         if (!ReceiveI2CAck()) {
             SendI2CStop();
             gfx_delay_milliseconds(10);
             continue;
         }
-        SendI2CData((unsigned char)(reg & 0xFF));
+        SendI2CData((unsigned char) (reg & 0xFF));
         SendI2CNack();
 
         /* read the first data byte. */
         SendI2CStart();
-        SendI2CData((char)((address << 1) | I2CREAD));
+        SendI2CData((char) ((address << 1) | I2CREAD));
         if (!ReceiveI2CAck()) {
             SendI2CStop();
             gfx_delay_milliseconds(10);
@@ -490,7 +490,7 @@ I2CAL_init(void)
         return 1;
 
     l_reg = gfx_pci_config_read(CS5530_GPIO);
-    reg = (unsigned short)l_reg;
+    reg = (unsigned short) l_reg;
 
     /* both outputs, both high. */
     reg |= (SDADIR | SCLDIR | SDA | SCL);
@@ -525,11 +525,12 @@ I2CAL_output_clock(int inState)
     unsigned long value;
 
     value = gfx_pci_config_read(CS5530_GPIO);
-    reg = (unsigned short)value;
+    reg = (unsigned short) value;
 
-    if (inState) {                     /* write a 1. */
+    if (inState) {              /* write a 1. */
         reg |= SCL;
-    } else {                           /* write a 0. */
+    }
+    else {                      /* write a 0. */
         reg &= ~SCL;
     }
 
@@ -554,11 +555,12 @@ I2CAL_output_data(int inState)
     unsigned long value;
 
     value = gfx_pci_config_read(CS5530_GPIO);
-    reg = (unsigned short)value;
+    reg = (unsigned short) value;
 
-    if (inState) {                     /* write a 1. */
+    if (inState) {              /* write a 1. */
         reg |= SDA;
-    } else {
+    }
+    else {
         /* write a 0. */
         reg &= ~SDA;
     }
@@ -583,7 +585,7 @@ I2CAL_input_data(void)
     unsigned long value;
 
     value = gfx_pci_config_read(CS5530_GPIO);
-    reg = (unsigned short)value;
+    reg = (unsigned short) value;
 
     if (reg & SDA)
         return 1;
@@ -605,7 +607,7 @@ I2CAL_set_data_for_input(void)
     unsigned long value;
 
     value = gfx_pci_config_read(CS5530_GPIO);
-    reg = (unsigned short)value;
+    reg = (unsigned short) value;
 
     reg &= ~SDADIR;
 
@@ -628,7 +630,7 @@ I2CAL_set_data_for_output(void)
     unsigned long value;
 
     value = gfx_pci_config_read(CS5530_GPIO);
-    reg = (unsigned short)value;
+    reg = (unsigned short) value;
     reg |= SDADIR;
     value = reg;
 
diff --git a/src/gfx/init_gu1.c b/src/gfx/init_gu1.c
index e7d9987..647fab5 100644
--- a/src/gfx/init_gu1.c
+++ b/src/gfx/init_gu1.c
@@ -43,7 +43,7 @@ gfx_gxm_config_read(unsigned char index)
     OUTB(0x22, GXM_CONFIG_CCR3);
     lock = INB(0x23);
     OUTB(0x22, GXM_CONFIG_CCR3);
-    OUTB(0x23, (unsigned char)(lock | 0x10));
+    OUTB(0x23, (unsigned char) (lock | 0x10));
     OUTB(0x22, index);
     value = INB(0x23);
     OUTB(0x22, GXM_CONFIG_CCR3);
@@ -103,7 +103,8 @@ gfx_get_core_freq(void)
         default:
             return (0);
         }
-    } else {
+    }
+    else {
         switch (dir0) {
         case 0:
         case 2:
@@ -150,7 +151,7 @@ gfx_get_cpu_register_base(void)
 {
     unsigned long base;
 
-    base = (unsigned long)gfx_gxm_config_read(GXM_CONFIG_GCR);
+    base = (unsigned long) gfx_gxm_config_read(GXM_CONFIG_GCR);
     base = (base & 0x03) << 30;
     return (base);
 }
@@ -175,7 +176,7 @@ gfx_get_frame_buffer_base(void)
 {
     unsigned long base;
 
-    base = (unsigned long)gfx_gxm_config_read(GXM_CONFIG_GCR);
+    base = (unsigned long) gfx_gxm_config_read(GXM_CONFIG_GCR);
     base = (base & 0x03) << 30;
     if (base)
         base |= 0x00800000;
@@ -225,7 +226,7 @@ gfx_get_vid_register_base(void)
 {
     unsigned long base;
 
-    base = (unsigned long)gfx_gxm_config_read(GXM_CONFIG_GCR);
+    base = (unsigned long) gfx_gxm_config_read(GXM_CONFIG_GCR);
     base = (base & 0x03) << 30;
     if (base)
         base |= 0x00010000;
@@ -254,7 +255,7 @@ gfx_get_vip_register_base(void)
     unsigned long base = 0;
 
     if ((gfx_cpu_version & 0xFF) == GFX_CPU_SC1200) {
-        base = (unsigned long)gfx_gxm_config_read(GXM_CONFIG_GCR);
+        base = (unsigned long) gfx_gxm_config_read(GXM_CONFIG_GCR);
         base = (base & 0x03) << 30;
         if (base)
             base |= 0x00015000;
diff --git a/src/gfx/init_gu2.c b/src/gfx/init_gu2.c
index 0bbb064..72a16c8 100644
--- a/src/gfx/init_gu2.c
+++ b/src/gfx/init_gu2.c
@@ -50,7 +50,7 @@ gfx_get_core_freq(void)
     OUTW(0xAC1C, 0xFC53);
     OUTW(0xAC1C, 0x1201);
 
-    value = (unsigned long)(INW(0xAC1E));
+    value = (unsigned long) (INW(0xAC1E));
 
     return (value);
 }
@@ -129,7 +129,7 @@ gfx_get_frame_buffer_size(void)
     OUTW(0xAC1C, 0xFC53);
     OUTW(0xAC1C, 0x0200);
 
-    value = (unsigned long)(INW(0xAC1E)) & 0xFFl;
+    value = (unsigned long) (INW(0xAC1E)) & 0xFFl;
 
     return (value << 19);
 }
diff --git a/src/gfx/msr_rdcl.c b/src/gfx/msr_rdcl.c
index 548e8a4..2f85e6a 100644
--- a/src/gfx/msr_rdcl.c
+++ b/src/gfx/msr_rdcl.c
@@ -27,7 +27,7 @@
  * This file contains MSR access routines for Redcloud.
  * */
 
-void redcloud_build_mbus_tree(void);   /* private routine definition */
+void redcloud_build_mbus_tree(void);    /* private routine definition */
 int redcloud_init_msr_devices(MSR aDev[], unsigned int array_size);
 
                                                                                 /* private routine definition */
@@ -212,7 +212,7 @@ redcloud_build_mbus_tree(void)
             MBIU0[port].deviceId = NOT_POPULATED;
         else {
             MSR_READ(MBD_MSR_CAP, MBIU0[port].address, &(msrValue.high),
-                &(msrValue.low));
+                     &(msrValue.low));
             MBIU0[port].deviceId = GET_DEVICE_ID(msrValue.high, msrValue.low);
         }
     }
@@ -253,7 +253,7 @@ redcloud_build_mbus_tree(void)
             MBIU1[port].deviceId = NOT_POPULATED;
         else {
             MSR_READ(MBD_MSR_CAP, MBIU1[port].address, &(msrValue.high),
-                &(msrValue.low));
+                     &(msrValue.low));
             MBIU1[port].deviceId = GET_DEVICE_ID(msrValue.high, msrValue.low);
         }
     }
@@ -273,8 +273,7 @@ redcloud_build_mbus_tree(void)
         /* Query the MBIU for the port through which we are communicating. */
         /* We will avoid accesses to this port to avoid a self-reference.  */
 
-        MSR_READ(MBIU_WHOAMI, CP_MB0_MBIU0, &(msrValue.high),
-            &(msrValue.low));
+        MSR_READ(MBIU_WHOAMI, CP_MB0_MBIU0, &(msrValue.high), &(msrValue.low));
         reflective = msrValue.low & WHOAMI_MASK;
 
         /* ENUMERATE ALL PORTS */
@@ -298,12 +297,13 @@ redcloud_build_mbus_tree(void)
                 MBIU2[port].deviceId = NOT_POPULATED;
             else {
                 MSR_READ(MBD_MSR_CAP, MBIU2[port].address, &(msrValue.high),
-                    &(msrValue.low));
+                         &(msrValue.low));
                 MBIU2[port].deviceId =
                     GET_DEVICE_ID(msrValue.high, msrValue.low);
             }
         }
-    } else {
+    }
+    else {
         /* NO 5535                                                  */
         /* If the CS5535 is not installed, fill in the cached table */
         /* with the 'NOT_INSTALLED' flag.  Also, fill in the device */
@@ -544,10 +544,12 @@ gfx_get_glink_id_at_address(unsigned int *device, unsigned long address)
         if (MBIU0[port].address == address) {
             *device = MBIU0[port].deviceId;
             return FOUND;
-        } else if (MBIU1[port].address == address) {
+        }
+        else if (MBIU1[port].address == address) {
             *device = MBIU1[port].deviceId;
             return FOUND;
-        } else if (MBIU2[port].address == address) {
+        }
+        else if (MBIU2[port].address == address) {
             *device = MBIU2[port].deviceId;
             return FOUND;
         }
@@ -577,7 +579,7 @@ gfx_get_glink_id_at_address(unsigned int *device, unsigned long address)
 #if GFX_MSR_DYNAMIC
 DEV_STATUS
 redcloud_msr_read(unsigned int device, unsigned int msrRegister,
-    Q_WORD * msrValue)
+                  Q_WORD * msrValue)
 #else
 DEV_STATUS
 gfx_msr_read(unsigned int device, unsigned int msrRegister, Q_WORD * msrValue)
@@ -586,7 +588,7 @@ gfx_msr_read(unsigned int device, unsigned int msrRegister, Q_WORD * msrValue)
     if (device < NUM_DEVS) {
         if (msrDev[device].Present == FOUND)
             MSR_READ(msrRegister, msrDev[device].Address, &(msrValue->high),
-                &(msrValue->low));
+                     &(msrValue->low));
 
         return msrDev[device].Present;
     }
@@ -614,17 +616,16 @@ gfx_msr_read(unsigned int device, unsigned int msrRegister, Q_WORD * msrValue)
 #if GFX_MSR_DYNAMIC
 DEV_STATUS
 redcloud_msr_write(unsigned int device, unsigned int msrRegister,
-    Q_WORD * msrValue)
+                   Q_WORD * msrValue)
 #else
 DEV_STATUS
-gfx_msr_write(unsigned int device, unsigned int msrRegister,
-    Q_WORD * msrValue)
+gfx_msr_write(unsigned int device, unsigned int msrRegister, Q_WORD * msrValue)
 #endif
 {
     if (device < NUM_DEVS) {
         if (msrDev[device].Present == FOUND)
             MSR_WRITE(msrRegister, msrDev[device].Address, &(msrValue->high),
-                &(msrValue->low));
+                      &(msrValue->low));
 
         return msrDev[device].Present;
     }
diff --git a/src/gfx/rndr_gu1.c b/src/gfx/rndr_gu1.c
index 5ad5af1..57fe9b1 100644
--- a/src/gfx/rndr_gu1.c
+++ b/src/gfx/rndr_gu1.c
@@ -104,7 +104,8 @@ gfx_set_bpp(unsigned short bpp)
     }
     if ((gfx_cpu_version == GFX_CPU_PYRAMID) && (pitch > 2048)) {
         control |= BC_FB_WIDTH_4096;
-    } else if (pitch > 1024) {
+    }
+    else if (pitch > 1024) {
         control |= BC_FB_WIDTH_2048;
     }
     GFX_WAIT_BUSY;
@@ -143,8 +144,8 @@ gfx_set_solid_source(unsigned long color)
     /* POLL UNTIL ABLE TO WRITE THE SOURCE COLOR */
 
     GFX_WAIT_PENDING;
-    WRITE_REG16(GP_SRC_COLOR_0, (unsigned short)color);
-    WRITE_REG16(GP_SRC_COLOR_1, (unsigned short)color);
+    WRITE_REG16(GP_SRC_COLOR_0, (unsigned short) color);
+    WRITE_REG16(GP_SRC_COLOR_1, (unsigned short) color);
 }
 
 /*
@@ -159,11 +160,11 @@ gfx_set_solid_source(unsigned long color)
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned short transparent)
+                    unsigned short transparent)
 #else
 void
 gfx_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned short transparent)
+                    unsigned short transparent)
 #endif
 {
     /* SET TRANSPARENCY FLAG */
@@ -183,8 +184,8 @@ gfx_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
     /* POLL UNTIL ABLE TO WRITE THE SOURCE COLOR */
 
     GFX_WAIT_PENDING;
-    WRITE_REG16(GP_SRC_COLOR_0, (unsigned short)bgcolor);
-    WRITE_REG16(GP_SRC_COLOR_1, (unsigned short)fgcolor);
+    WRITE_REG16(GP_SRC_COLOR_0, (unsigned short) bgcolor);
+    WRITE_REG16(GP_SRC_COLOR_1, (unsigned short) fgcolor);
 }
 
 /*
@@ -231,7 +232,7 @@ gfx_set_solid_pattern(unsigned long color)
     /* POLL UNTIL ABLE TO WRITE THE PATTERN COLOR */
 
     GFX_WAIT_PENDING;
-    WRITE_REG16(GP_PAT_COLOR_0, (unsigned short)color);
+    WRITE_REG16(GP_PAT_COLOR_0, (unsigned short) color);
 }
 
 /*
@@ -244,11 +245,13 @@ gfx_set_solid_pattern(unsigned long color)
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned char transparent)
+                     unsigned long data0, unsigned long data1,
+                     unsigned char transparent)
 #else
 void
 gfx_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned char transparent)
+                     unsigned long data0, unsigned long data1,
+                     unsigned char transparent)
 #endif
 {
     /* CLEAR TRANSPARENCY FLAG */
@@ -273,8 +276,8 @@ gfx_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
     /* POLL UNTIL ABLE TO WRITE THE PATTERN COLORS AND DATA */
 
     GFX_WAIT_PENDING;
-    WRITE_REG16(GP_PAT_COLOR_0, (unsigned short)bgcolor);
-    WRITE_REG16(GP_PAT_COLOR_1, (unsigned short)fgcolor);
+    WRITE_REG16(GP_PAT_COLOR_0, (unsigned short) bgcolor);
+    WRITE_REG16(GP_PAT_COLOR_1, (unsigned short) fgcolor);
     WRITE_REG32(GP_PAT_DATA_0, data0);
     WRITE_REG32(GP_PAT_DATA_1, data1);
 }
@@ -289,13 +292,15 @@ gfx_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_set_color_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned long data2,
-    unsigned long data3, unsigned char transparent)
+                      unsigned long data0, unsigned long data1,
+                      unsigned long data2, unsigned long data3,
+                      unsigned char transparent)
 #else
 void
 gfx_set_color_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned long data2,
-    unsigned long data3, unsigned char transparent)
+                      unsigned long data0, unsigned long data1,
+                      unsigned long data2, unsigned long data3,
+                      unsigned char transparent)
 #endif
 {
     /* CLEAR TRANSPARENCY FLAG */
@@ -321,8 +326,8 @@ gfx_set_color_pattern(unsigned long bgcolor, unsigned long fgcolor,
     /* POLL UNTIL ABLE TO WRITE THE PATTERN COLORS AND DATA */
 
     GFX_WAIT_PENDING;
-    WRITE_REG16(GP_PAT_COLOR_0, (unsigned short)bgcolor);
-    WRITE_REG16(GP_PAT_COLOR_1, (unsigned short)fgcolor);
+    WRITE_REG16(GP_PAT_COLOR_0, (unsigned short) bgcolor);
+    WRITE_REG16(GP_PAT_COLOR_1, (unsigned short) fgcolor);
     WRITE_REG32(GP_PAT_DATA_0, data0);
     WRITE_REG32(GP_PAT_DATA_1, data1);
     if (GFXbpp > 8) {
@@ -392,7 +397,7 @@ gfx_set_raster_operation(unsigned char rop)
 
     /* GENERATE 16-BIT VERSION OF ROP WITH PATTERN FLAGS */
 
-    rop16 = (unsigned short)rop | GFXpatternFlags;
+    rop16 = (unsigned short) rop | GFXpatternFlags;
     if ((rop & 0x33) ^ ((rop >> 2) & 0x33))
         rop16 |= GFXsourceFlags;
 
@@ -440,7 +445,7 @@ gfx_set_raster_operation(unsigned char rop)
  */
 void
 gu1_solid_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, unsigned long color)
+               unsigned short width, unsigned short height, unsigned long color)
 {
     unsigned short section;
 
@@ -455,7 +460,7 @@ gu1_solid_fill(unsigned short x, unsigned short y,
     WRITE_REG16(GP_DST_YCOOR, y);
     WRITE_REG16(GP_HEIGHT, height);
     WRITE_REG16(GP_RASTER_MODE, 0x00F0);        /* PATCOPY */
-    WRITE_REG16(GP_PAT_COLOR_0, (unsigned short)color);
+    WRITE_REG16(GP_PAT_COLOR_0, (unsigned short) color);
 
     /* CHECK WIDTH FOR GX BUG WORKAROUND */
 
@@ -464,7 +469,8 @@ gu1_solid_fill(unsigned short x, unsigned short y,
 
         WRITE_REG16(GP_WIDTH, width);
         WRITE_REG16(GP_BLIT_MODE, 0);
-    } else {
+    }
+    else {
         /* DRAW FIRST PART OF RECTANGLE */
         /* Get to a 16 pixel boundary. */
 
@@ -500,11 +506,11 @@ gu1_solid_fill(unsigned short x, unsigned short y,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height)
+                 unsigned short width, unsigned short height)
 #else
 void
 gfx_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height)
+                 unsigned short width, unsigned short height)
 #endif
 {
     unsigned short section, buffer_width, blit_mode;
@@ -517,10 +523,10 @@ gfx_pattern_fill(unsigned short x, unsigned short y,
         /* Need hardware workaround for fast "burst write" cases. */
 
     case 0x00F0:
-        gu1_solid_fill(x, y, width, height, (unsigned short)GFXsavedColor);
+        gu1_solid_fill(x, y, width, height, (unsigned short) GFXsavedColor);
         break;
     case 0x000F:
-        gu1_solid_fill(x, y, width, height, (unsigned short)~GFXsavedColor);
+        gu1_solid_fill(x, y, width, height, (unsigned short) ~GFXsavedColor);
         break;
     case 0x0000:
         gu1_solid_fill(x, y, width, height, 0x0000);
@@ -605,11 +611,13 @@ gfx_pattern_fill(unsigned short x, unsigned short y,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_color_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, unsigned long *pattern)
+                       unsigned short width, unsigned short height,
+                       unsigned long *pattern)
 #else
 void
 gfx_color_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, unsigned long *pattern)
+                       unsigned short width, unsigned short height,
+                       unsigned long *pattern)
 #endif
 {
     unsigned short blit_mode, passes, cur_y, pat_y, i;
@@ -632,7 +640,8 @@ gfx_color_pattern_fill(unsigned short x, unsigned short y,
 
     GFX_WAIT_PENDING;
     WRITE_REG16(GP_RASTER_MODE,
-        (GFXsavedRop & ~RM_PAT_MASK & ~RM_PAT_TRANSPARENT) | RM_PAT_COLOR);
+                (GFXsavedRop & ~RM_PAT_MASK & ~RM_PAT_TRANSPARENT) |
+                RM_PAT_COLOR);
 
     /* WRITE THE REGISTERS THAT DO NOT CHANGE         */
     /* If destination data is required, the width and */
@@ -695,7 +704,8 @@ gfx_color_pattern_fill(unsigned short x, unsigned short y,
                 line_width -= section;
             }
 
-        } else {
+        }
+        else {
             while (cur_y < y + height) {
                 GFX_WAIT_PENDING;
                 WRITE_REG16(GP_DST_YCOOR, cur_y);
@@ -731,13 +741,13 @@ gfx_color_pattern_fill(unsigned short x, unsigned short y,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height)
+                         unsigned short dstx, unsigned short dsty,
+                         unsigned short width, unsigned short height)
 #else
 void
 gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height)
+                         unsigned short dstx, unsigned short dsty,
+                         unsigned short width, unsigned short height)
 #endif
 {
     unsigned short section, buffer_width;
@@ -811,7 +821,8 @@ gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
             WRITE_REG16(GP_SRC_XCOOR, srcx);
             WRITE_REG16(GP_DST_XCOOR, dstx);
             WRITE_REG16(GP_BLIT_MODE, blit_mode);
-        } else {
+        }
+        else {
             /* POSITIVE X DIRECTION */
 
             WRITE_REG16(GP_SRC_XCOOR, srcx);
@@ -843,13 +854,15 @@ gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned long color)
+                          unsigned short dstx, unsigned short dsty,
+                          unsigned short width, unsigned short height,
+                          unsigned long color)
 #else
 void
 gfx_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned long color)
+                          unsigned short dstx, unsigned short dsty,
+                          unsigned short width, unsigned short height,
+                          unsigned long color)
 #endif
 {
     unsigned short section, buffer_width;
@@ -947,7 +960,8 @@ gfx_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
             WRITE_REG16(GP_SRC_XCOOR, srcx);
             WRITE_REG16(GP_DST_XCOOR, dstx);
             WRITE_REG16(GP_BLIT_MODE, blit_mode);
-        } else {
+        }
+        else {
             /* POSITIVE X DIRECTION */
 
             WRITE_REG16(GP_SRC_XCOOR, srcx);
@@ -985,13 +999,15 @@ gfx_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch)
+                               unsigned short dstx, unsigned short dsty,
+                               unsigned short width, unsigned short height,
+                               unsigned char *data, long pitch)
 #else
 void
 gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch)
+                               unsigned short dstx, unsigned short dsty,
+                               unsigned short width, unsigned short height,
+                               unsigned char *data, long pitch)
 #endif
 {
     unsigned short section, buffer_width;
@@ -1048,7 +1064,7 @@ gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         /* CALCULATE THE BITMAP OFFSET */
 
         array_offset =
-            (unsigned long)srcy *(long)pitch + ((long)srcx << bpp_shift);
+            (unsigned long) srcy *(long) pitch + ((long) srcx << bpp_shift);
 
         while (temp_height--) {
             GFX_WAIT_PIPELINE;
@@ -1059,7 +1075,7 @@ gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
              * */
 
             WRITE_SCRATCH_STRING(dword_bytes_needed, bytes_extra, data,
-                array_offset);
+                                 array_offset);
             WRITE_REG16(GP_BLIT_MODE, blit_mode);
 
             array_offset += pitch;
@@ -1094,15 +1110,17 @@ gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch,
-    unsigned long color)
+                                unsigned short dstx, unsigned short dsty,
+                                unsigned short width, unsigned short height,
+                                unsigned char *data, long pitch,
+                                unsigned long color)
 #else
 void
 gfx_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch,
-    unsigned long color)
+                                unsigned short dstx, unsigned short dsty,
+                                unsigned short width, unsigned short height,
+                                unsigned char *data, long pitch,
+                                unsigned long color)
 #endif
 {
     unsigned short section, buffer_width;
@@ -1178,7 +1196,7 @@ gfx_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
         /* CALCULATE THE BITMAP OFFSET */
 
         array_offset =
-            (unsigned long)srcy *(long)pitch + ((long)srcx << bpp_shift);
+            (unsigned long) srcy *(long) pitch + ((long) srcx << bpp_shift);
 
         while (temp_height--) {
             GFX_WAIT_PIPELINE;
@@ -1188,7 +1206,7 @@ gfx_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
             /* scratchpad offset set by the SET_SCRATCH_BASE macro.               */
 
             WRITE_SCRATCH_STRING(dword_bytes_needed, bytes_extra, data,
-                array_offset);
+                                 array_offset);
             WRITE_REG16(GP_BLIT_MODE, BM_READ_SRC_BB0);
 
             array_offset += pitch;
@@ -1219,13 +1237,15 @@ gfx_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch)
+                              unsigned short dstx, unsigned short dsty,
+                              unsigned short width, unsigned short height,
+                              unsigned char *data, short pitch)
 #else
 void
 gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch)
+                              unsigned short dstx, unsigned short dsty,
+                              unsigned short width, unsigned short height,
+                              unsigned char *data, short pitch)
 #endif
 {
     unsigned short section, buffer_width;
@@ -1242,7 +1262,8 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
     if (GFXusesDstData) {
         buffer_width = GFXbufferWidthPixels;
         blit_mode |= BM_READ_DST_FB1;
-    } else
+    }
+    else
         buffer_width = 3200;
 
     /* CHECK IF DATA ALREADY IN BLIT BUFFER */
@@ -1297,7 +1318,7 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
 
         /* CALCULATE THE BITMAP OFFSET */
 
-        array_offset = (unsigned long)srcy *(long)pitch + ((long)srcx >> 3);
+        array_offset = (unsigned long) srcy *(long) pitch + ((long) srcx >> 3);
 
         while (temp_height--) {
             GFX_WAIT_PIPELINE;
@@ -1307,7 +1328,7 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
             /* scratchpad offset set by the SET_SCRATCH_BASE macro.               */
 
             WRITE_SCRATCH_STRING(dword_bytes_needed, bytes_extra, data,
-                array_offset);
+                                 array_offset);
             WRITE_REG16(GP_BLIT_MODE, blit_mode);
 
             array_offset += pitch;
@@ -1335,11 +1356,11 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data)
+             unsigned short height, unsigned char *data)
 #else
 void
 gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data)
+             unsigned short height, unsigned char *data)
 #endif
 {
     unsigned long dword_bytes_needed, bytes_extra;
@@ -1348,7 +1369,7 @@ gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
     /* CALCULATE DATA SIZE */
 
     pitch = (width + 7) >> 3;
-    data_bytes = (long)height *pitch;
+    data_bytes = (long) height *pitch;
 
     /* CHECK FOR SIMPLE CASE */
     /* This routine is designed to render a source copy text glyph.  If 
@@ -1363,7 +1384,7 @@ gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
 
     if (GFXusesDstData || data_bytes > buffer_bytes) {
         gfx_mono_bitmap_to_screen_blt(0, 0, dstx, dsty, width, height, data,
-            (short)pitch);
+                                      (short) pitch);
         return;
     }
 
@@ -1415,13 +1436,15 @@ gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu1_bresenham_line(unsigned short x, unsigned short y,
-    unsigned short length, unsigned short initerr,
-    unsigned short axialerr, unsigned short diagerr, unsigned short flags)
+                   unsigned short length, unsigned short initerr,
+                   unsigned short axialerr, unsigned short diagerr,
+                   unsigned short flags)
 #else
 void
 gfx_bresenham_line(unsigned short x, unsigned short y,
-    unsigned short length, unsigned short initerr,
-    unsigned short axialerr, unsigned short diagerr, unsigned short flags)
+                   unsigned short length, unsigned short initerr,
+                   unsigned short axialerr, unsigned short diagerr,
+                   unsigned short flags)
 #endif
 {
     unsigned short vector_mode = flags;
diff --git a/src/gfx/rndr_gu2.c b/src/gfx/rndr_gu2.c
index db3ccf3..a8126fb 100644
--- a/src/gfx/rndr_gu2.c
+++ b/src/gfx/rndr_gu2.c
@@ -214,11 +214,11 @@ gfx_set_solid_source(unsigned long color)
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned short transparent)
+                    unsigned short transparent)
 #else
 void
 gfx_set_mono_source(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned short transparent)
+                    unsigned short transparent)
 #endif
 {
     /* SET TRANSPARENCY FLAG */
@@ -277,11 +277,13 @@ gfx_set_solid_pattern(unsigned long color)
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned char transparent)
+                     unsigned long data0, unsigned long data1,
+                     unsigned char transparent)
 #else
 void
 gfx_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned char transparent)
+                     unsigned long data0, unsigned long data1,
+                     unsigned char transparent)
 #endif
 {
     /* CLEAR TRANSPARENCY FLAG */
@@ -315,13 +317,15 @@ gfx_set_mono_pattern(unsigned long bgcolor, unsigned long fgcolor,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_set_color_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned long data2,
-    unsigned long data3, unsigned char transparent)
+                      unsigned long data0, unsigned long data1,
+                      unsigned long data2, unsigned long data3,
+                      unsigned char transparent)
 #else
 void
 gfx_set_color_pattern(unsigned long bgcolor, unsigned long fgcolor,
-    unsigned long data0, unsigned long data1, unsigned long data2,
-    unsigned long data3, unsigned char transparent)
+                      unsigned long data0, unsigned long data1,
+                      unsigned long data2, unsigned long data3,
+                      unsigned char transparent)
 #endif
 {
     /* REMOVE */
@@ -358,7 +362,7 @@ gfx_load_color_pattern_line(short y, unsigned long *pattern_8x8)
 
     GU2_WAIT_PENDING;
     WRITE_GP32(MGP_RASTER_MODE,
-        (gu2_rop32 & ~MGP_RM_PAT_FLAGS) | MGP_RM_PAT_COLOR);
+               (gu2_rop32 & ~MGP_RM_PAT_FLAGS) | MGP_RM_PAT_COLOR);
 
     /* LOAD THE PATTERN DATA */
     /* This routine is designed to work in tandem with gfx_pattern_fill.  */
@@ -384,7 +388,8 @@ gfx_load_color_pattern_line(short y, unsigned long *pattern_8x8)
         WRITE_GP32(MGP_PAT_COLOR_2, temp2);
         WRITE_GP32(MGP_PAT_COLOR_5, temp1);
         WRITE_GP32(MGP_PAT_COLOR_4, temp2);
-    } else if (gu2_xshift == 1) {
+    }
+    else if (gu2_xshift == 1) {
         pattern_8x8 += (y & 7) << 2;
         temp1 = WORD_SWIZZLE(pattern_8x8[0]);
         temp2 = WORD_SWIZZLE(pattern_8x8[1]);
@@ -401,7 +406,8 @@ gfx_load_color_pattern_line(short y, unsigned long *pattern_8x8)
         WRITE_GP32(MGP_PAT_COLOR_4, temp2);
         WRITE_GP32(MGP_PAT_COLOR_3, temp3);
         WRITE_GP32(MGP_PAT_COLOR_2, temp4);
-    } else {
+    }
+    else {
         pattern_8x8 += (y & 7) << 3;
 
         WRITE_GP32(MGP_PAT_COLOR_1, pattern_8x8[4]);
@@ -441,7 +447,7 @@ gfx_set_raster_operation(unsigned char rop)
 
     /* GENERATE 32-BIT VERSION OF ROP WITH PATTERN FLAGS */
 
-    gu2_rop32 = (unsigned long)rop | GFXpatternFlags | gu2_bpp;
+    gu2_rop32 = (unsigned long) rop | GFXpatternFlags | gu2_bpp;
 
     /* CHECK IF SOURCE FLAGS SHOULD BE MERGED */
 
@@ -457,7 +463,8 @@ gfx_set_raster_operation(unsigned char rop)
     if ((rop & 0x55) ^ ((rop >> 1) & 0x55)) {
         gu2_blt_mode |= MGP_BM_DST_REQ;
         gu2_vector_mode = MGP_VM_DST_REQ;
-    } else {
+    }
+    else {
         gu2_vector_mode = 0;
     }
 }
@@ -480,28 +487,28 @@ gfx_set_raster_operation(unsigned char rop)
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height)
+                 unsigned short width, unsigned short height)
 #else
 void
 gfx_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height)
+                 unsigned short width, unsigned short height)
 #endif
 {
     unsigned long offset = 0, size;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
     /* CALCULATE STARTING OFFSET */
 
-    offset = (unsigned long)y *gu2_pitch + (((unsigned long)x) << gu2_xshift);
+    offset = (unsigned long) y *gu2_pitch + (((unsigned long) x) << gu2_xshift);
 
     /* CHECK IF PATTERN ORIGINS NEED TO BE SET */
 
     if (GFXpatternFlags) {
         /* COMBINE X AND Y PATTERN ORIGINS WITH OFFSET */
 
-        offset |= ((unsigned long)(x & 7)) << 26;
-        offset |= ((unsigned long)(y & 7)) << 29;
+        offset |= ((unsigned long) (x & 7)) << 26;
+        offset |= ((unsigned long) (y & 7)) << 29;
     }
 
     /* POLL UNTIL ABLE TO WRITE TO THE REGISTERS */
@@ -534,22 +541,24 @@ gfx_pattern_fill(unsigned short x, unsigned short y,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_color_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, unsigned long *pattern)
+                       unsigned short width, unsigned short height,
+                       unsigned long *pattern)
 #else
 void
 gfx_color_pattern_fill(unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, unsigned long *pattern)
+                       unsigned short width, unsigned short height,
+                       unsigned long *pattern)
 #endif
 {
     /* CALL GFX2 ROUTINE TO AVOID DUPLICATION OF CODE */
 
-    unsigned long offset = (unsigned long)y * gu2_pitch +
-        (((unsigned long)x) << gu2_xshift);
+    unsigned long offset = (unsigned long) y * gu2_pitch +
+        (((unsigned long) x) << gu2_xshift);
     unsigned long origin = gu2_pattern_origin;
     unsigned long pitch = gu2_dst_pitch;
 
     gfx2_set_pattern_origin(x, y);
-    gfx2_set_destination_stride((unsigned short)gu2_pitch);
+    gfx2_set_destination_stride((unsigned short) gu2_pitch);
     gfx2_color_pattern_fill(offset, width, height, pattern);
 
     /* RESTORE GFX2 VALUES */
@@ -576,19 +585,19 @@ gfx_color_pattern_fill(unsigned short x, unsigned short y,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height)
+                         unsigned short dstx, unsigned short dsty,
+                         unsigned short width, unsigned short height)
 #else
 void
 gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height)
+                         unsigned short dstx, unsigned short dsty,
+                         unsigned short width, unsigned short height)
 #endif
 {
     unsigned long srcoffset, dstoffset, size;
     unsigned short blt_mode;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
     /* CALCULATE THE DIRECTION OF THE BLT */
 
@@ -606,10 +615,10 @@ gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
 
     /* CALCULATE STARTING OFFSETS */
 
-    srcoffset = (unsigned long)srcy *gu2_pitch +
-        (((unsigned long)srcx) << gu2_xshift);
-    dstoffset = ((unsigned long)dsty * gu2_pitch +
-        (((unsigned long)dstx) << gu2_xshift)) & 0xFFFFFF;
+    srcoffset = (unsigned long) srcy *gu2_pitch +
+        (((unsigned long) srcx) << gu2_xshift);
+    dstoffset = ((unsigned long) dsty * gu2_pitch +
+                 (((unsigned long) dstx) << gu2_xshift)) & 0xFFFFFF;
 
     /* MERGE PATTERN INFORMATION */
     /* This must be done after the x and y coordinates have been updated,  */
@@ -618,8 +627,8 @@ gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
     if (GFXpatternFlags) {
         /* COMBINE X AND Y PATTERN ORIGINS WITH OFFSET */
 
-        dstoffset |= ((unsigned long)(dstx & 7)) << 26;
-        dstoffset |= ((unsigned long)(dsty & 7)) << 29;
+        dstoffset |= ((unsigned long) (dstx & 7)) << 26;
+        dstoffset |= ((unsigned long) (dsty & 7)) << 29;
     }
 
     /* TURN INTO BYTE ADDRESS IF NEGATIVE X DIRECTION */
@@ -661,13 +670,15 @@ gfx_screen_to_screen_blt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned long color)
+                          unsigned short dstx, unsigned short dsty,
+                          unsigned short width, unsigned short height,
+                          unsigned long color)
 #else
 void
 gfx_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned long color)
+                          unsigned short dstx, unsigned short dsty,
+                          unsigned short width, unsigned short height,
+                          unsigned long color)
 #endif
 {
     unsigned long rop32;
@@ -720,13 +731,15 @@ gfx_screen_to_screen_xblt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch)
+                               unsigned short dstx, unsigned short dsty,
+                               unsigned short width, unsigned short height,
+                               unsigned char *data, long pitch)
 #else
 void
 gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch)
+                               unsigned short dstx, unsigned short dsty,
+                               unsigned short width, unsigned short height,
+                               unsigned char *data, long pitch)
 #endif
 {
     unsigned long dstoffset, srcoffset, size, bytes;
@@ -735,22 +748,22 @@ gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
     unsigned short blt_mode;
 
     blt_mode = (gu2_blt_mode & ~MGP_BM_SRC_TYPE_MASK) | MGP_BM_SRC_FB;
-    size = (((unsigned long)width) << 16) | 1;
+    size = (((unsigned long) width) << 16) | 1;
 
     /* CALCULATE STARTING OFFSETS */
 
-    offset = (unsigned long)srcy *pitch + ((unsigned long)srcx << gu2_xshift);
+    offset = (unsigned long) srcy *pitch + ((unsigned long) srcx << gu2_xshift);
 
-    dstoffset = (unsigned long)dsty *gu2_pitch +
-        (((unsigned long)dstx) << gu2_xshift);
+    dstoffset = (unsigned long) dsty *gu2_pitch +
+        (((unsigned long) dstx) << gu2_xshift);
 
     /* CHECK IF PATTERN ORIGINS NEED TO BE SET */
 
     if (GFXpatternFlags) {
         /* COMBINE X AND Y PATTERN ORIGINS WITH OFFSET */
 
-        dstoffset |= ((unsigned long)(dstx & 7)) << 26;
-        dstoffset |= ((unsigned long)(dsty & 7)) << 29;
+        dstoffset |= ((unsigned long) (dstx & 7)) << 26;
+        dstoffset |= ((unsigned long) (dsty & 7)) << 29;
     }
 
     bytes = width << gu2_xshift;
@@ -786,13 +799,12 @@ gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         dstoffset += gu2_pitch;
         dstoffset += 0x20000000;
 
-        WRITE_FRAME_BUFFER_STRING32(srcoffset, dword_bytes, data,
-            temp_offset);
+        WRITE_FRAME_BUFFER_STRING32(srcoffset, dword_bytes, data, temp_offset);
         if (bytes_extra) {
             temp_offset += dword_bytes;
             srcoffset += dword_bytes;
             WRITE_FRAME_BUFFER_STRING8(srcoffset, bytes_extra, data,
-                temp_offset);
+                                       temp_offset);
         }
         WRITE_GP16(MGP_BLT_MODE, blt_mode);
         offset += pitch;
@@ -823,15 +835,17 @@ gfx_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch,
-    unsigned long color)
+                                unsigned short dstx, unsigned short dsty,
+                                unsigned short width, unsigned short height,
+                                unsigned char *data, long pitch,
+                                unsigned long color)
 #else
 void
 gfx_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, long pitch,
-    unsigned long color)
+                                unsigned short dstx, unsigned short dsty,
+                                unsigned short width, unsigned short height,
+                                unsigned char *data, long pitch,
+                                unsigned long color)
 #endif
 {
     unsigned long rop32;
@@ -856,7 +870,7 @@ gfx_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
     /* CALL NORMAL COLOR BITMAP TO SCREEN BLT ROUTINE */
 
     gfx_color_bitmap_to_screen_blt(srcx, srcy, dstx, dsty, width, height,
-        data, pitch);
+                                   data, pitch);
 
     /* RESTORE RASTER SETTINGS */
 
@@ -882,13 +896,15 @@ gfx_color_bitmap_to_screen_xblt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch)
+                              unsigned short dstx, unsigned short dsty,
+                              unsigned short width, unsigned short height,
+                              unsigned char *data, short pitch)
 #else
 void
 gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch)
+                              unsigned short dstx, unsigned short dsty,
+                              unsigned short width, unsigned short height,
+                              unsigned char *data, short pitch)
 #endif
 {
     unsigned long dstoffset, size, bytes;
@@ -896,22 +912,22 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
     unsigned long i, j = 0, fifo_lines, dwords_extra, bytes_extra;
     unsigned long shift = 0;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
     /* CALCULATE STARTING OFFSETS */
 
-    offset = (unsigned long)srcy *pitch + ((unsigned long)srcx >> 3);
+    offset = (unsigned long) srcy *pitch + ((unsigned long) srcx >> 3);
 
-    dstoffset = (unsigned long)dsty *gu2_pitch +
-        (((unsigned long)dstx) << gu2_xshift);
+    dstoffset = (unsigned long) dsty *gu2_pitch +
+        (((unsigned long) dstx) << gu2_xshift);
 
     /* CHECK IF PATTERN ORIGINS NEED TO BE SET */
 
     if (GFXpatternFlags) {
         /* COMBINE X AND Y PATTERN ORIGINS WITH OFFSET */
 
-        dstoffset |= ((unsigned long)(dstx & 7)) << 26;
-        dstoffset |= ((unsigned long)(dsty & 7)) << 29;
+        dstoffset |= ((unsigned long) (dstx & 7)) << 26;
+        dstoffset |= ((unsigned long) (dsty & 7)) << 29;
     }
 
     bytes = ((srcx & 7) + width + 7) >> 3;
@@ -927,13 +943,13 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
 
     GU2_WAIT_PENDING;
     WRITE_GP32(MGP_RASTER_MODE, gu2_rop32 | GFXsourceFlags);
-    WRITE_GP32(MGP_SRC_OFFSET, ((unsigned long)srcx & 7) << 26);
+    WRITE_GP32(MGP_SRC_OFFSET, ((unsigned long) srcx & 7) << 26);
     WRITE_GP32(MGP_DST_OFFSET, dstoffset);
     WRITE_GP32(MGP_WID_HEIGHT, size);
     WRITE_GP32(MGP_STRIDE, gu2_pitch);
     WRITE_GP16(MGP_BLT_MODE,
-        (gu2_blt_mode & ~MGP_BM_SRC_TYPE_MASK) | MGP_BM_SRC_HOST |
-        MGP_BM_SRC_MONO);
+               (gu2_blt_mode & ~MGP_BM_SRC_TYPE_MASK) | MGP_BM_SRC_HOST |
+               MGP_BM_SRC_MONO);
 
     /* WAIT FOR BLT TO BE LATCHED */
 
@@ -949,7 +965,7 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         for (i = 0; i < fifo_lines; i++) {
             GU2_WAIT_HALF_EMPTY;
             WRITE_GPREG_STRING32(MGP_HST_SOURCE, 8, j, data, temp_offset,
-                temp1);
+                                 temp1);
             temp_offset += 32;
         }
 
@@ -958,7 +974,7 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         GU2_WAIT_HALF_EMPTY;
         if (dwords_extra) {
             WRITE_GPREG_STRING32(MGP_HST_SOURCE, dwords_extra, i, data,
-                temp_offset, temp1);
+                                 temp_offset, temp1);
             temp_offset += (dwords_extra << 2);
         }
 
@@ -967,7 +983,7 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         shift = 0;
         if (bytes_extra)
             WRITE_GPREG_STRING8(MGP_HST_SOURCE, bytes_extra, shift, i, data,
-                temp_offset, temp1, temp2);
+                                temp_offset, temp1, temp2);
 
         offset += pitch;
     }
@@ -983,11 +999,11 @@ gfx_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data)
+             unsigned short height, unsigned char *data)
 #else
 void
 gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
-    unsigned short height, unsigned char *data)
+             unsigned short height, unsigned char *data)
 #endif
 {
     unsigned long size, bytes;
@@ -995,18 +1011,18 @@ gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
     unsigned long i, j = 0, fifo_lines, dwords_extra, bytes_extra;
     unsigned long shift;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
-    dstoffset = (unsigned long)dsty *gu2_pitch +
-        (((unsigned long)dstx) << gu2_xshift);
+    dstoffset = (unsigned long) dsty *gu2_pitch +
+        (((unsigned long) dstx) << gu2_xshift);
 
     /* CHECK IF PATTERN ORIGINS NEED TO BE SET */
 
     if (GFXpatternFlags) {
         /* COMBINE X AND Y PATTERN ORIGINS WITH OFFSET */
 
-        dstoffset |= ((unsigned long)(dstx & 7)) << 26;
-        dstoffset |= ((unsigned long)(dsty & 7)) << 29;
+        dstoffset |= ((unsigned long) (dstx & 7)) << 26;
+        dstoffset |= ((unsigned long) (dsty & 7)) << 29;
     }
 
     /* CALCULATE STARTING OFFSETS */
@@ -1025,8 +1041,8 @@ gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
     WRITE_GP32(MGP_WID_HEIGHT, size);
     WRITE_GP32(MGP_STRIDE, gu2_pitch);
     WRITE_GP16(MGP_BLT_MODE,
-        (gu2_blt_mode & ~MGP_BM_SRC_TYPE_MASK) | MGP_BM_SRC_HOST |
-        MGP_BM_SRC_BP_MONO);
+               (gu2_blt_mode & ~MGP_BM_SRC_TYPE_MASK) | MGP_BM_SRC_HOST |
+               MGP_BM_SRC_BP_MONO);
 
     /* WAIT FOR BLT TO BE LATCHED */
 
@@ -1046,13 +1062,13 @@ gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
         GU2_WAIT_HALF_EMPTY;
         if (dwords_extra) {
             WRITE_GPREG_STRING32(MGP_HST_SOURCE, dwords_extra, i, data,
-                temp_offset, temp1);
+                                 temp_offset, temp1);
             temp_offset += (dwords_extra << 2);
         }
         if (bytes_extra) {
             shift = 0;
             WRITE_GPREG_STRING8(MGP_HST_SOURCE, bytes_extra, shift, i, data,
-                temp_offset, temp1, temp2);
+                                temp_offset, temp1, temp2);
         }
     }
 }
@@ -1079,23 +1095,25 @@ gfx_text_blt(unsigned short dstx, unsigned short dsty, unsigned short width,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu2_bresenham_line(unsigned short x, unsigned short y,
-    unsigned short length, unsigned short initerr,
-    unsigned short axialerr, unsigned short diagerr, unsigned short flags)
+                   unsigned short length, unsigned short initerr,
+                   unsigned short axialerr, unsigned short diagerr,
+                   unsigned short flags)
 #else
 void
 gfx_bresenham_line(unsigned short x, unsigned short y,
-    unsigned short length, unsigned short initerr,
-    unsigned short axialerr, unsigned short diagerr, unsigned short flags)
+                   unsigned short length, unsigned short initerr,
+                   unsigned short axialerr, unsigned short diagerr,
+                   unsigned short flags)
 #endif
 {
     unsigned long offset;
-    unsigned long data1 = (((unsigned long)axialerr) << 16) | diagerr;
-    unsigned long data2 = (((unsigned long)length) << 16) | initerr;
+    unsigned long data1 = (((unsigned long) axialerr) << 16) | diagerr;
+    unsigned long data2 = (((unsigned long) length) << 16) | initerr;
     unsigned short vector_mode = gu2_vector_mode | flags;
 
     /* CALCULATE STARTING OFFSET */
 
-    offset = (unsigned long)y *gu2_pitch + (((unsigned long)x) << gu2_xshift);
+    offset = (unsigned long) y *gu2_pitch + (((unsigned long) x) << gu2_xshift);
 
     /* CHECK NULL LENGTH */
 
@@ -1129,7 +1147,7 @@ void
 gfx_wait_until_idle(void)
 #endif
 {
-    while (READ_GP32(MGP_BLT_STATUS) & MGP_BS_BLT_BUSY) ;
+    while (READ_GP32(MGP_BLT_STATUS) & MGP_BS_BLT_BUSY);
 }
 
 /*---------------------------------------------------------------------------
@@ -1177,7 +1195,7 @@ gfx2_set_source_stride(unsigned short stride)
 {
     /* SAVE STRIDE TO BE USED LATER */
 
-    gu2_src_pitch = (unsigned long)stride;
+    gu2_src_pitch = (unsigned long) stride;
 }
 
 /*---------------------------------------------------------------------------
@@ -1196,7 +1214,7 @@ gfx2_set_destination_stride(unsigned short stride)
 {
     /* SAVE STRIDE TO BE USED LATER */
 
-    gu2_dst_pitch = (unsigned long)stride;
+    gu2_dst_pitch = (unsigned long) stride;
 }
 
 /*---------------------------------------------------------------------------
@@ -1216,8 +1234,8 @@ gfx2_set_pattern_origin(int x, int y)
 {
     /* STORE IN FORMAT THAT CAN BE COMBINED WITH THE DESTINATION OFFSET */
 
-    gu2_pattern_origin = (((unsigned long)(x & 7)) << 26) |
-        (((unsigned long)(y & 7)) << 29);
+    gu2_pattern_origin = (((unsigned long) (x & 7)) << 26) |
+        (((unsigned long) (y & 7)) << 29);
 }
 
 /*---------------------------------------------------------------------------
@@ -1285,7 +1303,7 @@ gfx2_set_alpha_value(unsigned char value)
 {
     /* SAVE ALPHA VALUE TO BE USED LATER */
 
-    gu2_alpha_value = (unsigned long)value;
+    gu2_alpha_value = (unsigned long) value;
 
     /* SET GLOBAL FLAG */
     /* gfx2_* routines will use this flag to program alpha values */
@@ -1372,16 +1390,16 @@ gfx2_set_alpha_value(unsigned char value)
 #if GFX_2DACCEL_DYNAMIC
 void
 gu22_pattern_fill(unsigned long dstoffset, unsigned short width,
-    unsigned short height)
+                  unsigned short height)
 #else
 void
 gfx2_pattern_fill(unsigned long dstoffset, unsigned short width,
-    unsigned short height)
+                  unsigned short height)
 #endif
 {
     unsigned long size;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
     /* POLL UNTIL ABLE TO WRITE TO THE REGISTERS */
     /* Put off poll for as long as possible (do most calculations first). */
@@ -1408,11 +1426,11 @@ gfx2_pattern_fill(unsigned long dstoffset, unsigned short width,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu22_color_pattern_fill(unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned long *pattern)
+                        unsigned short height, unsigned long *pattern)
 #else
 void
 gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned long *pattern)
+                        unsigned short height, unsigned long *pattern)
 #endif
 {
     int pass;
@@ -1427,7 +1445,7 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
 
     GU2_WAIT_PENDING;
     WRITE_GP32(MGP_RASTER_MODE,
-        (gu2_rop32 & ~MGP_RM_PAT_FLAGS) | MGP_RM_PAT_COLOR);
+               (gu2_rop32 & ~MGP_RM_PAT_FLAGS) | MGP_RM_PAT_COLOR);
 
     /* ATTEMPT TO OPTIMIZE */
     /* If possible, we can perform the pattern fill in only a few passes    */
@@ -1439,7 +1457,7 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
         /* HANDLE VARIOUS COLOR DEPTHS DIFFERENTLY */
 
         switch (gu2_xshift) {
-        case 0:                       /* 8 BPP */
+        case 0:                /* 8 BPP */
 
             /* TWO PASSES FOR 8 BPP */
             /* Render every other line per pass by doubling the pitch. */
@@ -1453,16 +1471,16 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
                 lines = (height + 1 - pass) >> 1;
                 if (!lines)
                     break;
-                size = (((unsigned long)width) << 16) | lines;
+                size = (((unsigned long) width) << 16) | lines;
                 WRITE_GP32(MGP_WID_HEIGHT, size);
                 WRITE_GP32(MGP_STRIDE, gu2_dst_pitch << 1);
                 WRITE_GP32(MGP_PAT_DATA_1, BYTE_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_DATA_0,
-                    BYTE_SWIZZLE(pattern[patoffset + 1]));
+                           BYTE_SWIZZLE(pattern[patoffset + 1]));
                 patoffset = (patoffset + 4) & 0x0E;
                 WRITE_GP32(MGP_PAT_COLOR_1, BYTE_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_0,
-                    BYTE_SWIZZLE(pattern[patoffset + 1]));
+                           BYTE_SWIZZLE(pattern[patoffset + 1]));
                 patoffset = (patoffset + 4) & 0x0E;
 
                 /* NEED TO WAIT UNTIL IDLE FOR COLORS 2 THROUGH 5 */
@@ -1471,11 +1489,11 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
                 GU2_WAIT_BUSY;
                 WRITE_GP32(MGP_PAT_COLOR_3, BYTE_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_2,
-                    BYTE_SWIZZLE(pattern[patoffset + 1]));
+                           BYTE_SWIZZLE(pattern[patoffset + 1]));
                 patoffset = (patoffset + 4) & 0x0E;
                 WRITE_GP32(MGP_PAT_COLOR_5, BYTE_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_4,
-                    BYTE_SWIZZLE(pattern[patoffset + 1]));
+                           BYTE_SWIZZLE(pattern[patoffset + 1]));
                 WRITE_GP16(MGP_BLT_MODE, gu2_blt_mode | gu2_bm_throttle);
                 gu2_bm_throttle = 0;
                 gu2_vm_throttle = 0;
@@ -1487,7 +1505,7 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
             }
             break;
 
-        case 1:                       /* 12, 15, OR 16 BPP */
+        case 1:                /* 12, 15, OR 16 BPP */
 
             /* FOUR PASSES FOR 16 BPP */
             /* Render every 4th line per pass by quadrupling the pitch. */
@@ -1501,16 +1519,16 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
                 lines = (height + 3 - pass) >> 2;
                 if (!lines)
                     break;
-                size = (((unsigned long)width) << 16) | lines;
+                size = (((unsigned long) width) << 16) | lines;
                 WRITE_GP32(MGP_WID_HEIGHT, size);
                 WRITE_GP32(MGP_STRIDE, gu2_dst_pitch << 2);
                 WRITE_GP32(MGP_PAT_COLOR_1, WORD_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_0,
-                    WORD_SWIZZLE(pattern[patoffset + 1]));
+                           WORD_SWIZZLE(pattern[patoffset + 1]));
                 WRITE_GP32(MGP_PAT_DATA_1,
-                    WORD_SWIZZLE(pattern[patoffset + 2]));
+                           WORD_SWIZZLE(pattern[patoffset + 2]));
                 WRITE_GP32(MGP_PAT_DATA_0,
-                    WORD_SWIZZLE(pattern[patoffset + 3]));
+                           WORD_SWIZZLE(pattern[patoffset + 3]));
                 patoffset = (patoffset + 16) & 0x1C;
 
                 /* NEED TO WAIT UNTIL IDLE FOR COLORS 2 THROUGH 5 */
@@ -1519,11 +1537,11 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
                 GU2_WAIT_BUSY;
                 WRITE_GP32(MGP_PAT_COLOR_5, WORD_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_4,
-                    WORD_SWIZZLE(pattern[patoffset + 1]));
+                           WORD_SWIZZLE(pattern[patoffset + 1]));
                 WRITE_GP32(MGP_PAT_COLOR_3,
-                    WORD_SWIZZLE(pattern[patoffset + 2]));
+                           WORD_SWIZZLE(pattern[patoffset + 2]));
                 WRITE_GP32(MGP_PAT_COLOR_2,
-                    WORD_SWIZZLE(pattern[patoffset + 3]));
+                           WORD_SWIZZLE(pattern[patoffset + 3]));
                 WRITE_GP16(MGP_BLT_MODE, gu2_blt_mode | gu2_bm_throttle);
                 gu2_bm_throttle = 0;
                 gu2_vm_throttle = 0;
@@ -1535,7 +1553,7 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
             }
             break;
 
-        case 2:                       /* 32 BPP */
+        case 2:                /* 32 BPP */
 
             /* EIGHT PASSES FOR 32 BPP */
             /* Render every 8th line per pass by setting pitch * 8. */
@@ -1549,7 +1567,7 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
                 lines = (height + 7 - pass) >> 3;
                 if (!lines)
                     break;
-                size = (((unsigned long)width) << 16) | lines;
+                size = (((unsigned long) width) << 16) | lines;
                 WRITE_GP32(MGP_WID_HEIGHT, size);
                 WRITE_GP32(MGP_STRIDE, gu2_dst_pitch << 3);
                 WRITE_GP32(MGP_PAT_COLOR_1, pattern[patoffset + 4]);
@@ -1582,7 +1600,7 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
         WRITE_GP32(MGP_STRIDE, gu2_dst_pitch);
 
         switch (gu2_xshift) {
-        case 0:                       /* 8 BPP - 4 LINES PER PASS */
+        case 0:                /* 8 BPP - 4 LINES PER PASS */
 
             patoffset = (gu2_pattern_origin >> 28) & 0x0E;
             while (height) {
@@ -1592,14 +1610,14 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
 
                 WRITE_GP32(MGP_DST_OFFSET, dstoffset | patxorigin);
                 WRITE_GP32(MGP_WID_HEIGHT,
-                    (((unsigned long)width) << 16) | lines);
+                           (((unsigned long) width) << 16) | lines);
                 WRITE_GP32(MGP_PAT_DATA_1, BYTE_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_DATA_0,
-                    BYTE_SWIZZLE(pattern[patoffset + 1]));
+                           BYTE_SWIZZLE(pattern[patoffset + 1]));
                 patoffset = (patoffset + 2) & 0x0E;
                 WRITE_GP32(MGP_PAT_COLOR_1, BYTE_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_0,
-                    BYTE_SWIZZLE(pattern[patoffset + 1]));
+                           BYTE_SWIZZLE(pattern[patoffset + 1]));
                 patoffset = (patoffset + 2) & 0x0E;
 
                 /* NEED TO WAIT UNTIL IDLE FOR COLORS 2 THROUGH 5 */
@@ -1608,22 +1626,22 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
                 GU2_WAIT_BUSY;
                 WRITE_GP32(MGP_PAT_COLOR_3, BYTE_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_2,
-                    BYTE_SWIZZLE(pattern[patoffset + 1]));
+                           BYTE_SWIZZLE(pattern[patoffset + 1]));
                 patoffset = (patoffset + 2) & 0x0E;
                 WRITE_GP32(MGP_PAT_COLOR_5, BYTE_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_4,
-                    BYTE_SWIZZLE(pattern[patoffset + 1]));
+                           BYTE_SWIZZLE(pattern[patoffset + 1]));
                 patoffset = (patoffset + 2) & 0x0E;
                 WRITE_GP16(MGP_BLT_MODE, gu2_blt_mode | gu2_bm_throttle);
 
                 /* ADJUST FOR NEXT PASS */
 
                 dstoffset += gu2_dst_pitch << 2;
-                height -= (unsigned short)lines;
+                height -= (unsigned short) lines;
             }
             break;
 
-        case 1:                       /* 12, 15 AND 16 BPP - 2 LINES PER PASS */
+        case 1:                /* 12, 15 AND 16 BPP - 2 LINES PER PASS */
 
             patoffset = (gu2_pattern_origin >> 27) & 0x1C;
             while (height) {
@@ -1633,14 +1651,14 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
 
                 WRITE_GP32(MGP_DST_OFFSET, dstoffset | patxorigin);
                 WRITE_GP32(MGP_WID_HEIGHT,
-                    (((unsigned long)width) << 16) | lines);
+                           (((unsigned long) width) << 16) | lines);
                 WRITE_GP32(MGP_PAT_COLOR_1, WORD_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_0,
-                    WORD_SWIZZLE(pattern[patoffset + 1]));
+                           WORD_SWIZZLE(pattern[patoffset + 1]));
                 WRITE_GP32(MGP_PAT_DATA_1,
-                    WORD_SWIZZLE(pattern[patoffset + 2]));
+                           WORD_SWIZZLE(pattern[patoffset + 2]));
                 WRITE_GP32(MGP_PAT_DATA_0,
-                    WORD_SWIZZLE(pattern[patoffset + 3]));
+                           WORD_SWIZZLE(pattern[patoffset + 3]));
                 patoffset = (patoffset + 4) & 0x1C;
 
                 /* NEED TO WAIT UNTIL IDLE FOR COLORS 2 THROUGH 5 */
@@ -1649,22 +1667,22 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
                 GU2_WAIT_BUSY;
                 WRITE_GP32(MGP_PAT_COLOR_5, WORD_SWIZZLE(pattern[patoffset]));
                 WRITE_GP32(MGP_PAT_COLOR_4,
-                    WORD_SWIZZLE(pattern[patoffset + 1]));
+                           WORD_SWIZZLE(pattern[patoffset + 1]));
                 WRITE_GP32(MGP_PAT_COLOR_3,
-                    WORD_SWIZZLE(pattern[patoffset + 2]));
+                           WORD_SWIZZLE(pattern[patoffset + 2]));
                 WRITE_GP32(MGP_PAT_COLOR_2,
-                    WORD_SWIZZLE(pattern[patoffset + 3]));
+                           WORD_SWIZZLE(pattern[patoffset + 3]));
                 patoffset = (patoffset + 4) & 0x1C;
                 WRITE_GP16(MGP_BLT_MODE, gu2_blt_mode | gu2_bm_throttle);
 
                 /* ADJUST FOR NEXT PASS */
 
                 dstoffset += gu2_dst_pitch << 1;
-                height -= (unsigned short)lines;
+                height -= (unsigned short) lines;
             }
             break;
 
-        case 2:                       /* 32 BPP - 1 LINE PER PASS */
+        case 2:                /* 32 BPP - 1 LINE PER PASS */
 
             patoffset = (gu2_pattern_origin >> 26) & 0x38;
             while (height) {
@@ -1672,7 +1690,7 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
 
                 WRITE_GP32(MGP_DST_OFFSET, dstoffset | patxorigin);
                 WRITE_GP32(MGP_WID_HEIGHT,
-                    (((unsigned long)width) << 16) | 1l);
+                           (((unsigned long) width) << 16) | 1l);
                 WRITE_GP32(MGP_PAT_COLOR_1, pattern[patoffset + 4]);
                 WRITE_GP32(MGP_PAT_COLOR_0, pattern[patoffset + 5]);
                 WRITE_GP32(MGP_PAT_DATA_1, pattern[patoffset + 6]);
@@ -1712,17 +1730,19 @@ gfx2_color_pattern_fill(unsigned long dstoffset, unsigned short width,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu22_screen_to_screen_blt(unsigned long srcoffset, unsigned long dstoffset,
-    unsigned short width, unsigned short height, int flags)
+                          unsigned short width, unsigned short height,
+                          int flags)
 #else
 void
 gfx2_screen_to_screen_blt(unsigned long srcoffset, unsigned long dstoffset,
-    unsigned short width, unsigned short height, int flags)
+                          unsigned short width, unsigned short height,
+                          int flags)
 #endif
 {
     unsigned long size, xbytes;
     unsigned short blt_mode;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
     /* USE ALPHA SETTINGS, IF REQUESTED */
 
@@ -1762,7 +1782,8 @@ gfx2_screen_to_screen_blt(unsigned long srcoffset, unsigned long dstoffset,
 
     if (gu2_alpha_active) {
         WRITE_GP32(MGP_RASTER_MODE, gu2_alpha32);
-    } else {
+    }
+    else {
         WRITE_GP32(MGP_RASTER_MODE, gu2_rop32 | GFXsourceFlags);
     }
 
@@ -1787,26 +1808,28 @@ gfx2_screen_to_screen_blt(unsigned long srcoffset, unsigned long dstoffset,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu22_mono_expand_blt(unsigned long srcbase, unsigned short srcx,
-    unsigned short srcy, unsigned long dstoffset, unsigned short width,
-    unsigned short height, int byte_packed)
+                     unsigned short srcy, unsigned long dstoffset,
+                     unsigned short width, unsigned short height,
+                     int byte_packed)
 #else
 void
 gfx2_mono_expand_blt(unsigned long srcbase, unsigned short srcx,
-    unsigned short srcy, unsigned long dstoffset, unsigned short width,
-    unsigned short height, int byte_packed)
+                     unsigned short srcy, unsigned long dstoffset,
+                     unsigned short width, unsigned short height,
+                     int byte_packed)
 #endif
 {
     unsigned long size, srcoffset;
     unsigned short blt_mode;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
     /* CALCULATE SOURCE OFFSET */
 
-    srcoffset = srcbase + (unsigned long)srcy *gu2_src_pitch;
+    srcoffset = srcbase + (unsigned long) srcy *gu2_src_pitch;
 
     srcoffset += srcx >> 3;
-    srcoffset |= ((unsigned long)srcx & 7) << 26;
+    srcoffset |= ((unsigned long) srcx & 7) << 26;
 
     /* POLL UNTIL ABLE TO WRITE TO THE REGISTERS */
     /* Put off poll for as long as possible (do most calculations first). */
@@ -1817,7 +1840,8 @@ gfx2_mono_expand_blt(unsigned long srcbase, unsigned short srcx,
         blt_mode = gu2_alpha_blt_mode;
 
         WRITE_GP32(MGP_RASTER_MODE, gu2_alpha32);
-    } else {
+    }
+    else {
         blt_mode = (gu2_blt_mode & ~MGP_BM_SRC_TYPE_MASK);
 
         WRITE_GP32(MGP_RASTER_MODE, gu2_rop32 | GFXsourceFlags);
@@ -1848,13 +1872,15 @@ gfx2_mono_expand_blt(unsigned long srcbase, unsigned short srcx,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu22_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch)
+                                unsigned long dstoffset, unsigned short width,
+                                unsigned short height, unsigned char *data,
+                                short pitch)
 #else
 void
 gfx2_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch)
+                                unsigned long dstoffset, unsigned short width,
+                                unsigned short height, unsigned char *data,
+                                short pitch)
 #endif
 {
     unsigned long size, bytes;
@@ -1862,11 +1888,11 @@ gfx2_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
     unsigned long srcoffset, dword_bytes, bytes_extra;
     unsigned short blt_mode;
 
-    size = (((unsigned long)width) << 16) | 1;
+    size = (((unsigned long) width) << 16) | 1;
 
     /* CALCULATE STARTING OFFSETS */
 
-    offset = (unsigned long)srcy *pitch + ((unsigned long)srcx << gu2_xshift);
+    offset = (unsigned long) srcy *pitch + ((unsigned long) srcx << gu2_xshift);
 
     dstoffset |= gu2_pattern_origin;
 
@@ -1886,7 +1912,8 @@ gfx2_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         blt_mode = gu2_alpha_blt_mode;
 
         WRITE_GP32(MGP_RASTER_MODE, gu2_alpha32);
-    } else {
+    }
+    else {
         blt_mode = (gu2_blt_mode & ~MGP_BM_SRC_TYPE_MASK);
 
         WRITE_GP32(MGP_RASTER_MODE, gu2_rop32 | GFXsourceFlags);
@@ -1916,13 +1943,12 @@ gfx2_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         dstoffset += gu2_dst_pitch;
         dstoffset += 0x20000000;
 
-        WRITE_FRAME_BUFFER_STRING32(srcoffset, dword_bytes, data,
-            temp_offset);
+        WRITE_FRAME_BUFFER_STRING32(srcoffset, dword_bytes, data, temp_offset);
         if (bytes_extra) {
             temp_offset += dword_bytes;
             srcoffset += dword_bytes;
             WRITE_FRAME_BUFFER_STRING8(srcoffset, bytes_extra, data,
-                temp_offset);
+                                       temp_offset);
         }
         WRITE_GP16(MGP_BLT_MODE, blt_mode);
         offset += pitch;
@@ -1940,11 +1966,11 @@ gfx2_color_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu22_text_blt(unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned char *data)
+              unsigned short height, unsigned char *data)
 #else
 void
 gfx2_text_blt(unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned char *data)
+              unsigned short height, unsigned char *data)
 #endif
 {
     unsigned long size, bytes;
@@ -1953,7 +1979,7 @@ gfx2_text_blt(unsigned long dstoffset, unsigned short width,
     unsigned long shift;
     unsigned short blt_mode;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
     /* CALCULATE STARTING OFFSETS */
 
@@ -1970,7 +1996,8 @@ gfx2_text_blt(unsigned long dstoffset, unsigned short width,
         blt_mode = gu2_alpha_blt_mode;
 
         WRITE_GP32(MGP_RASTER_MODE, gu2_alpha32);
-    } else {
+    }
+    else {
         blt_mode = (gu2_blt_mode & ~MGP_BM_SRC_TYPE_MASK);
 
         WRITE_GP32(MGP_RASTER_MODE, gu2_rop32 | GFXsourceFlags);
@@ -1981,7 +2008,7 @@ gfx2_text_blt(unsigned long dstoffset, unsigned short width,
     WRITE_GP32(MGP_WID_HEIGHT, size);
     WRITE_GP32(MGP_STRIDE, gu2_dst_pitch);
     WRITE_GP16(MGP_BLT_MODE, blt_mode | MGP_BM_SRC_HOST |
-        MGP_BM_SRC_BP_MONO | gu2_bm_throttle);
+               MGP_BM_SRC_BP_MONO | gu2_bm_throttle);
     gu2_bm_throttle = 0;
     gu2_vm_throttle = 0;
 
@@ -2003,13 +2030,13 @@ gfx2_text_blt(unsigned long dstoffset, unsigned short width,
         GU2_WAIT_HALF_EMPTY;
         if (dwords_extra) {
             WRITE_GPREG_STRING32(MGP_HST_SOURCE, dwords_extra, i, data,
-                temp_offset, temp1);
+                                 temp_offset, temp1);
             temp_offset += (dwords_extra << 2);
         }
         if (bytes_extra) {
             shift = 0;
             WRITE_GPREG_STRING8(MGP_HST_SOURCE, bytes_extra, shift, i, data,
-                temp_offset, temp1, temp2);
+                                temp_offset, temp1, temp2);
         }
     }
 }
@@ -2024,13 +2051,15 @@ gfx2_text_blt(unsigned long dstoffset, unsigned short width,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu22_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch)
+                               unsigned long dstoffset, unsigned short width,
+                               unsigned short height, unsigned char *data,
+                               short pitch)
 #else
 void
 gfx2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
-    unsigned long dstoffset, unsigned short width,
-    unsigned short height, unsigned char *data, short pitch)
+                               unsigned long dstoffset, unsigned short width,
+                               unsigned short height, unsigned char *data,
+                               short pitch)
 #endif
 {
     unsigned long size, bytes;
@@ -2039,11 +2068,11 @@ gfx2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
     unsigned long shift = 0;
     unsigned short blt_mode;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
     /* CALCULATE STARTING OFFSETS */
 
-    offset = (unsigned long)srcy *pitch + ((unsigned long)srcx >> 3);
+    offset = (unsigned long) srcy *pitch + ((unsigned long) srcx >> 3);
 
     bytes = ((srcx & 7) + width + 7) >> 3;
     fifo_lines = bytes >> 5;
@@ -2058,18 +2087,19 @@ gfx2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         blt_mode = gu2_alpha_blt_mode;
 
         WRITE_GP32(MGP_RASTER_MODE, gu2_alpha32);
-    } else {
+    }
+    else {
         blt_mode = (gu2_blt_mode & ~MGP_BM_SRC_TYPE_MASK);
 
         WRITE_GP32(MGP_RASTER_MODE, gu2_rop32 | GFXsourceFlags);
     }
 
-    WRITE_GP32(MGP_SRC_OFFSET, ((unsigned long)srcx & 7) << 26);
+    WRITE_GP32(MGP_SRC_OFFSET, ((unsigned long) srcx & 7) << 26);
     WRITE_GP32(MGP_DST_OFFSET, dstoffset | gu2_pattern_origin);
     WRITE_GP32(MGP_WID_HEIGHT, size);
     WRITE_GP32(MGP_STRIDE, gu2_dst_pitch);
     WRITE_GP16(MGP_BLT_MODE, blt_mode | MGP_BM_SRC_HOST |
-        MGP_BM_SRC_MONO | gu2_bm_throttle);
+               MGP_BM_SRC_MONO | gu2_bm_throttle);
     gu2_bm_throttle = 0;
     gu2_vm_throttle = 0;
 
@@ -2087,7 +2117,7 @@ gfx2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         for (i = 0; i < fifo_lines; i++) {
             GU2_WAIT_HALF_EMPTY;
             WRITE_GPREG_STRING32(MGP_HST_SOURCE, 8, j, data, temp_offset,
-                temp1);
+                                 temp1);
             temp_offset += 32;
         }
 
@@ -2096,7 +2126,7 @@ gfx2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         GU2_WAIT_HALF_EMPTY;
         if (dwords_extra)
             WRITE_GPREG_STRING32(MGP_HST_SOURCE, dwords_extra, i, data,
-                temp_offset, temp1);
+                                 temp_offset, temp1);
         temp_offset += (dwords_extra << 2);
 
         /* WRITE REMAINING BYTES */
@@ -2104,7 +2134,7 @@ gfx2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
         shift = 0;
         if (bytes_extra)
             WRITE_GPREG_STRING8(MGP_HST_SOURCE, bytes_extra, shift, i, data,
-                temp_offset, temp1, temp2);
+                                temp_offset, temp1, temp2);
 
         offset += pitch;
     }
@@ -2120,18 +2150,20 @@ gfx2_mono_bitmap_to_screen_blt(unsigned short srcx, unsigned short srcy,
 #if GFX_2DACCEL_DYNAMIC
 void
 gu22_bresenham_line(unsigned long dstoffset,
-    unsigned short length, unsigned short initerr,
-    unsigned short axialerr, unsigned short diagerr, unsigned short flags)
+                    unsigned short length, unsigned short initerr,
+                    unsigned short axialerr, unsigned short diagerr,
+                    unsigned short flags)
 #else
 void
 gfx2_bresenham_line(unsigned long dstoffset,
-    unsigned short length, unsigned short initerr,
-    unsigned short axialerr, unsigned short diagerr, unsigned short flags)
+                    unsigned short length, unsigned short initerr,
+                    unsigned short axialerr, unsigned short diagerr,
+                    unsigned short flags)
 #endif
 {
     unsigned long vector_mode = gu2_vector_mode | flags;
-    unsigned long data1 = (((unsigned long)axialerr) << 16) | diagerr;
-    unsigned long data2 = (((unsigned long)length) << 16) | initerr;
+    unsigned long data1 = (((unsigned long) axialerr) << 16) | diagerr;
+    unsigned long data2 = (((unsigned long) length) << 16) | initerr;
 
     /* CHECK NULL LENGTH */
 
@@ -2147,7 +2179,8 @@ gfx2_bresenham_line(unsigned long dstoffset,
         vector_mode = gu2_alpha_vec_mode | flags;
 
         WRITE_GP32(MGP_RASTER_MODE, gu2_alpha32);
-    } else
+    }
+    else
         WRITE_GP32(MGP_RASTER_MODE, gu2_rop32);
 
     WRITE_GP32(MGP_DST_OFFSET, dstoffset | gu2_pattern_origin);
diff --git a/src/gfx/saa7114.c b/src/gfx/saa7114.c
index df516bc..6e9ab8d 100644
--- a/src/gfx/saa7114.c
+++ b/src/gfx/saa7114.c
@@ -31,8 +31,7 @@
 /*  TABLE OF DEFAULT VALUES  */
 /*---------------------------*/
 
-typedef struct tagGFX_SAA7114_INIT
-{
+typedef struct tagGFX_SAA7114_INIT {
     unsigned char index;
     unsigned char value;
 } GFX_SAA7114_INIT;
@@ -97,8 +96,7 @@ GFX_SAA7114_INIT gfx_saa7114_init_values[] = {
 
 int optimize_for_aliasing = 0;
 
-typedef struct tagGFX_SAA7114_FIR_PREFILTER
-{
+typedef struct tagGFX_SAA7114_FIR_PREFILTER {
     unsigned char prescaler;
     unsigned char acl_low;
     unsigned char prefilter_low;
@@ -255,7 +253,7 @@ gfx_set_decoder_defaults(void)
 
     for (i = 0; i < GFX_NUM_SAA7114_INIT_VALUES; i++) {
         saa7114_write_reg(gfx_saa7114_init_values[i].index,
-            gfx_saa7114_init_values[i].value);
+                          gfx_saa7114_init_values[i].value);
     }
 
     gfx_decoder_software_reset();
@@ -312,7 +310,7 @@ int
 gfx_set_decoder_contrast(unsigned char contrast)
 #endif
 {
-    saa7114_write_reg(SAA7114_CONTRAST, (unsigned char)(contrast >> 1));
+    saa7114_write_reg(SAA7114_CONTRAST, (unsigned char) (contrast >> 1));
     return (0);
 }
 
@@ -330,7 +328,7 @@ int
 gfx_set_decoder_hue(char hue)
 #endif
 {
-    saa7114_write_reg(SAA7114_HUE, (unsigned char)hue);
+    saa7114_write_reg(SAA7114_HUE, (unsigned char) hue);
     return (0);
 }
 
@@ -348,7 +346,7 @@ int
 gfx_set_decoder_saturation(unsigned char saturation)
 #endif
 {
-    saa7114_write_reg(SAA7114_SATURATION, (unsigned char)(saturation >> 1));
+    saa7114_write_reg(SAA7114_SATURATION, (unsigned char) (saturation >> 1));
     return (0);
 }
 
@@ -368,10 +366,10 @@ gfx_set_decoder_input_offset(unsigned short x, unsigned short y)
 {
     /* SET THE INPUT WINDOW OFFSET */
 
-    saa7114_write_reg(SAA7114_HORZ_OFFSET_LO, (unsigned char)(x & 0x00FF));
-    saa7114_write_reg(SAA7114_HORZ_OFFSET_HI, (unsigned char)(x >> 8));
-    saa7114_write_reg(SAA7114_VERT_OFFSET_LO, (unsigned char)(y & 0x00FF));
-    saa7114_write_reg(SAA7114_VERT_OFFSET_HI, (unsigned char)(y >> 8));
+    saa7114_write_reg(SAA7114_HORZ_OFFSET_LO, (unsigned char) (x & 0x00FF));
+    saa7114_write_reg(SAA7114_HORZ_OFFSET_HI, (unsigned char) (x >> 8));
+    saa7114_write_reg(SAA7114_VERT_OFFSET_LO, (unsigned char) (y & 0x00FF));
+    saa7114_write_reg(SAA7114_VERT_OFFSET_HI, (unsigned char) (y >> 8));
 
     gfx_decoder_software_reset();
     return (0);
@@ -397,11 +395,10 @@ gfx_set_decoder_input_size(unsigned short width, unsigned short height)
 
     /* SET THE INPUT WINDOW SIZE */
 
-    saa7114_write_reg(SAA7114_HORZ_INPUT_LO, (unsigned char)(width & 0x00FF));
-    saa7114_write_reg(SAA7114_HORZ_INPUT_HI, (unsigned char)(width >> 8));
-    saa7114_write_reg(SAA7114_VERT_INPUT_LO,
-        (unsigned char)(height & 0x00FF));
-    saa7114_write_reg(SAA7114_VERT_INPUT_HI, (unsigned char)(height >> 8));
+    saa7114_write_reg(SAA7114_HORZ_INPUT_LO, (unsigned char) (width & 0x00FF));
+    saa7114_write_reg(SAA7114_HORZ_INPUT_HI, (unsigned char) (width >> 8));
+    saa7114_write_reg(SAA7114_VERT_INPUT_LO, (unsigned char) (height & 0x00FF));
+    saa7114_write_reg(SAA7114_VERT_INPUT_HI, (unsigned char) (height >> 8));
 
     gfx_decoder_software_reset();
     return (0);
@@ -431,12 +428,11 @@ gfx_set_decoder_output_size(unsigned short width, unsigned short height)
 
     /* SET THE OUTPUT WINDOW SIZE */
 
-    saa7114_write_reg(SAA7114_HORZ_OUTPUT_LO,
-        (unsigned char)(width & 0x00FF));
-    saa7114_write_reg(SAA7114_HORZ_OUTPUT_HI, (unsigned char)(width >> 8));
+    saa7114_write_reg(SAA7114_HORZ_OUTPUT_LO, (unsigned char) (width & 0x00FF));
+    saa7114_write_reg(SAA7114_HORZ_OUTPUT_HI, (unsigned char) (width >> 8));
     saa7114_write_reg(SAA7114_VERT_OUTPUT_LO,
-        (unsigned char)(height & 0x00FF));
-    saa7114_write_reg(SAA7114_VERT_OUTPUT_HI, (unsigned char)(height >> 8));
+                      (unsigned char) (height & 0x00FF));
+    saa7114_write_reg(SAA7114_VERT_OUTPUT_HI, (unsigned char) (height >> 8));
 
     gfx_decoder_software_reset();
     return (0);
@@ -451,11 +447,11 @@ gfx_set_decoder_output_size(unsigned short width, unsigned short height)
 #if GFX_DECODER_DYNAMIC
 int
 saa7114_set_decoder_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                          unsigned short dstw, unsigned short dsth)
 #else
 int
 gfx_set_decoder_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                      unsigned short dstw, unsigned short dsth)
 #endif
 {
     unsigned char prescale = 0;
@@ -465,7 +461,7 @@ gfx_set_decoder_scale(unsigned short srcw, unsigned short srch,
     /* Downscale from 1 to 1/63 source size. */
 
     if (dstw)
-        prescale = (unsigned char)(srcw / dstw);
+        prescale = (unsigned char) (srcw / dstw);
     if (!prescale)
         prescale = 1;
     if (prescale > 63)
@@ -477,27 +473,32 @@ gfx_set_decoder_scale(unsigned short srcw, unsigned short srch,
     if (prescale < 36) {
         if (optimize_for_aliasing) {
             saa7114_write_reg(SAA7114_HORZ_ACL,
-                gfx_saa7114_fir_values[prescale - 1].acl_low);
+                              gfx_saa7114_fir_values[prescale - 1].acl_low);
             saa7114_write_reg(SAA7114_HORZ_FIR_PREFILTER,
-                gfx_saa7114_fir_values[prescale - 1].prefilter_low);
-        } else {
+                              gfx_saa7114_fir_values[prescale -
+                                                     1].prefilter_low);
+        }
+        else {
             saa7114_write_reg(SAA7114_HORZ_ACL,
-                gfx_saa7114_fir_values[prescale - 1].acl_high);
+                              gfx_saa7114_fir_values[prescale - 1].acl_high);
             saa7114_write_reg(SAA7114_HORZ_FIR_PREFILTER,
-                gfx_saa7114_fir_values[prescale - 1].prefilter_high);
+                              gfx_saa7114_fir_values[prescale -
+                                                     1].prefilter_high);
         }
-    } else {
+    }
+    else {
         /* SAME SETTINGS FOR RATIO 1/35 DOWNTO 1/63 */
         if (optimize_for_aliasing) {
             saa7114_write_reg(SAA7114_HORZ_ACL,
-                gfx_saa7114_fir_values[34].acl_low);
+                              gfx_saa7114_fir_values[34].acl_low);
             saa7114_write_reg(SAA7114_HORZ_FIR_PREFILTER,
-                gfx_saa7114_fir_values[34].prefilter_low);
-        } else {
+                              gfx_saa7114_fir_values[34].prefilter_low);
+        }
+        else {
             saa7114_write_reg(SAA7114_HORZ_ACL,
-                gfx_saa7114_fir_values[34].acl_high);
+                              gfx_saa7114_fir_values[34].acl_high);
             saa7114_write_reg(SAA7114_HORZ_FIR_PREFILTER,
-                gfx_saa7114_fir_values[34].prefilter_high);
+                              gfx_saa7114_fir_values[34].prefilter_high);
         }
     }
 
@@ -508,13 +509,12 @@ gfx_set_decoder_scale(unsigned short srcw, unsigned short srch,
     scale = ((1024 * srcw * 1000) / (dstw * prescale)) / 1000;
     if ((scale > 8191) || (scale < 300))
         return (1);
-    saa7114_write_reg(SAA7114_HSCALE_LUMA_LO,
-        (unsigned char)(scale & 0x00FF));
-    saa7114_write_reg(SAA7114_HSCALE_LUMA_HI, (unsigned char)(scale >> 8));
+    saa7114_write_reg(SAA7114_HSCALE_LUMA_LO, (unsigned char) (scale & 0x00FF));
+    saa7114_write_reg(SAA7114_HSCALE_LUMA_HI, (unsigned char) (scale >> 8));
     scale >>= 1;
     saa7114_write_reg(SAA7114_HSCALE_CHROMA_LO,
-        (unsigned char)(scale & 0x00FF));
-    saa7114_write_reg(SAA7114_HSCALE_CHROMA_HI, (unsigned char)(scale >> 8));
+                      (unsigned char) (scale & 0x00FF));
+    saa7114_write_reg(SAA7114_HSCALE_CHROMA_HI, (unsigned char) (scale >> 8));
 
     /* SET THE VERTICAL SCALING (INTERPOLATION MODE) */
 
@@ -526,13 +526,12 @@ gfx_set_decoder_scale(unsigned short srcw, unsigned short srch,
 
     dsth = ((dsth + 1) >> 1) << 1;
 
-    scale = (int)((1024 * srch) / dsth);
-    saa7114_write_reg(SAA7114_VSCALE_LUMA_LO,
-        (unsigned char)(scale & 0x00FF));
-    saa7114_write_reg(SAA7114_VSCALE_LUMA_HI, (unsigned char)(scale >> 8));
+    scale = (int) ((1024 * srch) / dsth);
+    saa7114_write_reg(SAA7114_VSCALE_LUMA_LO, (unsigned char) (scale & 0x00FF));
+    saa7114_write_reg(SAA7114_VSCALE_LUMA_HI, (unsigned char) (scale >> 8));
     saa7114_write_reg(SAA7114_VSCALE_CHROMA_LO,
-        (unsigned char)(scale & 0x00FF));
-    saa7114_write_reg(SAA7114_VSCALE_CHROMA_HI, (unsigned char)(scale >> 8));
+                      (unsigned char) (scale & 0x00FF));
+    saa7114_write_reg(SAA7114_VSCALE_CHROMA_HI, (unsigned char) (scale >> 8));
 
     if (dsth >= (srch >> 1)) {
         /* USE INTERPOLATION MODE FOR SCALE FACTOR ABOVE 0.5 */
@@ -545,22 +544,27 @@ gfx_set_decoder_scale(unsigned short srcw, unsigned short srch,
         saa7114_write_reg(SAA7114_VSCALE_CHROMA_OFFS0, SAA7114_VSCALE_PHO);
         saa7114_write_reg(SAA7114_VSCALE_CHROMA_OFFS1, SAA7114_VSCALE_PHO);
         saa7114_write_reg(SAA7114_VSCALE_CHROMA_OFFS2,
-            (unsigned char)(SAA7114_VSCALE_PHO + scale / 64 - 16));
+                          (unsigned char) (SAA7114_VSCALE_PHO + scale / 64 -
+                                           16));
         saa7114_write_reg(SAA7114_VSCALE_CHROMA_OFFS3,
-            (unsigned char)(SAA7114_VSCALE_PHO + scale / 64 - 16));
+                          (unsigned char) (SAA7114_VSCALE_PHO + scale / 64 -
+                                           16));
 
         saa7114_write_reg(SAA7114_VSCALE_LUMINA_OFFS0, SAA7114_VSCALE_PHO);
         saa7114_write_reg(SAA7114_VSCALE_LUMINA_OFFS1, SAA7114_VSCALE_PHO);
         saa7114_write_reg(SAA7114_VSCALE_LUMINA_OFFS2,
-            (unsigned char)(SAA7114_VSCALE_PHO + scale / 64 - 16));
+                          (unsigned char) (SAA7114_VSCALE_PHO + scale / 64 -
+                                           16));
         saa7114_write_reg(SAA7114_VSCALE_LUMINA_OFFS3,
-            (unsigned char)(SAA7114_VSCALE_PHO + scale / 64 - 16));
+                          (unsigned char) (SAA7114_VSCALE_PHO + scale / 64 -
+                                           16));
 
         /* RESTORE CONTRAST AND SATURATION FOR INTERPOLATION MODE */
 
-        saa7114_write_reg(SAA7114_FILTER_CONTRAST, (unsigned char)0x40);
-        saa7114_write_reg(SAA7114_FILTER_SATURATION, (unsigned char)0x40);
-    } else {
+        saa7114_write_reg(SAA7114_FILTER_CONTRAST, (unsigned char) 0x40);
+        saa7114_write_reg(SAA7114_FILTER_SATURATION, (unsigned char) 0x40);
+    }
+    else {
         /* USE ACCUMULATION MODE FOR DOWNSCALING BY MORE THAN 2x */
 
         saa7114_write_reg(SAA7114_VSCALE_CONTROL, 0x01);
@@ -580,8 +584,8 @@ gfx_set_decoder_scale(unsigned short srcw, unsigned short srch,
 
         if (srch)
             scale = (64 * dsth) / srch;
-        saa7114_write_reg(SAA7114_FILTER_CONTRAST, (unsigned char)scale);
-        saa7114_write_reg(SAA7114_FILTER_SATURATION, (unsigned char)scale);
+        saa7114_write_reg(SAA7114_FILTER_CONTRAST, (unsigned char) scale);
+        saa7114_write_reg(SAA7114_FILTER_SATURATION, (unsigned char) scale);
     }
 
     gfx_decoder_software_reset();
@@ -610,20 +614,20 @@ gfx_set_decoder_vbi_format(int start, int end, int format)
         switch (format) {
         case VBI_FORMAT_VIDEO:
             data = 0xFF;
-            break;                     /* Active video */
+            break;              /* Active video */
         case VBI_FORMAT_RAW:
             data = 0x77;
-            break;                     /* Raw VBI data */
+            break;              /* Raw VBI data */
         case VBI_FORMAT_CC:
             data = 0x55;
-            break;                     /* US CC        */
+            break;              /* US CC        */
         case VBI_FORMAT_NABTS:
             data = 0xCC;
-            break;                     /* US NABTS     */
+            break;              /* US NABTS     */
         default:
             return GFX_STATUS_BAD_PARAMETER;
         }
-        saa7114_write_reg((unsigned char)(0x3F + i), data);
+        saa7114_write_reg((unsigned char) (0x3F + i), data);
     }
     return GFX_STATUS_OK;
 }
@@ -701,7 +705,7 @@ gfx_set_decoder_luminance_filter(unsigned char lufi)
 
     saa7114_read_reg(SAA7114_LUMINANCE_CONTROL, &data);
     saa7114_write_reg(SAA7114_LUMINANCE_CONTROL,
-        (unsigned char)((data & ~0x0F) | (lufi & 0x0F)));
+                      (unsigned char) ((data & ~0x0F) | (lufi & 0x0F)));
     return (0);
 }
 
@@ -769,7 +773,7 @@ gfx_get_decoder_hue(void)
     unsigned char hue = 0;
 
     saa7114_read_reg(SAA7114_HUE, &hue);
-    return ((char)hue);
+    return ((char) hue);
 }
 
 /*----------------------------------------------------------------------------
@@ -811,13 +815,13 @@ gfx_get_decoder_input_offset(void)
     unsigned char data;
 
     saa7114_read_reg(SAA7114_HORZ_OFFSET_LO, &data);
-    value = (unsigned long)data;
+    value = (unsigned long) data;
     saa7114_read_reg(SAA7114_HORZ_OFFSET_HI, &data);
-    value |= ((unsigned long)data) << 8;
+    value |= ((unsigned long) data) << 8;
     saa7114_read_reg(SAA7114_VERT_OFFSET_LO, &data);
-    value |= ((unsigned long)data) << 16;
+    value |= ((unsigned long) data) << 16;
     saa7114_read_reg(SAA7114_VERT_OFFSET_HI, &data);
-    value |= ((unsigned long)data) << 24;
+    value |= ((unsigned long) data) << 24;
     return (value);
 }
 
@@ -839,13 +843,13 @@ gfx_get_decoder_input_size(void)
     unsigned char data;
 
     saa7114_read_reg(SAA7114_HORZ_INPUT_LO, &data);
-    value = (unsigned long)data;
+    value = (unsigned long) data;
     saa7114_read_reg(SAA7114_HORZ_INPUT_HI, &data);
-    value |= ((unsigned long)data) << 8;
+    value |= ((unsigned long) data) << 8;
     saa7114_read_reg(SAA7114_VERT_INPUT_LO, &data);
-    value |= ((unsigned long)data) << 17;
+    value |= ((unsigned long) data) << 17;
     saa7114_read_reg(SAA7114_VERT_INPUT_HI, &data);
-    value |= ((unsigned long)data) << 25;
+    value |= ((unsigned long) data) << 25;
     return (value);
 }
 
@@ -867,13 +871,13 @@ gfx_get_decoder_output_size(void)
     unsigned char data;
 
     saa7114_read_reg(SAA7114_HORZ_OUTPUT_LO, &data);
-    value = (unsigned long)data;
+    value = (unsigned long) data;
     saa7114_read_reg(SAA7114_HORZ_OUTPUT_HI, &data);
-    value |= ((unsigned long)data) << 8;
+    value |= ((unsigned long) data) << 8;
     saa7114_read_reg(SAA7114_VERT_OUTPUT_LO, &data);
-    value |= ((unsigned long)data) << 17;
+    value |= ((unsigned long) data) << 17;
     saa7114_read_reg(SAA7114_VERT_OUTPUT_HI, &data);
-    value |= ((unsigned long)data) << 25;
+    value |= ((unsigned long) data) << 25;
     return (value);
 }
 
@@ -893,24 +897,24 @@ gfx_get_decoder_vbi_format(int line)
 {
     unsigned char format = 0, data;
 
-    saa7114_read_reg((unsigned char)(0x3F + line), &data);
+    saa7114_read_reg((unsigned char) (0x3F + line), &data);
     switch (data) {
     case 0xFF:
         format = VBI_FORMAT_VIDEO;
-        break;                         /* Active video */
+        break;                  /* Active video */
     case 0x77:
         format = VBI_FORMAT_RAW;
-        break;                         /* Raw VBI data */
+        break;                  /* Raw VBI data */
     case 0x55:
         format = VBI_FORMAT_CC;
-        break;                         /* US CC        */
+        break;                  /* US CC        */
     case 0xCC:
         format = VBI_FORMAT_NABTS;
-        break;                         /* US NABTS     */
+        break;                  /* US NABTS     */
     }
     return (format);
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
 /* END OF FILE */
diff --git a/src/gfx/tv_1200.c b/src/gfx/tv_1200.c
index a75cc32..8ebcffc 100644
--- a/src/gfx/tv_1200.c
+++ b/src/gfx/tv_1200.c
@@ -47,7 +47,7 @@ gfx_set_tv_format(TVStandardType format, GfxOnTVType resolution)
     /* Save TV output mode */
     ctrl2 =
         READ_VID32(SC1200_TVENC_TIM_CTRL_2) & (SC1200_TVENC_OUTPUT_YCBCR |
-        SC1200_TVENC_CFS_MASK);
+                                               SC1200_TVENC_CFS_MASK);
     /* Save flicker filter setting */
     mode =
         READ_VID32(SC1200_TVOUT_HORZ_SCALING) &
@@ -105,7 +105,8 @@ gfx_set_tv_format(TVStandardType format, GfxOnTVType resolution)
                 /* Horizontal display end is 919, i.e. 720 active pixels */
                 /* Total number of display lines per field is 240 */
                 WRITE_VID32(SC1200_TVOUT_LINE_END, 0x039700f0);
-            } else {                   /* Use new scaler available in Rev. C */
+            }
+            else {              /* Use new scaler available in Rev. C */
                 /* Horizontal Display start is 111 */
                 /* Total number of pixels per line is 857 */
                 WRITE_VID32(SC1200_TVOUT_HORZ_TIM, 0x006f0359);
@@ -214,7 +215,8 @@ gfx_set_tv_format(TVStandardType format, GfxOnTVType resolution)
                 /* Horizontal display end is 906, i.e. 704 active pixels */
                 /* Total number of display lines per field is 288 */
                 WRITE_VID32(SC1200_TVOUT_LINE_END, 0x038a0120);
-            } else {
+            }
+            else {
                 /* HSYNC generated in the TV Encoder module */
                 /* Interval between resets of TV Encoder is once every odd 
                  * field */
@@ -260,8 +262,7 @@ gfx_set_tv_output(int output)
     ctrl2 = READ_VID32(SC1200_TVENC_TIM_CTRL_2);
     ctrl3 = READ_VID32(SC1200_TVENC_TIM_CTRL_3);
     ctrl2 &= ~(SC1200_TVENC_OUTPUT_YCBCR | SC1200_TVENC_CFS_MASK);
-    ctrl3 &=
-        ~(SC1200_TVENC_CM | SC1200_TVENC_SYNCMODE_MASK | SC1200_TVENC_CS);
+    ctrl3 &= ~(SC1200_TVENC_CM | SC1200_TVENC_SYNCMODE_MASK | SC1200_TVENC_CS);
     switch (output) {
     case TV_OUTPUT_COMPOSITE:
         /* Analog outputs provide Y, C and CVBS */
@@ -279,16 +280,17 @@ gfx_set_tv_output(int output)
         /* Analog outputs provide Y, Cb and Cr */
         /* A 7.5 IRE setup is applied to the output */
         WRITE_VID32(SC1200_TVENC_TIM_CTRL_2,
-            ctrl2 | SC1200_TVENC_OUTPUT_YCBCR | SC1200_TVENC_CFS_BYPASS);
+                    ctrl2 | SC1200_TVENC_OUTPUT_YCBCR |
+                    SC1200_TVENC_CFS_BYPASS);
         WRITE_VID32(SC1200_TVENC_TIM_CTRL_3,
-            ctrl3 | SC1200_TVENC_CM | SC1200_TVENC_CS);
+                    ctrl3 | SC1200_TVENC_CM | SC1200_TVENC_CS);
         break;
     case TV_OUTPUT_SCART:
         /* Analog outputs provide SCART (RGB and CVBS) */
         /* Sync is added to green signal */
         WRITE_VID32(SC1200_TVENC_TIM_CTRL_2, ctrl2 | SC1200_TVENC_CFS_CVBS);
         WRITE_VID32(SC1200_TVENC_TIM_CTRL_3,
-            ctrl3 | SC1200_TVENC_CM | SC1200_TVENC_SYNC_ON_GREEN);
+                    ctrl3 | SC1200_TVENC_CM | SC1200_TVENC_SYNC_ON_GREEN);
         break;
     default:
         return (GFX_STATUS_BAD_PARAMETER);
@@ -336,7 +338,8 @@ gfx_set_tv_enable(int enable)
         value_dac &= ~SC1200_TVENC_POWER_DOWN;
         /* ENABLE GRAPHICS DISPLAY LOGIC IN VIDEO PROCESSOR */
         gfx_set_screen_enable(1);
-    } else {
+    }
+    else {
         value_tim &= ~SC1200_TVENC_VIDEO_TIMING_ENABLE;
         value_dac |= SC1200_TVENC_POWER_DOWN;
         /* Do not disable the graphics display logic because it might be
@@ -370,15 +373,15 @@ gfx_set_tv_flicker_filter(int ff)
     switch (ff) {
     case TV_FLICKER_FILTER_NONE:
         WRITE_VID32(SC1200_TVOUT_HORZ_SCALING,
-            mode | SC1200_TVOUT_FLICKER_FILTER_DISABLED);
+                    mode | SC1200_TVOUT_FLICKER_FILTER_DISABLED);
         break;
     case TV_FLICKER_FILTER_NORMAL:
         WRITE_VID32(SC1200_TVOUT_HORZ_SCALING,
-            mode | SC1200_TVOUT_FLICKER_FILTER_FOURTH_HALF_FOURTH);
+                    mode | SC1200_TVOUT_FLICKER_FILTER_FOURTH_HALF_FOURTH);
         break;
     case TV_FLICKER_FILTER_INTERLACED:
         WRITE_VID32(SC1200_TVOUT_HORZ_SCALING,
-            mode | SC1200_TVOUT_FLICKER_FILTER_HALF_ONE_HALF);
+                    mode | SC1200_TVOUT_FLICKER_FILTER_HALF_ONE_HALF);
         break;
     default:
         return GFX_STATUS_BAD_PARAMETER;
@@ -407,19 +410,19 @@ gfx_set_tv_sub_carrier_reset(int screset)
     switch (screset) {
     case TV_SUB_CARRIER_RESET_NEVER:
         WRITE_VID32(SC1200_TVENC_TIM_CTRL_1,
-            mode | SC1200_TVENC_SUB_CARRIER_RESET_NEVER);
+                    mode | SC1200_TVENC_SUB_CARRIER_RESET_NEVER);
         break;
     case TV_SUB_CARRIER_RESET_EVERY_TWO_LINES:
         WRITE_VID32(SC1200_TVENC_TIM_CTRL_1,
-            mode | SC1200_TVENC_SUB_CARRIER_RESET_EVERY_TWO_LINES);
+                    mode | SC1200_TVENC_SUB_CARRIER_RESET_EVERY_TWO_LINES);
         break;
     case TV_SUB_CARRIER_RESET_EVERY_TWO_FRAMES:
         WRITE_VID32(SC1200_TVENC_TIM_CTRL_1,
-            mode | SC1200_TVENC_SUB_CARRIER_RESET_EVERY_TWO_FRAMES);
+                    mode | SC1200_TVENC_SUB_CARRIER_RESET_EVERY_TWO_FRAMES);
         break;
     case TV_SUB_CARRIER_RESET_EVERY_FOUR_FRAMES:
         WRITE_VID32(SC1200_TVENC_TIM_CTRL_1,
-            mode | SC1200_TVENC_SUB_CARRIER_RESET_EVERY_FOUR_FRAMES);
+                    mode | SC1200_TVENC_SUB_CARRIER_RESET_EVERY_FOUR_FRAMES);
         break;
     default:
         return GFX_STATUS_BAD_PARAMETER;
@@ -474,19 +477,19 @@ gfx_set_tv_YC_delay(int delay)
     switch (delay) {
     case TV_YC_DELAY_NONE:
         WRITE_VID32(SC1200_TVOUT_HORZ_PRE_ENCODER_SCALE,
-            mode | SC1200_TVOUT_YC_DELAY_NONE);
+                    mode | SC1200_TVOUT_YC_DELAY_NONE);
         break;
     case TV_Y_DELAY_ONE_PIXEL:
         WRITE_VID32(SC1200_TVOUT_HORZ_PRE_ENCODER_SCALE,
-            mode | SC1200_TVOUT_Y_DELAY_ONE_PIXEL);
+                    mode | SC1200_TVOUT_Y_DELAY_ONE_PIXEL);
         break;
     case TV_C_DELAY_ONE_PIXEL:
         WRITE_VID32(SC1200_TVOUT_HORZ_PRE_ENCODER_SCALE,
-            mode | SC1200_TVOUT_C_DELAY_ONE_PIXEL);
+                    mode | SC1200_TVOUT_C_DELAY_ONE_PIXEL);
         break;
     case TV_C_DELAY_TWO_PIXELS:
         WRITE_VID32(SC1200_TVOUT_HORZ_PRE_ENCODER_SCALE,
-            mode | SC1200_TVOUT_C_DELAY_TWO_PIXELS);
+                    mode | SC1200_TVOUT_C_DELAY_TWO_PIXELS);
         break;
     default:
         return GFX_STATUS_BAD_PARAMETER;
@@ -516,23 +519,23 @@ gfx_set_tvenc_reset_interval(int interval)
     switch (interval) {
     case TVENC_RESET_EVERY_ODD_FIELD:
         WRITE_VID32(SC1200_TVOUT_HORZ_SCALING,
-            value | SC1200_TVENC_EXTERNAL_RESET_EVERY_ODD_FIELD);
+                    value | SC1200_TVENC_EXTERNAL_RESET_EVERY_ODD_FIELD);
         break;
     case TVENC_RESET_EVERY_EVEN_FIELD:
         WRITE_VID32(SC1200_TVOUT_HORZ_SCALING,
-            value | SC1200_TVENC_EXTERNAL_RESET_EVERY_EVEN_FIELD);
+                    value | SC1200_TVENC_EXTERNAL_RESET_EVERY_EVEN_FIELD);
         break;
     case TVENC_RESET_NEXT_ODD_FIELD:
         WRITE_VID32(SC1200_TVOUT_HORZ_SCALING,
-            value | SC1200_TVENC_EXTERNAL_RESET_NEXT_ODD_FIELD);
+                    value | SC1200_TVENC_EXTERNAL_RESET_NEXT_ODD_FIELD);
         break;
     case TVENC_RESET_NEXT_EVEN_FIELD:
         WRITE_VID32(SC1200_TVOUT_HORZ_SCALING,
-            value | SC1200_TVENC_EXTERNAL_RESET_NEXT_EVEN_FIELD);
+                    value | SC1200_TVENC_EXTERNAL_RESET_NEXT_EVEN_FIELD);
         break;
     case TVENC_RESET_EVERY_FIELD:
         WRITE_VID32(SC1200_TVOUT_HORZ_SCALING,
-            value | SC1200_TVENC_EXTERNAL_RESET_EVERY_FIELD);
+                    value | SC1200_TVENC_EXTERNAL_RESET_EVERY_FIELD);
         break;
     case TVENC_RESET_EVERY_X_ODD_FIELDS:
     case TVENC_RESET_EVERY_X_EVEN_FIELDS:
@@ -588,8 +591,8 @@ gfx_set_tv_display(int width, int height)
 
     for (i = 0; i < NUM_TV_MODES; i++) {
         pMode = &TVTimings[i];
-        if ((unsigned)width == pMode->hactive
-            && (unsigned)height == pMode->vactive)
+        if ((unsigned) width == pMode->hactive
+            && (unsigned) height == pMode->vactive)
             break;
     }
 
@@ -597,10 +600,12 @@ gfx_set_tv_display(int width, int height)
         return 0;
 
     gfx_set_display_timings(gfx_get_display_bpp(),
-        (unsigned short)pMode->flags, pMode->hactive, pMode->hblankstart,
-        pMode->hsyncstart, pMode->hsyncend, pMode->hblankend, pMode->htotal,
-        pMode->vactive, pMode->vblankstart, pMode->vsyncstart,
-        pMode->vsyncend, pMode->vblankend, pMode->vtotal, pMode->frequency);
+                            (unsigned short) pMode->flags, pMode->hactive,
+                            pMode->hblankstart, pMode->hsyncstart,
+                            pMode->hsyncend, pMode->hblankend, pMode->htotal,
+                            pMode->vactive, pMode->vblankstart,
+                            pMode->vsyncstart, pMode->vsyncend,
+                            pMode->vblankend, pMode->vtotal, pMode->frequency);
 
     return 1;
 }
@@ -719,7 +724,8 @@ gfx_set_tv_field_status_invert(int enable)
 
     if (enable) {
         value |= SC1200_TVOUT_FIELD_STATUS_INVERT;
-    } else {
+    }
+    else {
         value &= ~(SC1200_TVOUT_FIELD_STATUS_INVERT);
     }
 
@@ -744,8 +750,7 @@ gfx_get_tv_vphase(void)
 {
     unsigned long mode = READ_VID32(SC1200_TVENC_TIM_CTRL_1);
 
-    return (int)((mode & SC1200_TVENC_VPHASE_MASK) >>
-        SC1200_TVENC_VPHASE_POS);
+    return (int) ((mode & SC1200_TVENC_VPHASE_MASK) >> SC1200_TVENC_VPHASE_POS);
 }
 
 /*---------------------------------------------------------------------------
@@ -764,7 +769,7 @@ gfx_get_tv_enable(unsigned int *p_on)
 {
     unsigned long control = READ_VID32(SC1200_TVENC_DAC_CONTROL);
 
-    *p_on = (unsigned int)(!(control & SC1200_TVENC_POWER_DOWN));
+    *p_on = (unsigned int) (!(control & SC1200_TVENC_POWER_DOWN));
 
     return GFX_STATUS_OK;
 }
@@ -863,8 +868,8 @@ gfx_get_tv_display_mode(int *width, int *height, int *bpp, int *hz)
     frequency = gfx_get_clock_frequency();
 
     for (mode = 0; mode < NUM_TV_MODES; mode++) {
-        if (TVTimings[mode].hactive == (unsigned short)(*width) &&
-            TVTimings[mode].vactive == (unsigned short)(*height) &&
+        if (TVTimings[mode].hactive == (unsigned short) (*width) &&
+            TVTimings[mode].vactive == (unsigned short) (*height) &&
             TVTimings[mode].frequency == frequency) {
             flags = TVTimings[mode].flags;
 
@@ -890,11 +895,12 @@ gfx_get_tv_display_mode(int *width, int *height, int *bpp, int *hz)
 #if GFX_TV_DYNAMIC
 int
 sc1200_get_tv_display_mode_frequency(unsigned short width,
-    unsigned short height, TVStandardType format, int *frequency)
+                                     unsigned short height,
+                                     TVStandardType format, int *frequency)
 #else
 int
 gfx_get_tv_display_mode_frequency(unsigned short width, unsigned short height,
-    TVStandardType format, int *frequency)
+                                  TVStandardType format, int *frequency)
 #endif
 {
     unsigned long mode, flag;
@@ -933,11 +939,12 @@ gfx_get_tv_display_mode_frequency(unsigned short width, unsigned short height,
 #if GFX_TV_DYNAMIC
 int
 sc1200_is_tv_display_mode_supported(unsigned short width,
-    unsigned short height, TVStandardType format)
+                                    unsigned short height,
+                                    TVStandardType format)
 #else
 int
 gfx_is_tv_display_mode_supported(unsigned short width, unsigned short height,
-    TVStandardType format)
+                                 TVStandardType format)
 #endif
 {
     unsigned long mode, flag;
@@ -957,7 +964,7 @@ gfx_is_tv_display_mode_supported(unsigned short width, unsigned short height,
         if (TVTimings[mode].hactive == width &&
             TVTimings[mode].vactive == height &&
             (TVTimings[mode].flags & flag)) {
-            return ((int)mode);
+            return ((int) mode);
         }
     }
 
diff --git a/src/gfx/tv_fs450.c b/src/gfx/tv_fs450.c
index 942907b..24e7446 100644
--- a/src/gfx/tv_fs450.c
+++ b/src/gfx/tv_fs450.c
@@ -51,8 +51,7 @@
 #define WRITE	2
 #define READ_WRITE (READ | WRITE)
 
-typedef struct
-{
+typedef struct {
     char *name;
     unsigned long offset;
     unsigned char bit_length;
@@ -61,8 +60,7 @@ typedef struct
     char *bitfield_names[MAX_BITS];
 } S_REGISTER_DESCRIP;
 
-typedef struct
-{
+typedef struct {
     int source;
     char *name;
     S_REGISTER_DESCRIP registers[MAX_REGISTERS];
@@ -247,8 +245,7 @@ const S_SET_DESCRIP *gcc_regs(void);
  */
 #define TRACE(parameters) {}
 /*		GCC timing structure		*/
-typedef struct _S_TIMING_SPECS
-{
+typedef struct _S_TIMING_SPECS {
     int vga_width;
     int vga_lines;
     int tv_width;
@@ -302,15 +299,15 @@ DMAL_WriteUInt32(unsigned long phys_addr, unsigned long data)
 static int
 houston_ReadReg(unsigned int reg, unsigned long *p_value, unsigned int bytes)
 {
-    return gfx_i2c_read(1, PLAL_FS450_i2c_address(), (unsigned char)reg,
-        (unsigned char)bytes, (unsigned char *)p_value);
+    return gfx_i2c_read(1, PLAL_FS450_i2c_address(), (unsigned char) reg,
+                        (unsigned char) bytes, (unsigned char *) p_value);
 }
 
 static int
 houston_WriteReg(unsigned int reg, unsigned long value, unsigned int bytes)
 {
-    return gfx_i2c_write(1, PLAL_FS450_i2c_address(), (unsigned char)reg,
-        (unsigned char)bytes, (unsigned char *)&value);
+    return gfx_i2c_write(1, PLAL_FS450_i2c_address(), (unsigned char) reg,
+                         (unsigned char) bytes, (unsigned char *) &value);
 }
 
 /* TV configuration functions.			*/
@@ -324,7 +321,8 @@ static unsigned long supported_standards(void);
 static void config_tvout_mode(unsigned long tvout_mode);
 static void conget_tvout_mode(unsigned long *p_tvout_mode);
 static void config_overscan_xy(unsigned long tv_std, unsigned long vga_mode,
-    int overscan_x, int overscan_y, int pos_x, int pos_y);
+                               int overscan_x, int overscan_y, int pos_x,
+                               int pos_y);
 static void config_nco(unsigned long tv_std, unsigned long vga_mode);
 static void config_sharpness(int sharpness);
 static void conget_sharpness(int *p_sharpness);
@@ -333,20 +331,21 @@ static void conget_flicker(int *p_flicker);
 static void config_color(int color);
 static void conget_color(int *p_color);
 static void config_brightness_contrast(unsigned long tv_std,
-    unsigned int trigger_bits, int brightness, int contrast);
+                                       unsigned int trigger_bits,
+                                       int brightness, int contrast);
 static void conget_brightness_contrast(unsigned long tv_std,
-    unsigned int trigger_bits, int *p_brightness, int *p_contrast);
+                                       unsigned int trigger_bits,
+                                       int *p_brightness, int *p_contrast);
 static void config_yc_filter(unsigned long tv_std, int luma_filter,
-    int chroma_filter);
+                             int chroma_filter);
 static void conget_yc_filter(int *p_luma_filter, int *p_chroma_filter);
 static void config_macrovision(unsigned long tv_std,
-    unsigned int cp_trigger_bits);
+                               unsigned int cp_trigger_bits);
 static void conget_macrovision(unsigned long tv_std,
-    unsigned int *p_cp_trigger_bits);
+                               unsigned int *p_cp_trigger_bits);
 
 /* Device settings.			*/
-typedef struct _S_DEVICE_SETTINGS
-{
+typedef struct _S_DEVICE_SETTINGS {
     int tv_on;
     unsigned long vga_mode;
     unsigned long tv_std;
@@ -372,8 +371,7 @@ static S_DEVICE_SETTINGS d;
  *==========================================================================
  * */
 
-static const struct
-{
+static const struct {
     unsigned long chroma_freq[5];
     unsigned short chroma_phase[5];
     unsigned short cphase_rst[5];
@@ -496,8 +494,7 @@ static const struct
 
 /* MediaGX default underscan and centered position setups. */
 #define	SCANTABLE_ENTRIES	5
-struct _scantable
-{
+struct _scantable {
     unsigned long mode;
     unsigned short v_total[5];
     unsigned short v_sync[5];
@@ -508,56 +505,54 @@ struct _scantable
 
 static struct _scantable scantable[SCANTABLE_ENTRIES] = {
     {
-            GFX_VGA_MODE_640X480,
-            {617, 624, 617, 624, 624}, /* v_total      */
-            {69, 88, 69, 88, 88},      /* v_sync       */
-            {720, 720, 720, 720, 720}, /* iha          */
-            {0, 0, 0, 0, 0},           /* iho          */
-            {-12, 0, -6, 0, 0}         /* hsc          */
-        },
+     GFX_VGA_MODE_640X480,
+     {617, 624, 617, 624, 624}, /* v_total      */
+     {69, 88, 69, 88, 88},      /* v_sync       */
+     {720, 720, 720, 720, 720}, /* iha          */
+     {0, 0, 0, 0, 0},           /* iho          */
+     {-12, 0, -6, 0, 0}         /* hsc          */
+     },
     {
-            GFX_VGA_MODE_800X600,
-            {740, 740, 740, 740, 740}, /* v_total      */
-            {90, 88, 90, 88, 88},      /* v_sync       */
-            {720, 720, 508, 720, 720}, /* iha          */
-            {-8, 11, -8, -8, 11},      /* iho          */
-            {-27, -27, -27, -27, -27}  /* hsc          */
-        },
+     GFX_VGA_MODE_800X600,
+     {740, 740, 740, 740, 740}, /* v_total      */
+     {90, 88, 90, 88, 88},      /* v_sync       */
+     {720, 720, 508, 720, 720}, /* iha          */
+     {-8, 11, -8, -8, 11},      /* iho          */
+     {-27, -27, -27, -27, -27}  /* hsc          */
+     },
     {
-            GFX_VGA_MODE_720X487,
-            {525, 720, 525, 720, 720}, /* v_total      */
-            {23, 230, 23, 230, 230},   /* v_sync       */
-            {720, 720, 720, 720, 720}, /* iha          */
-            {0xa2, 0xa2, 0xa2, 0xa2, 0xa2},     /* iho          */
-            {0, 0, 0, 0, 0}            /* hsc          */
-        },
+     GFX_VGA_MODE_720X487,
+     {525, 720, 525, 720, 720}, /* v_total      */
+     {23, 230, 23, 230, 230},   /* v_sync       */
+     {720, 720, 720, 720, 720}, /* iha          */
+     {0xa2, 0xa2, 0xa2, 0xa2, 0xa2},    /* iho          */
+     {0, 0, 0, 0, 0}            /* hsc          */
+     },
     {
-            GFX_VGA_MODE_720X576,
-            {720, 625, 720, 625, 625}, /* v_total      */
-            {129, 25, 129, 25, 25},    /* v_sync       */
-            {720, 720, 720, 720, 720}, /* iha          */
-            {0xaa, 0xaa, 0xaa, 0xaa, 0xaa},     /* iho              */
-            {0, 0, 0, 0, 0}            /* hsc          */
-        },
+     GFX_VGA_MODE_720X576,
+     {720, 625, 720, 625, 625}, /* v_total      */
+     {129, 25, 129, 25, 25},    /* v_sync       */
+     {720, 720, 720, 720, 720}, /* iha          */
+     {0xaa, 0xaa, 0xaa, 0xaa, 0xaa},    /* iho              */
+     {0, 0, 0, 0, 0}            /* hsc          */
+     },
     {
-            GFX_VGA_MODE_1024X768,
-            {933, 942, 933, 806, 806}, /* v_total      */
-            {121, 112, 121, 88, 88},   /* v_sync       */
-            {600, 600, 600, 600, 600}, /* iha          */
-            {0x3c, 0x23, 0x3c, 0x65, 0x65},     /* iho              */
-            {35, 26, 35, 26, 26}       /* hsc          */
-        },
+     GFX_VGA_MODE_1024X768,
+     {933, 942, 933, 806, 806}, /* v_total      */
+     {121, 112, 121, 88, 88},   /* v_sync       */
+     {600, 600, 600, 600, 600}, /* iha          */
+     {0x3c, 0x23, 0x3c, 0x65, 0x65},    /* iho              */
+     {35, 26, 35, 26, 26}       /* hsc          */
+     },
 };
 
 /* Houston fifo configuration constants. */
-struct _ffolat
-{
+struct _ffolat {
     int v_total;
     unsigned short ffolat;
 };
 
-struct _ffolativo
-{
+struct _ffolativo {
     int v_total;
     unsigned short ivo;
     unsigned short ffolat;
@@ -668,7 +663,7 @@ static struct _ffolat ffo7x5pal[SIZE7X5PAL + 1] = {
 /* h_total=1056, vga_lines=600 */
 #define	SIZE8X6NTSC		37
 static struct _ffolat ffo8x6ntsc[SIZE8X6NTSC + 1] = {
-    {620, 0x40},                       /* v_total_min >= vsync+10 >= vga_lines+10 = 610 */
+    {620, 0x40},                /* v_total_min >= vsync+10 >= vga_lines+10 = 610 */
     {625, 0x58}, {630, 0x40}, {635, 0x40}, {640, 0x40},
     {645, 0x46}, {650, 0x46}, {655, 0x4f}, {660, 0x4c},
     {665, 0x4a}, {670, 0x50}, {675, 0x2f}, {680, 0x48},
@@ -862,7 +857,7 @@ FS450_init(void)
     d.brightness = 50;
     d.contrast = 60;
     config_brightness_contrast(d.tv_std, d.aps_trigger_bits, d.brightness,
-        d.contrast);
+                               d.contrast);
 
     /* get the current yc filtering */
     {
@@ -949,8 +944,9 @@ write_config(int req)
 
     if (REQ_OVERSCAN_POSITION_BIT & req) {
         config_overscan_xy(d.tv_std,
-            d.vga_mode,
-            d.overscan_x, d.overscan_y, d.position_x, d.position_y);
+                           d.vga_mode,
+                           d.overscan_x, d.overscan_y, d.position_x,
+                           d.position_y);
 
         /*h_timing and v_timing and syncs. */
         if (PLAL_IsTVOn())
@@ -971,13 +967,14 @@ write_config(int req)
 
     if (REQ_BRIGHTNESS_CONTRAST_BIT & req) {
         config_brightness_contrast(d.tv_std,
-            d.aps_trigger_bits, d.brightness, d.contrast);
+                                   d.aps_trigger_bits, d.brightness,
+                                   d.contrast);
     }
 
     if (REQ_YC_FILTER_BIT & req) {
         config_yc_filter(d.tv_std,
-            (d.yc_filter & GFX_LUMA_FILTER),
-            (d.yc_filter & GFX_CHROMA_FILTER));
+                         (d.yc_filter & GFX_LUMA_FILTER),
+                         (d.yc_filter & GFX_CHROMA_FILTER));
     }
 
     if (REQ_MACROVISION_BIT & req)
@@ -1054,9 +1051,9 @@ gfx_set_tv_enable(int on)
 
     /*configure encoder and nco. */
     write_config(REQ_VGA_MODE |
-        REQ_TV_STANDARD |
-        REQ_TVOUT_MODE |
-        REQ_OVERSCAN_POSITION | REQ_YC_FILTER | REQ_MACROVISION);
+                 REQ_TV_STANDARD |
+                 REQ_TVOUT_MODE |
+                 REQ_OVERSCAN_POSITION | REQ_YC_FILTER | REQ_MACROVISION);
 
     /*set LP_EN and UIM */
     houston_ReadReg(HOUSTON_CR, &reg, 2);
@@ -1664,19 +1661,19 @@ FS450_ReadRegister(S_REG_INFO * p_reg)
         switch (p_reg->size) {
         case 1:
         case 2:
-            {
-                houston_ReadReg((int)p_reg->offset, &tmp, (int)p_reg->size);
-                p_reg->value = tmp;
-            }
+        {
+            houston_ReadReg((int) p_reg->offset, &tmp, (int) p_reg->size);
+            p_reg->value = tmp;
+        }
             return 0;
 
         case 4:
-            {
-                houston_ReadReg((unsigned int)p_reg->offset, &tmp, 2);
-                p_reg->value = (tmp << 16);
-                houston_ReadReg((unsigned int)(p_reg->offset + 2), &tmp, 2);
-                p_reg->value |= tmp;
-            }
+        {
+            houston_ReadReg((unsigned int) p_reg->offset, &tmp, 2);
+            p_reg->value = (tmp << 16);
+            houston_ReadReg((unsigned int) (p_reg->offset + 2), &tmp, 2);
+            p_reg->value |= tmp;
+        }
             return 0;
         }
     }
@@ -1691,8 +1688,8 @@ FS450_WriteRegister(S_REG_INFO * p_reg)
         return 0;
 
     if (SOURCE_HOUSTON == p_reg->source) {
-        houston_WriteReg((unsigned int)p_reg->offset, p_reg->value,
-            p_reg->size);
+        houston_WriteReg((unsigned int) p_reg->offset, p_reg->value,
+                         p_reg->size);
 
         return 0;
     }
@@ -1736,7 +1733,7 @@ houston_init(void)
 
     /*read chip revision. */
     houston_ReadReg(HOUSTON_REV, &read, 2);
-    g_houston_rev = (int)read;
+    g_houston_rev = (int) read;
 
     /*ok. */
     return 0;
@@ -1793,8 +1790,7 @@ z2w10bit(unsigned short z)
 /* TV Standards																*/
 /*==========================================================================*/
 
-static const struct
-{
+static const struct {
     unsigned long standard;
     int tvsetup_index;
 } g_tv_standards[] = {
@@ -1853,7 +1849,8 @@ config_power(int on)
             houston_WriteReg(HOUSTON_CR, reg, 2);
             reg &= ~CR_RESET;
             houston_WriteReg(HOUSTON_CR, reg, 2);
-        } else {
+        }
+        else {
             houston_ReadReg(HOUSTON_CR, &reg, 2);
             reg |= CR_CLKOFF;
             houston_WriteReg(HOUSTON_CR, reg, 2);
@@ -1877,7 +1874,8 @@ config_power(int on)
         houston_ReadReg(HOUSTON_MISC, &reg, 2);
         reg &= ~MISC_GTLIO_PD;
         houston_WriteReg(HOUSTON_MISC, reg, 2);
-    } else {
+    }
+    else {
         /* CLKOFF, COMPOFF, YCOFF */
         houston_ReadReg(HOUSTON_CR, &reg, 2);
         reg |= (CR_CLKOFF | CR_COMPOFF | CR_YCOFF);
@@ -1899,8 +1897,7 @@ config_vga_mode(unsigned long vga_mode)
 {
     /*h_total must be evenly divisible by 32? */
 
-    static struct
-    {
+    static struct {
         unsigned long mode;
         int width;
         int lines;
@@ -1940,7 +1937,8 @@ config_vga_mode(unsigned long vga_mode)
          /*XGA*/ cr |= CR_UIM_DEC;
         misc |= MISC_VGACKDIV;
         byp |= (BYP_HDS_BYPASS | BYP_CAC_BYPASS);
-    } else {
+    }
+    else {
         /*VGA,SVGA */
         cr &= ~CR_UIM_DEC;
         misc &= ~MISC_VGACKDIV;
@@ -1981,10 +1979,10 @@ config_tv_std(unsigned long tv_std, unsigned int trigger_bits)
 
     /*setup the encoder. */
     l = tvsetup.chroma_freq[k];
-    houston_WriteReg(ENC_CHROMA_FREQ, (int)(l & 0x00ff), 1);
-    houston_WriteReg(ENC_CHROMA_FREQ + 1, (int)((l >> 8) & 0x00ff), 1);
-    houston_WriteReg(ENC_CHROMA_FREQ + 2, (int)((l >> 16) & 0x00ff), 1);
-    houston_WriteReg(ENC_CHROMA_FREQ + 3, (int)((l >> 24) & 0x00ff), 1);
+    houston_WriteReg(ENC_CHROMA_FREQ, (int) (l & 0x00ff), 1);
+    houston_WriteReg(ENC_CHROMA_FREQ + 1, (int) ((l >> 8) & 0x00ff), 1);
+    houston_WriteReg(ENC_CHROMA_FREQ + 2, (int) ((l >> 16) & 0x00ff), 1);
+    houston_WriteReg(ENC_CHROMA_FREQ + 3, (int) ((l >> 24) & 0x00ff), 1);
 
     houston_WriteReg(ENC_CHROMA_PHASE, tvsetup.chroma_phase[k], 1);
     houston_WriteReg(ENC_REG05, 0x00, 1);       /*reg 0x05 */
@@ -1999,11 +1997,11 @@ config_tv_std(unsigned long tv_std, unsigned int trigger_bits)
     if (trigger_bits == 0)
         w = w10bit2z(tvsetup.blank_level[k]);   /*blank level */
     else
-        w = w10bit2z((unsigned short)(tvsetup.blank_level[k] -
-                tvsetup.hamp_offset[k]));
+        w = w10bit2z((unsigned short) (tvsetup.blank_level[k] -
+                                       tvsetup.hamp_offset[k]));
     houston_WriteReg(ENC_BLANK_LEVEL, w & 0x00ff, 1);
     houston_WriteReg(ENC_BLANK_LEVEL + 1, w >> 8, 1);
-    w = w10bit2z(tvsetup.tv_lines[k]); /*num_lines */
+    w = w10bit2z(tvsetup.tv_lines[k]);  /*num_lines */
     houston_WriteReg(ENC_NUM_LINES, w & 0x00ff, 1);
     houston_WriteReg(ENC_NUM_LINES + 1, w >> 8, 1);
 
@@ -2022,7 +2020,7 @@ config_tv_std(unsigned long tv_std, unsigned int trigger_bits)
     if (trigger_bits == 0)
         w = w10bit2z(tvsetup.vbi_blank_level[k]);       /*blank level */
     else
-        w = w10bit2z((unsigned short)(tvsetup.vbi_blank_level[k] - 1));
+        w = w10bit2z((unsigned short) (tvsetup.vbi_blank_level[k] - 1));
     houston_WriteReg(ENC_VBI_BLANK_LEVEL, w & 0x00ff, 1);
     houston_WriteReg(ENC_VBI_BLANK_LEVEL + 1, w >> 8, 1);
 }
@@ -2115,7 +2113,8 @@ conget_tvout_mode(unsigned long *p_tvout_mode)
 
 static void
 get_ffolat_ivo(unsigned long vga_mode,
-    unsigned long tv_std, long i, unsigned short *ffolat, unsigned short *ivo)
+               unsigned long tv_std, long i, unsigned short *ffolat,
+               unsigned short *ivo)
 {
     switch (vga_mode) {
     case GFX_VGA_MODE_640X480:
@@ -2124,7 +2123,8 @@ get_ffolat_ivo(unsigned long vga_mode,
                 i = SIZE6X4NTSC - 1;
             *ffolat = ffo6x4ntsc[i].ffolat;
             *ivo = 0x20;
-        } else {
+        }
+        else {
             if (i > SIZE6X4PAL - 1)
                 i = SIZE6X4PAL - 1;
             *ffolat = ffo6x4pal[i].ffolat;
@@ -2138,7 +2138,8 @@ get_ffolat_ivo(unsigned long vga_mode,
                 i = SIZE8X6NTSC - 1;
             *ffolat = ffo8x6ntsc[i].ffolat;
             *ivo = 0x3a;
-        } else {
+        }
+        else {
             if (i > SIZE8X6PAL - 1)
                 i = SIZE8X6PAL - 1;
             *ffolat = ffo8x6pal[i].ffolat;
@@ -2147,12 +2148,12 @@ get_ffolat_ivo(unsigned long vga_mode,
         break;
 
     case GFX_VGA_MODE_720X487:
-        *ffolat = 0x40;                /*FFO7x4; */
+        *ffolat = 0x40;         /*FFO7x4; */
         *ivo = 0x1a;
         break;
 
     case GFX_VGA_MODE_720X576:
-        *ffolat = 0x40;                /*FFO7x5; */
+        *ffolat = 0x40;         /*FFO7x5; */
         *ivo = 0x1a;
         break;
 
@@ -2163,7 +2164,8 @@ get_ffolat_ivo(unsigned long vga_mode,
                 i = SIZE10X7NTSC - 1;
             *ffolat = ffo10x7ntsc[i].ffolat;
             *ivo = ffo10x7ntsc[i].ivo;
-        } else {
+        }
+        else {
             if (i > SIZE10X7PAL - 1)
                 i = SIZE10X7PAL - 1;
             *ffolat = ffo10x7pal[i].ffolat;
@@ -2177,7 +2179,8 @@ get_ffolat_ivo(unsigned long vga_mode,
 
 static void
 get_vtotal_min_max(unsigned long vga_mode,
-    unsigned long tv_std, int *v_total_min, int *v_total_max, int *v_step)
+                   unsigned long tv_std, int *v_total_min, int *v_total_max,
+                   int *v_step)
 {
     int k = map_tvstd_to_index(tv_std);
 
@@ -2186,7 +2189,8 @@ get_vtotal_min_max(unsigned long vga_mode,
         if (IS_NTSC(tv_std)) {
             *v_total_min = ffo6x4ntsc[0].v_total;
             *v_total_max = ffo6x4ntsc[SIZE6X4NTSC - 1].v_total;
-        } else {
+        }
+        else {
             *v_total_min = ffo6x4pal[0].v_total;
             *v_total_max = ffo6x4pal[SIZE6X4PAL - 1].v_total;
         }
@@ -2197,7 +2201,8 @@ get_vtotal_min_max(unsigned long vga_mode,
         if (IS_NTSC(tv_std)) {
             *v_total_min = ffo8x6ntsc[0].v_total;
             *v_total_max = ffo8x6ntsc[SIZE8X6NTSC - 1].v_total;
-        } else {
+        }
+        else {
             *v_total_min = ffo8x6pal[0].v_total;
             *v_total_max = ffo8x6pal[SIZE8X6PAL - 1].v_total;
         }
@@ -2215,7 +2220,8 @@ get_vtotal_min_max(unsigned long vga_mode,
         if (IS_NTSC(tv_std)) {
             *v_total_min = ffo10x7ntsc[0].v_total;
             *v_total_max = ffo10x7ntsc[SIZE10X7NTSC - 1].v_total;
-        } else {
+        }
+        else {
             *v_total_min = ffo10x7pal[0].v_total;
             *v_total_max = ffo10x7pal[SIZE10X7PAL - 1].v_total;
         }
@@ -2226,8 +2232,8 @@ get_vtotal_min_max(unsigned long vga_mode,
 
 static void
 config_overscan_xy(unsigned long tv_std,
-    unsigned long vga_mode,
-    int overscan_x, int overscan_y, int pos_x, int pos_y)
+                   unsigned long vga_mode,
+                   int overscan_x, int overscan_y, int pos_x, int pos_y)
 {
     unsigned int vga_index;
     unsigned long reg;
@@ -2266,7 +2272,7 @@ config_overscan_xy(unsigned long tv_std,
     TRACE(("v_total range = %d\n", range))
 
         /*map +/-1000 overscan y into +/-range. */
-        v_offset = (int)((((float)overscan_y * range) / 1000.f) + .5f);
+        v_offset = (int) ((((float) overscan_y * range) / 1000.f) + .5f);
     TRACE(("v_offset = %d\n", v_offset))
 
         /*range limit v_total. */
@@ -2283,26 +2289,27 @@ config_overscan_xy(unsigned long tv_std,
     houston_WriteReg(HOUSTON_IVO, ivo, 2);
 
     /*scale base sync offset by scaling ratio. */
-    r = (float)g_specs.v_total / (float)base_v_total;
-    v_offset = (int)(r * (float)scantable[vga_index].v_sync[k]);
+    r = (float) g_specs.v_total / (float) base_v_total;
+    v_offset = (int) (r * (float) scantable[vga_index].v_sync[k]);
 
     /*scale ivo. */
-    f = (float)ivo;
-    v_offset -= (int)(f - f / r);
+    f = (float) ivo;
+    v_offset -= (int) (f - f / r);
 
     /*compensate for center screen. */
-    f = (float)tvsetup.tv_active_lines[k] / 2.f;
-    v_offset += (int)(f * r - f);
+    f = (float) tvsetup.tv_active_lines[k] / 2.f;
+    v_offset += (int) (f * r - f);
 
     /*calculate vsync. */
     g_specs.v_sync = g_specs.v_total - v_offset + pos_y;
     TRACE(("desired v_total=%d, desired v_sync=%d\n", g_specs.v_total,
-            g_specs.v_sync))
+           g_specs.v_sync))
         if (g_specs.v_sync < g_specs.vga_lines + 10) {
         TRACE(("vsync too low\n"))
             /*d.v_total += d.vga_lines+10-d.v_sync; */
             g_specs.v_sync = g_specs.vga_lines + 10;
-    } else if (g_specs.v_sync > g_specs.v_total - 10) {
+    }
+    else if (g_specs.v_sync > g_specs.v_total - 10) {
         TRACE(("vsync too high\n"))
             g_specs.v_sync = g_specs.v_total - 10;
     }
@@ -2314,11 +2321,12 @@ config_overscan_xy(unsigned long tv_std,
     /* VSC. */
     vsc =
         (65536.0f * (1.0f -
-            (double)g_specs.tv_lines / (double)g_specs.v_total)) + 0.5f;
-    reg = ((unsigned long)-vsc) & 0xffff;
+                     (double) g_specs.tv_lines / (double) g_specs.v_total)) +
+        0.5f;
+    reg = ((unsigned long) -vsc) & 0xffff;
     TRACE(("vsc=%04x, tv_lines=%d, v_total=%d\n", reg, g_specs.tv_lines,
-            g_specs.v_total))
-        houston_WriteReg(HOUSTON_VSC, (int)reg, 2);
+           g_specs.v_total))
+        houston_WriteReg(HOUSTON_VSC, (int) reg, 2);
 
     /* horizontal scaling. */
 
@@ -2333,22 +2341,22 @@ config_overscan_xy(unsigned long tv_std,
     hscale_max = (720.0f / vga_pixels);
     hscale_min = fsmax((0.75f * hscale_max), (1.0f - (63.0f / 128.0f)));
     TRACE(("hscale_min = %u.%u, hscale_max = %u.%u\n",
-            (int)hscale_min,
-            (int)((hscale_min - (int)hscale_min) * 1000),
-            (int)hscale_max, (int)((hscale_max - (int)hscale_max) * 1000)))
+           (int) hscale_min,
+           (int) ((hscale_min - (int) hscale_min) * 1000),
+           (int) hscale_max, (int) ((hscale_max - (int) hscale_max) * 1000)))
 
         /* map overscan_x into min to max. */
         hscale =
         hscale_min + ((overscan_x + 1000.0f) / 2000.0f) * (hscale_max -
-        hscale_min);
-    TRACE(("hscale = %u.%u\n", (int)hscale,
-            (int)((hscale - (int)hscale) * 1000)))
+                                                           hscale_min);
+    TRACE(("hscale = %u.%u\n", (int) hscale,
+           (int) ((hscale - (int) hscale) * 1000)))
 
         /* determine hsc where hscale = (1 + hsc/128) */
         if (hscale >= 1.0f)
-        hsc = (int)(128.f * (hscale - 1.0f) + .5f);
+        hsc = (int) (128.f * (hscale - 1.0f) + .5f);
     else
-        hsc = (int)(128.f * (hscale - 1.0f) - .5f);
+        hsc = (int) (128.f * (hscale - 1.0f) - .5f);
 
     TRACE(("hsc = %d\n", hsc))
         if (hsc >= 0)
@@ -2358,15 +2366,15 @@ config_overscan_xy(unsigned long tv_std,
 
     /* recalculate hscale for future formulas */
     hscale = 1.0f + (hsc / 128.0f);
-    TRACE(("recalculated hscale = %u.%u\n", (int)hscale,
-            (int)((hscale - (int)hscale) * 1000)))
+    TRACE(("recalculated hscale = %u.%u\n", (int) hscale,
+           (int) ((hscale - (int) hscale) * 1000)))
 
         /* horizontal offset. */
         /* place hsync 40 before halfway from vga_width to htotal */
         /* but not less than vga_width + 10 */
         g_specs.h_sync =
         fsmax((g_specs.h_total + g_specs.vga_width) / 2 - 40,
-        g_specs.vga_width + 10);
+              g_specs.vga_width + 10);
     /* also, make it even */
     g_specs.h_sync &= ~1;
     TRACE(("hsync = %u\n", g_specs.h_sync))
@@ -2380,13 +2388,13 @@ config_overscan_xy(unsigned long tv_std,
         /* to skip, or subtract.  iho=0 maps to farthest right. */
         /* map -pos_x = +/-1000 into (0 to iho_max) */
         pre_pixels =
-        (int)((long)(g_specs.h_total -
-            g_specs.h_sync) * vga_pixels / g_specs.vga_width);
-    iho_max = (2 * pre_pixels) - ((int)(720.0f / hscale + 0.5f) - vga_pixels);
+        (int) ((long) (g_specs.h_total -
+                       g_specs.h_sync) * vga_pixels / g_specs.vga_width);
+    iho_max = (2 * pre_pixels) - ((int) (720.0f / hscale + 0.5f) - vga_pixels);
     TRACE(("iho_max = %u\n", iho_max))
         iho =
-        (int)range_limit(((long)(1000 - pos_x) * iho_max / 2000) +
-        scantable[vga_index].iho[k], 0, iho_max);
+        (int) range_limit(((long) (1000 - pos_x) * iho_max / 2000) +
+                          scantable[vga_index].iho[k], 0, iho_max);
     TRACE(("iho = %u\n", iho))
         houston_WriteReg(HOUSTON_IHO, iho, 2);
 
@@ -2396,17 +2404,17 @@ config_overscan_xy(unsigned long tv_std,
     /* additionally, ihw cannot exceed tv width / hscale */
     /* and if hsc is negative, (ihw)(-hsc/128) cannot exceed ~250. */
     /* and ihw should be even. */
-    ihw = fsmin(vga_pixels + pre_pixels - iho, (int)(720.0f / hscale));
+    ihw = fsmin(vga_pixels + pre_pixels - iho, (int) (720.0f / hscale));
     if (hsc < 0)
-        ihw = (int)fsmin(ihw, 253L * 128 / (-hsc));
+        ihw = (int) fsmin(ihw, 253L * 128 / (-hsc));
     ihw &= ~1;
     TRACE(("ihw = %u\n", ihw))
         houston_WriteReg(HOUSTON_IHA, ihw, 2);
 
-    f = (((float)g_specs.h_total * g_specs.v_total) * 27.f) /
-        ((float)g_specs.tv_width * g_specs.tv_lines);
+    f = (((float) g_specs.h_total * g_specs.v_total) * 27.f) /
+        ((float) g_specs.tv_width * g_specs.tv_lines);
 
-    TRACE(("freq=%u.%uMHz\n", (int)f, (int)((f - (int)f) * 1000)))
+    TRACE(("freq=%u.%uMHz\n", (int) f, (int) ((f - (int) f) * 1000)))
 }
 
 /*==========================================================================*/
@@ -2452,20 +2460,21 @@ config_nco(unsigned long tv_std, unsigned long vga_mode)
         houston_WriteReg(HOUSTON_MISC, misc, 2);
 
         /*NCON. */
-        reg = ((unsigned long)g_specs.v_total * g_specs.h_total) / 2;
+        reg = ((unsigned long) g_specs.v_total * g_specs.h_total) / 2;
         houston_WriteReg(HOUSTON_NCONH, reg >> 16, 2);
         houston_WriteReg(HOUSTON_NCONL, reg & 0xffff, 2);
 
         /*NCOD. */
         houston_WriteReg(HOUSTON_NCODL, tvsetup.houston_ncodl[k], 2);
         houston_WriteReg(HOUSTON_NCODH, tvsetup.houston_ncodh[k], 2);
-    } else {
+    }
+    else {
         /*setup for M and N load (Nco_load=2). */
         misc |= (MISC_NCO_LOAD1);
         houston_WriteReg(HOUSTON_MISC, misc, 2);
 
         /*NCON. */
-        reg = (unsigned long)g_specs.v_total * g_specs.h_total;
+        reg = (unsigned long) g_specs.v_total * g_specs.h_total;
         houston_WriteReg(HOUSTON_NCONH, reg >> 16, 2);
         houston_WriteReg(HOUSTON_NCONL, reg & 0xffff, 2);
 
@@ -2474,12 +2483,12 @@ config_nco(unsigned long tv_std, unsigned long vga_mode)
         houston_WriteReg(HOUSTON_NCODH, tvsetup.houston_ncodh[k], 2);
 
         TRACE(("NCON = %lu (0x%08lx), NCOD = %lu (0x%08lx)\n",
-                reg,
-                reg,
-                ((unsigned long)tvsetup.houston_ncodh[k] << 16) +
-                tvsetup.houston_ncodl[k],
-                ((unsigned long)tvsetup.houston_ncodh[k] << 16) +
-                tvsetup.houston_ncodl[k]))
+               reg,
+               reg,
+               ((unsigned long) tvsetup.houston_ncodh[k] << 16) +
+               tvsetup.houston_ncodl[k],
+               ((unsigned long) tvsetup.houston_ncodh[k] << 16) +
+               tvsetup.houston_ncodl[k]))
     }
 
     /*latch M/N and NCON/NCOD in. */
@@ -2499,7 +2508,7 @@ config_sharpness(int sharpness)
     unsigned int shp;
 
     /*map 0-1000 to 0-20. */
-    shp = (unsigned int)(0.5f + ((float)sharpness * 20.0f / 1000.0f));
+    shp = (unsigned int) (0.5f + ((float) sharpness * 20.0f / 1000.0f));
     shp = range_limit(shp, 0, 20);
 
     houston_WriteReg(HOUSTON_SHP, shp, 2);
@@ -2516,7 +2525,7 @@ conget_sharpness(int *p_sharpness)
     houston_ReadReg(HOUSTON_SHP, &shp, 2);
 
     /*map 0-20 to 0-1000. */
-    *p_sharpness = (int)(0.5f + ((float)shp * 1000.0f / 20.0f));
+    *p_sharpness = (int) (0.5f + ((float) shp * 1000.0f / 20.0f));
 }
 
 /*==========================================================================*/
@@ -2529,7 +2538,7 @@ config_flicker(int flicker)
     unsigned int flk;
 
     /*map 0-1000 to 0-16. */
-    flk = (unsigned int)(0.5f + ((float)flicker * 16.0f / 1000.0f));
+    flk = (unsigned int) (0.5f + ((float) flicker * 16.0f / 1000.0f));
     flk = range_limit(flk, 0, 16);
 
     houston_WriteReg(HOUSTON_FLK, flk, 2);
@@ -2546,7 +2555,7 @@ conget_flicker(int *p_flicker)
     houston_ReadReg(HOUSTON_FLK, &flk, 2);
 
     /*map 0-16 to 0-1000. */
-    *p_flicker = (int)(0.5f + ((float)flk * 1000.0f / 16.0f));
+    *p_flicker = (int) (0.5f + ((float) flk * 1000.0f / 16.0f));
 }
 
 /*==========================================================================*/
@@ -2561,7 +2570,7 @@ config_color(int color)
     /*map 0-100 to 0-255. */
     /*montreal production test needs 169 to be mappable, so */
     /*use .8 rounding factor, 169=(int)(66.*2.55+.8). */
-    clr = (unsigned long)(0.8f + ((float)color * 255.0f / 100.0f));
+    clr = (unsigned long) (0.8f + ((float) color * 255.0f / 100.0f));
     clr = range_limit(clr, 0, 255);
 
     houston_WriteReg(ENC_CR_GAIN, clr, 1);
@@ -2580,7 +2589,7 @@ conget_color(int *p_color)
     houston_ReadReg(ENC_CR_GAIN, &cr_gain, 1);
 
     /*map 0-255 to 0-100. */
-    *p_color = (int)(0.5f + ((float)cr_gain * 100.0f / 255.0f));
+    *p_color = (int) (0.5f + ((float) cr_gain * 100.0f / 255.0f));
 }
 
 /*==========================================================================*/
@@ -2594,7 +2603,7 @@ static const int max_white_level = 1023;
 
 static void
 config_brightness_contrast(unsigned long tv_std, unsigned int trigger_bits,
-    int brightness, int contrast)
+                           int brightness, int contrast)
 {
     int brightness_off;
     float contrast_mult;
@@ -2604,10 +2613,10 @@ config_brightness_contrast(unsigned long tv_std, unsigned int trigger_bits,
 
     /*0-100 maps to +/-220. */
     brightness_off =
-        (int)(0.5f + ((float)brightness * 440.0f / 100.0f)) - 220;
+        (int) (0.5f + ((float) brightness * 440.0f / 100.0f)) - 220;
 
     /*0-100 maps to .75-1.25. */
-    contrast_mult = ((float)contrast * 0.5f / 100.0f) + 0.75f;
+    contrast_mult = ((float) contrast * 0.5f / 100.0f) + 0.75f;
 
     black = tvsetup.black_level[k];
     if (trigger_bits != 0)
@@ -2617,24 +2626,24 @@ config_brightness_contrast(unsigned long tv_std, unsigned int trigger_bits,
     if (trigger_bits != 0)
         white -= tvsetup.hamp_offset[k];
 
-    black = (int)((float)(black + brightness_off) * contrast_mult);
-    white = (int)((float)(white + brightness_off) * contrast_mult);
+    black = (int) ((float) (black + brightness_off) * contrast_mult);
+    white = (int) ((float) (white + brightness_off) * contrast_mult);
     if (black < min_black_level)
         black = min_black_level;
     if (white > max_white_level)
         white = max_white_level;
 
-    w = w10bit2z((unsigned short)black);
+    w = w10bit2z((unsigned short) black);
     houston_WriteReg(ENC_BLACK_LEVEL, w & 0x00ff, 1);
     houston_WriteReg(ENC_BLACK_LEVEL + 1, w >> 8, 1);
-    w = w10bit2z((unsigned short)white);
+    w = w10bit2z((unsigned short) white);
     houston_WriteReg(ENC_WHITE_LEVEL, w & 0x00ff, 1);
     houston_WriteReg(ENC_WHITE_LEVEL + 1, w >> 8, 1);
 }
 
 static void
 conget_brightness_contrast(unsigned long tv_std, unsigned int trigger_bits,
-    int *p_brightness, int *p_contrast)
+                           int *p_brightness, int *p_contrast)
 {
     int brightness_off;
     float contrast_mult;
@@ -2649,32 +2658,32 @@ conget_brightness_contrast(unsigned long tv_std, unsigned int trigger_bits,
 
     houston_ReadReg(ENC_BLACK_LEVEL, &zl, 1);
     houston_ReadReg(ENC_BLACK_LEVEL + 1, &zh, 1);
-    black = z2w10bit((unsigned short)(zl + (zh << 8)));
+    black = z2w10bit((unsigned short) (zl + (zh << 8)));
     if (trigger_bits != 0)
         black += tvsetup.hamp_offset[k];
     houston_ReadReg(ENC_WHITE_LEVEL, &zl, 1);
     houston_ReadReg(ENC_WHITE_LEVEL + 1, &zh, 1);
-    white = z2w10bit((unsigned short)(zl + (zh << 8)));
+    white = z2w10bit((unsigned short) (zl + (zh << 8)));
     if (trigger_bits != 0)
         white += tvsetup.hamp_offset[k];
 
     /*this reverse computation does not account for clipping, but should */
     /*provide somewhat reasonable numbers */
     contrast_mult =
-        ((float)white - (float)black) / ((float)tvsetup.white_level[k] -
-        (float)tvsetup.black_level[k]);
+        ((float) white - (float) black) / ((float) tvsetup.white_level[k] -
+                                           (float) tvsetup.black_level[k]);
     brightness_off =
-        (int)(((float)black / contrast_mult) - tvsetup.black_level[k]);
+        (int) (((float) black / contrast_mult) - tvsetup.black_level[k]);
 
     /*+/-220 maps to 0-100. */
     *p_brightness =
-        range_limit((int)(0.5f + ((float)(brightness_off +
-                    220) * 100.0f / 440.0f)), 0, 100);
+        range_limit((int) (0.5f + ((float) (brightness_off +
+                                            220) * 100.0f / 440.0f)), 0, 100);
 
     /*.75-1.25 maps to 0-100. */
     *p_contrast =
-        range_limit((int)(0.5f + ((float)(contrast_mult -
-                    0.75f) * 100.0f / 0.5f)), 0, 100);
+        range_limit((int) (0.5f + ((float) (contrast_mult -
+                                            0.75f) * 100.0f / 0.5f)), 0, 100);
 }
 
 /*==========================================================================*/
@@ -2702,7 +2711,8 @@ config_yc_filter(unsigned long tv_std, int luma_filter, int chroma_filter)
     if (chroma_filter) {
         reg07 &= ~0x08;
         reg34 &= ~0x20;
-    } else {
+    }
+    else {
         reg07 |= 0x08;
         reg34 |= 0x20;
     }
@@ -2742,17 +2752,16 @@ static void
 config_macrovision(unsigned long tv_std, unsigned int trigger_bits)
 {
 /*Constants to index into mvsetup columns.*/
-#define	nNTSC_APS00		0      /*ntsc mv off.                   */
-#define	nNTSC_APS01		1      /*ntsc AGC only.                 */
-#define	nNTSC_APS10		2      /*ntsc AGC + 2-line CS.  */
-#define	nNTSC_APS11		3      /*ntsc AGC + 4-line CS.  */
-#define	nPAL_APS00		4      /*pal mv off.                    */
-#define	nPAL_APSXX		5      /*pal mv on.                     */
+#define	nNTSC_APS00		0       /*ntsc mv off.                   */
+#define	nNTSC_APS01		1       /*ntsc AGC only.                 */
+#define	nNTSC_APS10		2       /*ntsc AGC + 2-line CS.  */
+#define	nNTSC_APS11		3       /*ntsc AGC + 4-line CS.  */
+#define	nPAL_APS00		4       /*pal mv off.                    */
+#define	nPAL_APSXX		5       /*pal mv on.                     */
 #define	nMVModes		6
 
     /*Macrovision setup table. */
-    static const struct mvparms
-    {
+    static const struct mvparms {
         unsigned short n0[nMVModes];
         unsigned short n1[nMVModes];
         unsigned short n2[nMVModes];
@@ -2778,9 +2787,7 @@ config_macrovision(unsigned long tv_std, unsigned int trigger_bits)
         unsigned short n22[nMVModes];
         unsigned short agc_pulse_level[nMVModes];
         unsigned short bp_pulse_level[nMVModes];
-    }
-
-    mvsetup = {
+    } mvsetup = {
         /*    ntsc    ntsc    ntsc    ntsc    pal             pal */
         /*    MV      AGC     AGC +   AGC +   MV              MV */
         /*    off.    only    2-line  4-line  off.    on. */
@@ -2849,22 +2856,27 @@ config_macrovision(unsigned long tv_std, unsigned int trigger_bits)
         if (trigger_bits == 0) {
             /*turn Macrovision OFF. */
             nMode = nNTSC_APS00;
-        } else if (trigger_bits == 1) {
+        }
+        else if (trigger_bits == 1) {
             /*AGC Only. */
             nMode = nNTSC_APS01;
-        } else if (trigger_bits == 2) {
+        }
+        else if (trigger_bits == 2) {
             /*AGC + 2-line CS. */
             nMode = nNTSC_APS10;
-        } else {
+        }
+        else {
             /*AGC + 4-line CS. */
             nMode = nNTSC_APS11;
         }
-    } else {
+    }
+    else {
         /*PAL TV Standard. */
         if (trigger_bits == 0) {
             /*turn Macrovision OFF. */
             nMode = nPAL_APS00;
-        } else {
+        }
+        else {
             /*APS 01, 10, or 11. */
             nMode = nPAL_APSXX;
         }
@@ -2943,15 +2955,16 @@ conget_macrovision(unsigned long tv_std, unsigned int *p_cp_trigger_bits)
             break;
 
         case 0x3E:
-            {
-                if (0x1D == n1)
-                    *p_cp_trigger_bits = 2;
-                else
-                    *p_cp_trigger_bits = 3;
-            }
+        {
+            if (0x1D == n1)
+                *p_cp_trigger_bits = 2;
+            else
+                *p_cp_trigger_bits = 3;
+        }
             break;
         }
-    } else if (IS_PAL(tv_std)) {
+    }
+    else if (IS_PAL(tv_std)) {
         if (0 == n0)
             *p_cp_trigger_bits = 0;
         else {
@@ -3178,7 +3191,7 @@ PLAL_PrepForTVout(void)
     WriteGx(CX_TV_CONFIG, reg);
 
     /*invert FP clock */
-    reg = (int)ReadGx(CX_TV_CONFIG);
+    reg = (int) ReadGx(CX_TV_CONFIG);
     reg |= CX_INVERT_FPCLK;
     WriteGx(CX_TV_CONFIG, reg);
 
@@ -3240,12 +3253,12 @@ PLAL_FinalEnableTVout(unsigned long vga_mode)
     unsigned int reg;
 
     /*Cx5530 select tv dot clock. */
-    reg = (int)ReadGx(CX_DOT_CLK);
+    reg = (int) ReadGx(CX_DOT_CLK);
     reg |= CX_TVCLK_SELECT;
     WriteGx(CX_DOT_CLK, reg);
 
     /*2 x dclk (actually 1x) */
-    reg = (int)ReadGx(DC_GENERAL_CFG);
+    reg = (int) ReadGx(DC_GENERAL_CFG);
     reg &= ~GX_DCLK_MUL;
     WriteGx(DC_GENERAL_CFG, reg);
 
@@ -3253,7 +3266,7 @@ PLAL_FinalEnableTVout(unsigned long vga_mode)
     WriteGx(DC_GENERAL_CFG, reg);
 
     /*Cx5530 display configuration register. */
-    reg = (int)ReadGx(CX_DISPLAY_CONFIG);
+    reg = (int) ReadGx(CX_DISPLAY_CONFIG);
     reg |= (CX_FPVSYNC_POL | CX_FPHSYNC_POL | CX_FPDATA_ENB | CX_FPPOWER_ENB);
     WriteGx(CX_DISPLAY_CONFIG, reg);
 
diff --git a/src/gfx/tv_fs450.h b/src/gfx/tv_fs450.h
index 7e917c0..4da7a21 100644
--- a/src/gfx/tv_fs450.h
+++ b/src/gfx/tv_fs450.h
@@ -31,8 +31,7 @@
 #define __FS450_H__
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
 /*==========================================================================*/
@@ -171,8 +170,7 @@ extern "C"
 #define SOURCE_HOUSTON 0
 #define SOURCE_GCC 1
 
-    typedef struct _S_REG_INFO
-    {
+    typedef struct _S_REG_INFO {
         int source;
         unsigned int size;
         unsigned long offset;
@@ -202,5 +200,4 @@ extern "C"
 #ifdef __cplusplus
 }
 #endif
-
 #endif
diff --git a/src/gfx/vga_gu1.c b/src/gfx/vga_gu1.c
index 20cf232..8cbfe4f 100644
--- a/src/gfx/vga_gu1.c
+++ b/src/gfx/vga_gu1.c
@@ -60,189 +60,189 @@ int gu1_detect_vsa2(void);
 gfx_vga_struct gfx_vga_modes[] = {
 /*--------------------------------------------------------------------------*/
     {
-            640, 480, 60,              /* 640x480                                                              */
-            25,                        /* 25 MHz clock = 60 Hz refresh rate    */
-            0xE3,                      /* miscOutput register                                  */
-            {
-                    0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E,
-                    /* standard CRTC                                                */
-                    0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0xEA, 0x0C, 0xDF, 0x50, 0x00, 0xE7, 0x04, 0xE3, 0xFF},
-            {
-                    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
-                    /* extended CRTC                                                */
-                0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}
-        },
+     640, 480, 60,              /* 640x480                                                              */
+     25,                        /* 25 MHz clock = 60 Hz refresh rate    */
+     0xE3,                      /* miscOutput register                                  */
+     {
+      0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E,
+      /* standard CRTC                                                */
+      0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0xEA, 0x0C, 0xDF, 0x50, 0x00, 0xE7, 0x04, 0xE3, 0xFF},
+     {
+      0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+      /* extended CRTC                                                */
+      0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            640, 480, 72,              /* 640x480 */
-            29,                        /* 29 MHz clock = 72 Hz refresh rate */
-            0xE3,                      /* miscOutput register */
-            {
-                    0x63, 0x4f, 0x50, 0x86, 0x55, 0x99, 0x06, 0x3e,
-                    /* standard CRTC */
-                    0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0xe9, 0x0c, 0xdf, 0x00, 0x00, 0xe7, 0x00, 0xe3, 0xff},
-            {
-                    0x6D, 0x00, 0x00, 0x03, 0x00, 0x01, 0x01, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x01, 0x08, 0x80, 0x1F, 0x00, 0x4B}
-        },
+     640, 480, 72,              /* 640x480 */
+     29,                        /* 29 MHz clock = 72 Hz refresh rate */
+     0xE3,                      /* miscOutput register */
+     {
+      0x63, 0x4f, 0x50, 0x86, 0x55, 0x99, 0x06, 0x3e,
+      /* standard CRTC */
+      0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0xe9, 0x0c, 0xdf, 0x00, 0x00, 0xe7, 0x00, 0xe3, 0xff},
+     {
+      0x6D, 0x00, 0x00, 0x03, 0x00, 0x01, 0x01, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x01, 0x08, 0x80, 0x1F, 0x00, 0x4B}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            640, 480, 75,              /* 640x480 */
-            31,
-            /* 31.5 MHz clock = 75 Hz refresh rate */
-            0xE3,                      /* miscOutput register */
-            {
-                    0x64, 0x4F, 0x4F, 0x88, 0x54, 0x9B, 0xF2, 0x1F,
-                    /* standard CRTC */
-                    0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0xE1, 0x04, 0xDF, 0x50, 0x00, 0xDF, 0xF3, 0xE3, 0xFF},
-            {
-                    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x00, 0x03, 0x80, 0x1F, 0x00, 0x00}
-        },
+     640, 480, 75,              /* 640x480 */
+     31,
+     /* 31.5 MHz clock = 75 Hz refresh rate */
+     0xE3,                      /* miscOutput register */
+     {
+      0x64, 0x4F, 0x4F, 0x88, 0x54, 0x9B, 0xF2, 0x1F,
+      /* standard CRTC */
+      0x80, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0xE1, 0x04, 0xDF, 0x50, 0x00, 0xDF, 0xF3, 0xE3, 0xFF},
+     {
+      0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x00, 0x03, 0x80, 0x1F, 0x00, 0x00}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            800, 600, 60,              /* 800x600 */
-            40,                        /* 40 MHz clock = 60 Hz refresh rate */
-            0x23,                      /* miscOutput register */
-            {
-                    0x7F, 0x63, 0x64, 0x82, 0x6B, 0x1B, 0x72, 0xF0,
-                    /* standard CRTC */
-                    0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0x59, 0x0D, 0x57, 0x64, 0x00, 0x57, 0x73, 0xE3, 0xFF},
-            {
-                    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x00, 0x03, 0x80, 0x28, 0x00, 0x00}
-        },
+     800, 600, 60,              /* 800x600 */
+     40,                        /* 40 MHz clock = 60 Hz refresh rate */
+     0x23,                      /* miscOutput register */
+     {
+      0x7F, 0x63, 0x64, 0x82, 0x6B, 0x1B, 0x72, 0xF0,
+      /* standard CRTC */
+      0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x59, 0x0D, 0x57, 0x64, 0x00, 0x57, 0x73, 0xE3, 0xFF},
+     {
+      0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x00, 0x03, 0x80, 0x28, 0x00, 0x00}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            800, 600, 72,              /* 800x600 */
-            47,                        /* 47 MHz clock = 72 Hz refresh rate */
-            0x2B,                      /* miscOutput register */
-            {
-                    0x7D, 0x63, 0x63, 0x81, 0x6D, 0x1B, 0x98, 0xF0,
-                    /* standard CRTC */
-                    0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0x7D, 0x03, 0x57, 0x00, 0x00, 0x57, 0x9A, 0xE3, 0xFF},
-            {
-                    0x6F, 0x00, 0x00, 0x03, 0x00, 0x01, 0x01, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x01, 0x08, 0x80, 0x32, 0x00, 0x4B}
-        },
+     800, 600, 72,              /* 800x600 */
+     47,                        /* 47 MHz clock = 72 Hz refresh rate */
+     0x2B,                      /* miscOutput register */
+     {
+      0x7D, 0x63, 0x63, 0x81, 0x6D, 0x1B, 0x98, 0xF0,
+      /* standard CRTC */
+      0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x7D, 0x03, 0x57, 0x00, 0x00, 0x57, 0x9A, 0xE3, 0xFF},
+     {
+      0x6F, 0x00, 0x00, 0x03, 0x00, 0x01, 0x01, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x01, 0x08, 0x80, 0x32, 0x00, 0x4B}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            800, 600, 75,              /* 800x600 */
-            49,
-            /* 49.5 MHz clock = 75 Hz refresh rate */
-            0x23,                      /* miscOutput register */
-            {
-                    0x7F, 0x63, 0x63, 0x83, 0x68, 0x11, 0x6F, 0xF0,
-                    /* standard CRTC */
-                    0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0x59, 0x1C, 0x57, 0x64, 0x00, 0x57, 0x70, 0xE3, 0xFF},
-            {
-                    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x00, 0x03, 0x80, 0x31, 0x00, 0x00}
-        },
+     800, 600, 75,              /* 800x600 */
+     49,
+     /* 49.5 MHz clock = 75 Hz refresh rate */
+     0x23,                      /* miscOutput register */
+     {
+      0x7F, 0x63, 0x63, 0x83, 0x68, 0x11, 0x6F, 0xF0,
+      /* standard CRTC */
+      0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x59, 0x1C, 0x57, 0x64, 0x00, 0x57, 0x70, 0xE3, 0xFF},
+     {
+      0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x00, 0x03, 0x80, 0x31, 0x00, 0x00}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            1024, 768, 60,             /* 1024x768 */
-            65,                        /* 65 MHz clock = 60 Hz refresh rate */
-            0xE3,                      /* miscOutput register */
-            {
-                    0xA3, 0x7F, 0x80, 0x86, 0x85, 0x96, 0x24, 0xF5,
-                    /* standard CRTC */
-                    0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0x04, 0x0A, 0xFF, 0x80, 0x00, 0xFF, 0x25, 0xE3, 0xFF},
-            {
-                    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x00, 0x03, 0x80, 0x41, 0x00, 0x00}
-        },
+     1024, 768, 60,             /* 1024x768 */
+     65,                        /* 65 MHz clock = 60 Hz refresh rate */
+     0xE3,                      /* miscOutput register */
+     {
+      0xA3, 0x7F, 0x80, 0x86, 0x85, 0x96, 0x24, 0xF5,
+      /* standard CRTC */
+      0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x04, 0x0A, 0xFF, 0x80, 0x00, 0xFF, 0x25, 0xE3, 0xFF},
+     {
+      0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x00, 0x03, 0x80, 0x41, 0x00, 0x00}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            1024, 768, 70,             /* 1024x768 */
-            76,                        /* 76 MHz clock = 70 Hz refresh rate */
-            0x2B,                      /* miscOutput register */
-            {
-                    0xA1, 0x7F, 0x7F, 0x85, 0x85, 0x95, 0x24, 0xF5,
-                    /* standard CRTC */
-                    0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0x03, 0x09, 0xFF, 0x00, 0x00, 0xFF, 0x26, 0xE3, 0xFF},
-            {
-                    0x62, 0x00, 0x00, 0x03, 0x00, 0x01, 0x01, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x01, 0x02, 0x80, 0x4B, 0x00, 0x4B}
-        },
+     1024, 768, 70,             /* 1024x768 */
+     76,                        /* 76 MHz clock = 70 Hz refresh rate */
+     0x2B,                      /* miscOutput register */
+     {
+      0xA1, 0x7F, 0x7F, 0x85, 0x85, 0x95, 0x24, 0xF5,
+      /* standard CRTC */
+      0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x03, 0x09, 0xFF, 0x00, 0x00, 0xFF, 0x26, 0xE3, 0xFF},
+     {
+      0x62, 0x00, 0x00, 0x03, 0x00, 0x01, 0x01, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x01, 0x02, 0x80, 0x4B, 0x00, 0x4B}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            1024, 768, 75,             /* 1024x768 */
-            79,                        /* 79 MHz clock = 75 Hz refresh rate */
-            0xE3,                      /* miscOutput register */
-            {
-                    0x9F, 0x7F, 0x7F, 0x83, 0x84, 0x8F, 0x1E, 0xF5,
-                    /* standard CRTC */
-                    0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0x01, 0x04, 0xFF, 0x80, 0x00, 0xFF, 0x1F, 0xE3, 0xFF},
-            {
-                    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x00, 0x03, 0x80, 0x4F, 0x00, 0x00}
-        },
+     1024, 768, 75,             /* 1024x768 */
+     79,                        /* 79 MHz clock = 75 Hz refresh rate */
+     0xE3,                      /* miscOutput register */
+     {
+      0x9F, 0x7F, 0x7F, 0x83, 0x84, 0x8F, 0x1E, 0xF5,
+      /* standard CRTC */
+      0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x01, 0x04, 0xFF, 0x80, 0x00, 0xFF, 0x1F, 0xE3, 0xFF},
+     {
+      0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x00, 0x03, 0x80, 0x4F, 0x00, 0x00}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            1280, 1024, 60,            /* 1280x1024 */
-            108,
-            /* 108 MHz clock = 60 Hz refresh rate */
-            0x23,                      /* miscOutput register */
-            {
-                    0xCF, 0x9F, 0xA0, 0x92, 0xAA, 0x19, 0x28, 0x52,
-                    /* standard CRTC */
-                    0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0x01, 0x04, 0xFF, 0xA0, 0x00, 0x00, 0x29, 0xE3, 0xFF},
-            {
-                    0x00, 0x51, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x00, 0x03, 0x80, 0x6C, 0x00, 0x00}
-        },
+     1280, 1024, 60,            /* 1280x1024 */
+     108,
+     /* 108 MHz clock = 60 Hz refresh rate */
+     0x23,                      /* miscOutput register */
+     {
+      0xCF, 0x9F, 0xA0, 0x92, 0xAA, 0x19, 0x28, 0x52,
+      /* standard CRTC */
+      0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x01, 0x04, 0xFF, 0xA0, 0x00, 0x00, 0x29, 0xE3, 0xFF},
+     {
+      0x00, 0x51, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x00, 0x03, 0x80, 0x6C, 0x00, 0x00}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            1280, 1024, 75,            /* 1280x1024 */
-            135,
-            /* 135 MHz clock = 75 Hz refresh rate */
-            0x23,                      /* miscOutput register */
-            {
-                    0xCE, 0x9F, 0x9F, 0x92, 0xA4, 0x15, 0x28, 0x52,
-                    /* standard CRTC */
-                    0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0x01, 0x04, 0xFF, 0xA0, 0x00, 0x00, 0x29, 0xE3, 0xFF},
-            {
-                    0x00, 0x51, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x00, 0x03, 0x80, 0x87, 0x00, 0x00}
-        },
+     1280, 1024, 75,            /* 1280x1024 */
+     135,
+     /* 135 MHz clock = 75 Hz refresh rate */
+     0x23,                      /* miscOutput register */
+     {
+      0xCE, 0x9F, 0x9F, 0x92, 0xA4, 0x15, 0x28, 0x52,
+      /* standard CRTC */
+      0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x01, 0x04, 0xFF, 0xA0, 0x00, 0x00, 0x29, 0xE3, 0xFF},
+     {
+      0x00, 0x51, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x00, 0x03, 0x80, 0x87, 0x00, 0x00}
+     },
 /*--------------------------------------------------------------------------*/
     {
-            1280, 1024, 85,            /* 1280x1024 */
-            159,
-            /* 159 MHz clock = 85 Hz refresh rate */
-            0x2B,                      /* miscOutput register */
-            {
-                    0xD3, 0x9F, 0xA0, 0x98, 0xA8, 0x9C, 0x2E, 0x5A,
-                    /* standard CRTC */
-                    0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-                0x01, 0x04, 0xFF, 0x00, 0x00, 0xFF, 0x30, 0xE3, 0xFF},
-            {
-                    0x6B, 0x41, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00,
-                    /* extended CRTC */
-                0x00, 0x00, 0x01, 0x00, 0x80, 0x9D, 0x00, 0x4B}
-        },
+     1280, 1024, 85,            /* 1280x1024 */
+     159,
+     /* 159 MHz clock = 85 Hz refresh rate */
+     0x2B,                      /* miscOutput register */
+     {
+      0xD3, 0x9F, 0xA0, 0x98, 0xA8, 0x9C, 0x2E, 0x5A,
+      /* standard CRTC */
+      0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+      0x01, 0x04, 0xFF, 0x00, 0x00, 0xFF, 0x30, 0xE3, 0xFF},
+     {
+      0x6B, 0x41, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00,
+      /* extended CRTC */
+      0x00, 0x00, 0x01, 0x00, 0x80, 0x9D, 0x00, 0x4B}
+     },
 /*--------------------------------------------------------------------------*/
 };
 
@@ -314,7 +314,7 @@ gfx_vga_get_pci_command(void)
     unsigned long value;
 
     value = gfx_pci_config_read(0x80009404);
-    return ((unsigned char)value);
+    return ((unsigned char) value);
 }
 
 /*----------------------------------------------------------------------------
@@ -333,7 +333,7 @@ gfx_vga_set_pci_command(unsigned char command)
     unsigned long value;
 
     value = gfx_pci_config_read(0x80009404) & 0xFFFFFF00;
-    value |= (unsigned long)command;
+    value |= (unsigned long) command;
     gfx_pci_config_write(0x80009404, value);
     return (GFX_STATUS_OK);
 }
@@ -351,7 +351,7 @@ int
 gfx_vga_seq_reset(int reset)
 {
     OUTB(0x3C4, 0);
-    OUTB(0x3C5, (unsigned char)(reset ? 0x00 : 0x03));
+    OUTB(0x3C5, (unsigned char) (reset ? 0x00 : 0x03));
     return (GFX_STATUS_OK);
 }
 
@@ -377,7 +377,7 @@ gfx_vga_set_graphics_bits(void)
 
     /* SET GRAPHICS BIT IN ATTRIBUTE CONTROLLER REG 0x10 */
 
-    INB(0x3BA);                        /* Reset flip-flop */
+    INB(0x3BA);                 /* Reset flip-flop */
     INB(0x3DA);
     OUTB(0x3C0, 0x10);
     OUTB(0x3C0, 0x01);
@@ -409,15 +409,15 @@ gfx_vga_mode(gfx_vga_struct * vga, int xres, int yres, int bpp, int hz)
             /* SET PITCH TO 1K OR 2K */
             /* CRTC_EXTENDED_OFFSET index is 0x45, so offset = 0x05 */
 
-            pitch = (unsigned short)xres;
+            pitch = (unsigned short) xres;
             if (bpp > 8)
                 pitch <<= 1;
             if (pitch <= 1024)
                 pitch = 1024 >> 3;
             else
                 pitch = 2048 >> 3;
-            vga->stdCRTCregs[0x13] = (unsigned char)pitch;
-            vga->extCRTCregs[0x05] = (unsigned char)((pitch >> 8) & 0x03);
+            vga->stdCRTCregs[0x13] = (unsigned char) pitch;
+            vga->extCRTCregs[0x05] = (unsigned char) ((pitch >> 8) & 0x03);
 
             /* SET PROPER COLOR DEPTH VALUE */
             /* CRTC_EXTENDED_COLOR_CONTROL index is 0x46, so offset = 0x06 */
@@ -450,8 +450,8 @@ int
 gfx_vga_pitch(gfx_vga_struct * vga, unsigned short pitch)
 {
     pitch >>= 3;
-    vga->stdCRTCregs[0x13] = (unsigned char)pitch;
-    vga->extCRTCregs[0x05] = (unsigned char)((pitch >> 8) & 0x03);
+    vga->stdCRTCregs[0x13] = (unsigned char) pitch;
+    vga->extCRTCregs[0x05] = (unsigned char) ((pitch >> 8) & 0x03);
     return (0);
 }
 
@@ -486,7 +486,7 @@ gfx_vga_save(gfx_vga_struct * vga, int flags)
         /* SAVE STANDARD CRTC REGISTERS */
 
         for (i = 0; i < GFX_STD_CRTC_REGS; i++) {
-            OUTB(crtcindex, (unsigned char)i);
+            OUTB(crtcindex, (unsigned char) i);
             vga->stdCRTCregs[i] = INB(crtcdata);
         }
     }
@@ -497,7 +497,7 @@ gfx_vga_save(gfx_vga_struct * vga, int flags)
         /* SAVE EXTENDED CRTC REGISTERS */
 
         for (i = 0; i < GFX_EXT_CRTC_REGS; i++) {
-            OUTB(crtcindex, (unsigned char)(0x40 + i));
+            OUTB(crtcindex, (unsigned char) (0x40 + i));
             vga->extCRTCregs[i] = INB(crtcdata);
         }
     }
@@ -524,7 +524,7 @@ gfx_vga_clear_extended(void)
     OUTB(crtcdata, 0x57);
     OUTB(crtcdata, 0x4C);
     for (i = 0x40; i <= 0x4F; i++) {
-        OUTB(crtcindex, (unsigned char)i);
+        OUTB(crtcindex, (unsigned char) i);
         OUTB(crtcdata, 0);
     }
     OUTB(crtcindex, 0x30);
@@ -567,7 +567,7 @@ gfx_vga_restore(gfx_vga_struct * vga, int flags)
         /* RESTORE STANDARD CRTC REGISTERS */
 
         for (i = 0; i < GFX_STD_CRTC_REGS; i++) {
-            OUTB(crtcindex, (unsigned char)i);
+            OUTB(crtcindex, (unsigned char) i);
             OUTB(crtcdata, vga->stdCRTCregs[i]);
         }
     }
@@ -584,7 +584,7 @@ gfx_vga_restore(gfx_vga_struct * vga, int flags)
         /* RESTORE EXTENDED CRTC REGISTERS */
 
         for (i = 0; i < GFX_EXT_CRTC_REGS; i++) {
-            OUTB(crtcindex, (unsigned char)(0x40 + i));
+            OUTB(crtcindex, (unsigned char) (0x40 + i));
             OUTB(crtcdata, vga->extCRTCregs[i]);
         }
 
@@ -600,7 +600,7 @@ gfx_vga_restore(gfx_vga_struct * vga, int flags)
             /* This really should be another thing saved/restored, but */
             /* Durango currently doesn't do the attr controller registers. */
 
-            INB(0x3BA);                /* Reset flip-flop */
+            INB(0x3BA);         /* Reset flip-flop */
             INB(0x3DA);
             OUTB(0x3C0, 0x11);
             OUTB(0x3C0, 0x00);
@@ -636,7 +636,7 @@ gfx_vga_mode_switch(int active)
 
     OUTB(crtcindex, CRTC_MODE_SWITCH_CONTROL);
     active = active ? 1 : 0;
-    OUTB(crtcdata, (unsigned char)active);
+    OUTB(crtcdata, (unsigned char) active);
 
     /* WAIT UNTIL SOFTVGA HAS VALIDATED MODE IF ENDING MODE SWITCH */
     /* This is for VSA1 only, where SoftVGA waits until the next */
@@ -644,7 +644,7 @@ gfx_vga_mode_switch(int active)
 
     if ((!active) && (!(gu1_detect_vsa2()))) {
         OUTB(crtcindex, 0x33);
-        while (INB(crtcdata) & 0x80) ;
+        while (INB(crtcdata) & 0x80);
     }
 
     /* LOCK EXTENDED CRTC REGISTERS */
diff --git a/src/gfx/vid_1200.c b/src/gfx/vid_1200.c
index 5eb5793..abc1b54 100644
--- a/src/gfx/vid_1200.c
+++ b/src/gfx/vid_1200.c
@@ -83,10 +83,9 @@ unsigned long gfx_gamma_ram_1200[] = {
  *----------------------------------------------------------------------------
  */
 
-typedef struct tagSC1200PLL
-{
-    long frequency;                    /* 16.16 fixed point frequency */
-    unsigned long clock_select;        /* clock select register (0x2C) */
+typedef struct tagSC1200PLL {
+    long frequency;             /* 16.16 fixed point frequency */
+    unsigned long clock_select; /* clock select register (0x2C) */
 } SC1200PLL;
 
 SC1200PLL gfx_sc1200_clock_table[] = {
@@ -132,20 +131,20 @@ SC1200PLL gfx_sc1200_clock_table[] = {
     {(232L << 16) | ((0000L * 65536L) / 10000L), 0x0010AA04},   /* 232.50  */
 
     /* Precomputed inidces in the hardware */
-    {0x0018EC4D, 0x000F0000},          /*  24.923052 */
-    {0x00192CCC, 0x00000000},          /*  25.1750  */
-    {0x001B0000, 0x00300100},          /*  27.0000  */
-    {0x001F8000, 0x00010000},          /*  31.5000  */
-    {0x00240000, 0x00020000},          /*  36.0000  */
-    {0x00280000, 0x00030000},          /*  40.0000  */
-    {0x00318000, 0x00050000},          /*  49.5000  */
-    {0x00320000, 0x00040000},          /*  50.0000  */
-    {0x00384000, 0x00060000},          /*  56.2500  */
-    {0x00410000, 0x00080000},          /*  65.0000  */
-    {0x004E8000, 0x000A0000},          /*  78.5000  */
-    {0x005E8000, 0x000B0000},          /*  94.5000  */
-    {0x006C0000, 0x000C0000},          /* 108.0000  */
-    {0x00870000, 0x000D0000},          /* 135.0000  */
+    {0x0018EC4D, 0x000F0000},   /*  24.923052 */
+    {0x00192CCC, 0x00000000},   /*  25.1750  */
+    {0x001B0000, 0x00300100},   /*  27.0000  */
+    {0x001F8000, 0x00010000},   /*  31.5000  */
+    {0x00240000, 0x00020000},   /*  36.0000  */
+    {0x00280000, 0x00030000},   /*  40.0000  */
+    {0x00318000, 0x00050000},   /*  49.5000  */
+    {0x00320000, 0x00040000},   /*  50.0000  */
+    {0x00384000, 0x00060000},   /*  56.2500  */
+    {0x00410000, 0x00080000},   /*  65.0000  */
+    {0x004E8000, 0x000A0000},   /*  78.5000  */
+    {0x005E8000, 0x000B0000},   /*  94.5000  */
+    {0x006C0000, 0x000C0000},   /* 108.0000  */
+    {0x00870000, 0x000D0000},   /* 135.0000  */
 };
 
 #define NUM_SC1200_FREQUENCIES	\
@@ -186,10 +185,10 @@ gfx_reset_video(void)
     gfx_set_display_video_size(0, 0);
 
     if (gfx_test_timing_active()) {
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
     }
 }
 
@@ -222,11 +221,11 @@ gfx_set_display_control(int sync_polarities)
 
     dcfg = READ_VID32(SC1200_DISPLAY_CONFIG);
     dcfg &= ~(SC1200_DCFG_CRT_SYNC_SKW_MASK | SC1200_DCFG_PWR_SEQ_DLY_MASK |
-        SC1200_DCFG_CRT_HSYNC_POL | SC1200_DCFG_CRT_VSYNC_POL |
-        SC1200_DCFG_FP_PWR_EN | SC1200_DCFG_FP_DATA_EN);
+              SC1200_DCFG_CRT_HSYNC_POL | SC1200_DCFG_CRT_VSYNC_POL |
+              SC1200_DCFG_FP_PWR_EN | SC1200_DCFG_FP_DATA_EN);
 
     dcfg |= (SC1200_DCFG_CRT_SYNC_SKW_INIT |
-        SC1200_DCFG_PWR_SEQ_DLY_INIT | SC1200_DCFG_GV_PAL_BYP);
+             SC1200_DCFG_PWR_SEQ_DLY_INIT | SC1200_DCFG_GV_PAL_BYP);
 
     if (PanelEnable)
         dcfg |= SC1200_DCFG_FP_PWR_EN;
@@ -267,11 +266,11 @@ gfx_set_clock_frequency(unsigned long frequency)
     /* Search the table for the closest frequency (16.16 format). */
 
     value = gfx_sc1200_clock_table[0].clock_select;
-    min = (long)gfx_sc1200_clock_table[0].frequency - frequency;
+    min = (long) gfx_sc1200_clock_table[0].frequency - frequency;
     if (min < 0L)
         min = -min;
     for (index = 1; index < NUM_SC1200_FREQUENCIES; index++) {
-        diff = (long)gfx_sc1200_clock_table[index].frequency - frequency;
+        diff = (long) gfx_sc1200_clock_table[index].frequency - frequency;
         if (diff < 0L)
             diff = -diff;
         if (diff < min) {
@@ -338,30 +337,31 @@ gfx_set_crt_enable(int enable)
      */
 
     switch (enable) {
-    case CRT_DISABLE:                 /* HSync:Off VSync:Off */
+    case CRT_DISABLE:          /* HSync:Off VSync:Off */
         WRITE_VID32(SC1200_DISPLAY_CONFIG, config & ~(SC1200_DCFG_HSYNC_EN
-                | SC1200_DCFG_VSYNC_EN | SC1200_DCFG_DAC_BL_EN));
+                                                      | SC1200_DCFG_VSYNC_EN |
+                                                      SC1200_DCFG_DAC_BL_EN));
         WRITE_VID32(SC1200_VID_MISC, misc | SC1200_DAC_POWER_DOWN);
         break;
-    case CRT_ENABLE:                  /* Enable CRT display, including 
-                                        * display logic */
+    case CRT_ENABLE:           /* Enable CRT display, including 
+                                 * display logic */
         WRITE_VID32(SC1200_DISPLAY_CONFIG, config | SC1200_DCFG_HSYNC_EN
-            | SC1200_DCFG_VSYNC_EN | SC1200_DCFG_DAC_BL_EN);
+                    | SC1200_DCFG_VSYNC_EN | SC1200_DCFG_DAC_BL_EN);
         WRITE_VID32(SC1200_VID_MISC, misc & ~SC1200_DAC_POWER_DOWN);
 
         /* ENABLE GRAPHICS DISPLAY LOGIC */
         gfx_set_screen_enable(1);
         break;
-    case CRT_STANDBY:                 /* HSync:Off VSync:On */
+    case CRT_STANDBY:          /* HSync:Off VSync:On */
         WRITE_VID32(SC1200_DISPLAY_CONFIG, (config & ~(SC1200_DCFG_HSYNC_EN
-                    | SC1200_DCFG_DAC_BL_EN))
-            | SC1200_DCFG_VSYNC_EN);
+                                                       | SC1200_DCFG_DAC_BL_EN))
+                    | SC1200_DCFG_VSYNC_EN);
         WRITE_VID32(SC1200_VID_MISC, misc | SC1200_DAC_POWER_DOWN);
         break;
-    case CRT_SUSPEND:                 /* HSync:On VSync:Off */
+    case CRT_SUSPEND:          /* HSync:On VSync:Off */
         WRITE_VID32(SC1200_DISPLAY_CONFIG, (config & ~(SC1200_DCFG_VSYNC_EN
-                    | SC1200_DCFG_DAC_BL_EN))
-            | SC1200_DCFG_HSYNC_EN);
+                                                       | SC1200_DCFG_DAC_BL_EN))
+                    | SC1200_DCFG_HSYNC_EN);
         WRITE_VID32(SC1200_VID_MISC, misc | SC1200_DAC_POWER_DOWN);
         break;
     default:
@@ -391,9 +391,9 @@ gfx_set_video_enable(int enable)
 
     if (gfx_test_timing_active()) {
         if (!gfx_test_vertical_active()) {
-            while (!gfx_test_vertical_active()) ;
+            while (!gfx_test_vertical_active());
         }
-        while (gfx_test_vertical_active()) ;
+        while (gfx_test_vertical_active());
     }
 
     vcfg = READ_VID32(SC1200_VIDEO_CONFIG);
@@ -402,7 +402,8 @@ gfx_set_video_enable(int enable)
 
         vcfg |= SC1200_VCFG_VID_EN;
         WRITE_VID32(SC1200_VIDEO_CONFIG, vcfg);
-    } else {
+    }
+    else {
         /* DISABLE SC1200 VIDEO OVERLAY */
 
         vcfg &= ~SC1200_VCFG_VID_EN;
@@ -531,7 +532,7 @@ gfx_set_video_size(unsigned short width, unsigned short height)
     /* Use private routine to abstract the display controller. */
 
     /* Add 1 line to bypass issue #803 */
-    gfx_set_display_video_size(width, (unsigned short)(height + 2));
+    gfx_set_display_video_size(width, (unsigned short) (height + 2));
     return (0);
 }
 
@@ -571,11 +572,11 @@ gfx_set_video_offset(unsigned long offset)
 #if GFX_VIDEO_DYNAMIC
 int
 sc1200_set_video_upscale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                         unsigned short dstw, unsigned short dsth)
 #else
 int
 gfx_set_video_upscale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                      unsigned short dstw, unsigned short dsth)
 #endif
 {
     unsigned long xscale, yscale;
@@ -625,7 +626,7 @@ gfx_set_video_upscale(unsigned short srcw, unsigned short srch,
     /* amount of data that needs to be transferred. */
 
     gfx_set_video_window(gfx_vid_xpos, gfx_vid_ypos, gfx_vid_width,
-        gfx_vid_height);
+                         gfx_vid_height);
     return (0);
 }
 
@@ -639,11 +640,11 @@ gfx_set_video_upscale(unsigned short srcw, unsigned short srch,
 #if GFX_VIDEO_DYNAMIC
 int
 sc1200_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                       unsigned short dstw, unsigned short dsth)
 #else
 int
 gfx_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                    unsigned short dstw, unsigned short dsth)
 #endif
 {
     return gfx_set_video_upscale(srcw, srch, dstw, dsth);
@@ -673,7 +674,7 @@ gfx_set_video_downscale_config(unsigned short type, unsigned short m)
     downscale = READ_VID32(SC1200_VIDEO_DOWNSCALER_CONTROL);
     downscale &=
         ~(SC1200_VIDEO_DOWNSCALE_FACTOR_MASK |
-        SC1200_VIDEO_DOWNSCALE_TYPE_MASK);
+          SC1200_VIDEO_DOWNSCALE_TYPE_MASK);
     downscale |= ((m - 1l) << SC1200_VIDEO_DOWNSCALE_FACTOR_POS);
     switch (type) {
     case VIDEO_DOWNSCALE_KEEP_1_OF:
@@ -698,21 +699,24 @@ gfx_set_video_downscale_config(unsigned short type, unsigned short m)
 #if GFX_VIDEO_DYNAMIC
 int
 sc1200_set_video_downscale_coefficients(unsigned short coef1,
-    unsigned short coef2, unsigned short coef3, unsigned short coef4)
+                                        unsigned short coef2,
+                                        unsigned short coef3,
+                                        unsigned short coef4)
 #else
 int
 gfx_set_video_downscale_coefficients(unsigned short coef1,
-    unsigned short coef2, unsigned short coef3, unsigned short coef4)
+                                     unsigned short coef2, unsigned short coef3,
+                                     unsigned short coef4)
 #endif
 {
     if ((coef1 + coef2 + coef3 + coef4) != 16)
         return GFX_STATUS_BAD_PARAMETER;
 
     WRITE_VID32(SC1200_VIDEO_DOWNSCALER_COEFFICIENTS,
-        ((unsigned long)coef1 << SC1200_VIDEO_DOWNSCALER_COEF1_POS) |
-        ((unsigned long)coef2 << SC1200_VIDEO_DOWNSCALER_COEF2_POS) |
-        ((unsigned long)coef3 << SC1200_VIDEO_DOWNSCALER_COEF3_POS) |
-        ((unsigned long)coef4 << SC1200_VIDEO_DOWNSCALER_COEF4_POS));
+                ((unsigned long) coef1 << SC1200_VIDEO_DOWNSCALER_COEF1_POS) |
+                ((unsigned long) coef2 << SC1200_VIDEO_DOWNSCALER_COEF2_POS) |
+                ((unsigned long) coef3 << SC1200_VIDEO_DOWNSCALER_COEF3_POS) |
+                ((unsigned long) coef4 << SC1200_VIDEO_DOWNSCALER_COEF4_POS));
     return (0);
 }
 
@@ -786,37 +790,37 @@ gfx_set_video_window(short x, short y, unsigned short w, unsigned short h)
 
     /* HORIZONTAL START */
 
-    xstart = (unsigned long)x + hadjust;
+    xstart = (unsigned long) x + hadjust;
 
     /* HORIZONTAL END */
     /* End positions in register are non-inclusive (one more than the actual 
      * end) */
 
     if ((x + w) < gfx_get_hactive())
-        xend = (unsigned long)x + (unsigned long)w + hadjust;
-    else                               /* right clipping needed */
-        xend = (unsigned long)gfx_get_hactive() + hadjust;
+        xend = (unsigned long) x + (unsigned long) w + hadjust;
+    else                        /* right clipping needed */
+        xend = (unsigned long) gfx_get_hactive() + hadjust;
 
     /* VERTICAL START */
 
-    ystart = (unsigned long)y + vadjust;
+    ystart = (unsigned long) y + vadjust;
 
     /* VERTICAL END */
 
     if ((y + h) < gfx_get_vactive())
-        yend = (unsigned long)y + (unsigned long)h + vadjust;
-    else                               /* bottom clipping needed */
-        yend = (unsigned long)gfx_get_vactive() + vadjust;
+        yend = (unsigned long) y + (unsigned long) h + vadjust;
+    else                        /* bottom clipping needed */
+        yend = (unsigned long) gfx_get_vactive() + vadjust;
 
     /* SET VIDEO LINE INVERT BIT */
 
     control = READ_VID32(SC1200_VID_ALPHA_CONTROL);
     if (y & 0x1)
         WRITE_VID32(SC1200_VID_ALPHA_CONTROL,
-            control | SC1200_VIDEO_LINE_OFFSET_ODD);
+                    control | SC1200_VIDEO_LINE_OFFSET_ODD);
     else
         WRITE_VID32(SC1200_VID_ALPHA_CONTROL,
-            control & ~SC1200_VIDEO_LINE_OFFSET_ODD);
+                    control & ~SC1200_VIDEO_LINE_OFFSET_ODD);
 
     /* SET VIDEO POSITION */
 
@@ -849,7 +853,7 @@ gfx_set_video_left_crop(unsigned short x)
     /* Adjust initial read for scale, checking for divide by zero */
 
     if (gfx_vid_dstw)
-        initread = (unsigned long)x *gfx_vid_srcw / gfx_vid_dstw;
+        initread = (unsigned long) x *gfx_vid_srcw / gfx_vid_dstw;
 
     else
         initread = 0l;
@@ -879,8 +883,7 @@ gfx_set_video_left_crop(unsigned short x)
  */
 #if GFX_VIDEO_DYNAMIC
 int
-sc1200_set_video_color_key(unsigned long key, unsigned long mask,
-    int graphics)
+sc1200_set_video_color_key(unsigned long key, unsigned long mask, int graphics)
 #else
 int
 gfx_set_video_color_key(unsigned long key, unsigned long mask, int graphics)
@@ -956,9 +959,9 @@ gfx_set_video_palette(unsigned long *palette)
 
     if (gfx_test_timing_active()) {
         if (gfx_test_vertical_active()) {
-            while (gfx_test_vertical_active()) ;
+            while (gfx_test_vertical_active());
         }
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
     }
 
     /* LOAD SC1200 VIDEO PALETTE */
@@ -1012,9 +1015,9 @@ gfx_set_video_palette_entry(unsigned long index, unsigned long palette)
 
     if (gfx_test_timing_active()) {
         if (gfx_test_vertical_active()) {
-            while (gfx_test_vertical_active()) ;
+            while (gfx_test_vertical_active());
         }
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
     }
 
     /* SET A SINGLE ENTRY */
@@ -1091,8 +1094,8 @@ gfx_set_video_request(short x, short y)
         return GFX_STATUS_BAD_PARAMETER;
 
     WRITE_VID32(SC1200_VIDEO_REQUEST,
-        ((unsigned long)x << SC1200_VIDEO_X_REQUEST_POS) | ((unsigned long)y
-            << SC1200_VIDEO_Y_REQUEST_POS));
+                ((unsigned long) x << SC1200_VIDEO_X_REQUEST_POS) |
+                ((unsigned long) y << SC1200_VIDEO_Y_REQUEST_POS));
     return (0);
 }
 
@@ -1118,13 +1121,13 @@ gfx_set_video_source(VideoSourceType source)
     switch (source) {
     case VIDEO_SOURCE_MEMORY:
         WRITE_VID32(SC1200_VIDEO_DISPLAY_MODE,
-            (display_mode & ~SC1200_VIDEO_SOURCE_MASK) |
-            SC1200_VIDEO_SOURCE_GX1);
+                    (display_mode & ~SC1200_VIDEO_SOURCE_MASK) |
+                    SC1200_VIDEO_SOURCE_GX1);
         break;
     case VIDEO_SOURCE_DVIP:
         WRITE_VID32(SC1200_VIDEO_DISPLAY_MODE,
-            (display_mode & ~SC1200_VIDEO_SOURCE_MASK) |
-            SC1200_VIDEO_SOURCE_DVIP);
+                    (display_mode & ~SC1200_VIDEO_SOURCE_MASK) |
+                    SC1200_VIDEO_SOURCE_DVIP);
         break;
     default:
         return GFX_STATUS_BAD_PARAMETER;
@@ -1154,12 +1157,13 @@ gfx_set_vbi_source(VbiSourceType source)
     switch (source) {
     case VBI_SOURCE_MEMORY:
         WRITE_VID32(SC1200_VIDEO_DISPLAY_MODE,
-            (display_mode & ~SC1200_VBI_SOURCE_MASK) | SC1200_VBI_SOURCE_GX1);
+                    (display_mode & ~SC1200_VBI_SOURCE_MASK) |
+                    SC1200_VBI_SOURCE_GX1);
         break;
     case VBI_SOURCE_DVIP:
         WRITE_VID32(SC1200_VIDEO_DISPLAY_MODE,
-            (display_mode & ~SC1200_VBI_SOURCE_MASK) |
-            SC1200_VBI_SOURCE_DVIP);
+                    (display_mode & ~SC1200_VBI_SOURCE_MASK) |
+                    SC1200_VBI_SOURCE_DVIP);
         break;
     default:
         return GFX_STATUS_BAD_PARAMETER;
@@ -1183,9 +1187,9 @@ gfx_set_vbi_lines(unsigned long even, unsigned long odd)
 {
     /* SET SC1200 VBI LINES */
     WRITE_VID32(SC1200_VIDEO_EVEN_VBI_LINE_ENABLE,
-        even & SC1200_VIDEO_VBI_LINE_ENABLE_MASK);
+                even & SC1200_VIDEO_VBI_LINE_ENABLE_MASK);
     WRITE_VID32(SC1200_VIDEO_ODD_VBI_LINE_ENABLE,
-        odd & SC1200_VIDEO_VBI_LINE_ENABLE_MASK);
+                odd & SC1200_VIDEO_VBI_LINE_ENABLE_MASK);
     return (0);
 }
 
@@ -1206,9 +1210,9 @@ gfx_set_vbi_total(unsigned long even, unsigned long odd)
 {
     /* SET SC1200 VBI TOTAL */
     WRITE_VID32(SC1200_VIDEO_EVEN_VBI_TOTAL_COUNT,
-        even & SC1200_VIDEO_VBI_TOTAL_COUNT_MASK);
+                even & SC1200_VIDEO_VBI_TOTAL_COUNT_MASK);
     WRITE_VID32(SC1200_VIDEO_ODD_VBI_TOTAL_COUNT,
-        odd & SC1200_VIDEO_VBI_TOTAL_COUNT_MASK);
+                odd & SC1200_VIDEO_VBI_TOTAL_COUNT_MASK);
     return (0);
 }
 
@@ -1233,10 +1237,10 @@ gfx_set_video_interlaced(int enable)
     /* SET INTERLACED VIDEO */
     if (enable)
         WRITE_VID32(SC1200_VID_ALPHA_CONTROL,
-            control | SC1200_VIDEO_IS_INTERLACED);
+                    control | SC1200_VIDEO_IS_INTERLACED);
     else
         WRITE_VID32(SC1200_VID_ALPHA_CONTROL,
-            control & ~SC1200_VIDEO_IS_INTERLACED);
+                    control & ~SC1200_VIDEO_IS_INTERLACED);
     return (0);
 }
 
@@ -1274,7 +1278,8 @@ gfx_set_color_space_YUV(int enable)
         if (control & SC1200_VIDEO_INPUT_IS_RGB)
             return (GFX_STATUS_UNSUPPORTED);    /* Can't convert video from 
                                                  * RGB to YUV */
-    } else {
+    }
+    else {
         /* RGB BLENDING */
 
         control &= ~SC1200_CSC_GFX_RGB_TO_YUV;  /* Leave graphics in RGB */
@@ -1314,12 +1319,14 @@ gfx_set_vertical_scaler_offset(char offset)
         /* Set shifting value                                   */
         control |= SC1200_VERTICAL_SCALER_SHIFT_EN;
         /* Enable odd frame shifting                   */
-    } else if (offset == 0) {
+    }
+    else if (offset == 0) {
         control &= ~SC1200_VERTICAL_SCALER_SHIFT_EN;
         /* No shifting occurs                                   */
         control &= ~SC1200_VERTICAL_SCALER_SHIFT_MASK;
         /* Clear shifting value                                 */
-    } else
+    }
+    else
         return (GFX_STATUS_BAD_PARAMETER);
     /* TODO: how to program other values ?  */
     WRITE_VID32(SC1200_VID_ALPHA_CONTROL, control);
@@ -1451,18 +1458,20 @@ gfx_set_genlock_enable(int flags)
 #if GFX_VIDEO_DYNAMIC
 int
 sc1200_set_video_cursor(unsigned long key, unsigned long mask,
-    unsigned short select_color2, unsigned long color1, unsigned long color2)
+                        unsigned short select_color2, unsigned long color1,
+                        unsigned long color2)
 #else
 int
 gfx_set_video_cursor(unsigned long key, unsigned long mask,
-    unsigned short select_color2, unsigned long color1, unsigned long color2)
+                     unsigned short select_color2, unsigned long color1,
+                     unsigned long color2)
 #endif
 {
     if (select_color2 > SC1200_CURSOR_COLOR_BITS)
         return GFX_STATUS_BAD_PARAMETER;
     key =
-        (key & SC1200_COLOR_MASK) | ((unsigned long)select_color2 <<
-        SC1200_CURSOR_COLOR_KEY_OFFSET_POS);
+        (key & SC1200_COLOR_MASK) | ((unsigned long) select_color2 <<
+                                     SC1200_CURSOR_COLOR_KEY_OFFSET_POS);
     WRITE_VID32(SC1200_CURSOR_COLOR_KEY, key);
     WRITE_VID32(SC1200_CURSOR_COLOR_MASK, mask);
     WRITE_VID32(SC1200_CURSOR_COLOR_1, color1);
@@ -1488,7 +1497,7 @@ gfx_set_alpha_enable(int enable)
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = SC1200_ALPHA_CONTROL_1 + ((unsigned long)gfx_alpha_select << 4);
+    address = SC1200_ALPHA_CONTROL_1 + ((unsigned long) gfx_alpha_select << 4);
     value = READ_VID32(address);
     if (enable)
         value |= (SC1200_ACTRL_WIN_ENABLE | SC1200_ACTRL_LOAD_ALPHA);
@@ -1509,11 +1518,11 @@ gfx_set_alpha_enable(int enable)
 #if GFX_VIDEO_DYNAMIC
 int
 sc1200_set_alpha_window(short x, short y,
-    unsigned short width, unsigned short height)
+                        unsigned short width, unsigned short height)
 #else
 int
 gfx_set_alpha_window(short x, short y,
-    unsigned short width, unsigned short height)
+                     unsigned short width, unsigned short height)
 #endif
 {
     unsigned long address = 0;
@@ -1532,15 +1541,15 @@ gfx_set_alpha_window(short x, short y,
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = SC1200_ALPHA_XPOS_1 + ((unsigned long)gfx_alpha_select << 4);
+    address = SC1200_ALPHA_XPOS_1 + ((unsigned long) gfx_alpha_select << 4);
 
     /* End positions in register are non-inclusive (one more than the actual 
      * end) */
 
-    WRITE_VID32(address, (unsigned long)x |
-        ((unsigned long)(x + width) << 16));
-    WRITE_VID32(address + 4l, (unsigned long)y |
-        ((unsigned long)(y + height) << 16));
+    WRITE_VID32(address, (unsigned long) x |
+                ((unsigned long) (x + width) << 16));
+    WRITE_VID32(address + 4l, (unsigned long) y |
+                ((unsigned long) (y + height) << 16));
     return (GFX_STATUS_OK);
 }
 
@@ -1565,11 +1574,11 @@ gfx_set_alpha_value(unsigned char alpha, char delta)
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = SC1200_ALPHA_CONTROL_1 + ((unsigned long)gfx_alpha_select << 4);
+    address = SC1200_ALPHA_CONTROL_1 + ((unsigned long) gfx_alpha_select << 4);
     value = READ_VID32(address);
-    value &= SC1200_ACTRL_WIN_ENABLE;  /* keep only enable bit */
-    value |= (unsigned long)alpha;
-    value |= (((unsigned long)delta) & 0xff) << 8;
+    value &= SC1200_ACTRL_WIN_ENABLE;   /* keep only enable bit */
+    value |= (unsigned long) alpha;
+    value |= (((unsigned long) delta) & 0xff) << 8;
     value |= SC1200_ACTRL_LOAD_ALPHA;
     WRITE_VID32(address, value);
 
@@ -1580,12 +1589,12 @@ gfx_set_alpha_value(unsigned char alpha, char delta)
         /* WAIT FOR VERTICAL BLANK TO END */
         if (gfx_test_timing_active()) {
             if (gfx_test_vertical_active())
-                while (gfx_test_vertical_active()) ;
-            while (!gfx_test_vertical_active()) ;
+                while (gfx_test_vertical_active());
+            while (!gfx_test_vertical_active());
         }
         new_value =
-            (unsigned char)((READ_VID32(SC1200_ALPHA_WATCH) >>
-                (gfx_alpha_select << 3)) & 0xff);
+            (unsigned char) ((READ_VID32(SC1200_ALPHA_WATCH) >>
+                              (gfx_alpha_select << 3)) & 0xff);
         if (new_value == alpha)
             return GFX_STATUS_OK;
         if (++loop > 10)
@@ -1619,7 +1628,7 @@ gfx_set_alpha_priority(int priority)
     value = READ_VID32(SC1200_VID_ALPHA_CONTROL);
     pos = 16 + (gfx_alpha_select << 1);
     value &= ~(0x03l << pos);
-    value |= (unsigned long)priority << pos;
+    value |= (unsigned long) priority << pos;
     WRITE_VID32(SC1200_VID_ALPHA_CONTROL, value);
     return (GFX_STATUS_OK);
 }
@@ -1647,7 +1656,7 @@ gfx_set_alpha_color(unsigned long color)
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = SC1200_ALPHA_COLOR_1 + ((unsigned long)gfx_alpha_select << 4);
+    address = SC1200_ALPHA_COLOR_1 + ((unsigned long) gfx_alpha_select << 4);
 
     /* ONLY 24 VALID BITS */
     color &= 0xffffffl;
@@ -1676,7 +1685,7 @@ gfx_set_alpha_color_enable(int enable)
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = SC1200_ALPHA_COLOR_1 + ((unsigned long)gfx_alpha_select << 4);
+    address = SC1200_ALPHA_COLOR_1 + ((unsigned long) gfx_alpha_select << 4);
     color = READ_VID32(address);
     if (enable)
         color |= SC1200_ALPHA_COLOR_ENABLE;
@@ -1712,10 +1721,10 @@ gfx_set_no_ck_outside_alpha(int enable)
     value = READ_VID32(SC1200_VID_ALPHA_CONTROL);
     if (enable)
         WRITE_VID32(SC1200_VID_ALPHA_CONTROL,
-            value | SC1200_NO_CK_OUTSIDE_ALPHA);
+                    value | SC1200_NO_CK_OUTSIDE_ALPHA);
     else
         WRITE_VID32(SC1200_VID_ALPHA_CONTROL,
-            value & ~SC1200_NO_CK_OUTSIDE_ALPHA);
+                    value & ~SC1200_NO_CK_OUTSIDE_ALPHA);
     return (0);
 }
 
@@ -1995,7 +2004,8 @@ gfx_get_video_format(void)
         case SC1200_VCFG_YVYU_FORMAT:
             return VIDEO_FORMAT_Y1Y2Y3Y0;
         }
-    } else {
+    }
+    else {
         switch (vcfg & SC1200_VCFG_VID_INP_FORMAT) {
         case SC1200_VCFG_UYVY_FORMAT:
             return VIDEO_FORMAT_UYVY;
@@ -2158,8 +2168,8 @@ gfx_get_video_downscale_config(unsigned short *type, unsigned short *m)
     unsigned long downscale;
 
     downscale = READ_VID32(SC1200_VIDEO_DOWNSCALER_CONTROL);
-    *m = (unsigned short)((downscale & SC1200_VIDEO_DOWNSCALE_FACTOR_MASK) >>
-        SC1200_VIDEO_DOWNSCALE_FACTOR_POS) + 1;
+    *m = (unsigned short) ((downscale & SC1200_VIDEO_DOWNSCALE_FACTOR_MASK) >>
+                           SC1200_VIDEO_DOWNSCALE_FACTOR_POS) + 1;
 
     switch (downscale & SC1200_VIDEO_DOWNSCALE_TYPE_MASK) {
     case SC1200_VIDEO_DOWNSCALE_TYPE_A:
@@ -2184,28 +2194,32 @@ gfx_get_video_downscale_config(unsigned short *type, unsigned short *m)
 #if GFX_VIDEO_DYNAMIC
 void
 sc1200_get_video_downscale_coefficients(unsigned short *coef1,
-    unsigned short *coef2, unsigned short *coef3, unsigned short *coef4)
+                                        unsigned short *coef2,
+                                        unsigned short *coef3,
+                                        unsigned short *coef4)
 #else
 void
 gfx_get_video_downscale_coefficients(unsigned short *coef1,
-    unsigned short *coef2, unsigned short *coef3, unsigned short *coef4)
+                                     unsigned short *coef2,
+                                     unsigned short *coef3,
+                                     unsigned short *coef4)
 #endif
 {
     unsigned long coef;
 
     coef = READ_VID32(SC1200_VIDEO_DOWNSCALER_COEFFICIENTS);
     *coef1 =
-        (unsigned short)((coef >> SC1200_VIDEO_DOWNSCALER_COEF1_POS) &
-        SC1200_VIDEO_DOWNSCALER_COEF_MASK);
+        (unsigned short) ((coef >> SC1200_VIDEO_DOWNSCALER_COEF1_POS) &
+                          SC1200_VIDEO_DOWNSCALER_COEF_MASK);
     *coef2 =
-        (unsigned short)((coef >> SC1200_VIDEO_DOWNSCALER_COEF2_POS) &
-        SC1200_VIDEO_DOWNSCALER_COEF_MASK);
+        (unsigned short) ((coef >> SC1200_VIDEO_DOWNSCALER_COEF2_POS) &
+                          SC1200_VIDEO_DOWNSCALER_COEF_MASK);
     *coef3 =
-        (unsigned short)((coef >> SC1200_VIDEO_DOWNSCALER_COEF3_POS) &
-        SC1200_VIDEO_DOWNSCALER_COEF_MASK);
+        (unsigned short) ((coef >> SC1200_VIDEO_DOWNSCALER_COEF3_POS) &
+                          SC1200_VIDEO_DOWNSCALER_COEF_MASK);
     *coef4 =
-        (unsigned short)((coef >> SC1200_VIDEO_DOWNSCALER_COEF4_POS) &
-        SC1200_VIDEO_DOWNSCALER_COEF_MASK);
+        (unsigned short) ((coef >> SC1200_VIDEO_DOWNSCALER_COEF4_POS) &
+                          SC1200_VIDEO_DOWNSCALER_COEF_MASK);
     return;
 }
 
@@ -2282,10 +2296,10 @@ gfx_get_video_position(void)
     /* Use routines to abstract version of display controller. */
 
     hadjust =
-        (unsigned long)gfx_get_htotal() - (unsigned long)gfx_get_hsync_end() -
+        (unsigned long) gfx_get_htotal() - (unsigned long) gfx_get_hsync_end() -
         14l;
     vadjust =
-        (unsigned long)gfx_get_vtotal() - (unsigned long)gfx_get_vsync_end() +
+        (unsigned long) gfx_get_vtotal() - (unsigned long) gfx_get_vsync_end() +
         1l;
     xpos -= hadjust;
     ypos -= vadjust;
@@ -2385,7 +2399,7 @@ gfx_get_video_request(short *x, short *y)
 {
     int request = 0;
 
-    request = (int)(READ_VID32(SC1200_VIDEO_REQUEST));
+    request = (int) (READ_VID32(SC1200_VIDEO_REQUEST));
     *x = (request >> SC1200_VIDEO_X_REQUEST_POS) & SC1200_VIDEO_REQUEST_MASK;
     *y = (request >> SC1200_VIDEO_Y_REQUEST_POS) & SC1200_VIDEO_REQUEST_MASK;
 
@@ -2465,9 +2479,9 @@ gfx_get_vbi_lines(int odd)
 {
     if (odd)
         return (READ_VID32(SC1200_VIDEO_ODD_VBI_LINE_ENABLE) &
-            SC1200_VIDEO_VBI_LINE_ENABLE_MASK);
+                SC1200_VIDEO_VBI_LINE_ENABLE_MASK);
     return (READ_VID32(SC1200_VIDEO_EVEN_VBI_LINE_ENABLE) &
-        SC1200_VIDEO_VBI_LINE_ENABLE_MASK);
+            SC1200_VIDEO_VBI_LINE_ENABLE_MASK);
 }
 
 /*---------------------------------------------------------------------------
@@ -2486,9 +2500,9 @@ gfx_get_vbi_total(int odd)
 {
     if (odd)
         return (READ_VID32(SC1200_VIDEO_ODD_VBI_TOTAL_COUNT) &
-            SC1200_VIDEO_VBI_TOTAL_COUNT_MASK);
+                SC1200_VIDEO_VBI_TOTAL_COUNT_MASK);
     return (READ_VID32(SC1200_VIDEO_EVEN_VBI_TOTAL_COUNT) &
-        SC1200_VIDEO_VBI_TOTAL_COUNT_MASK);
+            SC1200_VIDEO_VBI_TOTAL_COUNT_MASK);
 }
 
 /*---------------------------------------------------------------------------
@@ -2564,7 +2578,8 @@ gfx_get_vertical_scaler_offset(char *offset)
         else
             return GFX_STATUS_ERROR;
         /* TODO: find the interpretation of other values */
-    } else
+    }
+    else
         *offset = 0;
     return (0);
 }
@@ -2619,24 +2634,24 @@ gfx_get_genlock_enable(void)
 #if GFX_VIDEO_DYNAMIC
 int
 sc1200_get_video_cursor(unsigned long *key, unsigned long *mask,
-    unsigned short *select_color2, unsigned long *color1,
-    unsigned short *color2)
+                        unsigned short *select_color2, unsigned long *color1,
+                        unsigned short *color2)
 #else
 int
 gfx_get_video_cursor(unsigned long *key, unsigned long *mask,
-    unsigned short *select_color2, unsigned long *color1,
-    unsigned short *color2)
+                     unsigned short *select_color2, unsigned long *color1,
+                     unsigned short *color2)
 #endif
 {
     *select_color2 =
-        (unsigned short)(READ_VID32(SC1200_CURSOR_COLOR_KEY) >>
-        SC1200_CURSOR_COLOR_KEY_OFFSET_POS);
+        (unsigned short) (READ_VID32(SC1200_CURSOR_COLOR_KEY) >>
+                          SC1200_CURSOR_COLOR_KEY_OFFSET_POS);
     *key = READ_VID32(SC1200_CURSOR_COLOR_KEY) & SC1200_COLOR_MASK;
     *mask = READ_VID32(SC1200_CURSOR_COLOR_MASK) & SC1200_COLOR_MASK;
     *color1 = READ_VID32(SC1200_CURSOR_COLOR_1) & SC1200_COLOR_MASK;
     *color2 =
-        (unsigned short)(READ_VID32(SC1200_CURSOR_COLOR_2) &
-        SC1200_COLOR_MASK);
+        (unsigned short) (READ_VID32(SC1200_CURSOR_COLOR_2) &
+                          SC1200_COLOR_MASK);
     return (0);
 }
 
@@ -2661,7 +2676,7 @@ gfx_read_crc(void)
     if (gfx_test_timing_active()) {
         /* WAIT UNTIL ACTIVE DISPLAY */
 
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
 
         /* RESET CRC DURING ACTIVE DISPLAY */
 
@@ -2670,10 +2685,10 @@ gfx_read_crc(void)
 
         /* WAIT UNTIL NOT ACTIVE, THEN ACTIVE, NOT ACTIVE, THEN ACTIVE */
 
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
         crc = READ_VID32(SC1200_VID_CRC) >> 8;
     }
     return (crc);
@@ -2720,7 +2735,7 @@ gfx_get_alpha_enable(int *enable)
     if (gfx_alpha_select <= 2) {
         value =
             READ_VID32(SC1200_ALPHA_CONTROL_1 +
-            ((unsigned long)gfx_alpha_select << 4));
+                       ((unsigned long) gfx_alpha_select << 4));
         if (value & SC1200_ACTRL_WIN_ENABLE)
             *enable = 1;
     }
@@ -2736,11 +2751,11 @@ gfx_get_alpha_enable(int *enable)
 #if GFX_VIDEO_DYNAMIC
 void
 sc1200_get_alpha_size(unsigned short *x, unsigned short *y,
-    unsigned short *width, unsigned short *height)
+                      unsigned short *width, unsigned short *height)
 #else
 void
 gfx_get_alpha_size(unsigned short *x, unsigned short *y,
-    unsigned short *width, unsigned short *height)
+                   unsigned short *width, unsigned short *height)
 #endif
 {
     unsigned long value = 0;
@@ -2752,14 +2767,14 @@ gfx_get_alpha_size(unsigned short *x, unsigned short *y,
     if (gfx_alpha_select <= 2) {
         value =
             READ_VID32(SC1200_ALPHA_XPOS_1 +
-            ((unsigned long)gfx_alpha_select << 4));
-        *x = (unsigned short)(value & 0x000007FF);
-        *width = (unsigned short)((value >> 16) & 0x000007FF) - *x;
+                       ((unsigned long) gfx_alpha_select << 4));
+        *x = (unsigned short) (value & 0x000007FF);
+        *width = (unsigned short) ((value >> 16) & 0x000007FF) - *x;
         value =
             READ_VID32(SC1200_ALPHA_YPOS_1 +
-            ((unsigned long)gfx_alpha_select << 4));
-        *y = (unsigned short)(value & 0x000007FF);
-        *height = (unsigned short)((value >> 16) & 0x000007FF) - *y;
+                       ((unsigned long) gfx_alpha_select << 4));
+        *y = (unsigned short) (value & 0x000007FF);
+        *height = (unsigned short) ((value >> 16) & 0x000007FF) - *y;
     }
     *x -= gfx_get_htotal() - gfx_get_hsync_end() - 2;
     *y -= gfx_get_vtotal() - gfx_get_vsync_end() + 1;
@@ -2788,9 +2803,9 @@ gfx_get_alpha_value(unsigned char *alpha, char *delta)
     if (gfx_alpha_select <= 2) {
         value =
             READ_VID32(SC1200_ALPHA_CONTROL_1 +
-            ((unsigned long)gfx_alpha_select << 4));
-        *alpha = (unsigned char)(value & 0x00FF);
-        *delta = (char)((value >> 8) & 0x00FF);
+                       ((unsigned long) gfx_alpha_select << 4));
+        *alpha = (unsigned char) (value & 0x00FF);
+        *delta = (char) ((value >> 8) & 0x00FF);
     }
     return;
 }
@@ -2815,7 +2830,7 @@ gfx_get_alpha_priority(int *priority)
     if (gfx_alpha_select <= 2) {
         value = READ_VID32(SC1200_VID_ALPHA_CONTROL);
         pos = 16 + (gfx_alpha_select << 1);
-        *priority = (int)((value >> pos) & 3);
+        *priority = (int) ((value >> pos) & 3);
     }
     return;
 }
@@ -2839,11 +2854,11 @@ gfx_get_alpha_color(unsigned long *color)
     if (gfx_alpha_select <= 2) {
         *color =
             READ_VID32(SC1200_ALPHA_COLOR_1 +
-            ((unsigned long)gfx_alpha_select << 4));
+                       ((unsigned long) gfx_alpha_select << 4));
     }
     return;
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
 /* END OF FILE */
diff --git a/src/gfx/vid_5530.c b/src/gfx/vid_5530.c
index 40e3ffc..f524300 100644
--- a/src/gfx/vid_5530.c
+++ b/src/gfx/vid_5530.c
@@ -31,50 +31,49 @@
  * CS5530 PLL TABLE
  *----------------------------------------------------------------------------
  */
-typedef struct tagCS5530PLLENTRY
-{
-    long frequency;                    /* 16.16 fixed point frequency */
-    unsigned long pll_value;           /* associated register value */
+typedef struct tagCS5530PLLENTRY {
+    long frequency;             /* 16.16 fixed point frequency */
+    unsigned long pll_value;    /* associated register value */
 } CS5530PLLENTRY;
 
 CS5530PLLENTRY CS5530_PLLtable[] = {
-    {0x00192CCC, 0x31C45801,},         /*  25.1750 */
-    {0x001C526E, 0x20E36802,},         /*  28.3220 */
-    {0x001F8000, 0x33915801,},         /*  31.5000 */
-    {0x00240000, 0x31EC4801,},         /*  36.0000 */
-    {0x00258000, 0x21E22801,},         /*  37.5000 */
-    {0x00280000, 0x33088801,},         /*  40.0000 */
-    {0x002CE666, 0x33E22801,},         /*  44.9000 */
-    {0x00318000, 0x336C4801,},         /*  49.5000 */
-    {0x00320000, 0x23088801,},         /*  50.0000 */
-    {0x00325999, 0x23088801,},         /*  50.3500 */
-    {0x00360000, 0x3708A801,},         /*  54.0000 */
-    {0x00384000, 0x23E36802,},         /*  56.2500 */
-    {0x0038643F, 0x23E36802,},         /*  56.3916 */
-    {0x0038A4DD, 0x23E36802,},         /*  56.6444 */
-    {0x003B0000, 0x37C45801,},         /*  59.0000 */
-    {0x003F0000, 0x23EC4801,},         /*  63.0000 */
-    {0x00410000, 0x37911801,},         /*  65.0000 */
-    {0x00438000, 0x37963803,},         /*  67.5000 */
-    {0x0046CCCC, 0x37058803,},         /*  70.8000 */
-    {0x00480000, 0x3710C805,},         /*  72.0000 */
-    {0x004B0000, 0x37E22801,},         /*  75.0000 */
-    {0x004EC000, 0x27915801,},         /*  78.7500 */
-    {0x00500000, 0x37D8D802,},         /*  80.0000 */
-    {0x0059CCCC, 0x27588802,},         /*  89.8000 */
-    {0x005E8000, 0x27EC4802,},         /*  94.5000 */
-    {0x00630000, 0x27AC6803,},         /*  99.0000 */
-    {0x00640000, 0x27088801,},         /* 100.0000 */
-    {0x006C0000, 0x2710C805,},         /* 108.0000 */
-    {0x00708000, 0x27E36802,},         /* 112.5000 */
-    {0x00820000, 0x27C58803,},         /* 130.0000 */
-    {0x00870000, 0x27316803,},         /* 135.0000 */
-    {0x009D8000, 0x2F915801,},         /* 157.5000 */
-    {0x00A20000, 0x2F08A801,},         /* 162.0000 */
-    {0x00AF0000, 0x2FB11802,},         /* 175.0000 */
-    {0x00BD0000, 0x2FEC4802,},         /* 189.0000 */
-    {0x00CA0000, 0x2F963803,},         /* 202.0000 */
-    {0x00E80000, 0x2FB1B802,},         /* 232.0000 */
+    {0x00192CCC, 0x31C45801,},  /*  25.1750 */
+    {0x001C526E, 0x20E36802,},  /*  28.3220 */
+    {0x001F8000, 0x33915801,},  /*  31.5000 */
+    {0x00240000, 0x31EC4801,},  /*  36.0000 */
+    {0x00258000, 0x21E22801,},  /*  37.5000 */
+    {0x00280000, 0x33088801,},  /*  40.0000 */
+    {0x002CE666, 0x33E22801,},  /*  44.9000 */
+    {0x00318000, 0x336C4801,},  /*  49.5000 */
+    {0x00320000, 0x23088801,},  /*  50.0000 */
+    {0x00325999, 0x23088801,},  /*  50.3500 */
+    {0x00360000, 0x3708A801,},  /*  54.0000 */
+    {0x00384000, 0x23E36802,},  /*  56.2500 */
+    {0x0038643F, 0x23E36802,},  /*  56.3916 */
+    {0x0038A4DD, 0x23E36802,},  /*  56.6444 */
+    {0x003B0000, 0x37C45801,},  /*  59.0000 */
+    {0x003F0000, 0x23EC4801,},  /*  63.0000 */
+    {0x00410000, 0x37911801,},  /*  65.0000 */
+    {0x00438000, 0x37963803,},  /*  67.5000 */
+    {0x0046CCCC, 0x37058803,},  /*  70.8000 */
+    {0x00480000, 0x3710C805,},  /*  72.0000 */
+    {0x004B0000, 0x37E22801,},  /*  75.0000 */
+    {0x004EC000, 0x27915801,},  /*  78.7500 */
+    {0x00500000, 0x37D8D802,},  /*  80.0000 */
+    {0x0059CCCC, 0x27588802,},  /*  89.8000 */
+    {0x005E8000, 0x27EC4802,},  /*  94.5000 */
+    {0x00630000, 0x27AC6803,},  /*  99.0000 */
+    {0x00640000, 0x27088801,},  /* 100.0000 */
+    {0x006C0000, 0x2710C805,},  /* 108.0000 */
+    {0x00708000, 0x27E36802,},  /* 112.5000 */
+    {0x00820000, 0x27C58803,},  /* 130.0000 */
+    {0x00870000, 0x27316803,},  /* 135.0000 */
+    {0x009D8000, 0x2F915801,},  /* 157.5000 */
+    {0x00A20000, 0x2F08A801,},  /* 162.0000 */
+    {0x00AF0000, 0x2FB11802,},  /* 175.0000 */
+    {0x00BD0000, 0x2FEC4802,},  /* 189.0000 */
+    {0x00CA0000, 0x2F963803,},  /* 202.0000 */
+    {0x00E80000, 0x2FB1B802,},  /* 232.0000 */
 };
 
 #define NUM_CS5530_FREQUENCIES sizeof(CS5530_PLLtable)/sizeof(CS5530PLLENTRY)
@@ -98,36 +97,36 @@ gfx_set_crt_enable(int enable)
     config = READ_VID32(CS5530_DISPLAY_CONFIG);
 
     switch (enable) {
-    case CRT_DISABLE:                 /* Disable everything */
+    case CRT_DISABLE:          /* Disable everything */
 
         WRITE_VID32(CS5530_DISPLAY_CONFIG,
-            config & ~(CS5530_DCFG_DIS_EN | CS5530_DCFG_HSYNC_EN |
-                CS5530_DCFG_VSYNC_EN | CS5530_DCFG_DAC_BL_EN |
-                CS5530_DCFG_DAC_PWDNX));
+                    config & ~(CS5530_DCFG_DIS_EN | CS5530_DCFG_HSYNC_EN |
+                               CS5530_DCFG_VSYNC_EN | CS5530_DCFG_DAC_BL_EN |
+                               CS5530_DCFG_DAC_PWDNX));
         break;
 
-    case CRT_ENABLE:                  /* Enable CRT display, including display logic */
+    case CRT_ENABLE:           /* Enable CRT display, including display logic */
 
         WRITE_VID32(CS5530_DISPLAY_CONFIG,
-            config | CS5530_DCFG_DIS_EN | CS5530_DCFG_HSYNC_EN |
-            CS5530_DCFG_VSYNC_EN | CS5530_DCFG_DAC_BL_EN |
-            CS5530_DCFG_DAC_PWDNX);
+                    config | CS5530_DCFG_DIS_EN | CS5530_DCFG_HSYNC_EN |
+                    CS5530_DCFG_VSYNC_EN | CS5530_DCFG_DAC_BL_EN |
+                    CS5530_DCFG_DAC_PWDNX);
         break;
 
-    case CRT_STANDBY:                 /* HSync:Off VSync:On */
+    case CRT_STANDBY:          /* HSync:Off VSync:On */
 
         WRITE_VID32(CS5530_DISPLAY_CONFIG,
-            (config & ~(CS5530_DCFG_DIS_EN | CS5530_DCFG_HSYNC_EN |
-                    CS5530_DCFG_DAC_BL_EN | CS5530_DCFG_DAC_PWDNX))
-            | CS5530_DCFG_VSYNC_EN);
+                    (config & ~(CS5530_DCFG_DIS_EN | CS5530_DCFG_HSYNC_EN |
+                                CS5530_DCFG_DAC_BL_EN | CS5530_DCFG_DAC_PWDNX))
+                    | CS5530_DCFG_VSYNC_EN);
         break;
 
-    case CRT_SUSPEND:                 /* HSync:On VSync:Off */
+    case CRT_SUSPEND:          /* HSync:On VSync:Off */
 
         WRITE_VID32(CS5530_DISPLAY_CONFIG,
-            (config & ~(CS5530_DCFG_DIS_EN | CS5530_DCFG_VSYNC_EN |
-                    CS5530_DCFG_DAC_BL_EN | CS5530_DCFG_DAC_PWDNX))
-            | CS5530_DCFG_HSYNC_EN);
+                    (config & ~(CS5530_DCFG_DIS_EN | CS5530_DCFG_VSYNC_EN |
+                                CS5530_DCFG_DAC_BL_EN | CS5530_DCFG_DAC_PWDNX))
+                    | CS5530_DCFG_HSYNC_EN);
         break;
 
     default:
@@ -161,10 +160,10 @@ gfx_reset_video(void)
     gfx_set_display_video_size(0, 0);
 
     if (gfx_test_timing_active()) {
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
     }
 }
 
@@ -200,13 +199,13 @@ gfx_set_display_control(int sync_polarities)
     /* CLEAR RELEVANT FIELDS */
 
     dcfg &= ~(CS5530_DCFG_CRT_SYNC_SKW_MASK | CS5530_DCFG_PWR_SEQ_DLY_MASK |
-        CS5530_DCFG_CRT_HSYNC_POL | CS5530_DCFG_CRT_VSYNC_POL |
-        CS5530_DCFG_FP_PWR_EN | CS5530_DCFG_FP_DATA_EN);
+              CS5530_DCFG_CRT_HSYNC_POL | CS5530_DCFG_CRT_VSYNC_POL |
+              CS5530_DCFG_FP_PWR_EN | CS5530_DCFG_FP_DATA_EN);
 
     /* INITIALIZATION */
 
     dcfg |= (CS5530_DCFG_CRT_SYNC_SKW_INIT |
-        CS5530_DCFG_PWR_SEQ_DLY_INIT | CS5530_DCFG_GV_PAL_BYP);
+             CS5530_DCFG_PWR_SEQ_DLY_INIT | CS5530_DCFG_GV_PAL_BYP);
 
     if (PanelEnable) {
         dcfg |= CS5530_DCFG_FP_PWR_EN;
@@ -248,11 +247,11 @@ gfx_set_clock_frequency(unsigned long frequency)
     /* Search the table for the closest frequency (16.16 format). */
 
     value = CS5530_PLLtable[0].pll_value;
-    min = (long)CS5530_PLLtable[0].frequency - frequency;
+    min = (long) CS5530_PLLtable[0].frequency - frequency;
     if (min < 0L)
         min = -min;
     for (index = 1; index < NUM_CS5530_FREQUENCIES; index++) {
-        diff = (long)CS5530_PLLtable[index].frequency - frequency;
+        diff = (long) CS5530_PLLtable[index].frequency - frequency;
         if (diff < 0L)
             diff = -diff;
         if (diff < min) {
@@ -266,7 +265,7 @@ gfx_set_clock_frequency(unsigned long frequency)
     WRITE_VID32(CS5530_DOT_CLK_CONFIG, value);
     WRITE_VID32(CS5530_DOT_CLK_CONFIG, value | 0x80000100);
     /* set reset/bypass             */
-    gfx_delay_milliseconds(1);         /* wait for PLL to settle       */
+    gfx_delay_milliseconds(1);  /* wait for PLL to settle       */
     WRITE_VID32(CS5530_DOT_CLK_CONFIG, value & 0x7FFFFFFF);
     /* clear reset                          */
     WRITE_VID32(CS5530_DOT_CLK_CONFIG, value & 0x7FFFFEFF);
@@ -295,9 +294,9 @@ gfx_set_video_enable(int enable)
 
     if (gfx_test_timing_active()) {
         if (!gfx_test_vertical_active()) {
-            while (!gfx_test_vertical_active()) ;
+            while (!gfx_test_vertical_active());
         }
-        while (gfx_test_vertical_active()) ;
+        while (gfx_test_vertical_active());
     }
     vcfg = READ_VID32(CS5530_VIDEO_CONFIG);
     if (enable) {
@@ -311,7 +310,8 @@ gfx_set_video_enable(int enable)
 
         vcfg |= CS5530_VCFG_VID_EN;
         WRITE_VID32(CS5530_VIDEO_CONFIG, vcfg);
-    } else {
+    }
+    else {
         /* DISABLE CS5530 VIDEO OVERLAY */
 
         vcfg &= ~CS5530_VCFG_VID_EN;
@@ -431,11 +431,11 @@ gfx_set_video_offset(unsigned long offset)
 #if GFX_VIDEO_DYNAMIC
 int
 cs5530_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                       unsigned short dstw, unsigned short dsth)
 #else
 int
 gfx_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                    unsigned short dstw, unsigned short dsth)
 #endif
 {
     unsigned long xscale, yscale;
@@ -471,7 +471,7 @@ gfx_set_video_scale(unsigned short srcw, unsigned short srch,
     /* amount of data that needs to be transferred. */
 
     gfx_set_video_window(gfx_vid_xpos, gfx_vid_ypos, gfx_vid_width,
-        gfx_vid_height);
+                         gfx_vid_height);
     return (0);
 }
 
@@ -514,11 +514,12 @@ gfx_set_video_window(short x, short y, unsigned short w, unsigned short h)
     /* LEFT CLIPPING */
 
     if (x < 0) {
-        gfx_set_video_left_crop((unsigned short)(-x));
+        gfx_set_video_left_crop((unsigned short) (-x));
         xstart = hadjust;
-    } else {
+    }
+    else {
         gfx_set_video_left_crop(0);
-        xstart = (unsigned long)x + hadjust;
+        xstart = (unsigned long) x + hadjust;
     }
 
     /* CLIPPING ON RIGHT */
@@ -533,7 +534,8 @@ gfx_set_video_window(short x, short y, unsigned short w, unsigned short h)
     offset = gfx_vid_offset;
     if (y >= 0) {
         ystart = y + vadjust;
-    } else {
+    }
+    else {
         ystart = vadjust;
         line_size = (READ_VID32(CS5530_VIDEO_CONFIG) >> 7) & 0x000001FE;
         if (READ_VID32(CS5530_VIDEO_CONFIG) & CS5530_VCFG_LINE_SIZE_UPPER)
@@ -595,7 +597,7 @@ gfx_set_video_left_crop(unsigned short x)
     /* Adjust initial read for scale, checking for divide by zero */
 
     if (gfx_vid_dstw)
-        initread = (unsigned long)x *gfx_vid_srcw / gfx_vid_dstw;
+        initread = (unsigned long) x *gfx_vid_srcw / gfx_vid_dstw;
 
     else
         initread = 0;
@@ -626,8 +628,7 @@ gfx_set_video_left_crop(unsigned short x)
  */
 #if GFX_VIDEO_DYNAMIC
 int
-cs5530_set_video_color_key(unsigned long key, unsigned long mask,
-    int graphics)
+cs5530_set_video_color_key(unsigned long key, unsigned long mask, int graphics)
 #else
 int
 gfx_set_video_color_key(unsigned long key, unsigned long mask, int graphics)
@@ -1057,7 +1058,7 @@ gfx_get_video_format(void)
     if (vcfg & CS5530_VCFG_4_2_0_MODE)
         return (VIDEO_FORMAT_Y0Y1Y2Y3);
 
-    return ((int)((vcfg >> 2) & 3));
+    return ((int) ((vcfg >> 2) & 3));
 }
 
 /*----------------------------------------------------------------------------
@@ -1331,7 +1332,7 @@ gfx_read_crc(void)
     if (gfx_test_timing_active()) {
         /* WAIT UNTIL ACTIVE DISPLAY */
 
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
 
         /* RESET CRC DURING ACTIVE DISPLAY */
 
@@ -1340,15 +1341,15 @@ gfx_read_crc(void)
 
         /* WAIT UNTIL NOT ACTIVE, THEN ACTIVE, NOT ACTIVE, THEN ACTIVE */
 
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
         crc = READ_VID32(CS5530_CRCSIG_TFT_TV) >> 8;
     }
     return (crc);
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
 /* END OF FILE */
diff --git a/src/gfx/vid_rdcl.c b/src/gfx/vid_rdcl.c
index 7c98d2d..3ccc57a 100644
--- a/src/gfx/vid_rdcl.c
+++ b/src/gfx/vid_rdcl.c
@@ -76,74 +76,73 @@ unsigned long gfx_gamma_ram_redcloud[] = {
 
 /* REDCLOUD PLL TABLE  */
 
-typedef struct RCDFPLL
-{
-    long frequency;                    /* 16.16 fixed point frequency                  */
-    unsigned long post_div3;           /* MCP Frequency dividers and multipliers       */
+typedef struct RCDFPLL {
+    long frequency;             /* 16.16 fixed point frequency                  */
+    unsigned long post_div3;    /* MCP Frequency dividers and multipliers       */
     unsigned long pre_mul2;
     unsigned long pre_div2;
-    unsigned long pll_value;           /* MCP DotPLL Register Upper 32(0x0015)         */
+    unsigned long pll_value;    /* MCP DotPLL Register Upper 32(0x0015)         */
 } RCDFPLLENTRY;
 
 RCDFPLLENTRY RCDF_PLLtable[] = {
-    {0x0018EC4D, 1, 0, 0, 0x0000099E}, /*  24.9230 */
-    {0x00192CCC, 0, 0, 0, 0x00000037}, /*  25.1750 */
-    {0x001C526E, 1, 0, 0, 0x000009DA}, /*  28.3220 */
-    {0x001C8F5C, 1, 0, 0, 0x0000005E}, /*  28.5600 */
-    {0x001F8000, 1, 0, 0, 0x000002D2}, /*  31.5000 */
-    {0x00240000, 1, 0, 0, 0x000007E2}, /*  36.0000 */
-    {0x00258000, 1, 0, 0, 0x0000057A}, /*  37.5000 */
-    {0x0025E395, 1, 0, 0, 0x000007FA}, /*  37.8890 */
-    {0x00280000, 1, 0, 0, 0x0000030A}, /*  40.0000 */
-    {0x002B29BA, 0, 0, 0, 0x0000005F}, /*  43.1630 */
-    {0x002CE666, 0, 0, 0, 0x00000063}, /*  44.9000 */
-    {0x002DB851, 1, 0, 0, 0x00000BC9}, /*  45.7200 */
-    {0x00318000, 0, 0, 0, 0x0000054B}, /*  49.5000 */
-    {0x00320000, 0, 0, 0, 0x0000006F}, /*  50.0000 */
-    {0x00325999, 0, 1, 0, 0x00000037}, /*  50.3500 */
-    {0x00360000, 1, 1, 0, 0x00000B0D}, /*  54.0000 */
-    {0x00384000, 0, 0, 0, 0x000007F7}, /*  56.2500 */
-    {0x0038643F, 0, 0, 0, 0x000007F7}, /*  56.3916 */
-    {0x0038A4DD, 0, 0, 0, 0x0000057B}, /*  56.6444 */
-    {0x003B0000, 0, 1, 0, 0x00000707}, /*  59.0000 */
-    {0x003C10A3, 0, 0, 0, 0x0000030B}, /*  60.0650 */
-    {0x003F0000, 1, 1, 0, 0x00000B39}, /*  63.0000 */
-    {0x00410000, 1, 0, 0, 0x00000545}, /*  65.0000 */
-    {0x00442DD2, 1, 0, 0, 0x000002E1}, /*  68.1790 */
-    {0x00438000, 1, 1, 0, 0x00000FC1}, /*  67.5000 */
-    {0x0046CCCC, 1, 0, 0, 0x00000561}, /*  70.8000 */
-    {0x00480000, 1, 0, 0, 0x000007E1}, /*  72.0000 */
-    {0x004A7B22, 0, 1, 0, 0x00000F4A}, /*  74.4810 */
-    {0x004B0000, 1, 0, 0, 0x000007F5}, /*  75.0000 */
-    {0x004EC000, 1, 0, 0, 0x00000305}, /*  78.7500 */
-    {0x00500000, 1, 1, 0, 0x00000709}, /*  80.0000 */
-    {0x00519999, 0, 0, 0, 0x000009C6}, /*  81.6000 */
-    {0x0059CCCC, 0, 1, 0, 0x00000262}, /*  89.8000 */
-    {0x005E8000, 0, 0, 0, 0x000002D2}, /*  94.5000 */
-    {0x00618560, 0, 0, 0, 0x00000546}, /*  97.5200 */
-    {0x00630000, 0, 1, 0, 0x00000B4A}, /*  99.0000 */
-    {0x00642FDF, 0, 0, 0, 0x0000006E}, /* 100.1870 */
-    {0x00656B85, 0, 0, 0, 0x00000552}, /* 101.4200 */
-    {0x006C0000, 0, 0, 0, 0x000007E2}, /* 108.0000 */
-    {0x00708000, 0, 0, 0, 0x000007F6}, /* 112.5000 */
-    {0x00714F1A, 0, 0, 0, 0x0000057A}, /* 113.3090 */
-    {0x0077A666, 0, 0, 0, 0x0000030A}, /* 119.6500 */
-    {0x00806666, 1, 0, 0, 0x00000068}, /* 128.4000 */
-    {0x00820000, 1, 1, 0, 0x00000FB0}, /* 130.0000 */
-    {0x00821999, 1, 0, 0, 0x00000544}, /* 130.1000 */
-    {0x00858000, 1, 0, 0, 0x0000006C}, /* 133.5000 */
-    {0x00870000, 1, 0, 0, 0x00000550}, /* 135.0000 */
-    {0x00906147, 1, 0, 0, 0x000007E0}, /* 144.3800 */
-    {0x009D8000, 1, 0, 0, 0x00000304}, /* 157.5000 */
-    {0x00A20000, 0, 0, 0, 0x000002B1}, /* 162.0000 */
-    {0x00A933F7, 0, 0, 0, 0x000002B9}, /* 169.2030 */
-    {0x00ACCC49, 0, 1, 0, 0x0000002D}, /* 172.798  */
-    {0x00AF8000, 0, 0, 0, 0x000002C1}, /* 175.5000 */
-    {0x00BD0000, 0, 0, 0, 0x000002D1}, /* 189.0000 */
-    {0x00BEF5C2, 0, 0, 0, 0x0000053D}, /* 190.9600 */
-    {0x00C60000, 0, 0, 0, 0x00000549}, /* 198.0000 */
-    {0x00CA8000, 0, 0, 0, 0x00000551}, /* 202.5000 */
-    {0x00E58000, 0, 0, 0, 0x0000057D}, /* 229.5000 */
+    {0x0018EC4D, 1, 0, 0, 0x0000099E},  /*  24.9230 */
+    {0x00192CCC, 0, 0, 0, 0x00000037},  /*  25.1750 */
+    {0x001C526E, 1, 0, 0, 0x000009DA},  /*  28.3220 */
+    {0x001C8F5C, 1, 0, 0, 0x0000005E},  /*  28.5600 */
+    {0x001F8000, 1, 0, 0, 0x000002D2},  /*  31.5000 */
+    {0x00240000, 1, 0, 0, 0x000007E2},  /*  36.0000 */
+    {0x00258000, 1, 0, 0, 0x0000057A},  /*  37.5000 */
+    {0x0025E395, 1, 0, 0, 0x000007FA},  /*  37.8890 */
+    {0x00280000, 1, 0, 0, 0x0000030A},  /*  40.0000 */
+    {0x002B29BA, 0, 0, 0, 0x0000005F},  /*  43.1630 */
+    {0x002CE666, 0, 0, 0, 0x00000063},  /*  44.9000 */
+    {0x002DB851, 1, 0, 0, 0x00000BC9},  /*  45.7200 */
+    {0x00318000, 0, 0, 0, 0x0000054B},  /*  49.5000 */
+    {0x00320000, 0, 0, 0, 0x0000006F},  /*  50.0000 */
+    {0x00325999, 0, 1, 0, 0x00000037},  /*  50.3500 */
+    {0x00360000, 1, 1, 0, 0x00000B0D},  /*  54.0000 */
+    {0x00384000, 0, 0, 0, 0x000007F7},  /*  56.2500 */
+    {0x0038643F, 0, 0, 0, 0x000007F7},  /*  56.3916 */
+    {0x0038A4DD, 0, 0, 0, 0x0000057B},  /*  56.6444 */
+    {0x003B0000, 0, 1, 0, 0x00000707},  /*  59.0000 */
+    {0x003C10A3, 0, 0, 0, 0x0000030B},  /*  60.0650 */
+    {0x003F0000, 1, 1, 0, 0x00000B39},  /*  63.0000 */
+    {0x00410000, 1, 0, 0, 0x00000545},  /*  65.0000 */
+    {0x00442DD2, 1, 0, 0, 0x000002E1},  /*  68.1790 */
+    {0x00438000, 1, 1, 0, 0x00000FC1},  /*  67.5000 */
+    {0x0046CCCC, 1, 0, 0, 0x00000561},  /*  70.8000 */
+    {0x00480000, 1, 0, 0, 0x000007E1},  /*  72.0000 */
+    {0x004A7B22, 0, 1, 0, 0x00000F4A},  /*  74.4810 */
+    {0x004B0000, 1, 0, 0, 0x000007F5},  /*  75.0000 */
+    {0x004EC000, 1, 0, 0, 0x00000305},  /*  78.7500 */
+    {0x00500000, 1, 1, 0, 0x00000709},  /*  80.0000 */
+    {0x00519999, 0, 0, 0, 0x000009C6},  /*  81.6000 */
+    {0x0059CCCC, 0, 1, 0, 0x00000262},  /*  89.8000 */
+    {0x005E8000, 0, 0, 0, 0x000002D2},  /*  94.5000 */
+    {0x00618560, 0, 0, 0, 0x00000546},  /*  97.5200 */
+    {0x00630000, 0, 1, 0, 0x00000B4A},  /*  99.0000 */
+    {0x00642FDF, 0, 0, 0, 0x0000006E},  /* 100.1870 */
+    {0x00656B85, 0, 0, 0, 0x00000552},  /* 101.4200 */
+    {0x006C0000, 0, 0, 0, 0x000007E2},  /* 108.0000 */
+    {0x00708000, 0, 0, 0, 0x000007F6},  /* 112.5000 */
+    {0x00714F1A, 0, 0, 0, 0x0000057A},  /* 113.3090 */
+    {0x0077A666, 0, 0, 0, 0x0000030A},  /* 119.6500 */
+    {0x00806666, 1, 0, 0, 0x00000068},  /* 128.4000 */
+    {0x00820000, 1, 1, 0, 0x00000FB0},  /* 130.0000 */
+    {0x00821999, 1, 0, 0, 0x00000544},  /* 130.1000 */
+    {0x00858000, 1, 0, 0, 0x0000006C},  /* 133.5000 */
+    {0x00870000, 1, 0, 0, 0x00000550},  /* 135.0000 */
+    {0x00906147, 1, 0, 0, 0x000007E0},  /* 144.3800 */
+    {0x009D8000, 1, 0, 0, 0x00000304},  /* 157.5000 */
+    {0x00A20000, 0, 0, 0, 0x000002B1},  /* 162.0000 */
+    {0x00A933F7, 0, 0, 0, 0x000002B9},  /* 169.2030 */
+    {0x00ACCC49, 0, 1, 0, 0x0000002D},  /* 172.798  */
+    {0x00AF8000, 0, 0, 0, 0x000002C1},  /* 175.5000 */
+    {0x00BD0000, 0, 0, 0, 0x000002D1},  /* 189.0000 */
+    {0x00BEF5C2, 0, 0, 0, 0x0000053D},  /* 190.9600 */
+    {0x00C60000, 0, 0, 0, 0x00000549},  /* 198.0000 */
+    {0x00CA8000, 0, 0, 0, 0x00000551},  /* 202.5000 */
+    {0x00E58000, 0, 0, 0, 0x0000057D},  /* 229.5000 */
 };
 
 #define NUM_RCDF_FREQUENCIES sizeof(RCDF_PLLtable)/sizeof(RCDFPLLENTRY)
@@ -205,8 +204,8 @@ gfx_set_display_control(int sync_polarities)
 
     dcfg = READ_VID32(RCDF_DISPLAY_CONFIG);
     dcfg &= ~(RCDF_DCFG_CRT_SYNC_SKW_MASK | RCDF_DCFG_PWR_SEQ_DLY_MASK |
-        RCDF_DCFG_CRT_HSYNC_POL | RCDF_DCFG_CRT_VSYNC_POL |
-        RCDF_DCFG_FP_PWR_EN | RCDF_DCFG_FP_DATA_EN);
+              RCDF_DCFG_CRT_HSYNC_POL | RCDF_DCFG_CRT_VSYNC_POL |
+              RCDF_DCFG_FP_PWR_EN | RCDF_DCFG_FP_DATA_EN);
 
     /* Don't blindly set the PAL_BYP bit - assume that somebody along
      * the line has set up the gamma correctly before this point */
@@ -222,16 +221,16 @@ gfx_set_display_control(int sync_polarities)
     /* SET APPROPRIATE SYNC POLARITIES */
 
     if (PanelEnable) {
-	unsigned int pt2 = READ_VID32(0x408);
+        unsigned int pt2 = READ_VID32(0x408);
 
-	pt2 &= ~((1 << 22) | (1 << 23));
-	WRITE_VID32(0x408, pt2);
+        pt2 &= ~((1 << 22) | (1 << 23));
+        WRITE_VID32(0x408, pt2);
     }
 
     if (sync_polarities & 0x1)
-		dcfg |= RCDF_DCFG_CRT_HSYNC_POL;
-	if (sync_polarities & 0x2)
-		dcfg |= RCDF_DCFG_CRT_VSYNC_POL;
+        dcfg |= RCDF_DCFG_CRT_HSYNC_POL;
+    if (sync_polarities & 0x2)
+        dcfg |= RCDF_DCFG_CRT_VSYNC_POL;
 
     WRITE_VID32(RCDF_DISPLAY_CONFIG, dcfg);
 
@@ -265,11 +264,11 @@ gfx_set_clock_frequency(unsigned long frequency)
     /* Search the table for the closest frequency (16.16 format). */
 
     value = RCDF_PLLtable[0].pll_value;
-    min = (long)RCDF_PLLtable[0].frequency - frequency;
+    min = (long) RCDF_PLLtable[0].frequency - frequency;
     if (min < 0L)
         min = -min;
     for (i = 1; i < NUM_RCDF_FREQUENCIES; i++) {
-        diff = (long)RCDF_PLLtable[i].frequency - frequency;
+        diff = (long) RCDF_PLLtable[i].frequency - frequency;
         if (diff < 0L)
             diff = -diff;
         if (diff < min) {
@@ -296,9 +295,8 @@ gfx_set_clock_frequency(unsigned long frequency)
 
     if ((msr_value.low & MCP_DOTPLL_LOCK) &&
         (msr_value.high == RCDF_PLLtable[index].pll_value) &&
-        ((sys_value.
-                low & (MCP_DOTPOSTDIV3 | MCP_DOTPREDIV2 | MCP_DOTPREMULT2)) ==
-            sys_low)) {
+        ((sys_value.low & (MCP_DOTPOSTDIV3 | MCP_DOTPREDIV2 | MCP_DOTPREMULT2))
+         == sys_low)) {
         return;
     }
 
@@ -349,36 +347,36 @@ gfx_set_crt_enable(int enable)
     misc = READ_VID32(RCDF_VID_MISC);
 
     switch (enable) {
-    case CRT_DISABLE:                 /* DISABLE EVERYTHING */
+    case CRT_DISABLE:          /* DISABLE EVERYTHING */
 
         WRITE_VID32(RCDF_DISPLAY_CONFIG,
-            config & ~(RCDF_DCFG_DIS_EN | RCDF_DCFG_HSYNC_EN |
-                RCDF_DCFG_VSYNC_EN | RCDF_DCFG_DAC_BL_EN));
+                    config & ~(RCDF_DCFG_DIS_EN | RCDF_DCFG_HSYNC_EN |
+                               RCDF_DCFG_VSYNC_EN | RCDF_DCFG_DAC_BL_EN));
         WRITE_VID32(RCDF_VID_MISC, misc | RCDF_DAC_POWER_DOWN);
         break;
 
-    case CRT_ENABLE:                  /* ENABLE CRT DISPLAY, INCLUDING DISPLAY LOGIC */
+    case CRT_ENABLE:           /* ENABLE CRT DISPLAY, INCLUDING DISPLAY LOGIC */
 
         WRITE_VID32(RCDF_DISPLAY_CONFIG,
-            config | RCDF_DCFG_DIS_EN | RCDF_DCFG_HSYNC_EN |
-            RCDF_DCFG_VSYNC_EN | RCDF_DCFG_DAC_BL_EN);
+                    config | RCDF_DCFG_DIS_EN | RCDF_DCFG_HSYNC_EN |
+                    RCDF_DCFG_VSYNC_EN | RCDF_DCFG_DAC_BL_EN);
         WRITE_VID32(RCDF_VID_MISC,
-            misc & ~RCDF_DAC_POWER_DOWN & ~RCDF_ANALOG_POWER_DOWN);
+                    misc & ~RCDF_DAC_POWER_DOWN & ~RCDF_ANALOG_POWER_DOWN);
         break;
 
-    case CRT_STANDBY:                 /* HSYNC:OFF VSYNC:ON */
+    case CRT_STANDBY:          /* HSYNC:OFF VSYNC:ON */
 
         WRITE_VID32(RCDF_DISPLAY_CONFIG,
-            (config & ~(RCDF_DCFG_DIS_EN | RCDF_DCFG_HSYNC_EN |
-                    RCDF_DCFG_DAC_BL_EN)) | RCDF_DCFG_VSYNC_EN);
+                    (config & ~(RCDF_DCFG_DIS_EN | RCDF_DCFG_HSYNC_EN |
+                                RCDF_DCFG_DAC_BL_EN)) | RCDF_DCFG_VSYNC_EN);
         WRITE_VID32(RCDF_VID_MISC, misc | RCDF_DAC_POWER_DOWN);
         break;
 
-    case CRT_SUSPEND:                 /* HSYNC:ON VSYNC:OFF */
+    case CRT_SUSPEND:          /* HSYNC:ON VSYNC:OFF */
 
         WRITE_VID32(RCDF_DISPLAY_CONFIG,
-            (config & ~(RCDF_DCFG_DIS_EN | RCDF_DCFG_VSYNC_EN |
-                    RCDF_DCFG_DAC_BL_EN)) | RCDF_DCFG_HSYNC_EN);
+                    (config & ~(RCDF_DCFG_DIS_EN | RCDF_DCFG_VSYNC_EN |
+                                RCDF_DCFG_DAC_BL_EN)) | RCDF_DCFG_HSYNC_EN);
         WRITE_VID32(RCDF_VID_MISC, misc | RCDF_DAC_POWER_DOWN);
         break;
 
@@ -409,9 +407,9 @@ gfx_set_video_enable(int enable)
 
     if (gfx_test_timing_active()) {
         if (!gfx_test_vertical_active()) {
-            while (!gfx_test_vertical_active()) ;
+            while (!gfx_test_vertical_active());
         }
-        while (gfx_test_vertical_active()) ;
+        while (gfx_test_vertical_active());
     }
 
     vcfg = READ_VID32(RCDF_VIDEO_CONFIG);
@@ -425,7 +423,8 @@ gfx_set_video_enable(int enable)
 
         vcfg |= RCDF_VCFG_VID_EN;
         WRITE_VID32(RCDF_VIDEO_CONFIG, vcfg);
-    } else {
+    }
+    else {
         /* DISABLE DISPLAY FILTER VIDEO OVERLAY */
 
         vcfg &= ~RCDF_VCFG_VID_EN;
@@ -619,11 +618,11 @@ gfx_set_video_offset(unsigned long offset)
 #if GFX_VIDEO_DYNAMIC
 int
 redcloud_set_video_yuv_offsets(unsigned long yoffset, unsigned long uoffset,
-    unsigned long voffset)
+                               unsigned long voffset)
 #else
 int
 gfx_set_video_yuv_offsets(unsigned long yoffset, unsigned long uoffset,
-    unsigned long voffset)
+                          unsigned long voffset)
 #endif
 {
     /* SAVE VALUE FOR FUTURE CLIPPING OF THE TOP OF THE VIDEO WINDOW */
@@ -672,11 +671,11 @@ gfx_set_video_yuv_pitch(unsigned long ypitch, unsigned long uvpitch)
 #if GFX_VIDEO_DYNAMIC
 int
 redcloud_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                         unsigned short dstw, unsigned short dsth)
 #else
 int
 gfx_set_video_scale(unsigned short srcw, unsigned short srch,
-    unsigned short dstw, unsigned short dsth)
+                    unsigned short dstw, unsigned short dsth)
 #endif
 {
     unsigned long xscale, yscale;
@@ -727,7 +726,7 @@ gfx_set_video_scale(unsigned short srcw, unsigned short srch,
     /* amount of data that needs to be transferred.                   */
 
     gfx_set_video_window(gfx_vid_xpos, gfx_vid_ypos, gfx_vid_width,
-        gfx_vid_height);
+                         gfx_vid_height);
     return (0);
 }
 
@@ -741,8 +740,7 @@ gfx_set_video_scale(unsigned short srcw, unsigned short srch,
  */
 #if GFX_VIDEO_DYNAMIC
 int
-redcloud_set_video_vertical_downscale(unsigned short srch,
-    unsigned short dsth)
+redcloud_set_video_vertical_downscale(unsigned short srch, unsigned short dsth)
 #else
 int
 gfx_set_video_vertical_downscale(unsigned short srch, unsigned short dsth)
@@ -800,7 +798,7 @@ gfx_set_video_downscale_config(unsigned short type, unsigned short m)
     downscale = READ_VID32(RCDF_VIDEO_DOWNSCALER_CONTROL);
     downscale &=
         ~(RCDF_VIDEO_DOWNSCALE_FACTOR_MASK | RCDF_VIDEO_DOWNSCALE_TYPE_MASK);
-    downscale |= ((unsigned long)(m - 1) << RCDF_VIDEO_DOWNSCALE_FACTOR_POS);
+    downscale |= ((unsigned long) (m - 1) << RCDF_VIDEO_DOWNSCALE_FACTOR_POS);
     switch (type) {
     case VIDEO_DOWNSCALE_KEEP_1_OF:
         downscale |= RCDF_VIDEO_DOWNSCALE_TYPE_A;
@@ -824,21 +822,24 @@ gfx_set_video_downscale_config(unsigned short type, unsigned short m)
 #if GFX_VIDEO_DYNAMIC
 int
 redcloud_set_video_downscale_coefficients(unsigned short coef1,
-    unsigned short coef2, unsigned short coef3, unsigned short coef4)
+                                          unsigned short coef2,
+                                          unsigned short coef3,
+                                          unsigned short coef4)
 #else
 int
 gfx_set_video_downscale_coefficients(unsigned short coef1,
-    unsigned short coef2, unsigned short coef3, unsigned short coef4)
+                                     unsigned short coef2, unsigned short coef3,
+                                     unsigned short coef4)
 #endif
 {
     if ((coef1 + coef2 + coef3 + coef4) != 16)
         return GFX_STATUS_BAD_PARAMETER;
 
     WRITE_VID32(RCDF_VIDEO_DOWNSCALER_COEFFICIENTS,
-        ((unsigned long)coef1 << RCDF_VIDEO_DOWNSCALER_COEF1_POS) |
-        ((unsigned long)coef2 << RCDF_VIDEO_DOWNSCALER_COEF2_POS) |
-        ((unsigned long)coef3 << RCDF_VIDEO_DOWNSCALER_COEF3_POS) |
-        ((unsigned long)coef4 << RCDF_VIDEO_DOWNSCALER_COEF4_POS));
+                ((unsigned long) coef1 << RCDF_VIDEO_DOWNSCALER_COEF1_POS) |
+                ((unsigned long) coef2 << RCDF_VIDEO_DOWNSCALER_COEF2_POS) |
+                ((unsigned long) coef3 << RCDF_VIDEO_DOWNSCALER_COEF3_POS) |
+                ((unsigned long) coef4 << RCDF_VIDEO_DOWNSCALER_COEF4_POS));
     return (0);
 }
 
@@ -879,8 +880,7 @@ gfx_set_video_downscale_enable(int enable)
  */
 #if GFX_VIDEO_DYNAMIC
 int
-redcloud_set_video_window(short x, short y, unsigned short w,
-    unsigned short h)
+redcloud_set_video_window(short x, short y, unsigned short w, unsigned short h)
 #else
 int
 gfx_set_video_window(short x, short y, unsigned short w, unsigned short h)
@@ -906,11 +906,12 @@ gfx_set_video_window(short x, short y, unsigned short w, unsigned short h)
     /* LEFT CLIPPING */
 
     if (x < 0) {
-        gfx_set_video_left_crop((unsigned short)(-x));
+        gfx_set_video_left_crop((unsigned short) (-x));
         xstart = hadjust;
-    } else {
+    }
+    else {
         gfx_set_video_left_crop(0);
-        xstart = (unsigned long)x + hadjust;
+        xstart = (unsigned long) x + hadjust;
     }
 
     /* HORIZONTAL END */
@@ -918,24 +919,24 @@ gfx_set_video_window(short x, short y, unsigned short w, unsigned short h)
      * end) */
 
     if ((x + w) < gfx_get_hactive())
-        xend = (unsigned long)x + (unsigned long)w + hadjust;
+        xend = (unsigned long) x + (unsigned long) w + hadjust;
 
     /* RIGHT-CLIPPING */
     else
-        xend = (unsigned long)gfx_get_hactive() + hadjust;
+        xend = (unsigned long) gfx_get_hactive() + hadjust;
 
     /* VERTICAL START */
 
-    ystart = (unsigned long)y + vadjust;
+    ystart = (unsigned long) y + vadjust;
 
     /* VERTICAL END */
 
     if ((y + h) < gfx_get_vactive())
-        yend = (unsigned long)y + (unsigned long)h + vadjust;
+        yend = (unsigned long) y + (unsigned long) h + vadjust;
 
     /* BOTTOM-CLIPPING */
     else
-        yend = (unsigned long)gfx_get_vactive() + vadjust;
+        yend = (unsigned long) gfx_get_vactive() + vadjust;
 
     /* SET VIDEO POSITION */
 
@@ -976,11 +977,12 @@ gfx_set_video_left_crop(unsigned short x)
      * */
 
     if (gfx_vid_dstw) {
-        initread = (unsigned long)x *gfx_vid_srcw / gfx_vid_dstw;
+        initread = (unsigned long) x *gfx_vid_srcw / gfx_vid_dstw;
 
         if (vcfg & RCDF_VCFG_4_2_0_MODE)
             initread &= 0xFFF8;
-    } else
+    }
+    else
         initread = 0;
 
     /* SET INITIAL READ ADDRESS */
@@ -1008,7 +1010,7 @@ gfx_set_video_left_crop(unsigned short x)
 #if GFX_VIDEO_DYNAMIC
 int
 redcloud_set_video_color_key(unsigned long key, unsigned long mask,
-    int graphics)
+                             int graphics)
 #else
 int
 gfx_set_video_color_key(unsigned long key, unsigned long mask, int graphics)
@@ -1093,9 +1095,9 @@ gfx_set_video_palette(unsigned long *palette)
     WRITE_VID32(RCDF_VID_MISC, misc);
 
     if (gfx_test_timing_active()) {
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
     }
 
     /* LOAD REDCLOUD VIDEO PALETTE */
@@ -1147,9 +1149,9 @@ gfx_set_graphics_palette(unsigned long *palette)
     WRITE_VID32(RCDF_VID_MISC, misc);
 
     if (gfx_test_timing_active()) {
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
     }
 
     /* LOAD REDCLOUD VIDEO PALETTE */
@@ -1174,8 +1176,7 @@ gfx_set_graphics_palette(unsigned long *palette)
  */
 #if GFX_VIDEO_DYNAMIC
 int
-redcloud_set_graphics_palette_entry(unsigned long index,
-    unsigned long palette)
+redcloud_set_graphics_palette_entry(unsigned long index, unsigned long palette)
 #else
 int
 gfx_set_graphics_palette_entry(unsigned long index, unsigned long palette)
@@ -1300,8 +1301,8 @@ gfx_set_video_request(short x, short y)
         return GFX_STATUS_BAD_PARAMETER;
 
     WRITE_VID32(RCDF_VIDEO_REQUEST,
-        ((unsigned long)x << RCDF_VIDEO_X_REQUEST_POS) | ((unsigned long)y <<
-            RCDF_VIDEO_Y_REQUEST_POS));
+                ((unsigned long) x << RCDF_VIDEO_X_REQUEST_POS) |
+                ((unsigned long) y << RCDF_VIDEO_Y_REQUEST_POS));
     return (0);
 }
 
@@ -1332,18 +1333,20 @@ gfx_set_video_request(short x, short y)
 #if GFX_VIDEO_DYNAMIC
 int
 redcloud_set_video_cursor(unsigned long key, unsigned long mask,
-    unsigned short select_color2, unsigned long color1, unsigned long color2)
+                          unsigned short select_color2, unsigned long color1,
+                          unsigned long color2)
 #else
 int
 gfx_set_video_cursor(unsigned long key, unsigned long mask,
-    unsigned short select_color2, unsigned long color1, unsigned long color2)
+                     unsigned short select_color2, unsigned long color1,
+                     unsigned long color2)
 #endif
 {
     if (select_color2 > RCDF_CURSOR_COLOR_BITS)
         return GFX_STATUS_BAD_PARAMETER;
     key =
-        (key & RCDF_COLOR_MASK) | ((unsigned long)select_color2 <<
-        RCDF_CURSOR_COLOR_KEY_OFFSET_POS);
+        (key & RCDF_COLOR_MASK) | ((unsigned long) select_color2 <<
+                                   RCDF_CURSOR_COLOR_KEY_OFFSET_POS);
     WRITE_VID32(RCDF_CURSOR_COLOR_KEY, key);
     WRITE_VID32(RCDF_CURSOR_COLOR_MASK, mask);
     WRITE_VID32(RCDF_CURSOR_COLOR_1, color1);
@@ -1412,7 +1415,7 @@ gfx_set_alpha_enable(int enable)
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = RCDF_ALPHA_CONTROL_1 + ((unsigned long)gfx_alpha_select << 5);
+    address = RCDF_ALPHA_CONTROL_1 + ((unsigned long) gfx_alpha_select << 5);
     value = READ_VID32(address);
     if (enable)
         value |= RCDF_ACTRL_WIN_ENABLE;
@@ -1433,11 +1436,11 @@ gfx_set_alpha_enable(int enable)
 #if GFX_VIDEO_DYNAMIC
 int
 redcloud_set_alpha_window(short x, short y,
-    unsigned short width, unsigned short height)
+                          unsigned short width, unsigned short height)
 #else
 int
 gfx_set_alpha_window(short x, short y,
-    unsigned short width, unsigned short height)
+                     unsigned short width, unsigned short height)
 #endif
 {
     unsigned long address = 0;
@@ -1456,15 +1459,15 @@ gfx_set_alpha_window(short x, short y,
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = RCDF_ALPHA_XPOS_1 + ((unsigned long)gfx_alpha_select << 5);
+    address = RCDF_ALPHA_XPOS_1 + ((unsigned long) gfx_alpha_select << 5);
 
     /* END POSITIONS IN REGISTERS ARE NON-INCLUSIVE (ONE MORE THAN ACTUAL END)
      * */
 
-    WRITE_VID32(address, (unsigned long)x |
-        ((unsigned long)(x + width) << 16));
-    WRITE_VID32(address + 8, (unsigned long)y |
-        ((unsigned long)(y + height) << 16));
+    WRITE_VID32(address, (unsigned long) x |
+                ((unsigned long) (x + width) << 16));
+    WRITE_VID32(address + 8, (unsigned long) y |
+                ((unsigned long) (y + height) << 16));
     return (GFX_STATUS_OK);
 }
 
@@ -1487,11 +1490,11 @@ gfx_set_alpha_value(unsigned char alpha, char delta)
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = RCDF_ALPHA_CONTROL_1 + ((unsigned long)gfx_alpha_select << 5);
+    address = RCDF_ALPHA_CONTROL_1 + ((unsigned long) gfx_alpha_select << 5);
     value = READ_VID32(address);
-    value &= RCDF_ACTRL_WIN_ENABLE;    /* keep only enable bit */
-    value |= (unsigned long)alpha;
-    value |= (((unsigned long)delta) & 0xff) << 8;
+    value &= RCDF_ACTRL_WIN_ENABLE;     /* keep only enable bit */
+    value |= (unsigned long) alpha;
+    value |= (((unsigned long) delta) & 0xff) << 8;
     value |= RCDF_ACTRL_LOAD_ALPHA;
     WRITE_VID32(address, value);
     return (GFX_STATUS_OK);
@@ -1522,7 +1525,7 @@ gfx_set_alpha_priority(int priority)
     value = READ_VID32(RCDF_VID_ALPHA_CONTROL);
     pos = 16 + (gfx_alpha_select << 1);
     value &= ~(0x03l << pos);
-    value |= (unsigned long)priority << pos;
+    value |= (unsigned long) priority << pos;
     WRITE_VID32(RCDF_VID_ALPHA_CONTROL, value);
     return (GFX_STATUS_OK);
 }
@@ -1550,7 +1553,7 @@ gfx_set_alpha_color(unsigned long color)
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = RCDF_ALPHA_COLOR_1 + ((unsigned long)gfx_alpha_select << 5);
+    address = RCDF_ALPHA_COLOR_1 + ((unsigned long) gfx_alpha_select << 5);
     WRITE_VID32(address, color);
     return (GFX_STATUS_OK);
 }
@@ -1574,7 +1577,7 @@ gfx_set_alpha_color_enable(int enable)
 
     if (gfx_alpha_select > 2)
         return (GFX_STATUS_UNSUPPORTED);
-    address = RCDF_ALPHA_COLOR_1 + ((unsigned long)gfx_alpha_select << 5);
+    address = RCDF_ALPHA_COLOR_1 + ((unsigned long) gfx_alpha_select << 5);
     color = READ_VID32(address);
     if (enable)
         color |= RCDF_ALPHA_COLOR_ENABLE;
@@ -1611,8 +1614,7 @@ gfx_set_no_ck_outside_alpha(int enable)
     if (enable)
         WRITE_VID32(RCDF_VID_ALPHA_CONTROL, value | RCDF_NO_CK_OUTSIDE_ALPHA);
     else
-        WRITE_VID32(RCDF_VID_ALPHA_CONTROL,
-            value & ~RCDF_NO_CK_OUTSIDE_ALPHA);
+        WRITE_VID32(RCDF_VID_ALPHA_CONTROL, value & ~RCDF_NO_CK_OUTSIDE_ALPHA);
     return (0);
 }
 
@@ -1778,7 +1780,8 @@ gfx_get_video_format(void)
         case RCDF_VCFG_YVYU_FORMAT:
             return VIDEO_FORMAT_Y1Y2Y3Y0;
         }
-    } else {
+    }
+    else {
         switch (vcfg & RCDF_VCFG_VID_INP_FORMAT) {
         case RCDF_VCFG_UYVY_FORMAT:
             return VIDEO_FORMAT_UYVY;
@@ -1922,11 +1925,11 @@ gfx_get_video_offset(void)
 #if GFX_VIDEO_DYNAMIC
 void
 redcloud_get_video_yuv_offsets(unsigned long *yoffset, unsigned long *uoffset,
-    unsigned long *voffset)
+                               unsigned long *voffset)
 #else
 void
 gfx_get_video_yuv_offsets(unsigned long *yoffset, unsigned long *uoffset,
-    unsigned long *voffset)
+                          unsigned long *voffset)
 #endif
 {
     gfx_get_display_video_yuv_offsets(yoffset, uoffset, voffset);
@@ -2023,8 +2026,8 @@ gfx_get_video_downscale_config(unsigned short *type, unsigned short *m)
     unsigned long downscale;
 
     downscale = READ_VID32(RCDF_VIDEO_DOWNSCALER_CONTROL);
-    *m = (unsigned short)((downscale & RCDF_VIDEO_DOWNSCALE_FACTOR_MASK) >>
-        RCDF_VIDEO_DOWNSCALE_FACTOR_POS) + 1;
+    *m = (unsigned short) ((downscale & RCDF_VIDEO_DOWNSCALE_FACTOR_MASK) >>
+                           RCDF_VIDEO_DOWNSCALE_FACTOR_POS) + 1;
 
     switch (downscale & RCDF_VIDEO_DOWNSCALE_TYPE_MASK) {
     case RCDF_VIDEO_DOWNSCALE_TYPE_A:
@@ -2049,28 +2052,32 @@ gfx_get_video_downscale_config(unsigned short *type, unsigned short *m)
 #if GFX_VIDEO_DYNAMIC
 void
 redcloud_get_video_downscale_coefficients(unsigned short *coef1,
-    unsigned short *coef2, unsigned short *coef3, unsigned short *coef4)
+                                          unsigned short *coef2,
+                                          unsigned short *coef3,
+                                          unsigned short *coef4)
 #else
 void
 gfx_get_video_downscale_coefficients(unsigned short *coef1,
-    unsigned short *coef2, unsigned short *coef3, unsigned short *coef4)
+                                     unsigned short *coef2,
+                                     unsigned short *coef3,
+                                     unsigned short *coef4)
 #endif
 {
     unsigned long coef;
 
     coef = READ_VID32(RCDF_VIDEO_DOWNSCALER_COEFFICIENTS);
     *coef1 =
-        (unsigned short)((coef >> RCDF_VIDEO_DOWNSCALER_COEF1_POS) &
-        RCDF_VIDEO_DOWNSCALER_COEF_MASK);
+        (unsigned short) ((coef >> RCDF_VIDEO_DOWNSCALER_COEF1_POS) &
+                          RCDF_VIDEO_DOWNSCALER_COEF_MASK);
     *coef2 =
-        (unsigned short)((coef >> RCDF_VIDEO_DOWNSCALER_COEF2_POS) &
-        RCDF_VIDEO_DOWNSCALER_COEF_MASK);
+        (unsigned short) ((coef >> RCDF_VIDEO_DOWNSCALER_COEF2_POS) &
+                          RCDF_VIDEO_DOWNSCALER_COEF_MASK);
     *coef3 =
-        (unsigned short)((coef >> RCDF_VIDEO_DOWNSCALER_COEF3_POS) &
-        RCDF_VIDEO_DOWNSCALER_COEF_MASK);
+        (unsigned short) ((coef >> RCDF_VIDEO_DOWNSCALER_COEF3_POS) &
+                          RCDF_VIDEO_DOWNSCALER_COEF_MASK);
     *coef4 =
-        (unsigned short)((coef >> RCDF_VIDEO_DOWNSCALER_COEF4_POS) &
-        RCDF_VIDEO_DOWNSCALER_COEF_MASK);
+        (unsigned short) ((coef >> RCDF_VIDEO_DOWNSCALER_COEF4_POS) &
+                          RCDF_VIDEO_DOWNSCALER_COEF_MASK);
     return;
 }
 
@@ -2089,8 +2096,7 @@ void
 gfx_get_video_downscale_enable(int *enable)
 #endif
 {
-    if (READ_VID32(RCDF_VIDEO_DOWNSCALER_CONTROL) &
-        RCDF_VIDEO_DOWNSCALE_ENABLE)
+    if (READ_VID32(RCDF_VIDEO_DOWNSCALER_CONTROL) & RCDF_VIDEO_DOWNSCALE_ENABLE)
         *enable = 1;
     else
         *enable = 0;
@@ -2147,10 +2153,10 @@ gfx_get_video_position(void)
     /* Use routines to abstract version of display controller. */
 
     hadjust =
-        (unsigned long)gfx_get_htotal() - (unsigned long)gfx_get_hsync_end() -
+        (unsigned long) gfx_get_htotal() - (unsigned long) gfx_get_hsync_end() -
         14l;
     vadjust =
-        (unsigned long)gfx_get_vtotal() - (unsigned long)gfx_get_vsync_end() +
+        (unsigned long) gfx_get_vtotal() - (unsigned long) gfx_get_vsync_end() +
         1l;
     xpos -= hadjust;
     ypos -= vadjust;
@@ -2251,10 +2257,10 @@ gfx_get_video_request(short *x, short *y)
     unsigned long request = 0;
 
     request = (READ_VID32(RCDF_VIDEO_REQUEST));
-    *x = (short)((request >> RCDF_VIDEO_X_REQUEST_POS) &
-        RCDF_VIDEO_REQUEST_MASK);
-    *y = (short)((request >> RCDF_VIDEO_Y_REQUEST_POS) &
-        RCDF_VIDEO_REQUEST_MASK);
+    *x = (short) ((request >> RCDF_VIDEO_X_REQUEST_POS) &
+                  RCDF_VIDEO_REQUEST_MASK);
+    *y = (short) ((request >> RCDF_VIDEO_Y_REQUEST_POS) &
+                  RCDF_VIDEO_REQUEST_MASK);
 
     *x -= gfx_get_htotal() - gfx_get_hsync_end() - 2;
     *y -= gfx_get_vtotal() - gfx_get_vsync_end() + 1;
@@ -2274,23 +2280,23 @@ gfx_get_video_request(short *x, short *y)
 #if GFX_VIDEO_DYNAMIC
 int
 redcloud_get_video_cursor(unsigned long *key, unsigned long *mask,
-    unsigned short *select_color2, unsigned long *color1,
-    unsigned short *color2)
+                          unsigned short *select_color2, unsigned long *color1,
+                          unsigned short *color2)
 #else
 int
 gfx_get_video_cursor(unsigned long *key, unsigned long *mask,
-    unsigned short *select_color2, unsigned long *color1,
-    unsigned short *color2)
+                     unsigned short *select_color2, unsigned long *color1,
+                     unsigned short *color2)
 #endif
 {
     *select_color2 =
-        (unsigned short)(READ_VID32(RCDF_CURSOR_COLOR_KEY) >>
-        RCDF_CURSOR_COLOR_KEY_OFFSET_POS);
+        (unsigned short) (READ_VID32(RCDF_CURSOR_COLOR_KEY) >>
+                          RCDF_CURSOR_COLOR_KEY_OFFSET_POS);
     *key = READ_VID32(RCDF_CURSOR_COLOR_KEY) & RCDF_COLOR_MASK;
     *mask = READ_VID32(RCDF_CURSOR_COLOR_MASK) & RCDF_COLOR_MASK;
     *color1 = READ_VID32(RCDF_CURSOR_COLOR_1) & RCDF_COLOR_MASK;
     *color2 =
-        (unsigned short)(READ_VID32(RCDF_CURSOR_COLOR_2) & RCDF_COLOR_MASK);
+        (unsigned short) (READ_VID32(RCDF_CURSOR_COLOR_2) & RCDF_COLOR_MASK);
     return (0);
 }
 
@@ -2324,7 +2330,7 @@ gfx_read_crc(void)
     if (gfx_test_timing_active()) {
         /* WAIT UNTIL ACTIVE DISPLAY */
 
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
 
         /* RESET CRC DURING ACTIVE DISPLAY */
 
@@ -2333,11 +2339,11 @@ gfx_read_crc(void)
 
         /* WAIT UNTIL NOT ACTIVE, THEN ACTIVE, NOT ACTIVE, THEN ACTIVE */
 
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
         crc = READ_VID32(RCDF_VID_CRC) >> 8;
     }
     return (crc);
@@ -2373,7 +2379,7 @@ gfx_read_crc32(void)
     if (gfx_test_timing_active()) {
         /* WAIT UNTIL ACTIVE DISPLAY */
 
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
 
         /* RESET CRC DURING ACTIVE DISPLAY */
 
@@ -2382,11 +2388,11 @@ gfx_read_crc32(void)
 
         /* WAIT UNTIL NOT ACTIVE, THEN ACTIVE, NOT ACTIVE, THEN ACTIVE */
 
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
-        while (gfx_test_vertical_active()) ;
-        while (!gfx_test_vertical_active()) ;
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
+        while (gfx_test_vertical_active());
+        while (!gfx_test_vertical_active());
         crc = READ_VID32(RCDF_VID_CRC32);
     }
     return (crc);
@@ -2402,11 +2408,11 @@ gfx_read_crc32(void)
 #if GFX_VIDEO_DYNAMIC
 unsigned long
 redcloud_read_window_crc(int source, unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, int crc32)
+                         unsigned short width, unsigned short height, int crc32)
 #else
 unsigned long
 gfx_read_window_crc(int source, unsigned short x, unsigned short y,
-    unsigned short width, unsigned short height, int crc32)
+                    unsigned short width, unsigned short height, int crc32)
 #endif
 {
     Q_WORD msr_value;
@@ -2432,8 +2438,7 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
         msr_value.low &= ~(RCDF_CONFIG_FMT_MASK);
         msr_value.low |=
             ((source ==
-                CRC_SOURCE_FP_DATA) ? RCDF_CONFIG_FMT_FP :
-            RCDF_CONFIG_FMT_CRT);
+              CRC_SOURCE_FP_DATA) ? RCDF_CONFIG_FMT_FP : RCDF_CONFIG_FMT_CRT);
         gfx_msr_write(RC_ID_DF, MBD_MSR_CONFIG, &msr_value);
     }
 
@@ -2466,7 +2471,8 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
         sync_polarities = gfx_get_sync_polarities();
         vsync_bit = 29;
         hsync_bit = 30;
-    } else {
+    }
+    else {
         vsync_bit = 25;
         hsync_bit = 26;
     }
@@ -2474,7 +2480,8 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
     if (sync_polarities & 1) {
         hsync_active_base = MCP_SETM0CTL;
         hsync_active_shift = 2;
-    } else {
+    }
+    else {
         hsync_active_base = MCP_SETN0CTL;
         hsync_active_shift = 1;
     }
@@ -2483,7 +2490,8 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
         vsync_inactive_base = MCP_SETN0CTL;
         vsync_active_shift = 2;
         vsync_inactive_shift = 1;
-    } else {
+    }
+    else {
         vsync_active_base = MCP_SETN0CTL;
         vsync_inactive_base = MCP_SETM0CTL;
         vsync_active_shift = 1;
@@ -2498,8 +2506,8 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
     /*       VG VSync = Diag Bus Bit 25  */
 
     msr_value.low = 0x000000A0;
-    msr_value.high = 0x00008000 | ((unsigned long)vsync_bit << 16) |
-        ((unsigned long)vsync_bit << 21) | ((unsigned long)vsync_bit << 26);
+    msr_value.high = 0x00008000 | ((unsigned long) vsync_bit << 16) |
+        ((unsigned long) vsync_bit << 21) | ((unsigned long) vsync_bit << 26);
     gfx_msr_write(RC_ID_MCP, vsync_inactive_base, &msr_value);
 
     /* STATE 1-2 TRANSITION (SET 4)   */
@@ -2519,8 +2527,8 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
     /* Notes: DF HSync = Diag Bus Bit 30  */
     /*        VG HSync = Diag Bus Bit 26  */
 
-    msr_value.high = 0x00008000 | ((unsigned long)hsync_bit << 16) |
-        ((unsigned long)hsync_bit << 21) | ((unsigned long)hsync_bit << 26);
+    msr_value.high = 0x00008000 | ((unsigned long) hsync_bit << 16) |
+        ((unsigned long) hsync_bit << 21) | ((unsigned long) hsync_bit << 26);
     msr_value.low = 0x00000120;
     gfx_msr_write(RC_ID_MCP, hsync_active_base + 5, &msr_value);
 
@@ -2552,8 +2560,8 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
     /*      data to access the diag bus                    */
     /*   2. h_blank_pixels = HTOTAL - HSYNC_END            */
 
-    xpos = (unsigned long)x + ((unsigned long)gfx_get_htotal() -
-        (unsigned long)gfx_get_hsync_end() - 1l) - 3l;
+    xpos = (unsigned long) x + ((unsigned long) gfx_get_htotal() -
+                                (unsigned long) gfx_get_hsync_end() - 1l) - 3l;
     if (source == CRC_SOURCE_GFX_DATA)
         xpos++;
     msr_value.high = 0x00000000;
@@ -2563,7 +2571,7 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
     /* COMPARATOR 1                                          */
     /* Upper limit = xpos + width + (h_blank_pixels - 1) - 3 */
 
-    msr_value.low = xpos + (unsigned long)width;
+    msr_value.low = xpos + (unsigned long) width;
     gfx_msr_write(RC_ID_MCP, MCP_CMPVAL0 + 2, &msr_value);
 
     /* COMPARATOR 2                                  */
@@ -2572,15 +2580,15 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
     /*   1. v_blank_pixels = VTOTAL - VSYNC_END      */
 
     ypos =
-        (unsigned long)y + (unsigned long)gfx_get_vtotal() -
-        (unsigned long)gfx_get_vsync_end();
+        (unsigned long) y + (unsigned long) gfx_get_vtotal() -
+        (unsigned long) gfx_get_vsync_end();
     msr_value.low = ypos << 16;
     gfx_msr_write(RC_ID_MCP, MCP_CMPVAL0 + 4, &msr_value);
 
     /* COMPARATOR 3                                  */
     /* Upper limit = ypos + height + v_blank_pixels  */
 
-    msr_value.low = (ypos + (unsigned long)height) << 16;
+    msr_value.low = (ypos + (unsigned long) height) << 16;
     gfx_msr_write(RC_ID_MCP, MCP_CMPVAL0 + 6, &msr_value);
 
     /* SET COMPARATOR MASKS */
@@ -2612,7 +2620,7 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
     msr_value.high = 0x00000000;
     msr_value.low = 0xFFFF0000 |
         ((gfx_get_htotal() - (gfx_get_hsync_end() - gfx_get_hsync_start()) -
-            1) & 0xFFFF);
+          1) & 0xFFFF);
     gfx_msr_write(RC_ID_MCP, MCP_REGBVAL, &msr_value);
 
     /* PROGRAM ACTIONS */
@@ -2706,11 +2714,11 @@ gfx_read_window_crc(int source, unsigned short x, unsigned short y,
 
     /* DELAY TWO FRAMES */
 
-    while (!gfx_test_vertical_active()) ;
-    while (gfx_test_vertical_active()) ;
-    while (!gfx_test_vertical_active()) ;
-    while (gfx_test_vertical_active()) ;
-    while (!gfx_test_vertical_active()) ;
+    while (!gfx_test_vertical_active());
+    while (gfx_test_vertical_active());
+    while (!gfx_test_vertical_active());
+    while (gfx_test_vertical_active());
+    while (!gfx_test_vertical_active());
 
     /* VERIFY THAT XSTATE = 11 */
 
@@ -2767,7 +2775,7 @@ gfx_get_alpha_enable(int *enable)
     if (gfx_alpha_select <= 2) {
         value =
             READ_VID32(RCDF_ALPHA_CONTROL_1 +
-            ((unsigned long)gfx_alpha_select << 5));
+                       ((unsigned long) gfx_alpha_select << 5));
         if (value & RCDF_ACTRL_WIN_ENABLE)
             *enable = 1;
     }
@@ -2783,11 +2791,11 @@ gfx_get_alpha_enable(int *enable)
 #if GFX_VIDEO_DYNAMIC
 void
 redcloud_get_alpha_size(unsigned short *x, unsigned short *y,
-    unsigned short *width, unsigned short *height)
+                        unsigned short *width, unsigned short *height)
 #else
 void
 gfx_get_alpha_size(unsigned short *x, unsigned short *y,
-    unsigned short *width, unsigned short *height)
+                   unsigned short *width, unsigned short *height)
 #endif
 {
     unsigned long value = 0;
@@ -2799,14 +2807,14 @@ gfx_get_alpha_size(unsigned short *x, unsigned short *y,
     if (gfx_alpha_select <= 2) {
         value =
             READ_VID32(RCDF_ALPHA_XPOS_1 +
-            ((unsigned long)gfx_alpha_select << 5));
-        *x = (unsigned short)(value & 0x000007FF);
-        *width = (unsigned short)((value >> 16) & 0x000007FF) - *x;
+                       ((unsigned long) gfx_alpha_select << 5));
+        *x = (unsigned short) (value & 0x000007FF);
+        *width = (unsigned short) ((value >> 16) & 0x000007FF) - *x;
         value =
             READ_VID32(RCDF_ALPHA_YPOS_1 +
-            ((unsigned long)gfx_alpha_select << 5));
-        *y = (unsigned short)(value & 0x000007FF);
-        *height = (unsigned short)((value >> 16) & 0x000007FF) - *y;
+                       ((unsigned long) gfx_alpha_select << 5));
+        *y = (unsigned short) (value & 0x000007FF);
+        *height = (unsigned short) ((value >> 16) & 0x000007FF) - *y;
     }
     *x -= gfx_get_htotal() - gfx_get_hsync_end() - 2;
     *y -= gfx_get_vtotal() - gfx_get_vsync_end() + 1;
@@ -2835,9 +2843,9 @@ gfx_get_alpha_value(unsigned char *alpha, char *delta)
     if (gfx_alpha_select <= 2) {
         value =
             READ_VID32(RCDF_ALPHA_CONTROL_1 +
-            ((unsigned long)gfx_alpha_select << 5));
-        *alpha = (unsigned char)(value & 0x00FF);
-        *delta = (char)((value >> 8) & 0x00FF);
+                       ((unsigned long) gfx_alpha_select << 5));
+        *alpha = (unsigned char) (value & 0x00FF);
+        *delta = (char) ((value >> 8) & 0x00FF);
     }
     return;
 }
@@ -2862,7 +2870,7 @@ gfx_get_alpha_priority(int *priority)
     if (gfx_alpha_select <= 2) {
         value = READ_VID32(RCDF_VID_ALPHA_CONTROL);
         pos = 16 + (gfx_alpha_select << 1);
-        *priority = (int)((value >> pos) & 3);
+        *priority = (int) ((value >> pos) & 3);
     }
     return;
 }
@@ -2886,11 +2894,11 @@ gfx_get_alpha_color(unsigned long *color)
     if (gfx_alpha_select <= 2) {
         *color =
             READ_VID32(RCDF_ALPHA_COLOR_1 +
-            ((unsigned long)gfx_alpha_select << 5));
+                       ((unsigned long) gfx_alpha_select << 5));
     }
     return;
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
 /* END OF FILE */
diff --git a/src/gfx/vip_1200.c b/src/gfx/vip_1200.c
index 731e1b8..34acb8a 100644
--- a/src/gfx/vip_1200.c
+++ b/src/gfx/vip_1200.c
@@ -107,9 +107,9 @@ gfx_set_vip_base(unsigned long even, unsigned long odd)
 
     if (even)
         WRITE_VIP32(SC1200_VIP_EVEN_BASE,
-            even + (unsigned long)gfx_phys_fbptr);
+                    even + (unsigned long) gfx_phys_fbptr);
     if (odd)
-        WRITE_VIP32(SC1200_VIP_ODD_BASE, odd + (unsigned long)gfx_phys_fbptr);
+        WRITE_VIP32(SC1200_VIP_ODD_BASE, odd + (unsigned long) gfx_phys_fbptr);
     return (0);
 }
 
@@ -204,7 +204,7 @@ gfx_set_vbi_mode(int mode)
     config = READ_VIP32(SC1200_VIP_CONFIG);
     config &=
         ~(SC1200_VBI_ANCILLARY_TO_MEMORY | SC1200_VBI_TASK_A_TO_MEMORY |
-        SC1200_VBI_TASK_B_TO_MEMORY);
+          SC1200_VBI_TASK_B_TO_MEMORY);
 
     if (mode & VBI_ANCILLARY)
         config |= SC1200_VBI_ANCILLARY_TO_MEMORY;
@@ -275,9 +275,9 @@ gfx_set_vbi_direct(unsigned long even_lines, unsigned long odd_lines)
 #endif
 {
     WRITE_VIP32(SC1200_EVEN_DIRECT_VBI_LINE_ENABLE,
-        even_lines & SC1200_DIRECT_VBI_LINE_ENABLE_MASK);
+                even_lines & SC1200_DIRECT_VBI_LINE_ENABLE_MASK);
     WRITE_VIP32(SC1200_ODD_DIRECT_VBI_LINE_ENABLE,
-        odd_lines & SC1200_DIRECT_VBI_LINE_ENABLE_MASK);
+                odd_lines & SC1200_DIRECT_VBI_LINE_ENABLE_MASK);
     return (0);
 }
 
@@ -424,7 +424,8 @@ gfx_test_vip_fifo_overflow(void)
          * writing 1 */
         WRITE_VIP32(SC1200_VIP_STATUS, SC1200_VIP_FIFO_OVERFLOW);
         return (1);
-    } else {
+    }
+    else {
         return (0);
     }
 }
@@ -444,8 +445,8 @@ int
 gfx_get_vip_line(void)
 #endif
 {
-    return (int)(READ_VIP32(SC1200_VIP_CURRENT_LINE) &
-        SC1200_VIP_CURRENT_LINE_MASK);
+    return (int) (READ_VIP32(SC1200_VIP_CURRENT_LINE) &
+                  SC1200_VIP_CURRENT_LINE_MASK);
 }
 
 /*----------------------------------------------------------------------------
@@ -573,8 +574,9 @@ gfx_get_vbi_mode(void)
     int mode = 0;
 
     config =
-        (int)(READ_VIP32(SC1200_VIP_CONFIG) & (SC1200_VBI_ANCILLARY_TO_MEMORY
-            | SC1200_VBI_TASK_A_TO_MEMORY | SC1200_VBI_TASK_B_TO_MEMORY));
+        (int) (READ_VIP32(SC1200_VIP_CONFIG) & (SC1200_VBI_ANCILLARY_TO_MEMORY
+                                                | SC1200_VBI_TASK_A_TO_MEMORY |
+                                                SC1200_VBI_TASK_B_TO_MEMORY));
     if (config & SC1200_VBI_ANCILLARY_TO_MEMORY)
         mode |= VBI_ANCILLARY;
     if (config & SC1200_VBI_TASK_A_TO_MEMORY)
@@ -619,9 +621,9 @@ gfx_get_vbi_direct(int odd)
 
     if (odd)
         return (READ_VIP32(SC1200_ODD_DIRECT_VBI_LINE_ENABLE) &
-            SC1200_DIRECT_VBI_LINE_ENABLE_MASK);
+                SC1200_DIRECT_VBI_LINE_ENABLE_MASK);
     return (READ_VIP32(SC1200_EVEN_DIRECT_VBI_LINE_ENABLE) &
-        SC1200_DIRECT_VBI_LINE_ENABLE_MASK);
+            SC1200_DIRECT_VBI_LINE_ENABLE_MASK);
 }
 
 /*---------------------------------------------------------------------------
@@ -658,6 +660,6 @@ gfx_get_vip_bus_request_threshold_high(void)
     return (0);
 }
 
-#endif /* GFX_READ_ROUTINES */
+#endif                          /* GFX_READ_ROUTINES */
 
 /* END OF FILE */
diff --git a/src/gx_accel.c b/src/gx_accel.c
index 34df4df..58aa833 100644
--- a/src/gx_accel.c
+++ b/src/gx_accel.c
@@ -97,8 +97,7 @@ static unsigned int ACCEL_STRIDE;
 
 /* static storage declarations */
 
-typedef struct sGBltBox
-{
+typedef struct sGBltBox {
     ulong x, y;
     ulong w, h;
     ulong color;
@@ -116,8 +115,7 @@ static ulong *gc8x8p;
 #endif
 
 #if GX_DASH_LINE_SUPPORT
-typedef struct sGDashLine
-{
+typedef struct sGDashLine {
     ulong pat[2];
     int len;
     int fg;
@@ -170,16 +168,16 @@ amd_gx_BppToRasterMode(int bpp)
 {
     switch (bpp) {
     case 16:
-	return MGP_RM_BPPFMT_565;
+        return MGP_RM_BPPFMT_565;
     case 32:
-	return MGP_RM_BPPFMT_8888;
+        return MGP_RM_BPPFMT_8888;
     case 8:
-	return MGP_RM_BPPFMT_332;
+        return MGP_RM_BPPFMT_332;
     default:
-	return 0;
+        return 0;
     }
 }
-#endif /* OPT_ACCEL */
+#endif                          /* OPT_ACCEL */
 
 /*----------------------------------------------------------------------------
  * GXAccelSync.
@@ -223,7 +221,7 @@ GXAccelSync(ScrnInfoPtr pScrni)
  *--------------------------------------------------------------------------*/
 static void
 GXSetupForSolidFill(ScrnInfoPtr pScrni,
-    int color, int rop, unsigned int planemask)
+                    int color, int rop, unsigned int planemask)
 {
     //ErrorF("GXSetupForSolidFill(%#x,%#x,%#x)\n", color, rop, planemask);
     rop &= 0x0F;
@@ -233,16 +231,16 @@ GXSetupForSolidFill(ScrnInfoPtr pScrni,
     gfx_set_raster_operation(planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
 #else
     {
-	unsigned int ROP =
-	    BPP | (planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
-	BLT_MODE = ((ROP ^ (ROP >> 2)) & 0x33) == 0 ? MGP_BM_SRC_MONO : 0;
-	if (((ROP ^ (ROP >> 1)) & 0x55) != 0)
-	    BLT_MODE |= MGP_BM_DST_REQ;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_RASTER_MODE, ROP);
-	WRITE_GP32(MGP_PAT_COLOR_0, planemask);
-	WRITE_GP32(MGP_SRC_COLOR_FG, color);
-	WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
+        unsigned int ROP = BPP | (planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
+
+        BLT_MODE = ((ROP ^ (ROP >> 2)) & 0x33) == 0 ? MGP_BM_SRC_MONO : 0;
+        if (((ROP ^ (ROP >> 1)) & 0x55) != 0)
+            BLT_MODE |= MGP_BM_DST_REQ;
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_RASTER_MODE, ROP);
+        WRITE_GP32(MGP_PAT_COLOR_0, planemask);
+        WRITE_GP32(MGP_SRC_COLOR_FG, color);
+        WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
     }
 #endif
 }
@@ -277,18 +275,18 @@ GXSubsequentSolidFillRect(ScrnInfoPtr pScrni, int x, int y, int w, int h)
     gfx_pattern_fill(x, y, w, h);
 #else
     {
-	unsigned int offset = CALC_FBOFFSET(x, y);
-	unsigned int size = (w << 16) | h;
+        unsigned int offset = CALC_FBOFFSET(x, y);
+        unsigned int size = (w << 16) | h;
 
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_DST_OFFSET, offset);
-	WRITE_GP32(MGP_WID_HEIGHT, size);
-	WRITE_GP32(MGP_BLT_MODE, BLT_MODE);
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_DST_OFFSET, offset);
+        WRITE_GP32(MGP_WID_HEIGHT, size);
+        WRITE_GP32(MGP_BLT_MODE, BLT_MODE);
     }
 #endif
 }
 
-#endif /* if GX_FILL_RECT_SUPPORT */
+#endif                          /* if GX_FILL_RECT_SUPPORT */
 
 #if GX_CLREXP_8X8_PAT_SUPPORT
 /*----------------------------------------------------------------------------
@@ -315,24 +313,24 @@ GXSubsequentSolidFillRect(ScrnInfoPtr pScrni, int x, int y, int w, int h)
 
 static void
 GXSetupForColor8x8PatternFill(ScrnInfoPtr pScrni, int patx, int paty, int rop,
-    uint planemask, int trans_color)
+                              uint planemask, int trans_color)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     //ErrorF("GXSetupForColor8x8PatternFill() pat %#x,%#x rop %#x %#x %#x\n",
     //    patx, paty, rop, planemask, trans_color);
     rop &= 0x0F;
-    gc8x8p = (unsigned long *)FBADDR(patx, paty);
+    gc8x8p = (unsigned long *) FBADDR(patx, paty);
     /* gfx_set_solid_pattern is needed to clear src/pat transparency */
     gfx_set_solid_pattern(0);
     gfx_set_raster_operation(planemask == ~0U ? PDfn[rop] :
-	(gfx_set_solid_source(planemask), PDfn_SM[rop]));
+                             (gfx_set_solid_source(planemask), PDfn_SM[rop]));
     gfx2_set_source_stride(pGeode->Pitch);
     gfx2_set_destination_stride(pGeode->Pitch);
     if (trans_color == -1)
-	gfx2_set_source_transparency(0, 0);
+        gfx2_set_source_transparency(0, 0);
     else
-	gfx2_set_source_transparency(trans_color, ~0);
+        gfx2_set_source_transparency(trans_color, ~0);
 }
 
 /*----------------------------------------------------------------------------
@@ -358,7 +356,7 @@ GXSetupForColor8x8PatternFill(ScrnInfoPtr pScrni, int patx, int paty, int rop,
  *--------------------------------------------------------------------------*/
 static void
 GXSubsequentColor8x8PatternFillRect(ScrnInfoPtr pScrni, int patx, int paty,
-    int x, int y, int w, int h)
+                                    int x, int y, int w, int h)
 {
     //ErrorF(
     //    "GXSubsequentColor8x8PatternFillRect() patxy %d,%d at %d,%d %dsx%d\n",
@@ -396,7 +394,7 @@ GXSubsequentColor8x8PatternFillRect(ScrnInfoPtr pScrni, int patx, int paty,
  *--------------------------------------------------------------------------*/
 static void
 GXSetupForMono8x8PatternFill(ScrnInfoPtr pScrni, int patx, int paty,
-    int fg, int bg, int rop, uint planemask)
+                             int fg, int bg, int rop, uint planemask)
 {
     //ErrorF(
     //"GXSetupForMono8x8PatternFill() pat %#x,%#x fg %#x bg %#x %#x %#x\n",
@@ -405,24 +403,24 @@ GXSetupForMono8x8PatternFill(ScrnInfoPtr pScrni, int patx, int paty,
 #ifndef OPT_ACCEL
     gfx_set_mono_pattern(bg, fg, patx, paty, bg == -1 ? 1 : 0);
     gfx_set_raster_operation(planemask == ~0U ? PDfn[rop] :
-	(gfx_set_solid_source(planemask), PDfn_SM[rop]));
+                             (gfx_set_solid_source(planemask), PDfn_SM[rop]));
 #else
     {
-	unsigned int ROP = BPP |
-	    (bg ==
-	    -1 ? MGP_RM_PAT_MONO | MGP_RM_PAT_TRANS : MGP_RM_PAT_MONO) |
-	    (planemask == ~0U ? PDfn[rop] : PDfn_SM[rop]);
-	BLT_MODE = ((ROP ^ (ROP >> 2)) & 0x33) == 0 ? MGP_BM_SRC_MONO : 0;
-	if (((ROP ^ (ROP >> 1)) & 0x55) != 0)
-	    BLT_MODE |= MGP_BM_DST_REQ;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_RASTER_MODE, ROP);
-	WRITE_GP32(MGP_SRC_COLOR_FG, planemask);
-	WRITE_GP32(MGP_PAT_COLOR_0, bg);
-	WRITE_GP32(MGP_PAT_COLOR_1, fg);
-	WRITE_GP32(MGP_PAT_DATA_0, patx);
-	WRITE_GP32(MGP_PAT_DATA_1, paty);
-	WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
+        unsigned int ROP = BPP |
+            (bg ==
+             -1 ? MGP_RM_PAT_MONO | MGP_RM_PAT_TRANS : MGP_RM_PAT_MONO) |
+            (planemask == ~0U ? PDfn[rop] : PDfn_SM[rop]);
+        BLT_MODE = ((ROP ^ (ROP >> 2)) & 0x33) == 0 ? MGP_BM_SRC_MONO : 0;
+        if (((ROP ^ (ROP >> 1)) & 0x55) != 0)
+            BLT_MODE |= MGP_BM_DST_REQ;
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_RASTER_MODE, ROP);
+        WRITE_GP32(MGP_SRC_COLOR_FG, planemask);
+        WRITE_GP32(MGP_PAT_COLOR_0, bg);
+        WRITE_GP32(MGP_PAT_COLOR_1, fg);
+        WRITE_GP32(MGP_PAT_DATA_0, patx);
+        WRITE_GP32(MGP_PAT_DATA_1, paty);
+        WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
     }
 #endif
 }
@@ -450,27 +448,27 @@ GXSetupForMono8x8PatternFill(ScrnInfoPtr pScrni, int patx, int paty,
  *--------------------------------------------------------------------------*/
 static void
 GXSubsequentMono8x8PatternFillRect(ScrnInfoPtr pScrni, int patx, int paty,
-    int x, int y, int w, int h)
+                                   int x, int y, int w, int h)
 {
     DEBUGMSG(1, (0, X_INFO, "%s() pat %#x,%#x at %d,%d %dx%d\n",
-	    __func__, patx, paty, x, y, w, h));
+                 __func__, patx, paty, x, y, w, h));
 #ifndef OPT_ACCEL
     gfx_pattern_fill(x, y, w, h);
 #else
     {
-	unsigned int offset =
-	    CALC_FBOFFSET(x, y) | ((x & 7) << 26) | ((y & 7) << 29);
-	unsigned int size = (w << 16) | h;
-
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_DST_OFFSET, offset);
-	WRITE_GP32(MGP_WID_HEIGHT, size);
-	WRITE_GP32(MGP_BLT_MODE, BLT_MODE);
+        unsigned int offset =
+            CALC_FBOFFSET(x, y) | ((x & 7) << 26) | ((y & 7) << 29);
+        unsigned int size = (w << 16) | h;
+
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_DST_OFFSET, offset);
+        WRITE_GP32(MGP_WID_HEIGHT, size);
+        WRITE_GP32(MGP_BLT_MODE, BLT_MODE);
     }
 #endif
 }
 
-#endif /* GX_MONO_8X8_PAT_SUPPORT */
+#endif                          /* GX_MONO_8X8_PAT_SUPPORT */
 
 #if GX_SCR2SCRCPY_SUPPORT
 /*----------------------------------------------------------------------------
@@ -492,40 +490,40 @@ GXSubsequentMono8x8PatternFillRect(ScrnInfoPtr pScrni, int patx, int paty,
  *---------------------------------------------------------------------------*/
 static void
 GXSetupForScreenToScreenCopy(ScrnInfoPtr pScrni, int xdir, int ydir, int rop,
-    uint planemask, int trans_color)
+                             uint planemask, int trans_color)
 {
     DEBUGMSG(1, (0, X_INFO, "%s() xd%d yd%d rop %#x %#x %#x\n",
-	    __func__, xdir, ydir, rop, planemask, trans_color));
+                 __func__, xdir, ydir, rop, planemask, trans_color));
     rop &= 0x0F;
 #ifndef OPT_ACCEL
     {
-	GeodeRec *pGeode = GEODEPTR(pScrni);
-
-	gfx_set_solid_pattern(planemask);
-	/* transparency is a parameter to set_rop, but set...pattern clears
-	 * transparency */
-	if (trans_color == -1)
-	    gfx2_set_source_transparency(0, 0);
-	else
-	    gfx2_set_source_transparency(trans_color, ~0);
-	gfx_set_raster_operation(planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
-	gfx2_set_source_stride(pGeode->Pitch);
-	gfx2_set_destination_stride(pGeode->Pitch);
+        GeodeRec *pGeode = GEODEPTR(pScrni);
+
+        gfx_set_solid_pattern(planemask);
+        /* transparency is a parameter to set_rop, but set...pattern clears
+         * transparency */
+        if (trans_color == -1)
+            gfx2_set_source_transparency(0, 0);
+        else
+            gfx2_set_source_transparency(trans_color, ~0);
+        gfx_set_raster_operation(planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
+        gfx2_set_source_stride(pGeode->Pitch);
+        gfx2_set_destination_stride(pGeode->Pitch);
     }
 #else
     {
-	unsigned int ROP =
-	    BPP | (planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
-	if (trans_color != -1)
-	    ROP |= MGP_RM_SRC_TRANS;
-	BLT_MODE = ((ROP ^ (ROP >> 1)) & 0x55) != 0 ?
-	    MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_RASTER_MODE, ROP);
-	WRITE_GP32(MGP_PAT_COLOR_0, planemask);
-	WRITE_GP32(MGP_SRC_COLOR_FG, trans_color);
-	WRITE_GP32(MGP_SRC_COLOR_BG, ~0);
-	WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
+        unsigned int ROP = BPP | (planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
+
+        if (trans_color != -1)
+            ROP |= MGP_RM_SRC_TRANS;
+        BLT_MODE = ((ROP ^ (ROP >> 1)) & 0x55) != 0 ?
+            MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_RASTER_MODE, ROP);
+        WRITE_GP32(MGP_PAT_COLOR_0, planemask);
+        WRITE_GP32(MGP_SRC_COLOR_FG, trans_color);
+        WRITE_GP32(MGP_SRC_COLOR_BG, ~0);
+        WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
     }
 #endif
 }
@@ -553,53 +551,54 @@ GXSetupForScreenToScreenCopy(ScrnInfoPtr pScrni, int xdir, int ydir, int rop,
  *---------------------------------------------------------------------------*/
 static void
 GXSubsequentScreenToScreenCopy(ScrnInfoPtr pScrni,
-    int x1, int y1, int x2, int y2, int w, int h)
+                               int x1, int y1, int x2, int y2, int w, int h)
 {
     DEBUGMSG(1, (0, X_INFO, "%s() from %d,%d to %d,%d %dx%d\n",
-	    __func__, x1, y1, x2, y2, w, h));
+                 __func__, x1, y1, x2, y2, w, h));
 #ifndef OPT_ACCEL
     {
-	int flags = 0;
-
-	if (x2 > x1)
-	    flags |= 1;
-	if (y2 > y1)
-	    flags |= 2;
-	gfx2_screen_to_screen_blt(CALC_FBOFFSET(x1, y1), CALC_FBOFFSET(x2,
-		y2), w, h, flags);
+        int flags = 0;
+
+        if (x2 > x1)
+            flags |= 1;
+        if (y2 > y1)
+            flags |= 2;
+        gfx2_screen_to_screen_blt(CALC_FBOFFSET(x1, y1), CALC_FBOFFSET(x2,
+                                                                       y2), w,
+                                  h, flags);
     }
 #else
     {
-	GeodeRec *pGeode = GEODEPTR(pScrni);
-	unsigned int src = CALC_FBOFFSET(x1, y1);
-	unsigned int dst = CALC_FBOFFSET(x2, y2);
-	unsigned int size = (w << 16) | h;
-	unsigned int blt_mode = BLT_MODE;
-
-	if (x2 > x1) {
-	    int n = (w << gu2_xshift) - 1;
-
-	    src += n;
-	    dst += n;
-	    blt_mode |= MGP_BM_NEG_XDIR;
-	}
-	if (y2 > y1) {
-	    int n = (h - 1) * pGeode->Pitch;
-
-	    src += n;
-	    dst += n;
-	    blt_mode |= MGP_BM_NEG_YDIR;
-	}
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_SRC_OFFSET, src);
-	WRITE_GP32(MGP_DST_OFFSET, dst);
-	WRITE_GP32(MGP_WID_HEIGHT, size);
-	WRITE_GP16(MGP_BLT_MODE, blt_mode);
+        GeodeRec *pGeode = GEODEPTR(pScrni);
+        unsigned int src = CALC_FBOFFSET(x1, y1);
+        unsigned int dst = CALC_FBOFFSET(x2, y2);
+        unsigned int size = (w << 16) | h;
+        unsigned int blt_mode = BLT_MODE;
+
+        if (x2 > x1) {
+            int n = (w << gu2_xshift) - 1;
+
+            src += n;
+            dst += n;
+            blt_mode |= MGP_BM_NEG_XDIR;
+        }
+        if (y2 > y1) {
+            int n = (h - 1) * pGeode->Pitch;
+
+            src += n;
+            dst += n;
+            blt_mode |= MGP_BM_NEG_YDIR;
+        }
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_SRC_OFFSET, src);
+        WRITE_GP32(MGP_DST_OFFSET, dst);
+        WRITE_GP32(MGP_WID_HEIGHT, size);
+        WRITE_GP16(MGP_BLT_MODE, blt_mode);
     }
 #endif
 }
 
-#endif /* if GX_SCR2SCRCPY_SUPPORT */
+#endif                          /* if GX_SCR2SCRCPY_SUPPORT */
 
 #if GX_SCANLINE_SUPPORT
 /*----------------------------------------------------------------------------
@@ -626,20 +625,20 @@ GXSubsequentScreenToScreenCopy(ScrnInfoPtr pScrni,
  */
 static void
 GXSetupForScanlineImageWrite(ScrnInfoPtr pScrni, int rop, uint planemask,
-    int trans_color, int bpp, int depth)
+                             int trans_color, int bpp, int depth)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     DEBUGMSG(1, (0, X_INFO, "%s() rop %#x %#x %#x %d %d\n",
-	    __func__, rop, planemask, trans_color, bpp, depth));
+                 __func__, rop, planemask, trans_color, bpp, depth));
     rop &= 0x0F;
     /* transparency is a parameter to set_rop, but set...pattern clears
      * transparency */
     gfx_set_solid_pattern(planemask);
     if (trans_color == -1)
-	gfx2_set_source_transparency(0, 0);
+        gfx2_set_source_transparency(0, 0);
     else
-	gfx2_set_source_transparency(trans_color, ~0);
+        gfx2_set_source_transparency(trans_color, ~0);
     gfx_set_raster_operation(planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
     gfx2_set_source_stride(pGeode->Pitch);
     gfx2_set_destination_stride(pGeode->Pitch);
@@ -662,10 +661,10 @@ GXSetupForScanlineImageWrite(ScrnInfoPtr pScrni, int rop, uint planemask,
  *---------------------------------------------------------------------------*/
 static void
 GXSubsequentScanlineImageWriteRect(ScrnInfoPtr pScrni,
-    int x, int y, int w, int h, int skipleft)
+                                   int x, int y, int w, int h, int skipleft)
 {
     DEBUGMSG(1, (0, X_INFO, "%s() rop %d,%d %dx%d %d\n",
-	    __func__, x, y, w, h, skipleft));
+                 __func__, x, y, w, h, skipleft));
     giwr.x = x;
     giwr.y = y;
     giwr.w = w;
@@ -708,35 +707,39 @@ GXSubsequentImageWriteScanline(ScrnInfoPtr pScrni, int bufno)
 #if !GX_USE_OFFSCRN_MEM
     offset = pGeode->AccelImageWriteBuffers[bufno] - pGeode->FBBase;
     gfx2_screen_to_screen_blt(offset, CALC_FBOFFSET(giwr.x, giwr.y), giwr.w,
-	1, 0);
-#else /* if !GX_USE_OFFSCRN_MEM */
+                              1, 0);
+#else                           /* if !GX_USE_OFFSCRN_MEM */
     gfx2_color_bitmap_to_screen_blt(0, 0, CALC_FBOFFSET(giwr.x, giwr.y),
-	giwr.w, 1, pGeode->AccelImageWriteBuffers[bufno], pGeode->Pitch);
-#endif /* if !GX_USE_OFFSCRN_MEM */
+                                    giwr.w, 1,
+                                    pGeode->AccelImageWriteBuffers[bufno],
+                                    pGeode->Pitch);
+#endif                          /* if !GX_USE_OFFSCRN_MEM */
     ++giwr.y;
-#else /* if GX_ONE_LINE_AT_A_TIME */
+#else                           /* if GX_ONE_LINE_AT_A_TIME */
     int blt_height;
 
     DEBUGMSG(1, (0, X_INFO, "%s() %d\n", __func__, bufno));
 
     if ((blt_height = pGeode->NoOfImgBuffers) > giwr.h)
-	blt_height = giwr.h;
+        blt_height = giwr.h;
     if (++bufno < blt_height)
-	return;
+        return;
 #if !GX_USE_OFFSCRN_MEM
     offset = pGeode->AccelImageWriteBuffers[0] - pGeode->FBBase;
     gfx2_screen_to_screen_blt(offset, CALC_FBOFFSET(giwr.x, giwr.y), giwr.w,
-	blt_height, 0);
+                              blt_height, 0);
     GXAccelSync(pScrni);
-#else /* if !GX_USE_OFFSCRN_MEM */
+#else                           /* if !GX_USE_OFFSCRN_MEM */
     gfx2_color_bitmap_to_screen_blt(0, 0, CALC_FBOFFSET(giwr.x, giwr.y),
-	giwr.w, blt_height, pGeode->AccelImageWriteBuffers[0], pGeode->Pitch);
-#endif /* if !GX_USE_OFFSCRN_MEM */
+                                    giwr.w, blt_height,
+                                    pGeode->AccelImageWriteBuffers[0],
+                                    pGeode->Pitch);
+#endif                          /* if !GX_USE_OFFSCRN_MEM */
     giwr.h -= blt_height;
     giwr.y += blt_height;
-#endif /* if GX_ONE_LINE_AT_A_TIME */
+#endif                          /* if GX_ONE_LINE_AT_A_TIME */
 }
-#endif /* GX_SCANLINE_SUPPORT */
+#endif                          /* GX_SCANLINE_SUPPORT */
 
 #if GX_CPU2SCREXP_SUPPORT
 /*----------------------------------------------------------------------------
@@ -759,13 +762,14 @@ GXSubsequentImageWriteScanline(ScrnInfoPtr pScrni, int bufno)
 
 static void
 GXSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrni,
-    int fg, int bg, int rop, uint planemask)
+                                             int fg, int bg, int rop,
+                                             uint planemask)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
     ulong srcpitch;
 
     DEBUGMSG(1, (0, X_INFO, "%s() fg %#x bg %#x rop %#x %#x\n",
-	    __func__, fg, bg, rop, planemask));
+                 __func__, fg, bg, rop, planemask));
     rop &= 0x0F;
     srcpitch = ((pGeode->Pitch + 31) >> 5) << 2;
 #ifndef OPT_ACCEL
@@ -776,20 +780,20 @@ GXSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrni,
     gfx2_set_destination_stride(pGeode->Pitch);
 #else
     {
-	unsigned int stride = (srcpitch << 16) | pGeode->Pitch;
-	unsigned int ROP =
-	    BPP | (planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
-	if (bg == -1)
-	    ROP |= MGP_RM_SRC_TRANS;
-	BLT_MODE = ((ROP ^ (ROP >> 1)) & 0x55) != 0 ?
-	    MGP_BM_SRC_MONO | MGP_BM_SRC_FB | MGP_BM_DST_REQ :
-	    MGP_BM_SRC_MONO | MGP_BM_SRC_FB;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_RASTER_MODE, ROP);
-	WRITE_GP32(MGP_PAT_COLOR_0, planemask);
-	WRITE_GP32(MGP_SRC_COLOR_BG, bg);
-	WRITE_GP32(MGP_SRC_COLOR_FG, fg);
-	WRITE_GP32(MGP_STRIDE, stride);
+        unsigned int stride = (srcpitch << 16) | pGeode->Pitch;
+        unsigned int ROP = BPP | (planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
+
+        if (bg == -1)
+            ROP |= MGP_RM_SRC_TRANS;
+        BLT_MODE = ((ROP ^ (ROP >> 1)) & 0x55) != 0 ?
+            MGP_BM_SRC_MONO | MGP_BM_SRC_FB | MGP_BM_DST_REQ :
+            MGP_BM_SRC_MONO | MGP_BM_SRC_FB;
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_RASTER_MODE, ROP);
+        WRITE_GP32(MGP_PAT_COLOR_0, planemask);
+        WRITE_GP32(MGP_SRC_COLOR_BG, bg);
+        WRITE_GP32(MGP_SRC_COLOR_FG, fg);
+        WRITE_GP32(MGP_STRIDE, stride);
     }
 #endif
 }
@@ -812,10 +816,11 @@ GXSetupForScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrni,
  *---------------------------------------------------------------------------*/
 static void
 GXSubsequentScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrni,
-    int x, int y, int w, int h, int skipleft)
+                                               int x, int y, int w, int h,
+                                               int skipleft)
 {
     DEBUGMSG(1, (0, X_INFO, "%s() %d,%d %dx%d %d\n",
-	    __func__, x, y, w, h, skipleft));
+                 __func__, x, y, w, h, skipleft));
     gc2s.x = x;
     gc2s.y = y;
     gc2s.w = w;
@@ -823,16 +828,16 @@ GXSubsequentScanlineCPUToScreenColorExpandFill(ScrnInfoPtr pScrni,
 #ifdef OPT_ACCEL
     {
 #if GX_ONE_LINE_AT_A_TIME
-	unsigned int size = (gc2s.w << 16) | 1;
+        unsigned int size = (gc2s.w << 16) | 1;
 
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_WID_HEIGHT, size);
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_WID_HEIGHT, size);
 #else
-	GeodeRec *pGeode = GEODEPTR(pScrni);
-	unsigned int src =
-	    pGeode->AccelColorExpandBuffers[0] - pGeode->FBBase;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_SRC_OFFSET, src);
+        GeodeRec *pGeode = GEODEPTR(pScrni);
+        unsigned int src = pGeode->AccelColorExpandBuffers[0] - pGeode->FBBase;
+
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_SRC_OFFSET, src);
 #endif
     }
 #endif
@@ -859,62 +864,64 @@ GXSubsequentColorExpandScanline(ScrnInfoPtr pScrni, int bufno)
 #ifndef OPT_ACCEL
     {
 #if GX_ONE_LINE_AT_A_TIME
-	ulong offset =
-	    pGeode->AccelColorExpandBuffers[bufno] - pGeode->FBBase;
-	gfx2_mono_expand_blt(offset, 0, 0, CALC_FBOFFSET(gc2s.x, gc2s.y),
-	    gc2s.w, 1, 0);
-	++gc2s.y;
-#else /* if GX_ONE_LINE_AT_A_TIME */
-	ulong srcpitch;
-	int blt_height;
-
-	if ((blt_height = pGeode->NoOfImgBuffers) > gc2s.h)
-	    blt_height = gc2s.h;
-	if (++bufno < blt_height)
-	    return;
-
-	/* convert from bits to dwords */
-	srcpitch = ((pGeode->Pitch + 31) >> 5) << 2;
-	gfx2_mono_bitmap_to_screen_blt(0, 0, CALC_FBOFFSET(gc2s.x, gc2s.y),
-	    gc2s.w, blt_height, pGeode->AccelColorExpandBuffers[0], srcpitch);
-	gc2s.h -= blt_height;
-	gc2s.y += blt_height;
-#endif /* if GX_ONE_LINE_AT_A_TIME */
+        ulong offset = pGeode->AccelColorExpandBuffers[bufno] - pGeode->FBBase;
+
+        gfx2_mono_expand_blt(offset, 0, 0, CALC_FBOFFSET(gc2s.x, gc2s.y),
+                             gc2s.w, 1, 0);
+        ++gc2s.y;
+#else                           /* if GX_ONE_LINE_AT_A_TIME */
+        ulong srcpitch;
+        int blt_height;
+
+        if ((blt_height = pGeode->NoOfImgBuffers) > gc2s.h)
+            blt_height = gc2s.h;
+        if (++bufno < blt_height)
+            return;
+
+        /* convert from bits to dwords */
+        srcpitch = ((pGeode->Pitch + 31) >> 5) << 2;
+        gfx2_mono_bitmap_to_screen_blt(0, 0, CALC_FBOFFSET(gc2s.x, gc2s.y),
+                                       gc2s.w, blt_height,
+                                       pGeode->AccelColorExpandBuffers[0],
+                                       srcpitch);
+        gc2s.h -= blt_height;
+        gc2s.y += blt_height;
+#endif                          /* if GX_ONE_LINE_AT_A_TIME */
     }
-#else /* ifndef OPT_ACCEL */
+#else                           /* ifndef OPT_ACCEL */
     {
 #if GX_ONE_LINE_AT_A_TIME
-	unsigned int src =
-	    pGeode->AccelColorExpandBuffers[bufno] - pGeode->FBBase;
-	unsigned int dst = CALC_FBOFFSET(gc2s.x, gc2s.y);
-
-	++gc2s.y;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_SRC_OFFSET, src);
-	WRITE_GP32(MGP_DST_OFFSET, dst);
-	WRITE_GP16(MGP_BLT_MODE, BLT_MODE);
-#else /* if GX_ONE_LINE_AT_A_TIME */
-	unsigned int dst, size;
-	int blt_height;
-
-	GU2_WAIT_BUSY;
-	if ((blt_height = pGeode->NoOfImgBuffers) > gc2s.h)
-	    blt_height = gc2s.h;
-	if (++bufno < blt_height)
-	    return;
-	dst = CALC_FBOFFSET(gc2s.x, gc2s.y);
-	size = (gc2s.w << 16) | blt_height;
-	gc2s.h -= blt_height;
-	gc2s.y += blt_height;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_DST_OFFSET, dst);
-	WRITE_GP32(MGP_WID_HEIGHT, size);
-	WRITE_GP16(MGP_BLT_MODE, BLT_MODE);
-#endif /* if GX_ONE_LINE_AT_A_TIME */
+        unsigned int src =
+            pGeode->AccelColorExpandBuffers[bufno] - pGeode->FBBase;
+        unsigned int dst = CALC_FBOFFSET(gc2s.x, gc2s.y);
+
+        ++gc2s.y;
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_SRC_OFFSET, src);
+        WRITE_GP32(MGP_DST_OFFSET, dst);
+        WRITE_GP16(MGP_BLT_MODE, BLT_MODE);
+#else                           /* if GX_ONE_LINE_AT_A_TIME */
+        unsigned int dst, size;
+        int blt_height;
+
+        GU2_WAIT_BUSY;
+        if ((blt_height = pGeode->NoOfImgBuffers) > gc2s.h)
+            blt_height = gc2s.h;
+        if (++bufno < blt_height)
+            return;
+        dst = CALC_FBOFFSET(gc2s.x, gc2s.y);
+        size = (gc2s.w << 16) | blt_height;
+        gc2s.h -= blt_height;
+        gc2s.y += blt_height;
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_DST_OFFSET, dst);
+        WRITE_GP32(MGP_WID_HEIGHT, size);
+        WRITE_GP16(MGP_BLT_MODE, BLT_MODE);
+#endif                          /* if GX_ONE_LINE_AT_A_TIME */
     }
-#endif /* ifndef OPT_ACCEL */
+#endif                          /* ifndef OPT_ACCEL */
 }
-#endif /* GX_CPU2SCREXP_SUPPORT */
+#endif                          /* GX_CPU2SCREXP_SUPPORT */
 
 #if GX_SCR2SCREXP_SUPPORT
 /*----------------------------------------------------------------------------
@@ -937,36 +944,36 @@ GXSubsequentColorExpandScanline(ScrnInfoPtr pScrni, int bufno)
 
 static void
 GXSetupForScreenToScreenColorExpandFill(ScrnInfoPtr pScrni, int fg, int bg,
-    int rop, uint planemask)
+                                        int rop, uint planemask)
 {
     DEBUGMSG(1, (0, X_INFO, "%s() fg %#x bg %#x rop %#x %#x\n",
-	    __func__, fg, bg, rop, planemask));
+                 __func__, fg, bg, rop, planemask));
     rop &= 0x0F;
 #ifndef OPT_ACCEL
     {
-	GeodeRec *pGeode = GEODEPTR(pScrni);
+        GeodeRec *pGeode = GEODEPTR(pScrni);
 
-	gfx_set_solid_pattern(planemask);
-	gfx_set_mono_source(bg, fg, bg == -1 ? 1 : 0);
-	gfx_set_raster_operation(planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
-	gfx2_set_source_stride(pGeode->Pitch);
-	gfx2_set_destination_stride(pGeode->Pitch);
+        gfx_set_solid_pattern(planemask);
+        gfx_set_mono_source(bg, fg, bg == -1 ? 1 : 0);
+        gfx_set_raster_operation(planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
+        gfx2_set_source_stride(pGeode->Pitch);
+        gfx2_set_destination_stride(pGeode->Pitch);
     }
 #else
     {
-	unsigned int ROP =
-	    BPP | (planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
-	if (bg == -1)
-	    ROP |= MGP_RM_SRC_TRANS;
-	BLT_MODE = ((ROP ^ (ROP >> 1)) & 0x55) != 0 ?
-	    MGP_BM_SRC_MONO | MGP_BM_SRC_FB | MGP_BM_DST_REQ :
-	    MGP_BM_SRC_MONO | MGP_BM_SRC_FB;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_RASTER_MODE, ROP);
-	WRITE_GP32(MGP_PAT_COLOR_0, planemask);
-	WRITE_GP32(MGP_SRC_COLOR_BG, bg);
-	WRITE_GP32(MGP_SRC_COLOR_FG, fg);
-	WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
+        unsigned int ROP = BPP | (planemask == ~0U ? SDfn[rop] : SDfn_PM[rop]);
+
+        if (bg == -1)
+            ROP |= MGP_RM_SRC_TRANS;
+        BLT_MODE = ((ROP ^ (ROP >> 1)) & 0x55) != 0 ?
+            MGP_BM_SRC_MONO | MGP_BM_SRC_FB | MGP_BM_DST_REQ :
+            MGP_BM_SRC_MONO | MGP_BM_SRC_FB;
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_RASTER_MODE, ROP);
+        WRITE_GP32(MGP_PAT_COLOR_0, planemask);
+        WRITE_GP32(MGP_SRC_COLOR_BG, bg);
+        WRITE_GP32(MGP_SRC_COLOR_FG, fg);
+        WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
     }
 #endif
 }
@@ -990,29 +997,31 @@ GXSetupForScreenToScreenColorExpandFill(ScrnInfoPtr pScrni, int fg, int bg,
  *---------------------------------------------------------------------------*/
 static void
 GXSubsequentScreenToScreenColorExpandFill(ScrnInfoPtr pScrni,
-    int x, int y, int w, int h, int srcx, int srcy, int offset)
+                                          int x, int y, int w, int h, int srcx,
+                                          int srcy, int offset)
 {
     DEBUGMSG(1, (0, X_INFO, "%s() %d,%d %dx%d %d,%d %d\n",
-	    __func__, x, y, w, h, srcx, srcy, offset));
+                 __func__, x, y, w, h, srcx, srcy, offset));
 #ifndef OPT_ACCEL
     gfx2_mono_expand_blt(CALC_FBOFFSET(srcx, srcy), offset, 0,
-	CALC_FBOFFSET(x, y), w, h, 0);
+                         CALC_FBOFFSET(x, y), w, h, 0);
 #else
     {
-	unsigned int src = (CALC_FBOFFSET(srcx,
-		srcy) + (offset >> 3)) | ((offset & 7) << 26);
-	unsigned int dst = CALC_FBOFFSET(x, y);
-	unsigned int size = (w << 16) | h;
-
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_SRC_OFFSET, src);
-	WRITE_GP32(MGP_DST_OFFSET, dst);
-	WRITE_GP32(MGP_WID_HEIGHT, size);
-	WRITE_GP16(MGP_BLT_MODE, BLT_MODE);
+        unsigned int src = (CALC_FBOFFSET(srcx,
+                                          srcy) +
+                            (offset >> 3)) | ((offset & 7) << 26);
+        unsigned int dst = CALC_FBOFFSET(x, y);
+        unsigned int size = (w << 16) | h;
+
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_SRC_OFFSET, src);
+        WRITE_GP32(MGP_DST_OFFSET, dst);
+        WRITE_GP32(MGP_WID_HEIGHT, size);
+        WRITE_GP16(MGP_BLT_MODE, BLT_MODE);
     }
 #endif
 }
-#endif /* GX_SCR2SCREXP_SUPPORT */
+#endif                          /* GX_SCR2SCREXP_SUPPORT */
 
 #define VM_MAJOR_DEC 0
 #define VM_MINOR_DEC 0
@@ -1056,24 +1065,25 @@ static void
 GXSetupForSolidLine(ScrnInfoPtr pScrni, int color, int rop, uint planemask)
 {
     DEBUGMSG(1, (0, X_INFO, "%s() %#x %#x %#x\n",
-	    __func__, color, rop, planemask));
+                 __func__, color, rop, planemask));
     rop &= 0x0F;
 #ifndef OPT_ACCEL
     gfx_set_solid_pattern(color);
     gfx_set_raster_operation(planemask == ~0U ? PDfn[rop] :
-	(gfx_set_solid_source(planemask), PDfn_SM[rop]));
+                             (gfx_set_solid_source(planemask), PDfn_SM[rop]));
 #else
     {
-	unsigned int ROP =
-	    BPP | (planemask == ~0U ? PDfn[rop] : PDfn_SM[rop]);
-	BLT_MODE = ((ROP ^ (ROP >> 2)) & 0x33) == 0 ? MGP_BM_SRC_MONO : 0;
-	VEC_MODE = ((ROP ^ (ROP >> 1)) & 0x55) != 0 ? ((BLT_MODE |=
-		MGP_BM_DST_REQ), MGP_VM_DST_REQ) : 0;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_RASTER_MODE, ROP);
-	WRITE_GP32(MGP_PAT_COLOR_0, color);
-	WRITE_GP32(MGP_SRC_COLOR_FG, planemask);
-	WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
+        unsigned int ROP = BPP | (planemask == ~0U ? PDfn[rop] : PDfn_SM[rop]);
+
+        BLT_MODE = ((ROP ^ (ROP >> 2)) & 0x33) == 0 ? MGP_BM_SRC_MONO : 0;
+        VEC_MODE = ((ROP ^ (ROP >> 1)) & 0x55) != 0 ? ((BLT_MODE |=
+                                                        MGP_BM_DST_REQ),
+                                                       MGP_VM_DST_REQ) : 0;
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_RASTER_MODE, ROP);
+        WRITE_GP32(MGP_PAT_COLOR_0, color);
+        WRITE_GP32(MGP_SRC_COLOR_FG, planemask);
+        WRITE_GP32(MGP_STRIDE, ACCEL_STRIDE);
     }
 #endif
 }
@@ -1103,14 +1113,15 @@ GXSetupForSolidLine(ScrnInfoPtr pScrni, int color, int rop, uint planemask)
  *---------------------------------------------------------------------------*/
 static void
 GXSubsequentSolidBresenhamLine(ScrnInfoPtr pScrni, int x1, int y1,
-    int absmaj, int absmin, int err, int len, int octant)
+                               int absmaj, int absmin, int err, int len,
+                               int octant)
 {
     long axial, diagn;
 
     DEBUGMSG(1, (0, X_INFO, "%s() %d,%d %d %d, %d %d, %d\n",
-	    __func__, x1, y1, absmaj, absmin, err, len, octant));
+                 __func__, x1, y1, absmaj, absmin, err, len, octant));
     if (len <= 0)
-	return;
+        return;
     axial = absmin;
     err += axial;
     diagn = absmin - absmaj;
@@ -1118,16 +1129,16 @@ GXSubsequentSolidBresenhamLine(ScrnInfoPtr pScrni, int x1, int y1,
     gfx_bresenham_line(x1, y1, len, err, axial, diagn, vmode[octant]);
 #else
     {
-	unsigned int offset = CALC_FBOFFSET(x1, y1);
-	unsigned int vec_err = (axial << 16) | (unsigned short)diagn;
-	unsigned int vec_len = (len << 16) | (unsigned short)err;
-	unsigned int vec_mode = VEC_MODE | vmode[octant];
-
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_DST_OFFSET, offset);
-	WRITE_GP32(MGP_VEC_ERR, vec_err);
-	WRITE_GP32(MGP_VEC_LEN, vec_len);
-	WRITE_GP32(MGP_VECTOR_MODE, vec_mode);
+        unsigned int offset = CALC_FBOFFSET(x1, y1);
+        unsigned int vec_err = (axial << 16) | (unsigned short) diagn;
+        unsigned int vec_len = (len << 16) | (unsigned short) err;
+        unsigned int vec_mode = VEC_MODE | vmode[octant];
+
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_DST_OFFSET, offset);
+        WRITE_GP32(MGP_VEC_ERR, vec_err);
+        WRITE_GP32(MGP_VEC_LEN, vec_len);
+        WRITE_GP32(MGP_VECTOR_MODE, vec_mode);
     }
 #endif
 }
@@ -1149,36 +1160,37 @@ GXSubsequentSolidBresenhamLine(ScrnInfoPtr pScrni, int x1, int y1,
  *---------------------------------------------------------------------------*/
 static void
 GXSubsequentSolidTwoPointLine(ScrnInfoPtr pScrni, int x0, int y0,
-    int x1, int y1, int flags)
+                              int x1, int y1, int flags)
 {
     long dx, dy, dmaj, dmin, octant, bias;
     long axial, diagn, err, len;
 
     DEBUGMSG(1, (0, X_INFO, "%s() %d,%d %d,%d, %#x\n",
-	    __func__, x0, y0, x1, y1, flags));
+                 __func__, x0, y0, x1, y1, flags));
 
     if ((dx = x1 - x0) < 0)
-	dx = -dx;
+        dx = -dx;
     if ((dy = y1 - y0) < 0)
-	dy = -dy;
+        dy = -dy;
     if (dy >= dx) {
-	dmaj = dy;
-	dmin = dx;
-	octant = YMAJOR;
-    } else {
-	dmaj = dx;
-	dmin = dy;
-	octant = 0;
+        dmaj = dy;
+        dmin = dx;
+        octant = YMAJOR;
+    }
+    else {
+        dmaj = dx;
+        dmin = dy;
+        octant = 0;
     }
     len = dmaj;
     if ((flags & OMIT_LAST) == 0)
-	++len;
+        ++len;
     if (len <= 0)
-	return;
+        return;
     if (x1 < x0)
-	octant |= XDECREASING;
+        octant |= XDECREASING;
     if (y1 < y0)
-	octant |= YDECREASING;
+        octant |= YDECREASING;
 
     axial = dmin << 1;
     bias = miGetZeroLineBias(pScrni->pScreen);
@@ -1189,16 +1201,16 @@ GXSubsequentSolidTwoPointLine(ScrnInfoPtr pScrni, int x0, int y0,
     gfx_bresenham_line(x0, y0, len, err, axial, diagn, vmode[octant]);
 #else
     {
-	unsigned int offset = CALC_FBOFFSET(x0, y0);
-	unsigned int vec_err = (axial << 16) | (unsigned short)diagn;
-	unsigned int vec_len = (len << 16) | (unsigned short)err;
-	unsigned int vec_mode = VEC_MODE | vmode[octant];
-
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_DST_OFFSET, offset);
-	WRITE_GP32(MGP_VEC_ERR, vec_err);
-	WRITE_GP32(MGP_VEC_LEN, vec_len);
-	WRITE_GP32(MGP_VECTOR_MODE, vec_mode);
+        unsigned int offset = CALC_FBOFFSET(x0, y0);
+        unsigned int vec_err = (axial << 16) | (unsigned short) diagn;
+        unsigned int vec_len = (len << 16) | (unsigned short) err;
+        unsigned int vec_mode = VEC_MODE | vmode[octant];
+
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_DST_OFFSET, offset);
+        WRITE_GP32(MGP_VEC_ERR, vec_err);
+        WRITE_GP32(MGP_VEC_LEN, vec_len);
+        WRITE_GP32(MGP_VECTOR_MODE, vec_mode);
     }
 #endif
 }
@@ -1222,28 +1234,27 @@ GXSubsequentSolidTwoPointLine(ScrnInfoPtr pScrni, int x0, int y0,
  *---------------------------------------------------------------------------
  */
 static void
-GXSubsequentSolidHorVertLine(ScrnInfoPtr pScrni,
-    int x, int y, int len, int dir)
+GXSubsequentSolidHorVertLine(ScrnInfoPtr pScrni, int x, int y, int len, int dir)
 {
     DEBUGMSG(1, (0, X_INFO, "%s() %d,%d %d %d\n", __func__, x, y, len, dir));
 #ifndef OPT_ACCEL
     if (dir == DEGREES_0)
-	gfx_pattern_fill(x, y, len, 1);
+        gfx_pattern_fill(x, y, len, 1);
     else
-	gfx_pattern_fill(x, y, 1, len);
+        gfx_pattern_fill(x, y, 1, len);
 #else
     {
-	unsigned int offset = CALC_FBOFFSET(x, y);
-	unsigned int size =
-	    dir == DEGREES_0 ? (len << 16) | 1 : (1 << 16) | len;
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_DST_OFFSET, offset);
-	WRITE_GP32(MGP_WID_HEIGHT, size);
-	WRITE_GP32(MGP_BLT_MODE, BLT_MODE);
+        unsigned int offset = CALC_FBOFFSET(x, y);
+        unsigned int size =
+            dir == DEGREES_0 ? (len << 16) | 1 : (1 << 16) | len;
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_DST_OFFSET, offset);
+        WRITE_GP32(MGP_WID_HEIGHT, size);
+        WRITE_GP32(MGP_BLT_MODE, BLT_MODE);
     }
 #endif
 }
-#endif /* GX_BRES_LINE_SUPPORT */
+#endif                          /* GX_BRES_LINE_SUPPORT */
 
 #if GX_DASH_LINE_SUPPORT
 /*----------------------------------------------------------------------------
@@ -1266,23 +1277,23 @@ GXSubsequentSolidHorVertLine(ScrnInfoPtr pScrni,
  *---------------------------------------------------------------------------*/
 static void
 GXSetupForDashedLine(ScrnInfoPtr pScrn, int fg, int bg, int rop,
-    unsigned int planemask, int length, unsigned char *pattern)
+                     unsigned int planemask, int length, unsigned char *pattern)
 {
     int i, l, n, m;
     CARD32 pat = *pattern;
     CARD32 pat8x8[2];
 
     if (length <= 0)
-	return;
+        return;
     i = l = m = 0;
     while (i < 2) {
-	m |= pat >> l;
-	l += length;
-	if ((n = l - 32) >= 0) {
-	    pat8x8[i++] = m;
-	    m = pat << (length - n);
-	    l = n;
-	}
+        m |= pat >> l;
+        l += length;
+        if ((n = l - 32) >= 0) {
+            pat8x8[i++] = m;
+            m = pat << (length - n);
+            l = n;
+        }
     }
     gdln.pat[0] = pat8x8[0];
     gdln.pat[1] = pat8x8[1];
@@ -1292,7 +1303,7 @@ GXSetupForDashedLine(ScrnInfoPtr pScrn, int fg, int bg, int rop,
     rop &= 0x0F;
     gfx_set_solid_pattern(0);
     gfx_set_raster_operation(planemask == ~0U ? PDfn[rop] :
-	(gfx_set_solid_source(planemask), PDfn_SM[rop]));
+                             (gfx_set_solid_source(planemask), PDfn_SM[rop]));
 }
 
 /*---------------------------------------------------------------------------
@@ -1324,8 +1335,8 @@ GXSetupForDashedLine(ScrnInfoPtr pScrn, int fg, int bg, int rop,
  */
 static void
 GXSubsequentDashedBresenhamLine(ScrnInfoPtr pScrni,
-    int x1, int y1, int absmaj, int absmin,
-    int err, int len, int octant, int phase)
+                                int x1, int y1, int absmaj, int absmin,
+                                int err, int len, int octant, int phase)
 {
     int i, n;
     int axial, diagn;
@@ -1338,16 +1349,16 @@ GXSubsequentDashedBresenhamLine(ScrnInfoPtr pScrni,
     i = phase >= 32 ? (phase -= 32, 1) : 0;
     n = 32 - phase;
     pat8x8[0] =
-	((gdln.pat[i] >> phase) & ((1UL << n) - 1)) | (gdln.pat[1 - i] << n);
+        ((gdln.pat[i] >> phase) & ((1UL << n) - 1)) | (gdln.pat[1 - i] << n);
     pat8x8[1] =
-	((gdln.pat[1 - i] >> phase) & ((1UL << n) - 1)) | (gdln.pat[i] << n);
+        ((gdln.pat[1 - i] >> phase) & ((1UL << n) - 1)) | (gdln.pat[i] << n);
     axial = absmin;
     err += axial;
     diagn = absmin - absmaj;
     gfx_set_mono_pattern(gdln.bg, gdln.fg, pat8x8[0], pat8x8[1], trans);
     gfx2_set_pattern_origin(x1, y1);
     gfx2_bresenham_line(CALC_FBOFFSET(x1, y1), len, err, axial, diagn,
-	vmode[octant]);
+                        vmode[octant]);
 }
 
 /*---------------------------------------------------------------------------
@@ -1368,7 +1379,7 @@ GXSubsequentDashedBresenhamLine(ScrnInfoPtr pScrni,
  *---------------------------------------------------------------------------*/
 static void
 GXSubsequentDashedTwoPointLine(ScrnInfoPtr pScrni, int x0, int y0,
-    int x1, int y1, int flags, int phase)
+                               int x1, int y1, int flags, int phase)
 {
     int i, n;
     long dx, dy, dmaj, dmin, octant, bias;
@@ -1380,32 +1391,33 @@ GXSubsequentDashedTwoPointLine(ScrnInfoPtr pScrni, int x0, int y0,
     i = phase >= 32 ? (phase -= 32, 1) : 0;
     n = 32 - phase;
     pat8x8[0] =
-	((gdln.pat[i] >> phase) & ((1UL << n) - 1)) | (gdln.pat[1 - i] << n);
+        ((gdln.pat[i] >> phase) & ((1UL << n) - 1)) | (gdln.pat[1 - i] << n);
     pat8x8[1] =
-	((gdln.pat[1 - i] >> phase) & ((1UL << n) - 1)) | (gdln.pat[i] << n);
+        ((gdln.pat[1 - i] >> phase) & ((1UL << n) - 1)) | (gdln.pat[i] << n);
 
     if ((dx = x1 - x0) < 0)
-	dx = -dx;
+        dx = -dx;
     if ((dy = y1 - y0) < 0)
-	dy = -dy;
+        dy = -dy;
     if (dy >= dx) {
-	dmaj = dy;
-	dmin = dx;
-	octant = YMAJOR;
-    } else {
-	dmaj = dx;
-	dmin = dy;
-	octant = 0;
+        dmaj = dy;
+        dmin = dx;
+        octant = YMAJOR;
+    }
+    else {
+        dmaj = dx;
+        dmin = dy;
+        octant = 0;
     }
     len = dmaj;
     if ((flags & OMIT_LAST) == 0)
-	++len;
+        ++len;
     if (len <= 0)
-	return;
+        return;
     if (x1 < x0)
-	octant |= XDECREASING;
+        octant |= XDECREASING;
     if (y1 < y0)
-	octant |= YDECREASING;
+        octant |= YDECREASING;
 
     axial = dmin << 1;
     bias = miGetZeroLineBias(pScrni->pScreen);
@@ -1414,16 +1426,16 @@ GXSubsequentDashedTwoPointLine(ScrnInfoPtr pScrni, int x0, int y0,
 
     gfx2_set_pattern_origin(x0, y0);
     gfx2_bresenham_line(CALC_FBOFFSET(x0, y0), len, err, axial, diagn,
-	vmode[octant]);
+                        vmode[octant]);
 
 }
-#endif /* GX_DASH_LINE_SUPPORT */
+#endif                          /* GX_DASH_LINE_SUPPORT */
 
 #if GX_WRITE_PIXMAP_SUPPORT
 static void
 GXWritePixmap(ScrnInfoPtr pScrni, int x, int y, int w, int h,
-    unsigned char *src, int srcwidth, int rop, unsigned int planemask,
-    int trans, int bpp, int depth)
+              unsigned char *src, int srcwidth, int rop, unsigned int planemask,
+              int trans, int bpp, int depth)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
@@ -1431,29 +1443,30 @@ GXWritePixmap(ScrnInfoPtr pScrni, int x, int y, int w, int h,
     //    x, y, w, h, src, srcwidth, rop, planemask, trans, bpp, depth);
 
     if (bpp == pScrni->bitsPerPixel) {
-	rop &= 0x0F;
-	if (rop == GXcopy && trans == -1) {
-	    gfx_wait_until_idle();
-	    geode_memory_to_screen_blt((unsigned long)src,
-		(unsigned long)FBADDR(x, y), srcwidth, pGeode->Pitch, w,
-		h, bpp);
-	} else {
-	    gfx_set_solid_pattern(planemask);
-	    gfx_set_raster_operation(planemask ==
-		~0U ? SDfn[rop] : SDfn_PM[rop]);
-	    if (trans != -1)
-		gfx_color_bitmap_to_screen_xblt(0, 0, x, y, w, h, src,
-		    srcwidth, trans);
-	    else
-		gfx_color_bitmap_to_screen_blt(0, 0, x, y, w, h, src,
-		    srcwidth);
-	    SET_SYNC_FLAG(pGeode->AccelInfoRec);
-	}
-    } else
-	pGeode->WritePixmap(pScrni, x, y, w, h, src, srcwidth, rop, planemask,
-	    trans, bpp, depth);
+        rop &= 0x0F;
+        if (rop == GXcopy && trans == -1) {
+            gfx_wait_until_idle();
+            geode_memory_to_screen_blt((unsigned long) src,
+                                       (unsigned long) FBADDR(x, y), srcwidth,
+                                       pGeode->Pitch, w, h, bpp);
+        }
+        else {
+            gfx_set_solid_pattern(planemask);
+            gfx_set_raster_operation(planemask ==
+                                     ~0U ? SDfn[rop] : SDfn_PM[rop]);
+            if (trans != -1)
+                gfx_color_bitmap_to_screen_xblt(0, 0, x, y, w, h, src,
+                                                srcwidth, trans);
+            else
+                gfx_color_bitmap_to_screen_blt(0, 0, x, y, w, h, src, srcwidth);
+            SET_SYNC_FLAG(pGeode->AccelInfoRec);
+        }
+    }
+    else
+        pGeode->WritePixmap(pScrni, x, y, w, h, src, srcwidth, rop, planemask,
+                            trans, bpp, depth);
 }
-#endif /* if GX_WRITE_PIXMAP_SUPPORT */
+#endif                          /* if GX_WRITE_PIXMAP_SUPPORT */
 
 #if XF86EXA
 
@@ -1470,7 +1483,7 @@ amd_gx_exa_Done(PixmapPtr p)
 
 static Bool
 amd_gx_exa_UploadToScreen(PixmapPtr pDst, int x, int y, int w, int h,
-    char *src, int src_pitch)
+                          char *src, int src_pitch)
 {
     char *dst = pDst->devPrivate.ptr;
     int dst_pitch = exaGetPixmapPitch(pDst);
@@ -1478,14 +1491,14 @@ amd_gx_exa_UploadToScreen(PixmapPtr pDst, int x, int y, int w, int h,
 
     dst += y * dst_pitch + x * (bpp >> 3);
     GU2_WAIT_BUSY;
-    geode_memory_to_screen_blt((unsigned long)src, (unsigned long)dst,
-	src_pitch, dst_pitch, w, h, bpp);
+    geode_memory_to_screen_blt((unsigned long) src, (unsigned long) dst,
+                               src_pitch, dst_pitch, w, h, bpp);
     return TRUE;
 }
 
 static Bool
 amd_gx_exa_DownloadFromScreen(PixmapPtr pSrc, int x, int y, int w, int h,
-    char *dst, int dst_pitch)
+                              char *dst, int dst_pitch)
 {
     char *src = pSrc->devPrivate.ptr;
     int src_pitch = exaGetPixmapPitch(pSrc);
@@ -1493,8 +1506,8 @@ amd_gx_exa_DownloadFromScreen(PixmapPtr pSrc, int x, int y, int w, int h,
 
     src += (y * src_pitch) + (x * (bpp >> 3));
     GU2_WAIT_BUSY;
-    geode_memory_to_screen_blt((unsigned long)src, (unsigned long)dst,
-	src_pitch, dst_pitch, w, h, bpp);
+    geode_memory_to_screen_blt((unsigned long) src, (unsigned long) dst,
+                               src_pitch, dst_pitch, w, h, bpp);
     return TRUE;
 }
 
@@ -1505,7 +1518,7 @@ amd_gx_exa_PrepareSolid(PixmapPtr pxMap, int alu, Pixel planemask, Pixel fg)
 {
     int dstPitch = exaGetPixmapPitch(pxMap);
     unsigned int ROP = amd_gx_BppToRasterMode(pxMap->drawable.bitsPerPixel)
-	| (planemask == ~0U ? SDfn[alu] : SDfn_PM[alu]);
+        | (planemask == ~0U ? SDfn[alu] : SDfn_PM[alu]);
 
     //  FIXME: this should go away -- workaround for the blockparty icon corruption
     //if (pxMap->drawable.bitsPerPixel == 32)
@@ -1513,7 +1526,7 @@ amd_gx_exa_PrepareSolid(PixmapPtr pxMap, int alu, Pixel planemask, Pixel fg)
 
     BLT_MODE = ((ROP ^ (ROP >> 2)) & 0x33) == 0 ? MGP_BM_SRC_MONO : 0;
     if (((ROP ^ (ROP >> 1)) & 0x55) != 0)
-	BLT_MODE |= MGP_BM_DST_REQ;
+        BLT_MODE |= MGP_BM_DST_REQ;
     //ErrorF("amd_gx_exa_PrepareSolid(%#x,%#x,%#x - ROP=%x,BLT_MODE=%x)\n", alu, planemask, fg, ROP, BLT_MODE);
     GU2_WAIT_PENDING;
     WRITE_GP32(MGP_RASTER_MODE, ROP);
@@ -1543,7 +1556,7 @@ amd_gx_exa_Solid(PixmapPtr pxMap, int x1, int y1, int x2, int y2)
 
 static Bool
 amd_gx_exa_PrepareCopy(PixmapPtr pxSrc, PixmapPtr pxDst, int dx, int dy,
-    int alu, Pixel planemask)
+                       int alu, Pixel planemask)
 {
     GeodeRec *pGeode = GEODEPTR_FROM_PIXMAP(pxDst);
     int dstPitch = exaGetPixmapPitch(pxDst);
@@ -1552,7 +1565,7 @@ amd_gx_exa_PrepareCopy(PixmapPtr pxSrc, PixmapPtr pxDst, int dx, int dy,
     /* Punt if the color formats aren't the same */
 
     if (pxSrc->drawable.bitsPerPixel != pxDst->drawable.bitsPerPixel)
-	return FALSE;
+        return FALSE;
 
     //ErrorF("amd_gx_exa_PrepareCopy() dx%d dy%d alu %#x %#x\n",
     //  dx, dy, alu, planemask);
@@ -1563,10 +1576,10 @@ amd_gx_exa_PrepareCopy(PixmapPtr pxSrc, PixmapPtr pxDst, int dx, int dy,
     pGeode->cpyDx = dx;
     pGeode->cpyDy = dy;
     ROP = amd_gx_BppToRasterMode(pxSrc->drawable.bitsPerPixel) |
-	(planemask == ~0U ? SDfn[alu] : SDfn_PM[alu]);
+        (planemask == ~0U ? SDfn[alu] : SDfn_PM[alu]);
 
     BLT_MODE = ((ROP ^ (ROP >> 1)) & 0x55) != 0 ?
-	MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
+        MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
     GU2_WAIT_PENDING;
     WRITE_GP32(MGP_RASTER_MODE, ROP);
     WRITE_GP32(MGP_PAT_COLOR_0, planemask);
@@ -1578,16 +1591,16 @@ amd_gx_exa_PrepareCopy(PixmapPtr pxSrc, PixmapPtr pxDst, int dx, int dy,
 
 static void
 amd_gx_exa_Copy(PixmapPtr pxDst, int srcX, int srcY, int dstX, int dstY,
-    int w, int h)
+                int w, int h)
 {
     GeodeRec *pGeode = GEODEPTR_FROM_PIXMAP(pxDst);
     int dstBpp = (pxDst->drawable.bitsPerPixel + 7) / 8;
     int dstPitch = exaGetPixmapPitch(pxDst);
     unsigned int srcOffset =
-	pGeode->cpySrcOffset + (pGeode->cpySrcPitch * srcY) +
-	(pGeode->cpySrcBpp * srcX);
+        pGeode->cpySrcOffset + (pGeode->cpySrcPitch * srcY) +
+        (pGeode->cpySrcBpp * srcX);
     unsigned int dstOffset =
-	exaGetPixmapOffset(pxDst) + (dstPitch * dstY) + (dstBpp * dstX);
+        exaGetPixmapOffset(pxDst) + (dstPitch * dstY) + (dstBpp * dstX);
     unsigned int size = (w << 16) | h;
     unsigned int blt_mode = BLT_MODE;
 
@@ -1595,14 +1608,14 @@ amd_gx_exa_Copy(PixmapPtr pxDst, int srcX, int srcY, int dstX, int dstY,
     //   dstX, dstY, w, h);
 
     if (pGeode->cpyDx < 0) {
-	srcOffset += w * pGeode->cpySrcBpp - 1;
-	dstOffset += w * dstBpp - 1;
-	blt_mode |= MGP_BM_NEG_XDIR;
+        srcOffset += w * pGeode->cpySrcBpp - 1;
+        dstOffset += w * dstBpp - 1;
+        blt_mode |= MGP_BM_NEG_XDIR;
     }
     if (pGeode->cpyDy < 0) {
-	srcOffset += (h - 1) * pGeode->cpySrcPitch;
-	dstOffset += (h - 1) * dstPitch;
-	blt_mode |= MGP_BM_NEG_YDIR;
+        srcOffset += (h - 1) * pGeode->cpySrcPitch;
+        dstOffset += (h - 1) * dstPitch;
+        blt_mode |= MGP_BM_NEG_YDIR;
     }
     GU2_WAIT_PENDING;
     WRITE_GP32(MGP_SRC_OFFSET, srcOffset);
@@ -1633,32 +1646,31 @@ amd_gx_exa_Copy(PixmapPtr pxDst, int srcX, int srcY, int dstX, int dstY,
 #define a_1 MGP_RM_SELECT_ALPHA_1
 
 #define MGP_RM_ALPHA_TO_ARGB (MGP_RM_ALPHA_TO_ALPHA | MGP_RM_ALPHA_TO_RGB)
-#define gxPictOpMAX PictOpAdd	       /* highest accelerated op */
+#define gxPictOpMAX PictOpAdd   /* highest accelerated op */
 
 unsigned int amd_gx_exa_alpha_ops[] =
 /*    A   B      OP     AS           const = 0 */
 {
-    (SRC_DST | Aa_B0 | a_C), 0,	       /* clear    (src*0) */
-    (SRC_DST | Aa_B0 | a_1), 0,	       /* src      (src*1) */
-    (DST_SRC | Aa_B0 | a_1), 0,	       /* dst      (dst*1) */
-    (SRC_DST | A1_B1a | a_A), 0,       /* src-over (src*1 + dst(1-A)) */
-    (DST_SRC | A1_B1a | a_A), 0,       /* dst-over (dst*1 + src(1-B)) */
-    (SRC_DST | Aa_B0 | a_B), 0,	       /* src-in   (src*B) */
-    (DST_SRC | Aa_B0 | a_B), 0,	       /* dst-in   (dst*A) */
-    (DST_SRC | A0_B1a | a_A), 0,       /* src-out  (src*(1-B)) */
-    (SRC_DST | A0_B1a | a_A), 0,       /* dst-out  (dst*(1-A)) */
+    (SRC_DST | Aa_B0 | a_C), 0, /* clear    (src*0) */
+    (SRC_DST | Aa_B0 | a_1), 0, /* src      (src*1) */
+    (DST_SRC | Aa_B0 | a_1), 0, /* dst      (dst*1) */
+    (SRC_DST | A1_B1a | a_A), 0,        /* src-over (src*1 + dst(1-A)) */
+    (DST_SRC | A1_B1a | a_A), 0,        /* dst-over (dst*1 + src(1-B)) */
+    (SRC_DST | Aa_B0 | a_B), 0, /* src-in   (src*B) */
+    (DST_SRC | Aa_B0 | a_B), 0, /* dst-in   (dst*A) */
+    (DST_SRC | A0_B1a | a_A), 0,        /* src-out  (src*(1-B)) */
+    (SRC_DST | A0_B1a | a_A), 0,        /* dst-out  (dst*(1-A)) */
 /* pass1 (SRC=dst DST=scr=src), pass2 (SRC=src, DST=dst) */
-    (DST_SRC | Aa_B0 | a_B),	       /* srcatop  (src*B) */
-    (SRC_DST | A0_B1a | a_A),	       /*                  + (dst(1-A)) */
-    (SRC_DST | Aa_B0 | a_B),	       /* dstatop  (dst*A) */
-    (DST_SRC | A0_B1a | a_A),	       /*                  + (src(1-B) */
-    (SRC_DST | A0_B1a | a_A),	       /* xor      (src*(1-B) */
-    (SRC_DST | A0_B1a | a_A),	       /*                  + (dst(1-A) */
-    (SRC_DST | A1_B1a | a_C), 0,       /* add      (src*1 + dst*1) */
+    (DST_SRC | Aa_B0 | a_B),    /* srcatop  (src*B) */
+    (SRC_DST | A0_B1a | a_A),   /*                  + (dst(1-A)) */
+    (SRC_DST | Aa_B0 | a_B),    /* dstatop  (dst*A) */
+    (DST_SRC | A0_B1a | a_A),   /*                  + (src(1-B) */
+    (SRC_DST | A0_B1a | a_A),   /* xor      (src*(1-B) */
+    (SRC_DST | A0_B1a | a_A),   /*                  + (dst(1-A) */
+    (SRC_DST | A1_B1a | a_C), 0,        /* add      (src*1 + dst*1) */
 };
 
-typedef struct
-{
+typedef struct {
     int exa_fmt;
     int bpp;
     int gx_fmt;
@@ -1682,13 +1694,13 @@ amd_gx_exa_check_format(PicturePtr p)
     amd_gx_exa_fmt_t *fp = &amd_gx_exa_fmts[0];
 
     for (i = sizeof(amd_gx_exa_fmts) / sizeof(amd_gx_exa_fmts[0]); --i >= 0;
-	++fp) {
-	if (fp->bpp < bpp)
-	    return NULL;
-	if (fp->bpp != bpp)
-	    continue;
-	if (fp->exa_fmt == p->format)
-	    break;
+         ++fp) {
+        if (fp->bpp < bpp)
+            return NULL;
+        if (fp->bpp != bpp)
+            continue;
+        if (fp->exa_fmt == p->format)
+            break;
     }
     return i < 0 ? NULL : fp;
 }
@@ -1697,30 +1709,31 @@ amd_gx_exa_check_format(PicturePtr p)
 
 static Bool
 amd_gx_exa_CheckComposite(int op, PicturePtr pSrc, PicturePtr pMsk,
-    PicturePtr pDst)
+                          PicturePtr pDst)
 {
     GeodeRec *pGeode = GEODEPTR_FROM_PICTURE(pDst);
 
     if (op > gxPictOpMAX)
-	return FALSE;
+        return FALSE;
     if (pMsk)
-	return FALSE;
+        return FALSE;
     if (usesPasses(op) && pGeode->exaBfrSz == 0)
-	return FALSE;
+        return FALSE;
     if (pSrc->filter != PictFilterNearest &&
-	pSrc->filter != PictFilterFast &&
-	pSrc->filter != PictFilterGood && pSrc->filter != PictFilterBest)
-	return FALSE;
+        pSrc->filter != PictFilterFast &&
+        pSrc->filter != PictFilterGood && pSrc->filter != PictFilterBest)
+        return FALSE;
     if (pSrc->repeat)
-	return FALSE;
+        return FALSE;
     if (pSrc->transform)
-	return FALSE;
+        return FALSE;
     return TRUE;
 }
 
 static Bool
 amd_gx_exa_PrepareComposite(int op, PicturePtr pSrc, PicturePtr pMsk,
-    PicturePtr pDst, PixmapPtr pxSrc, PixmapPtr pxMsk, PixmapPtr pxDst)
+                            PicturePtr pDst, PixmapPtr pxSrc, PixmapPtr pxMsk,
+                            PixmapPtr pxDst)
 {
     int srcPitch;
 
@@ -1730,31 +1743,32 @@ amd_gx_exa_PrepareComposite(int op, PicturePtr pSrc, PicturePtr pMsk,
     //ErrorF("amd_gx_exa_PrepareComposite()\n");
 
     if ((sfp = amd_gx_exa_check_format(pSrc)) == NULL)
-	return FALSE;
+        return FALSE;
     if (sfp->alpha_bits == 0 && usesSrcAlpha(op))
-	return FALSE;
+        return FALSE;
     if ((dfp = amd_gx_exa_check_format(pDst)) == NULL)
-	return FALSE;
+        return FALSE;
     if (dfp->alpha_bits == 0 && usesDstAlpha(op))
-	return FALSE;
+        return FALSE;
     if (sfp->gx_fmt != dfp->gx_fmt)
-	return FALSE;
+        return FALSE;
     srcPitch = exaGetPixmapPitch(pxSrc);
     if (usesPasses(op) && srcPitch > pGeode->exaBfrSz)
-	return FALSE;
+        return FALSE;
     pGeode->cmpSrcPitch = srcPitch;
     pGeode->cmpOp = op;
     pGeode->cmpSrcOffset = exaGetPixmapOffset(pxSrc);
     pGeode->cmpSrcBpp = (pxSrc->drawable.bitsPerPixel + 7) / 8;
     pGeode->cmpSrcFmt = sfp->gx_fmt;
     pGeode->cmpDstFmt = dfp->gx_fmt | (dfp->alpha_bits == 0 ?
-	MGP_RM_ALPHA_TO_RGB : MGP_RM_ALPHA_TO_ARGB);
+                                       MGP_RM_ALPHA_TO_RGB :
+                                       MGP_RM_ALPHA_TO_ARGB);
     return TRUE;
 }
 
 static void
 amd_gx_exa_Composite(PixmapPtr pxDst, int srcX, int srcY, int maskX,
-    int maskY, int dstX, int dstY, int width, int height)
+                     int maskY, int dstX, int dstY, int width, int height)
 {
     int op, current_line, max_lines, lines, pass, scratchPitch;
     unsigned int srcOffset, srcOfs = 0, srcPitch, srcPch = 0, srcBpp;
@@ -1767,16 +1781,17 @@ amd_gx_exa_Composite(PixmapPtr pxDst, int srcX, int srcY, int maskX,
 
     op = pGeode->cmpOp;
     if (usesPasses(op)) {
-	int cacheLineSz = 32;
-	int cachelines =
-	    (width * pGeode->cmpSrcBpp + cacheLineSz - 1) / cacheLineSz;
-	scratchPitch = cachelines * cacheLineSz;
-	if (scratchPitch > pGeode->cmpSrcPitch)
-	    scratchPitch = pGeode->cmpSrcPitch;
-	max_lines = pGeode->exaBfrSz / scratchPitch;
-    } else {
-	scratchPitch = 0;
-	max_lines = height;
+        int cacheLineSz = 32;
+        int cachelines =
+            (width * pGeode->cmpSrcBpp + cacheLineSz - 1) / cacheLineSz;
+        scratchPitch = cachelines * cacheLineSz;
+        if (scratchPitch > pGeode->cmpSrcPitch)
+            scratchPitch = pGeode->cmpSrcPitch;
+        max_lines = pGeode->exaBfrSz / scratchPitch;
+    }
+    else {
+        scratchPitch = 0;
+        max_lines = height;
     }
 
     dstBpp = (pxDst->drawable.bitsPerPixel + 7) / 8;
@@ -1788,83 +1803,84 @@ amd_gx_exa_Composite(PixmapPtr pxDst, int srcX, int srcY, int maskX,
 
     current_line = pass = 0;
     while (current_line < height) {
-	if (usesPasses(op)) {
-	    lines = height - current_line;
-	    if (lines > max_lines)
-		lines = max_lines;
-	    switch (pass) {
-	    case 0:		       /* copy src to scratch */
-		srcPch = srcPitch;
-		srcOfs = srcOffset + current_line * srcPch;
-		dstPch = scratchPitch;
-		dstOfs = pGeode->exaBfrOffset;
-		rop = pGeode->cmpSrcFmt | MGP_RM_ALPHA_TO_ARGB;
-		rop |= amd_gx_exa_alpha_ops[PictOpSrc * 2];
-		blt_mode = usesChanB0(PictOpSrc) ?
-		    MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
-		++pass;
-		break;
-	    case 1:		       /* pass1 */
-		srcPch = dstPitch;
-		srcOfs = dstOffset + current_line * srcPch;
-		dstPch = scratchPitch;
-		dstOfs = pGeode->exaBfrOffset;
-		rop = pGeode->cmpSrcFmt | MGP_RM_ALPHA_TO_ARGB;
-		rop |= amd_gx_exa_alpha_ops[op * 2];
-		blt_mode = usesChanB1(op) ?
-		    MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
-		++pass;
-		break;
-	    case 2:		       /* pass2 */
-		srcPch = srcPitch;
-		srcOfs = srcOffset + current_line * srcPch;
-		dstPch = dstPitch;
-		dstOfs = dstOffset + current_line * dstPch;
-		rop = pGeode->cmpSrcFmt | MGP_RM_ALPHA_TO_ARGB;
-		rop |= amd_gx_exa_alpha_ops[op * 2 + 1];
-		blt_mode = usesChanB2(op) ?
-		    MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
-		++pass;
-		break;
-	    case 3:		       /* add */
-		srcPch = scratchPitch;
-		srcOfs = pGeode->exaBfrOffset;
-		dstPch = dstPitch;
-		dstOfs = dstOffset + current_line * dstPch;
-		rop = pGeode->cmpDstFmt;
-		rop |= amd_gx_exa_alpha_ops[PictOpAdd * 2];
-		blt_mode = usesChanB0(PictOpAdd) ?
-		    MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
-		current_line += lines;
-		pass = 0;
-		break;
-	    }
-	    strides = (srcPch << 16) | dstPch;
-	} else {		       /* not multi pass */
-	    srcOfs = srcOffset;
-	    dstOfs = dstOffset;
-	    current_line = lines = height;
-	    strides = (srcPitch << 16) | dstPitch;
-	    rop = pGeode->cmpDstFmt | amd_gx_exa_alpha_ops[op * 2];
-	    blt_mode = usesChanB0(op) ?
-		MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
-	}
-	sizes = (width << 16) | lines;
-	if (srcOfs < dstOfs) {
-	    srcOfs += (lines - 1) * srcPitch + width * srcBpp - 1;
-	    dstOfs += (lines - 1) * dstPitch + width * dstBpp - 1;
-	    blt_mode |= MGP_BM_NEG_XDIR | MGP_BM_NEG_YDIR;
-	}
-	GU2_WAIT_PENDING;
-	WRITE_GP32(MGP_RASTER_MODE, rop);
-	WRITE_GP32(MGP_SRC_OFFSET, srcOfs);
-	WRITE_GP32(MGP_DST_OFFSET, dstOfs);
-	WRITE_GP32(MGP_WID_HEIGHT, sizes);
-	WRITE_GP32(MGP_STRIDE, strides);
-	WRITE_GP16(MGP_BLT_MODE, blt_mode);
+        if (usesPasses(op)) {
+            lines = height - current_line;
+            if (lines > max_lines)
+                lines = max_lines;
+            switch (pass) {
+            case 0:            /* copy src to scratch */
+                srcPch = srcPitch;
+                srcOfs = srcOffset + current_line * srcPch;
+                dstPch = scratchPitch;
+                dstOfs = pGeode->exaBfrOffset;
+                rop = pGeode->cmpSrcFmt | MGP_RM_ALPHA_TO_ARGB;
+                rop |= amd_gx_exa_alpha_ops[PictOpSrc * 2];
+                blt_mode = usesChanB0(PictOpSrc) ?
+                    MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
+                ++pass;
+                break;
+            case 1:            /* pass1 */
+                srcPch = dstPitch;
+                srcOfs = dstOffset + current_line * srcPch;
+                dstPch = scratchPitch;
+                dstOfs = pGeode->exaBfrOffset;
+                rop = pGeode->cmpSrcFmt | MGP_RM_ALPHA_TO_ARGB;
+                rop |= amd_gx_exa_alpha_ops[op * 2];
+                blt_mode = usesChanB1(op) ?
+                    MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
+                ++pass;
+                break;
+            case 2:            /* pass2 */
+                srcPch = srcPitch;
+                srcOfs = srcOffset + current_line * srcPch;
+                dstPch = dstPitch;
+                dstOfs = dstOffset + current_line * dstPch;
+                rop = pGeode->cmpSrcFmt | MGP_RM_ALPHA_TO_ARGB;
+                rop |= amd_gx_exa_alpha_ops[op * 2 + 1];
+                blt_mode = usesChanB2(op) ?
+                    MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
+                ++pass;
+                break;
+            case 3:            /* add */
+                srcPch = scratchPitch;
+                srcOfs = pGeode->exaBfrOffset;
+                dstPch = dstPitch;
+                dstOfs = dstOffset + current_line * dstPch;
+                rop = pGeode->cmpDstFmt;
+                rop |= amd_gx_exa_alpha_ops[PictOpAdd * 2];
+                blt_mode = usesChanB0(PictOpAdd) ?
+                    MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
+                current_line += lines;
+                pass = 0;
+                break;
+            }
+            strides = (srcPch << 16) | dstPch;
+        }
+        else {                  /* not multi pass */
+            srcOfs = srcOffset;
+            dstOfs = dstOffset;
+            current_line = lines = height;
+            strides = (srcPitch << 16) | dstPitch;
+            rop = pGeode->cmpDstFmt | amd_gx_exa_alpha_ops[op * 2];
+            blt_mode = usesChanB0(op) ?
+                MGP_BM_SRC_FB | MGP_BM_DST_REQ : MGP_BM_SRC_FB;
+        }
+        sizes = (width << 16) | lines;
+        if (srcOfs < dstOfs) {
+            srcOfs += (lines - 1) * srcPitch + width * srcBpp - 1;
+            dstOfs += (lines - 1) * dstPitch + width * dstBpp - 1;
+            blt_mode |= MGP_BM_NEG_XDIR | MGP_BM_NEG_YDIR;
+        }
+        GU2_WAIT_PENDING;
+        WRITE_GP32(MGP_RASTER_MODE, rop);
+        WRITE_GP32(MGP_SRC_OFFSET, srcOfs);
+        WRITE_GP32(MGP_DST_OFFSET, dstOfs);
+        WRITE_GP32(MGP_WID_HEIGHT, sizes);
+        WRITE_GP32(MGP_STRIDE, strides);
+        WRITE_GP16(MGP_BLT_MODE, blt_mode);
     }
 }
-#endif /* #if XF86EXA */
+#endif                          /* #if XF86EXA */
 
 /*----------------------------------------------------------------------------
  * GXAccelInit.
@@ -1899,17 +1915,17 @@ GXAccelInit(ScreenPtr pScrn)
 
     switch (pGeode->Pitch) {
     case 1024:
-	gu2_yshift = 10;
-	break;
+        gu2_yshift = 10;
+        break;
     case 2048:
-	gu2_yshift = 11;
-	break;
+        gu2_yshift = 11;
+        break;
     case 4096:
-	gu2_yshift = 12;
-	break;
+        gu2_yshift = 12;
+        break;
     default:
-	gu2_yshift = 13;
-	break;
+        gu2_yshift = 13;
+        break;
     }
 
 #ifdef OPT_ACCEL
@@ -1919,43 +1935,42 @@ GXAccelInit(ScreenPtr pScrn)
 
 #if XF86EXA
     if (pExa && pGeode->useEXA) {
-	pExa->exa_major = EXA_VERSION_MAJOR;
-	pExa->exa_minor = EXA_VERSION_MINOR;
-
-	/* Sync */
-	pExa->WaitMarker = amd_gx_exa_WaitMarker;
-	/* UploadToScreen */
-	pExa->UploadToScreen = amd_gx_exa_UploadToScreen;
-	pExa->DownloadFromScreen = amd_gx_exa_DownloadFromScreen;
-
-	/* Solid fill */
-	pExa->PrepareSolid = amd_gx_exa_PrepareSolid;
-	pExa->Solid = amd_gx_exa_Solid;
-	pExa->DoneSolid = amd_gx_exa_Done;
-
-	/* Copy */
-	pExa->PrepareCopy = amd_gx_exa_PrepareCopy;
-	pExa->Copy = amd_gx_exa_Copy;
-	pExa->DoneCopy = amd_gx_exa_Done;
-
-	/* Composite */
-	pExa->CheckComposite = amd_gx_exa_CheckComposite;
-	pExa->PrepareComposite = amd_gx_exa_PrepareComposite;
-	pExa->Composite = amd_gx_exa_Composite;
-	pExa->DoneComposite = amd_gx_exa_Done;
-
-	return exaDriverInit(pScrn, pGeode->pExa);
+        pExa->exa_major = EXA_VERSION_MAJOR;
+        pExa->exa_minor = EXA_VERSION_MINOR;
+
+        /* Sync */
+        pExa->WaitMarker = amd_gx_exa_WaitMarker;
+        /* UploadToScreen */
+        pExa->UploadToScreen = amd_gx_exa_UploadToScreen;
+        pExa->DownloadFromScreen = amd_gx_exa_DownloadFromScreen;
+
+        /* Solid fill */
+        pExa->PrepareSolid = amd_gx_exa_PrepareSolid;
+        pExa->Solid = amd_gx_exa_Solid;
+        pExa->DoneSolid = amd_gx_exa_Done;
+
+        /* Copy */
+        pExa->PrepareCopy = amd_gx_exa_PrepareCopy;
+        pExa->Copy = amd_gx_exa_Copy;
+        pExa->DoneCopy = amd_gx_exa_Done;
+
+        /* Composite */
+        pExa->CheckComposite = amd_gx_exa_CheckComposite;
+        pExa->PrepareComposite = amd_gx_exa_PrepareComposite;
+        pExa->Composite = amd_gx_exa_Composite;
+        pExa->DoneComposite = amd_gx_exa_Done;
+
+        return exaDriverInit(pScrn, pGeode->pExa);
     }
 #endif
 
     /* Getting the pointer for acceleration Inforecord */
     pGeode->AccelInfoRec = localRecPtr = XAACreateInfoRec();
     if (!pGeode->AccelInfoRec)
-	return FALSE;
+        return FALSE;
 
     /* SET ACCELERATION FLAGS */
-    localRecPtr->Flags =
-	PIXMAP_CACHE | OFFSCREEN_PIXMAPS | LINEAR_FRAMEBUFFER;
+    localRecPtr->Flags = PIXMAP_CACHE | OFFSCREEN_PIXMAPS | LINEAR_FRAMEBUFFER;
 
     /* HOOK SYNCRONIZARION ROUTINE */
     localRecPtr->Sync = GXAccelSync;
@@ -1973,7 +1988,7 @@ GXAccelInit(ScreenPtr pScrn)
     HOOK(SubsequentMono8x8PatternFillRect);
 /*         BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD | NO_TRANSPARENCY | */
     localRecPtr->Mono8x8PatternFillFlags = BIT_ORDER_IN_BYTE_MSBFIRST |
-	HARDWARE_PATTERN_PROGRAMMED_BITS | HARDWARE_PATTERN_SCREEN_ORIGIN;
+        HARDWARE_PATTERN_PROGRAMMED_BITS | HARDWARE_PATTERN_SCREEN_ORIGIN;
 #endif
 
 #if GX_CLREXP_8X8_PAT_SUPPORT
@@ -1982,8 +1997,8 @@ GXAccelInit(ScreenPtr pScrn)
     HOOK(SubsequentColor8x8PatternFillRect);
 /*         BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD | NO_TRANSPARENCY | */
     localRecPtr->Color8x8PatternFillFlags =
-	BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD |
-	HARDWARE_PATTERN_PROGRAMMED_BITS | HARDWARE_PATTERN_PROGRAMMED_ORIGIN;
+        BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD |
+        HARDWARE_PATTERN_PROGRAMMED_BITS | HARDWARE_PATTERN_PROGRAMMED_ORIGIN;
 #endif
 
 #if GX_SCR2SCRCPY_SUPPORT
@@ -1993,7 +2008,7 @@ GXAccelInit(ScreenPtr pScrn)
     HOOK(SetupForScreenToScreenCopy);
     HOOK(SubsequentScreenToScreenCopy);
     localRecPtr->ScreenToScreenCopyFlags =
-	BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD;
+        BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD;
 #endif
 
 #if GX_BRES_LINE_SUPPORT
@@ -2013,8 +2028,8 @@ GXAccelInit(ScreenPtr pScrn)
     HOOK(SubsequentDashedTwoPointLine);
     localRecPtr->DashedBresenhamLineErrorTermBits = 15;
     localRecPtr->DashPatternMaxLength = 64;
-    localRecPtr->DashedLineFlags = NO_PLANEMASK |	/* TRANSPARENCY_ONLY | */
-	LINE_PATTERN_POWER_OF_2_ONLY | LINE_PATTERN_MSBFIRST_MSBJUSTIFIED;
+    localRecPtr->DashedLineFlags = NO_PLANEMASK |       /* TRANSPARENCY_ONLY | */
+        LINE_PATTERN_POWER_OF_2_ONLY | LINE_PATTERN_MSBFIRST_MSBJUSTIFIED;
 #endif
 
 #if GX_SCR2SCREXP_SUPPORT
@@ -2022,37 +2037,37 @@ GXAccelInit(ScreenPtr pScrn)
     HOOK(SetupForScreenToScreenColorExpandFill);
     HOOK(SubsequentScreenToScreenColorExpandFill);
     localRecPtr->ScreenToScreenColorExpandFillFlags =
-	BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD | NO_TRANSPARENCY;
+        BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD | NO_TRANSPARENCY;
 #endif
 
     if (pGeode->AccelImageWriteBuffers) {
 #if GX_SCANLINE_SUPPORT
-	localRecPtr->ScanlineImageWriteBuffers =
-	    pGeode->AccelImageWriteBuffers;
-	localRecPtr->NumScanlineImageWriteBuffers = pGeode->NoOfImgBuffers;
-	HOOK(SetupForScanlineImageWrite);
-	HOOK(SubsequentScanlineImageWriteRect);
-	HOOK(SubsequentImageWriteScanline);
-	localRecPtr->ScanlineImageWriteFlags = NO_PLANEMASK | NO_GXCOPY |
-	    BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD;
+        localRecPtr->ScanlineImageWriteBuffers = pGeode->AccelImageWriteBuffers;
+        localRecPtr->NumScanlineImageWriteBuffers = pGeode->NoOfImgBuffers;
+        HOOK(SetupForScanlineImageWrite);
+        HOOK(SubsequentScanlineImageWriteRect);
+        HOOK(SubsequentImageWriteScanline);
+        localRecPtr->ScanlineImageWriteFlags = NO_PLANEMASK | NO_GXCOPY |
+            BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD;
 #endif
 
-    } else {
-	localRecPtr->PixmapCacheFlags = DO_NOT_BLIT_STIPPLES;
+    }
+    else {
+        localRecPtr->PixmapCacheFlags = DO_NOT_BLIT_STIPPLES;
     }
 
     if (pGeode->AccelColorExpandBuffers) {
 #if GX_CPU2SCREXP_SUPPORT
-	/* Color expansion */
-	localRecPtr->ScanlineColorExpandBuffers =
-	    pGeode->AccelColorExpandBuffers;
-	localRecPtr->NumScanlineColorExpandBuffers =
-	    pGeode->NoOfColorExpandLines;
-	HOOK(SetupForScanlineCPUToScreenColorExpandFill);
-	HOOK(SubsequentScanlineCPUToScreenColorExpandFill);
-	HOOK(SubsequentColorExpandScanline);
-	localRecPtr->ScanlineCPUToScreenColorExpandFillFlags = NO_PLANEMASK |
-	    BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD;
+        /* Color expansion */
+        localRecPtr->ScanlineColorExpandBuffers =
+            pGeode->AccelColorExpandBuffers;
+        localRecPtr->NumScanlineColorExpandBuffers =
+            pGeode->NoOfColorExpandLines;
+        HOOK(SetupForScanlineCPUToScreenColorExpandFill);
+        HOOK(SubsequentScanlineCPUToScreenColorExpandFill);
+        HOOK(SubsequentColorExpandScanline);
+        localRecPtr->ScanlineCPUToScreenColorExpandFillFlags = NO_PLANEMASK |
+            BIT_ORDER_IN_BYTE_MSBFIRST | SCANLINE_PAD_DWORD;
 #endif
     }
 #if GX_WRITE_PIXMAP_SUPPORT
diff --git a/src/gx_cursor.c b/src/gx_cursor.c
index 9221dfa..de706fc 100644
--- a/src/gx_cursor.c
+++ b/src/gx_cursor.c
@@ -45,8 +45,9 @@ static void GXSetCursorColors(ScrnInfoPtr pScrni, int bg, int fg);
 static void GXSetCursorPosition(ScrnInfoPtr pScrni, int x, int y);
 static Bool GXUseHWCursor(ScreenPtr pScrn, CursorPtr pCurs);
 extern void GXSetVideoPosition(int x, int y, int width, int height,
-    short src_w, short src_h, short drw_w,
-    short drw_h, int id, int offset, ScrnInfoPtr pScrn);
+                               short src_w, short src_h, short drw_w,
+                               short drw_h, int id, int offset,
+                               ScrnInfoPtr pScrn);
 
 /*----------------------------------------------------------------------------
  * GXHWCursorInit.
@@ -72,15 +73,15 @@ GXHWCursorInit(ScreenPtr pScrn)
 
     infoPtr = xf86CreateCursorInfoRec();
     if (!infoPtr)
-	return FALSE;
+        return FALSE;
     /* the geode structure is intiallized with the cursor infoRec */
     pGeode->CursorInfo = infoPtr;
     infoPtr->MaxWidth = 32;
     infoPtr->MaxHeight = 32;
     /* seeting up the cursor flags */
     infoPtr->Flags = HARDWARE_CURSOR_BIT_ORDER_MSBFIRST |
-	HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
-	HARDWARE_CURSOR_SOURCE_MASK_NOT_INTERLEAVED;
+        HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
+        HARDWARE_CURSOR_SOURCE_MASK_NOT_INTERLEAVED;
     /* cursor info ptr is intiallized with the values obtained from
      * * durnago calls
      */
@@ -145,27 +146,27 @@ GXSetCursorPosition(ScrnInfoPtr pScrni, int x, int y)
 
     switch (pGeode->rotation) {
     default:
-	ErrorF("%s:%d invalid rotation %d\n", __func__, __LINE__,
-	    pGeode->rotation);
+        ErrorF("%s:%d invalid rotation %d\n", __func__, __LINE__,
+               pGeode->rotation);
     case RR_Rotate_0:
-	newX = savex;
-	newY = savey;
-	break;
+        newX = savex;
+        newY = savey;
+        break;
 
     case RR_Rotate_90:
-	newX = savey;
-	newY = pScrni->pScreen->width - savex;
-	break;
+        newX = savey;
+        newY = pScrni->pScreen->width - savex;
+        break;
 
     case RR_Rotate_180:
-	newX = pScrni->pScreen->width - savex;
-	newY = pScrni->pScreen->height - savey;
-	break;
+        newX = pScrni->pScreen->width - savex;
+        newY = pScrni->pScreen->height - savey;
+        break;
 
     case RR_Rotate_270:
-	newX = pScrni->pScreen->height - savey;
-	newY = savex;
-	break;
+        newX = pScrni->pScreen->height - savey;
+        newY = savex;
+        break;
     }
 
     newX += pScrni->frameX0;
@@ -174,25 +175,25 @@ GXSetCursorPosition(ScrnInfoPtr pScrni, int x, int y)
     //ErrorF("Turned (%d,%d) into (%d,%d)\n", x,y,newX, newY);
 
     if (newX < -31)
-	newX = -31;
+        newX = -31;
     if (newY < -31)
-	newY = -31;
+        newY = -31;
 
     gfx_set_cursor_position(pGeode->CursorStartOffset, newX + 31, newY + 31,
-	31, 31);
+                            31, 31);
     gfx_set_cursor_enable(1);
 
     if ((pGeode->OverlayON) && (pGeode->Panel)) {
-	pGeode->PrevDisplayOffset = gfx_get_display_offset();
-	if (pGeode->PrevDisplayOffset != panOffset) {
-	    GXSetVideoPosition(pGeode->video_x, pGeode->video_y,
-		pGeode->video_w, pGeode->video_h,
-		pGeode->video_srcw, pGeode->video_srch,
-		pGeode->video_dstw, pGeode->video_dsth,
-		pGeode->video_id, pGeode->video_offset,
-		pGeode->video_scrnptr);
-	    panOffset = pGeode->PrevDisplayOffset;
-	}
+        pGeode->PrevDisplayOffset = gfx_get_display_offset();
+        if (pGeode->PrevDisplayOffset != panOffset) {
+            GXSetVideoPosition(pGeode->video_x, pGeode->video_y,
+                               pGeode->video_w, pGeode->video_h,
+                               pGeode->video_srcw, pGeode->video_srch,
+                               pGeode->video_dstw, pGeode->video_dsth,
+                               pGeode->video_id, pGeode->video_offset,
+                               pGeode->video_scrnptr);
+            panOffset = pGeode->PrevDisplayOffset;
+        }
     }
 }
 
@@ -221,55 +222,55 @@ GXLoadCursorImage(ScrnInfoPtr pScrni, unsigned char *src)
     unsigned char *mskp = &src[128];
 
     if (src != NULL) {
-	mskb = rowb = 0;
-	for (y = 32; --y >= 0;)
-	    andMask[y] = xorMask[y] = 0;
-	for (y = 0; y < 32; ++y) {
-	    for (x = 0; x < 32; ++x) {
-		if ((i = x & 7) == 0) {
-		    rowb = (*rowp & *mskp);
-		    mskb = ~(*mskp);
-		    ++rowp;
-		    ++mskp;
-		}
+        mskb = rowb = 0;
+        for (y = 32; --y >= 0;)
+            andMask[y] = xorMask[y] = 0;
+        for (y = 0; y < 32; ++y) {
+            for (x = 0; x < 32; ++x) {
+                if ((i = x & 7) == 0) {
+                    rowb = (*rowp & *mskp);
+                    mskb = ~(*mskp);
+                    ++rowp;
+                    ++mskp;
+                }
 
-		switch (pGeode->rotation) {
-		default:
-		    ErrorF("%s:%d invalid rotation %d\n", __func__, __LINE__,
-			pGeode->rotation);
-		case RR_Rotate_0:
-		    newX = x;
-		    newY = y;
-		    break;
-		case RR_Rotate_90:
-		    newX = y;
-		    newY = 31 - x;
-		    break;
-		case RR_Rotate_180:
-		    newX = 31 - x;
-		    newY = 31 - y;
-		    break;
-		case RR_Rotate_270:
-		    newX = 31 - y;
-		    newY = x;
-		    break;
-		}
+                switch (pGeode->rotation) {
+                default:
+                    ErrorF("%s:%d invalid rotation %d\n", __func__, __LINE__,
+                           pGeode->rotation);
+                case RR_Rotate_0:
+                    newX = x;
+                    newY = y;
+                    break;
+                case RR_Rotate_90:
+                    newX = y;
+                    newY = 31 - x;
+                    break;
+                case RR_Rotate_180:
+                    newX = 31 - x;
+                    newY = 31 - y;
+                    break;
+                case RR_Rotate_270:
+                    newX = 31 - y;
+                    newY = x;
+                    break;
+                }
 
-		i = 7 - i;
-		n = 31 - newX;
-		andMask[newY] |= (((mskb >> i) & 1) << n);
-		xorMask[newY] |= (((rowb >> i) & 1) << n);
-	    }
-	}
-    } else {
-	for (y = 32; --y >= 0;) {
-	    andMask[y] = ~0;
-	    xorMask[y] = 0;
-	}
+                i = 7 - i;
+                n = 31 - newX;
+                andMask[newY] |= (((mskb >> i) & 1) << n);
+                xorMask[newY] |= (((rowb >> i) & 1) << n);
+            }
+        }
+    }
+    else {
+        for (y = 32; --y >= 0;) {
+            andMask[y] = ~0;
+            xorMask[y] = 0;
+        }
     }
 
-    gfx_set_cursor_shape32(pGeode->CursorStartOffset, &andMask[0],
-	&xorMask[0]);
+    gfx_set_cursor_shape32(pGeode->CursorStartOffset, &andMask[0], &xorMask[0]);
 }
 
 /*----------------------------------------------------------------------------
diff --git a/src/gx_driver.c b/src/gx_driver.c
index b9904d1..f6ac4c6 100644
--- a/src/gx_driver.c
+++ b/src/gx_driver.c
@@ -81,15 +81,15 @@ static inline void
 gx_enable_dac_power(void)
 {
     gfx_write_vid32(RCDF_VID_MISC,
-	gfx_read_vid32(RCDF_VID_MISC) & RCDF_GAMMA_BYPASS_BOTH);
+                    gfx_read_vid32(RCDF_VID_MISC) & RCDF_GAMMA_BYPASS_BOTH);
 }
 
 static inline void
 gx_disable_dac_power(void)
 {
     gfx_write_vid32(RCDF_VID_MISC,
-	RCDF_DAC_POWER_DOWN | RCDF_ANALOG_POWER_DOWN |
-	(gfx_read_vid32(RCDF_VID_MISC) & RCDF_GAMMA_BYPASS_BOTH));
+                    RCDF_DAC_POWER_DOWN | RCDF_ANALOG_POWER_DOWN |
+                    (gfx_read_vid32(RCDF_VID_MISC) & RCDF_GAMMA_BYPASS_BOTH));
 }
 
 static void
@@ -98,9 +98,9 @@ GXInitEXAMemory(ScrnInfoPtr pScrni, unsigned int *offset, unsigned int *avail)
     GeodePtr pGeode = GEODEPTR(pScrni);
 
     if (pGeode->exaBfrSz > 0 && pGeode->exaBfrSz <= *avail) {
-	pGeode->exaBfrOffset = *offset;
-	*offset += pGeode->exaBfrOffset;
-	*avail -= pGeode->exaBfrOffset;
+        pGeode->exaBfrOffset = *offset;
+        *offset += pGeode->exaBfrOffset;
+        *avail -= pGeode->exaBfrOffset;
     }
 }
 
@@ -114,39 +114,41 @@ GXInitXAAMemory(ScrnInfoPtr pScrni, unsigned int *offset, unsigned int *avail)
     /* For now, we NULL them all out.                        */
 
     if (pGeode->NoOfImgBuffers > 0) {
-	size = pGeode->displayPitch * pGeode->NoOfImgBuffers;
-	if (size <= *avail) {
-	    for (i = 0; i < pGeode->NoOfImgBuffers; i++) {
-		pGeode->AccelImageWriteBuffers[i] = pGeode->FBBase + *offset;
-		*offset += pGeode->displayPitch;
-		*avail -= pGeode->displayPitch;
-	    }
-	} else {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Not enough memory for image write buffers.\n");
-
-	    for (i = 0; i < pGeode->NoOfImgBuffers; i++)
-		pGeode->AccelImageWriteBuffers[i] = NULL;
-	}
+        size = pGeode->displayPitch * pGeode->NoOfImgBuffers;
+        if (size <= *avail) {
+            for (i = 0; i < pGeode->NoOfImgBuffers; i++) {
+                pGeode->AccelImageWriteBuffers[i] = pGeode->FBBase + *offset;
+                *offset += pGeode->displayPitch;
+                *avail -= pGeode->displayPitch;
+            }
+        }
+        else {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Not enough memory for image write buffers.\n");
+
+            for (i = 0; i < pGeode->NoOfImgBuffers; i++)
+                pGeode->AccelImageWriteBuffers[i] = NULL;
+        }
     }
 
     if (pGeode->NoOfColorExpandLines > 0) {
-	pitch = ((pGeode->displayPitch + 31) >> 5) << 2;
-	size = pitch * pGeode->NoOfColorExpandLines;
-
-	if (size <= *avail) {
-	    for (i = 0; i < pGeode->NoOfColorExpandLines; i++) {
-		pGeode->AccelColorExpandBuffers[i] = pGeode->FBBase + *offset;
-		*offset += pitch;
-		*avail -= pitch;
-	    }
-	} else {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Not enough memory for color expansion buffers.\n");
-
-	    for (i = 0; i < pGeode->NoOfImgBuffers; i++)
-		pGeode->AccelColorExpandBuffers[i] = NULL;
-	}
+        pitch = ((pGeode->displayPitch + 31) >> 5) << 2;
+        size = pitch * pGeode->NoOfColorExpandLines;
+
+        if (size <= *avail) {
+            for (i = 0; i < pGeode->NoOfColorExpandLines; i++) {
+                pGeode->AccelColorExpandBuffers[i] = pGeode->FBBase + *offset;
+                *offset += pitch;
+                *avail -= pitch;
+            }
+        }
+        else {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Not enough memory for color expansion buffers.\n");
+
+            for (i = 0; i < pGeode->NoOfImgBuffers; i++)
+                pGeode->AccelColorExpandBuffers[i] = NULL;
+        }
     }
 }
 
@@ -161,11 +163,11 @@ GXAllocateMemory(ScreenPtr pScrn, ScrnInfoPtr pScrni, int rotate)
     BOOL ret = TRUE;
 
     if (pGeode->tryCompression)
-	pGeode->displayPitch =
-	    GeodeCalculatePitchBytes(pScrni->virtualX, pScrni->bitsPerPixel);
+        pGeode->displayPitch =
+            GeodeCalculatePitchBytes(pScrni->virtualX, pScrni->bitsPerPixel);
     else
-	pGeode->displayPitch =
-	    ((pScrni->virtualX + 3) & ~3) * (pScrni->bitsPerPixel >> 3);
+        pGeode->displayPitch =
+            ((pScrni->virtualX + 3) & ~3) * (pScrni->bitsPerPixel >> 3);
 
     pGeode->Pitch = pGeode->displayPitch;
     pGeode->displayWidth = pGeode->displayPitch / bytpp;
@@ -180,62 +182,65 @@ GXAllocateMemory(ScreenPtr pScrn, ScrnInfoPtr pScrni, int rotate)
     fboffset += pGeode->displaySize;
 
     if (pGeode->tryCompression) {
-	size = pScrni->virtualY * GX_CB_PITCH;
+        size = pScrni->virtualY * GX_CB_PITCH;
 
-	if (size <= fbavail) {
-	    pGeode->CBData.compression_offset = fboffset;
+        if (size <= fbavail) {
+            pGeode->CBData.compression_offset = fboffset;
 
-	    fboffset += size;
-	    fbavail -= size;
+            fboffset += size;
+            fbavail -= size;
 
-	    pGeode->Compression = TRUE;
-	} else {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Not enough memory for compression\n");
-	    pGeode->Compression = FALSE;
-	}
+            pGeode->Compression = TRUE;
+        }
+        else {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Not enough memory for compression\n");
+            pGeode->Compression = FALSE;
+        }
     }
 
     if (pGeode->tryHWCursor) {
 
-	if (fbavail >= 1024) {
-	    pGeode->CursorStartOffset = fboffset;
-	    fboffset += 1024;
-	    fbavail -= 1024;
-	    pGeode->HWCursor = TRUE;
-	} else {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Not enough memory for the hardware cursor\n");
-	    pGeode->HWCursor = FALSE;
-	}
+        if (fbavail >= 1024) {
+            pGeode->CursorStartOffset = fboffset;
+            fboffset += 1024;
+            fbavail -= 1024;
+            pGeode->HWCursor = TRUE;
+        }
+        else {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Not enough memory for the hardware cursor\n");
+            pGeode->HWCursor = FALSE;
+        }
     }
 
     if (!pGeode->NoAccel) {
-	if (pGeode->useEXA)
-	    GXInitEXAMemory(pScrni, &fboffset, &fbavail);
-	else
-	    GXInitXAAMemory(pScrni, &fboffset, &fbavail);
+        if (pGeode->useEXA)
+            GXInitEXAMemory(pScrni, &fboffset, &fbavail);
+        else
+            GXInitXAAMemory(pScrni, &fboffset, &fbavail);
     }
 
     pGeode->shadowSize = 0;
 
     if (rotate != RR_Rotate_0) {
-	if (rotate & (RR_Rotate_90 | RR_Rotate_270))
-	    size = pGeode->displayPitch * pScrni->virtualX;
-	else
-	    size = pGeode->displayPitch * pScrni->virtualY;
-
-	if (size <= fbavail) {
-	    pGeode->shadowOffset = fboffset;
-	    pGeode->shadowSize = size;
-
-	    fboffset += size;
-	    fbavail -= size;
-	} else {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Not enough memory for the shadow framebuffer\n");
-	    ret = FALSE;
-	}
+        if (rotate & (RR_Rotate_90 | RR_Rotate_270))
+            size = pGeode->displayPitch * pScrni->virtualX;
+        else
+            size = pGeode->displayPitch * pScrni->virtualY;
+
+        if (size <= fbavail) {
+            pGeode->shadowOffset = fboffset;
+            pGeode->shadowSize = size;
+
+            fboffset += size;
+            fbavail -= size;
+        }
+        else {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Not enough memory for the shadow framebuffer\n");
+            ret = FALSE;
+        }
     }
 
     /* XAA always exists - we can't remove it on demand like we can with EXA.
@@ -244,53 +249,54 @@ GXAllocateMemory(ScreenPtr pScrn, ScrnInfoPtr pScrni, int rotate)
 
     if (!pGeode->NoAccel) {
 
-	if (pGeode->useEXA && pGeode->pExa) {
-	    ExaDriverPtr pExa = pGeode->pExa;
+        if (pGeode->useEXA && pGeode->pExa) {
+            ExaDriverPtr pExa = pGeode->pExa;
 
-	    pExa->offScreenBase = fboffset;
-	    pExa->memorySize = fboffset + fbavail;
-	}
+            pExa->offScreenBase = fboffset;
+            pExa->memorySize = fboffset + fbavail;
+        }
 
-	if (!pGeode->useEXA) {
+        if (!pGeode->useEXA) {
 
-	    if (!xf86FBManagerRunning(pScrn)) {
+            if (!xf86FBManagerRunning(pScrn)) {
 
-		unsigned int offset = fboffset;
-		unsigned int avail = fbavail;
-		RegionRec OffscreenRegion;
-		BoxRec AvailBox;
+                unsigned int offset = fboffset;
+                unsigned int avail = fbavail;
+                RegionRec OffscreenRegion;
+                BoxRec AvailBox;
 
-		/* Assume the shadow FB exists even if it doesnt */
+                /* Assume the shadow FB exists even if it doesnt */
 
-		if (pGeode->shadowSize == 0) {
-		    size = (pScrn->width * bytpp) * pScrni->virtualX;
-		    offset += size;
-		    avail -= size;
-		}
+                if (pGeode->shadowSize == 0) {
+                    size = (pScrn->width * bytpp) * pScrni->virtualX;
+                    offset += size;
+                    avail -= size;
+                }
 
-		AvailBox.x1 = 0;
-		AvailBox.y1 =
-		    (offset + pGeode->displayPitch -
-		    1) / pGeode->displayPitch;
+                AvailBox.x1 = 0;
+                AvailBox.y1 =
+                    (offset + pGeode->displayPitch - 1) / pGeode->displayPitch;
 
-		AvailBox.x2 = pGeode->displayWidth;
-		AvailBox.y2 = (offset + avail) / pGeode->displayPitch;
+                AvailBox.x2 = pGeode->displayWidth;
+                AvailBox.y2 = (offset + avail) / pGeode->displayPitch;
 
-		if (AvailBox.y1 < AvailBox.y2) {
-		    REGION_INIT(pScrn, &OffscreenRegion, &AvailBox, 2);
+                if (AvailBox.y1 < AvailBox.y2) {
+                    REGION_INIT(pScrn, &OffscreenRegion, &AvailBox, 2);
 
-		    if (!xf86InitFBManagerRegion(pScrn, &OffscreenRegion))
-			xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-			    "Memory manager initialization failed.\n");
+                    if (!xf86InitFBManagerRegion(pScrn, &OffscreenRegion))
+                        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                                   "Memory manager initialization failed.\n");
 
-		    REGION_UNINIT(pScrn, &OffscreenRegion);
-		} else
-		    xf86DrvMsg(pScrni->scrnIndex, X_INFO,
-			"Cache disabled - no offscreen memory available.\n");
-	    } else
-		xf86DrvMsg(pScrni->scrnIndex, X_INFO,
-		    "XAA offscreen memory has already been allocated.\n");
-	}
+                    REGION_UNINIT(pScrn, &OffscreenRegion);
+                }
+                else
+                    xf86DrvMsg(pScrni->scrnIndex, X_INFO,
+                               "Cache disabled - no offscreen memory available.\n");
+            }
+            else
+                xf86DrvMsg(pScrni->scrnIndex, X_INFO,
+                           "XAA offscreen memory has already been allocated.\n");
+        }
     }
     return ret;
 }
@@ -302,7 +308,7 @@ GXSaveScreen(ScreenPtr pScrn, int mode)
     GeodePtr pGeode = GEODEPTR(pScrni);
 
     if (pGeode->useVGA && !pScrni->vtSema)
-	return vgaHWSaveScreen(pScrn, mode);
+        return vgaHWSaveScreen(pScrn, mode);
 
     return TRUE;
 }
@@ -311,21 +317,21 @@ GXSaveScreen(ScreenPtr pScrn, int mode)
 #ifdef XSERVER_LIBPCIACCESS
 static inline void *
 map_pci_mem(ScrnInfoPtr pScrni, int vram,
-    struct pci_device *dev, int bar, int size)
+            struct pci_device *dev, int bar, int size)
 {
     void *ptr;
-    void **result = (void **)&ptr;
+    void **result = (void **) &ptr;
     int map_size = size ? size : dev->regions[bar].size;
 
     int err = pci_device_map_range(dev,
-	dev->regions[bar].base_addr,
-	map_size,
-	PCI_DEV_MAP_FLAG_WRITABLE |
-	(vram ? PCI_DEV_MAP_FLAG_WRITE_COMBINE : 0),
-	result);
+                                   dev->regions[bar].base_addr,
+                                   map_size,
+                                   PCI_DEV_MAP_FLAG_WRITABLE |
+                                   (vram ? PCI_DEV_MAP_FLAG_WRITE_COMBINE : 0),
+                                   result);
 
     if (err)
-	return NULL;
+        return NULL;
     return ptr;
 }
 #endif
@@ -341,17 +347,21 @@ GXMapMem(ScrnInfoPtr pScrni)
     pciVideoPtr pci = xf86GetPciInfoForEntity(pGeode->pEnt->index);
 
 #ifndef XSERVER_LIBPCIACCESS
-    gfx_virt_regptr = (unsigned char *)xf86MapVidMem(index, VIDMEM_MMIO,
-	pci->memBase[2], pci->size[2]);
+    gfx_virt_regptr = (unsigned char *) xf86MapVidMem(index, VIDMEM_MMIO,
+                                                      pci->memBase[2],
+                                                      pci->size[2]);
 
-    gfx_virt_gpptr = (unsigned char *)xf86MapVidMem(index, VIDMEM_MMIO,
-	pci->memBase[1], pci->size[1]);
+    gfx_virt_gpptr = (unsigned char *) xf86MapVidMem(index, VIDMEM_MMIO,
+                                                     pci->memBase[1],
+                                                     pci->size[1]);
 
-    gfx_virt_vidptr = (unsigned char *)xf86MapVidMem(index, VIDMEM_MMIO,
-	pci->memBase[3], pci->size[3]);
+    gfx_virt_vidptr = (unsigned char *) xf86MapVidMem(index, VIDMEM_MMIO,
+                                                      pci->memBase[3],
+                                                      pci->size[3]);
 
-    gfx_virt_fbptr = (unsigned char *)xf86MapVidMem(index, VIDMEM_FRAMEBUFFER,
-	pci->memBase[0], pGeode->FBAvail);
+    gfx_virt_fbptr = (unsigned char *) xf86MapVidMem(index, VIDMEM_FRAMEBUFFER,
+                                                     pci->memBase[0],
+                                                     pGeode->FBAvail);
 #else
     gfx_virt_regptr = map_pci_mem(pScrni, 0, pci, 2, 0);
     gfx_virt_gpptr = map_pci_mem(pScrni, 0, pci, 1, 0);
@@ -366,14 +376,14 @@ GXMapMem(ScrnInfoPtr pScrni)
     pGeode->FBBase = gfx_virt_fbptr;
 
     if ((!gfx_virt_regptr) || (!gfx_virt_gpptr) ||
-	(!gfx_virt_vidptr) || (!gfx_virt_fbptr))
-	return FALSE;
+        (!gfx_virt_vidptr) || (!gfx_virt_fbptr))
+        return FALSE;
 
     if (!pGeode->NoAccel && pGeode->useEXA)
-	pGeode->pExa->memoryBase = pGeode->FBBase;
+        pGeode->pExa->memoryBase = pGeode->FBBase;
 
     xf86DrvMsg(index, X_INFO, "Found Geode %x %p\n",
-	pGeode->FBAvail, pGeode->FBBase);
+               pGeode->FBAvail, pGeode->FBBase);
 
     return TRUE;
 }
@@ -391,11 +401,11 @@ GXCheckVGA(ScrnInfoPtr pScrni)
     int ret;
 
     ptr =
-	xf86MapVidMem(pScrni->scrnIndex, VIDMEM_FRAMEBUFFER, 0xC001E,
-	strlen(vgasig));
+        xf86MapVidMem(pScrni->scrnIndex, VIDMEM_FRAMEBUFFER, 0xC001E,
+                      strlen(vgasig));
 
     if (ptr == NULL)
-	return FALSE;
+        return FALSE;
 
     ret = memcmp(ptr, vgasig, strlen(vgasig));
     xf86UnMapVidMem(pScrni->scrnIndex, (pointer) ptr, strlen(vgasig));
@@ -418,24 +428,24 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
     Bool useVGA;
 
     if (pScrni->numEntities != 1)
-	return FALSE;
+        return FALSE;
 
     pEnt = xf86GetEntityInfo(pScrni->entityList[0]);
 #ifndef XSERVER_LIBPCIACCESS
     if (pEnt->resources)
-	return FALSE;
+        return FALSE;
 #endif
 
     pGeode = pScrni->driverPrivate = xnfcalloc(1, sizeof(GeodeRec));
 
     if (pGeode == NULL)
-	return FALSE;
+        return FALSE;
 
     useVGA = GXCheckVGA(pScrni);
 
     if (flags & PROBE_DETECT) {
-	GeodeProbeDDC(pScrni, pEnt->index);
-	return TRUE;
+        GeodeProbeDDC(pScrni, pEnt->index);
+        return TRUE;
     }
 
     /* Probe for VGA */
@@ -443,13 +453,13 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
     pGeode->pEnt = pEnt;
 
     if (pGeode->useVGA) {
-	if (!xf86LoadSubModule(pScrni, "vgahw") || !vgaHWGetHWRec(pScrni))
-	    pGeode->useVGA = FALSE;
-	else
-	    vgaHWSetStdFuncs(VGAHWPTR(pScrni));
+        if (!xf86LoadSubModule(pScrni, "vgahw") || !vgaHWGetHWRec(pScrni))
+            pGeode->useVGA = FALSE;
+        else
+            vgaHWSetStdFuncs(VGAHWPTR(pScrni));
 
 #if INT10_SUPPORT
-	pGeode->vesa = calloc(1, sizeof(VESARec));
+        pGeode->vesa = calloc(1, sizeof(VESARec));
 #endif
     }
 
@@ -458,48 +468,49 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
     ret = gfx_msr_read(RC_ID_DF, MBD_MSR_CONFIG, &msrValue);
 
     if (!ret) {
-	pGeode->Output =
-	    ((msrValue.low & RCDF_CONFIG_FMT_MASK) ==
-	    RCDF_CONFIG_FMT_FP) ? OUTPUT_PANEL : OUTPUT_CRT;
+        pGeode->Output =
+            ((msrValue.low & RCDF_CONFIG_FMT_MASK) ==
+             RCDF_CONFIG_FMT_FP) ? OUTPUT_PANEL : OUTPUT_CRT;
     }
 
     /* Fill in the monitor information */
     pScrni->monitor = pScrni->confScreen->monitor;
 
     if (!xf86SetDepthBpp(pScrni, 16, 16, 16, Support24bppFb | Support32bppFb))
-	return FALSE;
+        return FALSE;
 
     switch (pScrni->depth) {
     case 8:
-	pScrni->rgbBits = 8;
+        pScrni->rgbBits = 8;
     case 16:
     case 24:
     case 32:
-	break;
+        break;
     default:
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "The driver does not support %d as a depth.\n", pScrni->depth);
-	return FALSE;
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "The driver does not support %d as a depth.\n",
+                   pScrni->depth);
+        return FALSE;
     }
 
     xf86PrintDepthBpp(pScrni);
 
     if (!xf86SetWeight(pScrni, defaultWeight, defaultWeight))
-	return FALSE;
+        return FALSE;
 
     if (!xf86SetDefaultVisual(pScrni, -1))
-	return FALSE;
+        return FALSE;
 
     /*
      * If the driver can do gamma correction, it should call xf86SetGamma()
      * here.
      */
     {
-	Gamma zeros = { 0.0, 0.0, 0.0 };
+        Gamma zeros = { 0.0, 0.0, 0.0 };
 
-	if (!xf86SetGamma(pScrni, zeros)) {
-	    return FALSE;
-	}
+        if (!xf86SetGamma(pScrni, zeros)) {
+            return FALSE;
+        }
     }
 
     pScrni->progClock = TRUE;
@@ -521,94 +532,92 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
     pGeode->NoOfColorExpandLines = DEFAULT_CLR_LINE_BUFS;
     pGeode->exaBfrSz = DEFAULT_EXA_SCRATCH_BFRSZ;
 
-    xf86GetOptValBool(GeodeOptions, GX_OPTION_HW_CURSOR,
-	&pGeode->tryHWCursor);
+    xf86GetOptValBool(GeodeOptions, GX_OPTION_HW_CURSOR, &pGeode->tryHWCursor);
 
     if (!xf86GetOptValInteger(GeodeOptions, GX_OPTION_FBSIZE,
-	    (int *)&(pGeode->FBAvail)))
-	pGeode->FBAvail = 0;
+                              (int *) &(pGeode->FBAvail)))
+        pGeode->FBAvail = 0;
 
     /* For compatability - allow SWCursor too */
 
     if (xf86ReturnOptValBool(GeodeOptions, GX_OPTION_SW_CURSOR, FALSE))
-	pGeode->tryHWCursor = FALSE;
+        pGeode->tryHWCursor = FALSE;
 
     if (xf86ReturnOptValBool(GeodeOptions, GX_OPTION_NOCOMPRESSION, FALSE))
-	pGeode->tryCompression = FALSE;
+        pGeode->tryCompression = FALSE;
 
     if (xf86ReturnOptValBool(GeodeOptions, GX_OPTION_NOACCEL, FALSE))
-	pGeode->NoAccel = TRUE;
+        pGeode->NoAccel = TRUE;
 
     pGeode->rotation = RR_Rotate_0;
 
     if ((s = xf86GetOptValString(GeodeOptions, GX_OPTION_ROTATE))) {
 
-	if (!xf86NameCmp(s, "LEFT"))
-	    pGeode->rotation = RR_Rotate_90;
-	else if (!xf86NameCmp(s, "INVERT"))
-	    pGeode->rotation = RR_Rotate_180;
-	else if (!xf86NameCmp(s, "CCW"))
-	    pGeode->rotation = RR_Rotate_270;
-	else
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Invalid rotation %s.\n", s);
+        if (!xf86NameCmp(s, "LEFT"))
+            pGeode->rotation = RR_Rotate_90;
+        else if (!xf86NameCmp(s, "INVERT"))
+            pGeode->rotation = RR_Rotate_180;
+        else if (!xf86NameCmp(s, "CCW"))
+            pGeode->rotation = RR_Rotate_270;
+        else
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR, "Invalid rotation %s.\n", s);
     }
 
     xf86GetOptValInteger(GeodeOptions, GX_OPTION_OSM_IMG_BUFS,
-	&(pGeode->NoOfImgBuffers));
+                         &(pGeode->NoOfImgBuffers));
 
     if (pGeode->NoOfImgBuffers <= 0)
-	pGeode->NoOfImgBuffers = 0;
+        pGeode->NoOfImgBuffers = 0;
 
     xf86GetOptValInteger(GeodeOptions, GX_OPTION_OSM_CLR_BUFS,
-	&(pGeode->NoOfColorExpandLines));
+                         &(pGeode->NoOfColorExpandLines));
 
     if (pGeode->NoOfColorExpandLines <= 0)
-	pGeode->NoOfColorExpandLines = 0;
+        pGeode->NoOfColorExpandLines = 0;
 
     xf86GetOptValInteger(GeodeOptions, GX_OPTION_OSM_CLR_BUFS,
-	(int *)&(pGeode->exaBfrSz));
+                         (int *) &(pGeode->exaBfrSz));
 
     if (pGeode->exaBfrSz <= 0)
-	pGeode->exaBfrSz = 0;
+        pGeode->exaBfrSz = 0;
 
     if (pGeode->Panel == TRUE) {
-	if (xf86ReturnOptValBool(GeodeOptions, GX_OPTION_NOPANEL, FALSE))
-	    pGeode->Panel = FALSE;
+        if (xf86ReturnOptValBool(GeodeOptions, GX_OPTION_NOPANEL, FALSE))
+            pGeode->Panel = FALSE;
     }
 
     panelgeo = xf86GetOptValString(GeodeOptions, GX_OPTION_PANEL_GEOMETRY);
 
     if ((s = xf86GetOptValString(GeodeOptions, GX_OPTION_ACCEL_METHOD))) {
-	if (!xf86NameCmp(s, "XAA"))
-	    pGeode->useEXA = FALSE;
-	else if (xf86NameCmp(s, "EXA"))
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Unknown accleration method %s.  Defaulting to XAA.\n", s);
+        if (!xf86NameCmp(s, "XAA"))
+            pGeode->useEXA = FALSE;
+        else if (xf86NameCmp(s, "EXA"))
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Unknown accleration method %s.  Defaulting to XAA.\n",
+                       s);
     }
 
     xf86DrvMsg(pScrni->scrnIndex, X_INFO,
-	"Using %s acceleration architecture\n",
-	pGeode->useEXA ? "EXA" : "XAA");
+               "Using %s acceleration architecture\n",
+               pGeode->useEXA ? "EXA" : "XAA");
 
     /* Set up the panel */
 
     if (pGeode->Panel) {
-	if (panelgeo != NULL) {
-	    if (GeodeGetFPGeometry(panelgeo, &pGeode->PanelX,
-		    &pGeode->PanelY))
-		pGeode->Panel = FALSE;
-	}
+        if (panelgeo != NULL) {
+            if (GeodeGetFPGeometry(panelgeo, &pGeode->PanelX, &pGeode->PanelY))
+                pGeode->Panel = FALSE;
+        }
 #ifdef PNL_SUP
-	else {
-	    int b, f;
+        else {
+            int b, f;
 
-	    /* The bitdepth and refresh isn't used anywhere else in the driver */
+            /* The bitdepth and refresh isn't used anywhere else in the driver */
 
-	    if ((pGeode->Panel = Pnl_IsPanelEnabledInBIOS()))
-		Pnl_GetPanelInfoFromBIOS(&pGeode->PanelX, &pGeode->PanelY, &b,
-		    &f);
-	}
+            if ((pGeode->Panel = Pnl_IsPanelEnabledInBIOS()))
+                Pnl_GetPanelInfoFromBIOS(&pGeode->PanelX, &pGeode->PanelY, &b,
+                                         &f);
+        }
 #endif
     }
 
@@ -616,18 +625,18 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
 
     if (pGeode->useVGA) {
 #if INT10_SUPPORT
-	VESARec *pVesa;
+        VESARec *pVesa;
 
-	if (!xf86LoadSubModule(pScrni, "int10"))
-	    return FALSE;
+        if (!xf86LoadSubModule(pScrni, "int10"))
+            return FALSE;
 
-	pVesa = pGeode->vesa;
+        pVesa = pGeode->vesa;
 
-	if ((pVesa->pInt = xf86InitInt10(pGeode->pEnt->index)) == NULL) {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Unable to initialize 1NT10 support\n");
-	    pGeode->useVGA = FALSE;
-	}
+        if ((pVesa->pInt = xf86InitInt10(pGeode->pEnt->index)) == NULL) {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Unable to initialize 1NT10 support\n");
+            pGeode->useVGA = FALSE;
+        }
 #endif
     }
 
@@ -637,19 +646,19 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
      */
 
     if (pGeode->FBAvail == 0) {
-	if (GeodeGetSizeFromFB(&pGeode->FBAvail))
-	    pGeode->FBAvail = gfx_get_frame_buffer_size();
+        if (GeodeGetSizeFromFB(&pGeode->FBAvail))
+            pGeode->FBAvail = gfx_get_frame_buffer_size();
     }
 
     if (pScrni->memPhysBase == 0)
-	pScrni->memPhysBase = gfx_get_frame_buffer_base();
+        pScrni->memPhysBase = gfx_get_frame_buffer_base();
 
     pScrni->fbOffset = 0;
 
     if (pGeode->pEnt->device->videoRam == 0)
-	pScrni->videoRam = pGeode->FBAvail / 1024;
+        pScrni->videoRam = pGeode->FBAvail / 1024;
     else
-	pScrni->videoRam = pGeode->pEnt->device->videoRam;
+        pScrni->videoRam = pGeode->pEnt->device->videoRam;
 
     GeodeClockRange = (ClockRangePtr) xnfcalloc(1, sizeof(ClockRange));
     GeodeClockRange->next = NULL;
@@ -664,24 +673,25 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
     /* I'm still not 100% sure this uses the right values */
 
     modecnt = xf86ValidateModes(pScrni,
-	pScrni->monitor->Modes,
-	pScrni->display->modes,
-	GeodeClockRange,
-	NULL, GX_MIN_PITCH, GX_MAX_PITCH,
-	32, GX_MIN_HEIGHT, GX_MAX_HEIGHT,
-	pScrni->display->virtualX,
-	pScrni->display->virtualY, pGeode->FBAvail, LOOKUP_BEST_REFRESH);
+                                pScrni->monitor->Modes,
+                                pScrni->display->modes,
+                                GeodeClockRange,
+                                NULL, GX_MIN_PITCH, GX_MAX_PITCH,
+                                32, GX_MIN_HEIGHT, GX_MAX_HEIGHT,
+                                pScrni->display->virtualX,
+                                pScrni->display->virtualY, pGeode->FBAvail,
+                                LOOKUP_BEST_REFRESH);
 
     if (modecnt <= 0) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR, "No valid modes were found\n");
-	return FALSE;
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR, "No valid modes were found\n");
+        return FALSE;
     }
 
     xf86PruneDriverModes(pScrni);
 
     if (pScrni->modes == NULL) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR, "No valid modes were found\n");
-	return FALSE;
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR, "No valid modes were found\n");
+        return FALSE;
     }
 
     xf86SetCrtcForModes(pScrni, 0);
@@ -693,28 +703,28 @@ GXPreInit(ScrnInfoPtr pScrni, int flags)
     /* Load the modules we'll need */
 
     if (xf86LoadSubModule(pScrni, "fb") == NULL) {
-	return FALSE;
+        return FALSE;
     }
 
     if (pGeode->NoAccel == FALSE) {
-	const char *module = (pGeode->useEXA) ? "exa" : "xaa";
+        const char *module = (pGeode->useEXA) ? "exa" : "xaa";
 
-	if (!xf86LoadSubModule(pScrni, module)) {
-	    return FALSE;
-	}
+        if (!xf86LoadSubModule(pScrni, module)) {
+            return FALSE;
+        }
     }
 
     if (pGeode->tryHWCursor == TRUE) {
-	if (!xf86LoadSubModule(pScrni, "ramdac")) {
-	    return FALSE;
-	}
+        if (!xf86LoadSubModule(pScrni, "ramdac")) {
+            return FALSE;
+        }
     }
 
 #ifndef XSERVER_LIBPCIACCESS
     if (xf86RegisterResources(pGeode->pEnt->index, NULL, ResExclusive)) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "Couldn't register the resources.\n");
-	return FALSE;
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "Couldn't register the resources.\n");
+        return FALSE;
     }
 #endif
     return TRUE;
@@ -726,11 +736,11 @@ GXRestore(ScrnInfoPtr pScrni)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pGeode->useVGA && pGeode->FBVGAActive) {
-	vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
+        vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
 
-	vgaHWProtect(pScrni, TRUE);
-	vgaHWRestore(pScrni, &pvgaHW->SavedReg, VGA_SR_ALL);
-	vgaHWProtect(pScrni, FALSE);
+        vgaHWProtect(pScrni, TRUE);
+        vgaHWRestore(pScrni, &pvgaHW->SavedReg, VGA_SR_ALL);
+        vgaHWProtect(pScrni, FALSE);
     }
 }
 
@@ -754,13 +764,13 @@ GXSetDvLineSize(unsigned int pitch)
     unsigned long temp, dv_size = MDC_DV_LINE_SIZE_1024;
 
     if (pitch > 1024) {
-	dv_size = MDC_DV_LINE_SIZE_2048;
+        dv_size = MDC_DV_LINE_SIZE_2048;
     }
     if (pitch > 2048) {
-	dv_size = MDC_DV_LINE_SIZE_4096;
+        dv_size = MDC_DV_LINE_SIZE_4096;
     }
     if (pitch > 4096) {
-	dv_size = MDC_DV_LINE_SIZE_8192;
+        dv_size = MDC_DV_LINE_SIZE_8192;
     }
 
     /* WRITE DIRTY/VALID CONTROL WITH LINE LENGTH */
@@ -795,38 +805,40 @@ GXSetVideoMode(ScrnInfoPtr pScrni, DisplayModePtr pMode)
     gx_disable_dac_power();
 
     if (pMode->Flags & V_NHSYNC)
-	flags |= 1;
+        flags |= 1;
     if (pMode->Flags & V_NVSYNC)
-	flags |= 2;
+        flags |= 2;
 
     /* Check to see if we should use custom or built-in timings */
 
     if (pGeode->Panel)
-	custom = (pMode->type & M_T_USERDEF);
+        custom = (pMode->type & M_T_USERDEF);
     else
-	custom = !(pMode->type & (M_T_BUILTIN | M_T_DEFAULT));
+        custom = !(pMode->type & (M_T_BUILTIN | M_T_DEFAULT));
 
     /* If we're not doing a custom mode, then just set the fixed timings,
      * otherwise, do the whole shooting match */
 
     if (!custom) {
-	GFX(set_fixed_timings(pGeode->PanelX, pGeode->PanelY,
-		pMode->CrtcHDisplay, pMode->CrtcVDisplay,
-		pScrni->bitsPerPixel));
-    } else {
-	if (pGeode->Panel)
-	    GFX(set_panel_present(pGeode->PanelX, pGeode->PanelY,
-		    pMode->CrtcHDisplay, pMode->CrtcVDisplay,
-		    pScrni->bitsPerPixel));
-
-	GFX(set_display_timings(pScrni->bitsPerPixel, flags,
-		pMode->CrtcHDisplay, pMode->CrtcHBlankStart,
-		pMode->CrtcHSyncStart, pMode->CrtcHSyncEnd,
-		pMode->CrtcHBlankEnd, pMode->CrtcHTotal,
-		pMode->CrtcVDisplay, pMode->CrtcVBlankStart,
-		pMode->CrtcVSyncStart, pMode->CrtcVSyncEnd,
-		pMode->CrtcVBlankEnd, pMode->CrtcVTotal,
-		(int)((pMode->SynthClock / 1000.0) * 0x10000)));
+        GFX(set_fixed_timings(pGeode->PanelX, pGeode->PanelY,
+                              pMode->CrtcHDisplay, pMode->CrtcVDisplay,
+                              pScrni->bitsPerPixel));
+    }
+    else {
+        if (pGeode->Panel)
+            GFX(set_panel_present(pGeode->PanelX, pGeode->PanelY,
+                                  pMode->CrtcHDisplay, pMode->CrtcVDisplay,
+                                  pScrni->bitsPerPixel));
+
+        GFX(set_display_timings(pScrni->bitsPerPixel, flags,
+                                pMode->CrtcHDisplay, pMode->CrtcHBlankStart,
+                                pMode->CrtcHSyncStart, pMode->CrtcHSyncEnd,
+                                pMode->CrtcHBlankEnd, pMode->CrtcHTotal,
+                                pMode->CrtcVDisplay, pMode->CrtcVBlankStart,
+                                pMode->CrtcVSyncStart, pMode->CrtcVSyncEnd,
+                                pMode->CrtcVBlankEnd, pMode->CrtcVTotal,
+                                (int) ((pMode->SynthClock / 1000.0) *
+                                       0x10000)));
     }
 
     GFX(set_crt_enable(CRT_ENABLE));
@@ -835,22 +847,23 @@ GXSetVideoMode(ScrnInfoPtr pScrni, DisplayModePtr pMode)
     GFX(wait_vertical_blank());
 
     if (pGeode->Compression) {
-	GXSetDvLineSize(pGeode->Pitch);
+        GXSetDvLineSize(pGeode->Pitch);
 
-	gfx_set_compression_offset(pGeode->CBData.compression_offset);
-	gfx_set_compression_pitch(GX_CB_PITCH);
-	gfx_set_compression_size(GX_CB_SIZE);
+        gfx_set_compression_offset(pGeode->CBData.compression_offset);
+        gfx_set_compression_pitch(GX_CB_PITCH);
+        gfx_set_compression_size(GX_CB_SIZE);
 
-	gfx_set_compression_enable(1);
+        gfx_set_compression_enable(1);
     }
 
     if (pGeode->HWCursor && !(pMode->Flags & V_DBLSCAN)) {
-	GXLoadCursorImage(pScrni, NULL);
-	GFX(set_cursor_position(pGeode->CursorStartOffset, 0, 0, 0, 0));
-	GXShowCursor(pScrni);
-    } else {
-	GFX(set_cursor_enable(0));
-	pGeode->HWCursor = FALSE;
+        GXLoadCursorImage(pScrni, NULL);
+        GFX(set_cursor_position(pGeode->CursorStartOffset, 0, 0, 0, 0));
+        GXShowCursor(pScrni);
+    }
+    else {
+        GFX(set_cursor_enable(0));
+        pGeode->HWCursor = FALSE;
     }
 
     GXAdjustFrame(pScrni->scrnIndex, pScrni->frameX0, pScrni->frameY0, 0);
@@ -876,21 +889,22 @@ GXSwitchMode(int index, DisplayModePtr pMode, int flags)
     ret = GXAllocateMemory(pScrni->pScreen, pScrni, rotate);
 
     if (ret) {
-	if (pGeode->curMode != pMode)
-	    ret = GXSetVideoMode(pScrni, pMode);
+        if (pGeode->curMode != pMode)
+            ret = GXSetVideoMode(pScrni, pMode);
     }
 
     if (ret)
-	ret = GXRotate(pScrni, pMode);
+        ret = GXRotate(pScrni, pMode);
 
     /* Go back the way it was */
 
     if (ret == FALSE) {
-	if (!GXSetVideoMode(pScrni, pGeode->curMode))
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Could not restore the previous mode\n");
-    } else
-	pGeode->curMode = pMode;
+        if (!GXSetVideoMode(pScrni, pGeode->curMode))
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Could not restore the previous mode\n");
+    }
+    else
+        pGeode->curMode = pMode;
 
     return ret;
 }
@@ -904,29 +918,29 @@ GXLeaveGraphics(ScrnInfoPtr pScrni)
 
     /* Restore VG registers */
     gfx_set_display_timings(pGeode->FBgfxdisplaytiming.wBpp,
-	pGeode->FBgfxdisplaytiming.wPolarity,
-	pGeode->FBgfxdisplaytiming.wHActive,
-	pGeode->FBgfxdisplaytiming.wHBlankStart,
-	pGeode->FBgfxdisplaytiming.wHSyncStart,
-	pGeode->FBgfxdisplaytiming.wHSyncEnd,
-	pGeode->FBgfxdisplaytiming.wHBlankEnd,
-	pGeode->FBgfxdisplaytiming.wHTotal,
-	pGeode->FBgfxdisplaytiming.wVActive,
-	pGeode->FBgfxdisplaytiming.wVBlankStart,
-	pGeode->FBgfxdisplaytiming.wVSyncStart,
-	pGeode->FBgfxdisplaytiming.wVSyncEnd,
-	pGeode->FBgfxdisplaytiming.wVBlankEnd,
-	pGeode->FBgfxdisplaytiming.wVTotal,
-	pGeode->FBgfxdisplaytiming.dwDotClock);
+                            pGeode->FBgfxdisplaytiming.wPolarity,
+                            pGeode->FBgfxdisplaytiming.wHActive,
+                            pGeode->FBgfxdisplaytiming.wHBlankStart,
+                            pGeode->FBgfxdisplaytiming.wHSyncStart,
+                            pGeode->FBgfxdisplaytiming.wHSyncEnd,
+                            pGeode->FBgfxdisplaytiming.wHBlankEnd,
+                            pGeode->FBgfxdisplaytiming.wHTotal,
+                            pGeode->FBgfxdisplaytiming.wVActive,
+                            pGeode->FBgfxdisplaytiming.wVBlankStart,
+                            pGeode->FBgfxdisplaytiming.wVSyncStart,
+                            pGeode->FBgfxdisplaytiming.wVSyncEnd,
+                            pGeode->FBgfxdisplaytiming.wVBlankEnd,
+                            pGeode->FBgfxdisplaytiming.wVTotal,
+                            pGeode->FBgfxdisplaytiming.dwDotClock);
 
     gfx_set_compression_enable(0);
 
     /* Restore the previous Compression state */
     if (pGeode->FBCompressionEnable) {
-	gfx_set_compression_offset(pGeode->FBCompressionOffset);
-	gfx_set_compression_pitch(pGeode->FBCompressionPitch);
-	gfx_set_compression_size(pGeode->FBCompressionSize);
-	gfx_set_compression_enable(1);
+        gfx_set_compression_offset(pGeode->FBCompressionOffset);
+        gfx_set_compression_pitch(pGeode->FBCompressionPitch);
+        gfx_set_compression_size(pGeode->FBCompressionSize);
+        gfx_set_compression_enable(1);
     }
 
     gfx_set_display_pitch(pGeode->FBgfxdisplaytiming.wPitch);
@@ -937,11 +951,11 @@ GXLeaveGraphics(ScrnInfoPtr pScrni)
     gfx_set_cursor_position(pGeode->FBCursorOffset, 0, 0, 0, 0);
 
     if (pGeode->useVGA) {
-	pGeode->vesa->pInt->num = 0x10;
-	pGeode->vesa->pInt->ax = 0x0 | pGeode->FBBIOSMode;
-	pGeode->vesa->pInt->bx = 0;
-	xf86ExecX86int10(pGeode->vesa->pInt);
-	gfx_delay_milliseconds(3);
+        pGeode->vesa->pInt->num = 0x10;
+        pGeode->vesa->pInt->ax = 0x0 | pGeode->FBBIOSMode;
+        pGeode->vesa->pInt->bx = 0;
+        xf86ExecX86int10(pGeode->vesa->pInt);
+        gfx_delay_milliseconds(3);
     }
 
     GXRestore(pScrni);
@@ -956,26 +970,26 @@ GXCloseScreen(int scrnIndex, ScreenPtr pScrn)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pScrni->vtSema)
-	GXLeaveGraphics(pScrni);
+        GXLeaveGraphics(pScrni);
 
     if (pGeode->AccelInfoRec)
-	XAADestroyInfoRec(pGeode->AccelInfoRec);
+        XAADestroyInfoRec(pGeode->AccelInfoRec);
 
     if (pGeode->AccelImageWriteBuffers) {
-	free(pGeode->AccelImageWriteBuffers[0]);
-	free(pGeode->AccelImageWriteBuffers);
-	pGeode->AccelImageWriteBuffers = NULL;
+        free(pGeode->AccelImageWriteBuffers[0]);
+        free(pGeode->AccelImageWriteBuffers);
+        pGeode->AccelImageWriteBuffers = NULL;
     }
 
     if (pGeode->AccelColorExpandBuffers) {
-	free(pGeode->AccelColorExpandBuffers);
-	pGeode->AccelColorExpandBuffers = NULL;
+        free(pGeode->AccelColorExpandBuffers);
+        pGeode->AccelColorExpandBuffers = NULL;
     }
 
     if (pGeode->pExa) {
-	exaDriverFini(pScrn);
-	free(pGeode->pExa);
-	pGeode->pExa = NULL;
+        exaDriverFini(pScrn);
+        free(pGeode->pExa);
+        pGeode->pExa = NULL;
     }
 
     pScrni->vtSema = FALSE;
@@ -986,7 +1000,7 @@ GXCloseScreen(int scrnIndex, ScreenPtr pScrn)
     pScrn->CloseScreen = pGeode->CloseScreen;
 
     if (pScrn->CloseScreen)
-	return (*pScrn->CloseScreen) (scrnIndex, pScrn);
+        return (*pScrn->CloseScreen) (scrnIndex, pScrn);
 
     return TRUE;
 }
@@ -997,10 +1011,10 @@ GXEnterGraphics(ScreenPtr pScrn, ScrnInfoPtr pScrni)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (!GXMapMem(pScrni))
-	return FALSE;
+        return FALSE;
 
     if (pGeode->useVGA)
-	pGeode->FBVGAActive = gu2_get_vga_active();
+        pGeode->FBVGAActive = gu2_get_vga_active();
 
     gfx_wait_until_idle();
 
@@ -1026,9 +1040,9 @@ GXEnterGraphics(ScreenPtr pScrn, ScrnInfoPtr pScrni)
     pGeode->FBDisplayOffset = gfx_get_display_offset();
 
     if (pGeode->useVGA) {
-	vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
+        vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
 
-	pGeode->FBBIOSMode = pvgaHW->readCrtc(pvgaHW, 0x040);
+        pGeode->FBBIOSMode = pvgaHW->readCrtc(pvgaHW, 0x040);
     }
 
     pGeode->FBCompressionEnable = gfx_get_compression_enable();
@@ -1043,37 +1057,37 @@ GXEnterGraphics(ScreenPtr pScrn, ScrnInfoPtr pScrni)
     /* Turn off the VGA */
 
     if (pGeode->useVGA && pGeode->FBVGAActive) {
-	unsigned short sequencer;
-	vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
+        unsigned short sequencer;
+        vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
 
-	/* Map VGA aperture */
-	if (!vgaHWMapMem(pScrni))
-	    return FALSE;
+        /* Map VGA aperture */
+        if (!vgaHWMapMem(pScrni))
+            return FALSE;
 
-	/* Unlock VGA registers */
-	vgaHWUnlock(pvgaHW);
+        /* Unlock VGA registers */
+        vgaHWUnlock(pvgaHW);
 
-	/* Save the current state and setup the current mode */
-	vgaHWSave(pScrni, &VGAHWPTR(pScrni)->SavedReg, VGA_SR_ALL);
+        /* Save the current state and setup the current mode */
+        vgaHWSave(pScrni, &VGAHWPTR(pScrni)->SavedReg, VGA_SR_ALL);
 
-	/* DISABLE VGA SEQUENCER */
-	/* This allows the VGA state machine to terminate. We must delay */
-	/* such that there are no pending MBUS requests.  */
+        /* DISABLE VGA SEQUENCER */
+        /* This allows the VGA state machine to terminate. We must delay */
+        /* such that there are no pending MBUS requests.  */
 
-	gfx_outb(MDC_SEQUENCER_INDEX, MDC_SEQUENCER_CLK_MODE);
-	sequencer = gfx_inb(MDC_SEQUENCER_DATA);
-	sequencer |= MDC_CLK_MODE_SCREEN_OFF;
-	gfx_outb(MDC_SEQUENCER_DATA, sequencer);
+        gfx_outb(MDC_SEQUENCER_INDEX, MDC_SEQUENCER_CLK_MODE);
+        sequencer = gfx_inb(MDC_SEQUENCER_DATA);
+        sequencer |= MDC_CLK_MODE_SCREEN_OFF;
+        gfx_outb(MDC_SEQUENCER_DATA, sequencer);
 
-	gfx_delay_milliseconds(1);
+        gfx_delay_milliseconds(1);
 
-	/* BLANK THE VGA DISPLAY */
-	gfx_outw(MDC_SEQUENCER_INDEX, MDC_SEQUENCER_RESET);
-	sequencer = gfx_inb(MDC_SEQUENCER_DATA);
-	sequencer &= ~MDC_RESET_VGA_DISP_ENABLE;
-	gfx_outb(MDC_SEQUENCER_DATA, sequencer);
+        /* BLANK THE VGA DISPLAY */
+        gfx_outw(MDC_SEQUENCER_INDEX, MDC_SEQUENCER_RESET);
+        sequencer = gfx_inb(MDC_SEQUENCER_DATA);
+        sequencer &= ~MDC_RESET_VGA_DISP_ENABLE;
+        gfx_outb(MDC_SEQUENCER_DATA, sequencer);
 
-	gfx_delay_milliseconds(1);
+        gfx_delay_milliseconds(1);
     }
 
     /* Set up the memory */
@@ -1092,17 +1106,17 @@ GXEnterGraphics(ScreenPtr pScrn, ScrnInfoPtr pScrni)
 
 static void
 GXLoadPalette(ScrnInfoPtr pScrni,
-    int numColors, int *indizes, LOCO * colors, VisualPtr pVisual)
+              int numColors, int *indizes, LOCO * colors, VisualPtr pVisual)
 {
     int i, index, color;
 
     for (i = 0; i < numColors; i++) {
-	index = indizes[i] & 0xFF;
-	color = (((unsigned long)(colors[index].red & 0xFF)) << 16) |
-	    (((unsigned long)(colors[index].green & 0xFF)) << 8) |
-	    ((unsigned long)(colors[index].blue & 0xFF));
+        index = indizes[i] & 0xFF;
+        color = (((unsigned long) (colors[index].red & 0xFF)) << 16) |
+            (((unsigned long) (colors[index].green & 0xFF)) << 8) |
+            ((unsigned long) (colors[index].blue & 0xFF));
 
-	GFX(set_display_palette_entry(index, color));
+        GFX(set_display_palette_entry(index, color));
     }
 }
 
@@ -1113,9 +1127,9 @@ GXPanelPower(int enable)
     unsigned long power = READ_VID32(RCDF_POWER_MANAGEMENT);
 
     if (enable != 0)
-	power |= RCDF_PM_PANEL_POWER_ON;
+        power |= RCDF_PM_PANEL_POWER_ON;
     else
-	power &= ~RCDF_PM_PANEL_POWER_ON;
+        power &= ~RCDF_PM_PANEL_POWER_ON;
 
     WRITE_VID32(RCDF_POWER_MANAGEMENT, power);
 }
@@ -1128,52 +1142,52 @@ GXDPMSSet(ScrnInfoPtr pScrni, int mode, int flags)
     pGeode = GEODEPTR(pScrni);
 
     if (!pScrni->vtSema)
-	return;
+        return;
 
     switch (mode) {
     case DPMSModeOn:
-	/* Screen: On; HSync: On; VSync: On */
-	GFX(set_crt_enable(CRT_ENABLE));
+        /* Screen: On; HSync: On; VSync: On */
+        GFX(set_crt_enable(CRT_ENABLE));
 #if defined(PNL_SUP)
-	if (pGeode->Panel) {
-	    Pnl_PowerUp();
-	    GXPanelPower(1);
-	}
+        if (pGeode->Panel) {
+            Pnl_PowerUp();
+            GXPanelPower(1);
+        }
 #endif
-	break;
+        break;
 
     case DPMSModeStandby:
-	/* Screen: Off; HSync: Off; VSync: On */
-	GFX(set_crt_enable(CRT_STANDBY));
+        /* Screen: Off; HSync: Off; VSync: On */
+        GFX(set_crt_enable(CRT_STANDBY));
 #if defined(PNL_SUP)
-	if (pGeode->Panel) {
-	    Pnl_PowerDown();
-	    GXPanelPower(0);
-	}
+        if (pGeode->Panel) {
+            Pnl_PowerDown();
+            GXPanelPower(0);
+        }
 #endif
-	break;
+        break;
 
     case DPMSModeSuspend:
-	/* Screen: Off; HSync: On; VSync: Off */
-	GFX(set_crt_enable(CRT_SUSPEND));
+        /* Screen: Off; HSync: On; VSync: Off */
+        GFX(set_crt_enable(CRT_SUSPEND));
 #if defined(PNL_SUP)
-	if (pGeode->Panel) {
-	    Pnl_PowerDown();
-	    GXPanelPower(0);
-	}
+        if (pGeode->Panel) {
+            Pnl_PowerDown();
+            GXPanelPower(0);
+        }
 #endif
-	break;
+        break;
 
     case DPMSModeOff:
-	/* Screen: Off; HSync: Off; VSync: Off */
-	GFX(set_crt_enable(CRT_DISABLE));
+        /* Screen: Off; HSync: Off; VSync: Off */
+        GFX(set_crt_enable(CRT_DISABLE));
 #if defined(PNL_SUP)
-	if (pGeode->Panel) {
-	    Pnl_PowerDown();
-	    GXPanelPower(0);
-	}
+        if (pGeode->Panel) {
+            Pnl_PowerDown();
+            GXPanelPower(0);
+        }
 #endif
-	break;
+        break;
     }
 }
 #endif
@@ -1186,31 +1200,31 @@ GXCreateScreenResources(ScreenPtr pScreen)
 
     pScreen->CreateScreenResources = pGeode->CreateScreenResources;
     if (!(*pScreen->CreateScreenResources) (pScreen))
-	return FALSE;
+        return FALSE;
 
     if (xf86LoaderCheckSymbol("GXRandRSetConfig")
-	&& pGeode->rotation != RR_Rotate_0) {
-	Rotation(*GXRandRSetConfig) (ScreenPtr pScreen, Rotation rr, int rate,
-	    RRScreenSizePtr pSize) = NULL;
+        && pGeode->rotation != RR_Rotate_0) {
+        Rotation(*GXRandRSetConfig) (ScreenPtr pScreen, Rotation rr, int rate,
+                                     RRScreenSizePtr pSize) = NULL;
 
-	RRScreenSize p;
-	Rotation requestedRotation = pGeode->rotation;
+        RRScreenSize p;
+        Rotation requestedRotation = pGeode->rotation;
 
-	pGeode->rotation = RR_Rotate_0;
+        pGeode->rotation = RR_Rotate_0;
 
-	/* Just setup enough for an initial rotate */
+        /* Just setup enough for an initial rotate */
 
-	p.width = pScreen->width;
-	p.height = pScreen->height;
-	p.mmWidth = pScreen->mmWidth;
-	p.mmHeight = pScreen->mmHeight;
+        p.width = pScreen->width;
+        p.height = pScreen->height;
+        p.mmWidth = pScreen->mmWidth;
+        p.mmHeight = pScreen->mmHeight;
 
-	GXRandRSetConfig = LoaderSymbol("GXRandRSetConfig");
-	if (GXRandRSetConfig) {
-	    pGeode->starting = TRUE;
-	    (*GXRandRSetConfig) (pScreen, requestedRotation, 0, &p);
-	    pGeode->starting = FALSE;
-	}
+        GXRandRSetConfig = LoaderSymbol("GXRandRSetConfig");
+        if (GXRandRSetConfig) {
+            pGeode->starting = TRUE;
+            (*GXRandRSetConfig) (pScreen, requestedRotation, 0, &p);
+            pGeode->starting = FALSE;
+        }
     }
 
     return TRUE;
@@ -1230,65 +1244,69 @@ GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
 
     if (pGeode->useVGA) {
 
-	if (!vgaHWMapMem(pScrni))
-	    return FALSE;
+        if (!vgaHWMapMem(pScrni))
+            return FALSE;
 
-	vgaHWGetIOBase(VGAHWPTR(pScrni));
+        vgaHWGetIOBase(VGAHWPTR(pScrni));
     }
 
     if (!pGeode->NoAccel) {
 
-	if (pGeode->useEXA) {
-
-	    if (!(pGeode->pExa = exaDriverAlloc())) {
-		xf86DrvMsg(scrnIndex, X_ERROR,
-		    "Couldn't allocate the EXA structure.\n");
-		pGeode->NoAccel = TRUE;
-	    } else {
-		ExaDriverPtr pExa = pGeode->pExa;
-
-		/* THis is set in GXAllocMem */
-		pExa->memoryBase = 0;
-
-		/* This is set in GXAllocateMemory */
-		pExa->memorySize = 0;
-
-		pExa->pixmapOffsetAlign = 32;
-		pExa->pixmapPitchAlign = 32;
-		pExa->flags = EXA_OFFSCREEN_PIXMAPS;
-		pExa->maxX = GX_MAX_WIDTH - 1;
-		pExa->maxY = GX_MAX_HEIGHT - 1;
-	    }
-	} else {
-	    pGeode->AccelImageWriteBuffers =
-		calloc(pGeode->NoOfImgBuffers,
-		sizeof(pGeode->AccelImageWriteBuffers[0]));
-	    pGeode->AccelColorExpandBuffers =
-		calloc(pGeode->NoOfColorExpandLines,
-		sizeof(pGeode->AccelColorExpandBuffers[0]));
-	}
+        if (pGeode->useEXA) {
+
+            if (!(pGeode->pExa = exaDriverAlloc())) {
+                xf86DrvMsg(scrnIndex, X_ERROR,
+                           "Couldn't allocate the EXA structure.\n");
+                pGeode->NoAccel = TRUE;
+            }
+            else {
+                ExaDriverPtr pExa = pGeode->pExa;
+
+                /* THis is set in GXAllocMem */
+                pExa->memoryBase = 0;
+
+                /* This is set in GXAllocateMemory */
+                pExa->memorySize = 0;
+
+                pExa->pixmapOffsetAlign = 32;
+                pExa->pixmapPitchAlign = 32;
+                pExa->flags = EXA_OFFSCREEN_PIXMAPS;
+                pExa->maxX = GX_MAX_WIDTH - 1;
+                pExa->maxY = GX_MAX_HEIGHT - 1;
+            }
+        }
+        else {
+            pGeode->AccelImageWriteBuffers =
+                calloc(pGeode->NoOfImgBuffers,
+                       sizeof(pGeode->AccelImageWriteBuffers[0]));
+            pGeode->AccelColorExpandBuffers =
+                calloc(pGeode->NoOfColorExpandLines,
+                       sizeof(pGeode->AccelColorExpandBuffers[0]));
+        }
     }
 
     /* XXX FIXME - Take down any of the structures on failure? */
 
     if (!GXEnterGraphics(pScrn, pScrni))
-	return FALSE;
+        return FALSE;
 
     miClearVisualTypes();
 
     /* XXX Again - take down anything? */
 
     if (pScrni->bitsPerPixel > 8) {
-	if (!miSetVisualTypes(pScrni->depth,
-		TrueColorMask, pScrni->rgbBits, pScrni->defaultVisual)) {
-	    return FALSE;
-	}
-    } else {
-	if (!miSetVisualTypes(pScrni->depth,
-		miGetDefaultVisualMask(pScrni->depth),
-		pScrni->rgbBits, pScrni->defaultVisual)) {
-	    return FALSE;
-	}
+        if (!miSetVisualTypes(pScrni->depth,
+                              TrueColorMask, pScrni->rgbBits,
+                              pScrni->defaultVisual)) {
+            return FALSE;
+        }
+    }
+    else {
+        if (!miSetVisualTypes(pScrni->depth,
+                              miGetDefaultVisualMask(pScrni->depth),
+                              pScrni->rgbBits, pScrni->defaultVisual)) {
+            return FALSE;
+        }
     }
 
     miSetPixmapDepths();
@@ -1296,37 +1314,37 @@ GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
     /* Point at the visible area to start */
 
     ret = fbScreenInit(pScrn, pGeode->FBBase + pGeode->displayOffset,
-	pScrni->virtualX, pScrni->virtualY,
-	pScrni->xDpi, pScrni->yDpi, pGeode->displayWidth,
-	pScrni->bitsPerPixel);
+                       pScrni->virtualX, pScrni->virtualY,
+                       pScrni->xDpi, pScrni->yDpi, pGeode->displayWidth,
+                       pScrni->bitsPerPixel);
 
     if (!ret)
-	return FALSE;
+        return FALSE;
 
     xf86SetBlackWhitePixels(pScrn);
 
     /* Set up the color ordering */
 
     if (pScrni->bitsPerPixel > 8) {
-	VisualPtr visual = pScrn->visuals + pScrn->numVisuals;
-
-	while (--visual >= pScrn->visuals) {
-	    if ((visual->class | DynamicClass) == DirectColor) {
-		visual->offsetRed = pScrni->offset.red;
-		visual->offsetGreen = pScrni->offset.green;
-		visual->offsetBlue = pScrni->offset.blue;
-		visual->redMask = pScrni->mask.red;
-		visual->greenMask = pScrni->mask.green;
-		visual->blueMask = pScrni->mask.blue;
-	    }
-	}
+        VisualPtr visual = pScrn->visuals + pScrn->numVisuals;
+
+        while (--visual >= pScrn->visuals) {
+            if ((visual->class | DynamicClass) == DirectColor) {
+                visual->offsetRed = pScrni->offset.red;
+                visual->offsetGreen = pScrni->offset.green;
+                visual->offsetBlue = pScrni->offset.blue;
+                visual->redMask = pScrni->mask.red;
+                visual->greenMask = pScrni->mask.green;
+                visual->blueMask = pScrni->mask.blue;
+            }
+        }
     }
 
     /* Must follow the color ordering */
     fbPictureInit(pScrn, 0, 0);
 
     if (!pGeode->NoAccel)
-	GXAccelInit(pScrn);
+        GXAccelInit(pScrn);
 
     miInitializeBackingStore(pScrn);
     xf86SetBackingStore(pScrn);
@@ -1337,24 +1355,25 @@ GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
     /* Set up the HW cursor - must follow the soft cursor init */
 
     if (pGeode->tryHWCursor) {
-	if (!GXHWCursorInit(pScrn))
-	    xf86DrvMsg(scrnIndex, X_ERROR,
-		"Hardware cursor initialization failed.\n");
+        if (!GXHWCursorInit(pScrn))
+            xf86DrvMsg(scrnIndex, X_ERROR,
+                       "Hardware cursor initialization failed.\n");
     }
 
     /* Set up the color map */
 
     if (!miCreateDefColormap(pScrn))
-	return FALSE;
+        return FALSE;
 
     if (pScrni->bitsPerPixel == 8) {
-	/* Must follow initialization of the default colormap */
+        /* Must follow initialization of the default colormap */
 
-	if (!xf86HandleColormaps(pScrn, 256, 8,
-		GXLoadPalette, NULL,
-		CMAP_PALETTED_TRUECOLOR | CMAP_RELOAD_ON_MODE_SWITCH)) {
-	    return FALSE;
-	}
+        if (!xf86HandleColormaps(pScrn, 256, 8,
+                                 GXLoadPalette, NULL,
+                                 CMAP_PALETTED_TRUECOLOR |
+                                 CMAP_RELOAD_ON_MODE_SWITCH)) {
+            return FALSE;
+        }
     }
 #ifdef DPMSExtension
     xf86DPMSInit(pScrn, GXDPMSSet, 0);
@@ -1364,7 +1383,7 @@ GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
 
     /* Set up RandR */
 
-    xf86DisableRandR();		       /* We provide our own RandR goodness */
+    xf86DisableRandR();         /* We provide our own RandR goodness */
 
     /* Try to set up the shadow FB for rotation */
 
@@ -1373,20 +1392,21 @@ GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
     shadowReq.minorversion = 1;
 
     if (LoadSubModule(pScrni->module, "shadow",
-	    NULL, NULL, NULL, &shadowReq, &maj, &min)) {
+                      NULL, NULL, NULL, &shadowReq, &maj, &min)) {
 
-	rotate = RR_Rotate_0 | RR_Rotate_90 | RR_Rotate_180 | RR_Rotate_270;
-	shadowSetup(pScrn);
-    } else {
-	LoaderErrorMsg(NULL, "shadow", maj, min);
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "Error loading shadow - rotation not available.\n");
+        rotate = RR_Rotate_0 | RR_Rotate_90 | RR_Rotate_180 | RR_Rotate_270;
+        shadowSetup(pScrn);
+    }
+    else {
+        LoaderErrorMsg(NULL, "shadow", maj, min);
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "Error loading shadow - rotation not available.\n");
 
-	if (pGeode->rotation != RR_Rotate_0)
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Reverting back to normal rotation.\n");
+        if (pGeode->rotation != RR_Rotate_0)
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Reverting back to normal rotation.\n");
 
-	rotate = pGeode->rotation = RR_Rotate_0;
+        rotate = pGeode->rotation = RR_Rotate_0;
     }
 
     GXRandRInit(pScrn, rotate);
@@ -1402,7 +1422,7 @@ GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
     pScrn->SaveScreen = GXSaveScreen;
 
     if (serverGeneration == 1)
-	xf86ShowUnusedOptions(pScrni->scrnIndex, pScrni->options);
+        xf86ShowUnusedOptions(pScrni->scrnIndex, pScrni->options);
 
     pGeode->starting = FALSE;
 
@@ -1418,9 +1438,9 @@ GXValidMode(int scrnIndex, DisplayModePtr pMode, Bool Verbose, int flags)
     int custom = 0;
 
     if (pGeode->Panel)
-	custom = (pMode->type & M_T_USERDEF);
+        custom = (pMode->type & M_T_USERDEF);
     else
-	custom = (pMode->type & (M_T_BUILTIN | M_T_DEFAULT));
+        custom = (pMode->type & (M_T_BUILTIN | M_T_DEFAULT));
 
     /* Use the durango lookup for !custom modes */
 
@@ -1445,16 +1465,15 @@ GXValidMode(int scrnIndex, DisplayModePtr pMode, Bool Verbose, int flags)
     }
 
     if (pMode->Flags & V_INTERLACE)
-	return MODE_NO_INTERLACE;
+        return MODE_NO_INTERLACE;
 
     if (pGeode->tryCompression)
-	p = GeodeCalculatePitchBytes(pMode->CrtcHDisplay,
-	    pScrni->bitsPerPixel);
+        p = GeodeCalculatePitchBytes(pMode->CrtcHDisplay, pScrni->bitsPerPixel);
     else
-	p = ((pMode->CrtcHDisplay + 3) & ~3) * (pScrni->bitsPerPixel >> 3);
+        p = ((pMode->CrtcHDisplay + 3) & ~3) * (pScrni->bitsPerPixel >> 3);
 
     if (p * pMode->CrtcVDisplay > pGeode->FBAvail)
-	return MODE_MEM;
+        return MODE_MEM;
 
     return MODE_OK;
 }
@@ -1506,19 +1525,19 @@ GeodePointerMoved(int index, int x, int y)
 
     switch (pGeode->rotation) {
     case RR_Rotate_0:
-	break;
+        break;
     case RR_Rotate_90:
-	newX = y;
-	newY = pScrni->pScreen->width - x - 1;
-	break;
+        newX = y;
+        newY = pScrni->pScreen->width - x - 1;
+        break;
     case RR_Rotate_180:
-	newX = pScrni->pScreen->width - x - 1;
-	newY = pScrni->pScreen->height - y - 1;
-	break;
+        newX = pScrni->pScreen->width - x - 1;
+        newY = pScrni->pScreen->height - y - 1;
+        break;
     case RR_Rotate_270:
-	newX = pScrni->pScreen->height - y - 1;
-	newY = x;
-	break;
+        newX = pScrni->pScreen->height - y - 1;
+        newY = x;
+        break;
     }
 
     (*pGeode->PointerMoved) (index, newX, newY);
@@ -1537,8 +1556,8 @@ static void
 GeodeFreeRec(ScrnInfoPtr pScrni)
 {
     if (pScrni->driverPrivate != NULL) {
-	free(pScrni->driverPrivate);
-	pScrni->driverPrivate = NULL;
+        free(pScrni->driverPrivate);
+        pScrni->driverPrivate = NULL;
     }
 }
 
@@ -1548,11 +1567,11 @@ GeodeFreeScreen(int scrnIndex, int flags)
     GeodeRec *pGeode = GEODEPTR(xf86Screens[scrnIndex]);
 
     if (pGeode == NULL)
-	return;
+        return;
 
     if (pGeode->useVGA) {
-	if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
-	    vgaHWFreeHWRec(xf86Screens[scrnIndex]);
+        if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
+            vgaHWFreeHWRec(xf86Screens[scrnIndex]);
     }
 
     GeodeFreeRec(xf86Screens[scrnIndex]);
@@ -1567,18 +1586,18 @@ GeodeCalculatePitchBytes(unsigned int width, unsigned int bpp)
     /* Less then 640 has doubling enabled */
 
     if (width < 640)
-	delta <<= 1;
+        delta <<= 1;
 
     /* Calculate the pitch (compression rquires a power of 2) */
 
     if (delta > 4096)
-	delta = 8192;
+        delta = 8192;
     else if (delta > 2048)
-	delta = 4096;
+        delta = 4096;
     else if (delta > 1024)
-	delta = 2048;
+        delta = 2048;
     else
-	delta = 1024;
+        delta = 1024;
 
     return delta;
 }
diff --git a/src/gx_randr.c b/src/gx_randr.c
index 116678d..2176019 100644
--- a/src/gx_randr.c
+++ b/src/gx_randr.c
@@ -48,16 +48,15 @@
 
 static int GXRandRGeneration;
 
-typedef struct _GXRandRInfo
-{
+typedef struct _GXRandRInfo {
     int virtualX;
     int virtualY;
     int mmWidth;
     int mmHeight;
     int maxX;
     int maxY;
-    Rotation rotation;		       /* current mode */
-    Rotation supported_rotations;      /* driver supported */
+    Rotation rotation;          /* current mode */
+    Rotation supported_rotations;       /* driver supported */
 } XF86RandRInfoRec, *XF86RandRInfoPtr;
 
 #if HAS_DEVPRIVATEKEYREC
@@ -81,10 +80,9 @@ static int
 GXRandRModeRefresh(DisplayModePtr mode)
 {
     if (mode->VRefresh)
-	return (int)(mode->VRefresh + 0.5);
+        return (int) (mode->VRefresh + 0.5);
     else
-	return (int)(mode->Clock * 1000.0 / mode->HTotal / mode->VTotal +
-	    0.5);
+        return (int) (mode->Clock * 1000.0 / mode->HTotal / mode->VTotal + 0.5);
 }
 
 static Bool
@@ -100,59 +98,59 @@ GXRandRGetInfo(ScreenPtr pScreen, Rotation * rotations)
     *rotations = pRandr->supported_rotations;
 
     if (pRandr->virtualX == -1 || pRandr->virtualY == -1) {
-	pRandr->virtualX = pScrni->virtualX;
-	pRandr->virtualY = pScrni->virtualY;
+        pRandr->virtualX = pScrni->virtualX;
+        pRandr->virtualY = pScrni->virtualY;
     }
 
     for (mode = pScrni->modes;; mode = mode->next) {
-	int refresh = GXRandRModeRefresh(mode);
-
-	if (pRandr->maxX == 0 || pRandr->maxY == 0) {
-	    if (maxX < mode->HDisplay)
-		maxX = mode->HDisplay;
-	    if (maxY < mode->VDisplay)
-		maxY = mode->VDisplay;
-	}
-
-	if (mode == pScrni->modes)
-	    refresh0 = refresh;
-
-	pSize = RRRegisterSize(pScreen,
-	    mode->HDisplay, mode->VDisplay,
-	    pRandr->mmWidth, pRandr->mmHeight);
-	if (!pSize)
-	    return FALSE;
-
-	RRRegisterRate(pScreen, pSize, refresh);
-
-	if (mode == pScrni->currentMode &&
-	    mode->HDisplay == pScrni->virtualX
-	    && mode->VDisplay == pScrni->virtualY)
-	    RRSetCurrentConfig(pScreen, pRandr->rotation, refresh, pSize);
-	if (mode->next == pScrni->modes)
-	    break;
+        int refresh = GXRandRModeRefresh(mode);
+
+        if (pRandr->maxX == 0 || pRandr->maxY == 0) {
+            if (maxX < mode->HDisplay)
+                maxX = mode->HDisplay;
+            if (maxY < mode->VDisplay)
+                maxY = mode->VDisplay;
+        }
+
+        if (mode == pScrni->modes)
+            refresh0 = refresh;
+
+        pSize = RRRegisterSize(pScreen,
+                               mode->HDisplay, mode->VDisplay,
+                               pRandr->mmWidth, pRandr->mmHeight);
+        if (!pSize)
+            return FALSE;
+
+        RRRegisterRate(pScreen, pSize, refresh);
+
+        if (mode == pScrni->currentMode &&
+            mode->HDisplay == pScrni->virtualX
+            && mode->VDisplay == pScrni->virtualY)
+            RRSetCurrentConfig(pScreen, pRandr->rotation, refresh, pSize);
+        if (mode->next == pScrni->modes)
+            break;
     }
 
     if (pRandr->maxX == 0 || pRandr->maxY == 0) {
-	pRandr->maxX = maxX;
-	pRandr->maxY = maxY;
+        pRandr->maxX = maxX;
+        pRandr->maxY = maxY;
     }
 
     if (pScrni->currentMode->HDisplay != pScrni->virtualX ||
-	pScrni->currentMode->VDisplay != pScrni->virtualY) {
-
-	mode = pScrni->modes;
-	pSize = RRRegisterSize(pScreen,
-	    pRandr->virtualX, pRandr->virtualY,
-	    pRandr->mmWidth, pRandr->mmHeight);
-	if (!pSize)
-	    return FALSE;
-
-	RRRegisterRate(pScreen, pSize, refresh0);
-	if (pScrni->virtualX == pRandr->virtualX &&
-	    pScrni->virtualY == pRandr->virtualY) {
-	    RRSetCurrentConfig(pScreen, pRandr->rotation, refresh0, pSize);
-	}
+        pScrni->currentMode->VDisplay != pScrni->virtualY) {
+
+        mode = pScrni->modes;
+        pSize = RRRegisterSize(pScreen,
+                               pRandr->virtualX, pRandr->virtualY,
+                               pRandr->mmWidth, pRandr->mmHeight);
+        if (!pSize)
+            return FALSE;
+
+        RRRegisterRate(pScreen, pSize, refresh0);
+        if (pScrni->virtualX == pRandr->virtualX &&
+            pScrni->virtualY == pRandr->virtualY) {
+            RRSetCurrentConfig(pScreen, pRandr->rotation, refresh0, pSize);
+        }
     }
 
     return TRUE;
@@ -160,7 +158,7 @@ GXRandRGetInfo(ScreenPtr pScreen, Rotation * rotations)
 
 static Bool
 GXRandRSetMode(ScreenPtr pScreen,
-    DisplayModePtr mode, Bool useVirtual, int mmWidth, int mmHeight)
+               DisplayModePtr mode, Bool useVirtual, int mmWidth, int mmHeight)
 {
     ScrnInfoPtr pScrni = XF86SCRNINFO(pScreen);
     XF86RandRInfoPtr pRandr = XF86RANDRINFO(pScreen);
@@ -169,6 +167,7 @@ GXRandRSetMode(ScreenPtr pScreen,
     int oldHeight = pScreen->height;
     int oldmmWidth = pScreen->mmWidth;
     int oldmmHeight = pScreen->mmHeight;
+
 #if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 8
     WindowPtr pRoot = WindowTable[pScreen->myNum];
 #else
@@ -176,45 +175,48 @@ GXRandRSetMode(ScreenPtr pScreen,
 #endif
     DisplayModePtr currentMode = NULL;
     Bool ret = TRUE;
+
 #if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,9,99,1,0)
     PixmapPtr pspix = NULL;
- #endif
+#endif
 
     if (pRoot)
-	(*pScrni->EnableDisableFBAccess) (pScreen->myNum, FALSE);
+        (*pScrni->EnableDisableFBAccess) (pScreen->myNum, FALSE);
 
     if (useVirtual) {
-	pScrni->virtualX = pRandr->virtualX;
-	pScrni->virtualY = pRandr->virtualY;
-    } else {
-	pScrni->virtualX = mode->HDisplay;
-	pScrni->virtualY = mode->VDisplay;
+        pScrni->virtualX = pRandr->virtualX;
+        pScrni->virtualY = pRandr->virtualY;
+    }
+    else {
+        pScrni->virtualX = mode->HDisplay;
+        pScrni->virtualY = mode->VDisplay;
     }
 
     if (pRandr->rotation & (RR_Rotate_90 | RR_Rotate_270)) {
-	pScreen->width = pScrni->virtualY;
-	pScreen->height = pScrni->virtualX;
-	pScreen->mmWidth = mmHeight;
-	pScreen->mmHeight = mmWidth;
-    } else {
-	pScreen->width = pScrni->virtualX;
-	pScreen->height = pScrni->virtualY;
-	pScreen->mmWidth = mmWidth;
-	pScreen->mmHeight = mmHeight;
+        pScreen->width = pScrni->virtualY;
+        pScreen->height = pScrni->virtualX;
+        pScreen->mmWidth = mmHeight;
+        pScreen->mmHeight = mmWidth;
+    }
+    else {
+        pScreen->width = pScrni->virtualX;
+        pScreen->height = pScrni->virtualY;
+        pScreen->mmWidth = mmWidth;
+        pScreen->mmHeight = mmHeight;
     }
 
     if (pScrni->currentMode == mode) {
-	currentMode = pScrni->currentMode;
-	pScrni->currentMode = NULL;
+        currentMode = pScrni->currentMode;
+        pScrni->currentMode = NULL;
     }
 
     if (!xf86SwitchMode(pScreen, mode)) {
-	ret = FALSE;
-	pScrni->virtualX = pScreen->width = oldWidth;
-	pScrni->virtualY = pScreen->height = oldHeight;
-	pScreen->mmWidth = oldmmWidth;
-	pScreen->mmHeight = oldmmHeight;
-	pScrni->currentMode = currentMode;
+        ret = FALSE;
+        pScrni->virtualX = pScreen->width = oldWidth;
+        pScrni->virtualY = pScreen->height = oldHeight;
+        pScreen->mmWidth = oldmmWidth;
+        pScreen->mmHeight = oldmmHeight;
+        pScrni->currentMode = currentMode;
     }
 
 #if XORG_VERSION_CURRENT < XORG_VERSION_NUMERIC(1,9,99,1,0)
@@ -225,7 +227,7 @@ GXRandRSetMode(ScreenPtr pScreen,
      */
     pspix = (*pScreen->GetScreenPixmap) (pScreen);
     if (pspix->devPrivate.ptr)
-	pScrni->pixmapPrivate = pspix->devPrivate;
+        pScrni->pixmapPrivate = pspix->devPrivate;
 #endif
 
     xf86ReconfigureLayout();
@@ -234,14 +236,14 @@ GXRandRSetMode(ScreenPtr pScreen,
     xf86SetViewport(pScreen, 0, 0);
 
     if (pRoot)
-	(*pScrni->EnableDisableFBAccess) (pScreen->myNum, TRUE);
+        (*pScrni->EnableDisableFBAccess) (pScreen->myNum, TRUE);
 
     return ret;
 }
 
 Bool
 GXRandRSetConfig(ScreenPtr pScreen, Rotation rotation,
-    int rate, RRScreenSizePtr pSize)
+                 int rate, RRScreenSizePtr pSize)
 {
     ScrnInfoPtr pScrni = XF86SCRNINFO(pScreen);
     XF86RandRInfoPtr pRandr = XF86RANDRINFO(pScreen);
@@ -255,8 +257,8 @@ GXRandRSetConfig(ScreenPtr pScreen, Rotation rotation,
     pRandr->rotation = rotation;
 
     if (pRandr->virtualX == -1 || pRandr->virtualY == -1) {
-	pRandr->virtualX = pScrni->virtualX;
-	pRandr->virtualY = pScrni->virtualY;
+        pRandr->virtualX = pScrni->virtualX;
+        pRandr->virtualY = pScrni->virtualY;
     }
 
 /* FIXME: we don't have a new video ABI yet */
@@ -267,40 +269,40 @@ GXRandRSetConfig(ScreenPtr pScreen, Rotation rotation,
 #endif
 
     for (mode = pScrni->modes;; mode = mode->next) {
-	if (pRandr->maxX == 0 || pRandr->maxY == 0) {
-	    if (maxX < mode->HDisplay)
-		maxX = mode->HDisplay;
-	    if (maxY < mode->VDisplay)
-		maxY = mode->VDisplay;
-	}
-	if (mode->HDisplay == pSize->width &&
-	    mode->VDisplay == pSize->height &&
-	    (rate == 0 || GXRandRModeRefresh(mode) == rate))
-	    break;
-	if (mode->next == pScrni->modes) {
-	    if (pSize->width == pRandr->virtualX &&
-		pSize->height == pRandr->virtualY) {
-		mode = pScrni->modes;
-		useVirtual = TRUE;
-		break;
-	    }
-	    if (pRandr->maxX == 0 || pRandr->maxY == 0) {
-		pRandr->maxX = maxX;
-		pRandr->maxY = maxY;
-	    }
-	    return FALSE;
-	}
+        if (pRandr->maxX == 0 || pRandr->maxY == 0) {
+            if (maxX < mode->HDisplay)
+                maxX = mode->HDisplay;
+            if (maxY < mode->VDisplay)
+                maxY = mode->VDisplay;
+        }
+        if (mode->HDisplay == pSize->width &&
+            mode->VDisplay == pSize->height &&
+            (rate == 0 || GXRandRModeRefresh(mode) == rate))
+            break;
+        if (mode->next == pScrni->modes) {
+            if (pSize->width == pRandr->virtualX &&
+                pSize->height == pRandr->virtualY) {
+                mode = pScrni->modes;
+                useVirtual = TRUE;
+                break;
+            }
+            if (pRandr->maxX == 0 || pRandr->maxY == 0) {
+                pRandr->maxX = maxX;
+                pRandr->maxY = maxY;
+            }
+            return FALSE;
+        }
     }
 
     if (pRandr->maxX == 0 || pRandr->maxY == 0) {
-	pRandr->maxX = maxX;
-	pRandr->maxY = maxY;
+        pRandr->maxX = maxX;
+        pRandr->maxY = maxY;
     }
 
     if (!GXRandRSetMode(pScreen, mode, useVirtual, pSize->mmWidth,
-	    pSize->mmHeight)) {
-	pRandr->rotation = oldRotation;
-	return FALSE;
+                        pSize->mmHeight)) {
+        pRandr->rotation = oldRotation;
+        return FALSE;
     }
 
 /* FIXME: we don't have a new video ABI yet */
@@ -310,17 +312,17 @@ GXRandRSetConfig(ScreenPtr pScreen, Rotation rotation,
     if (pScreen == miPointerCurrentScreen())
 #endif
     {
-	px = (px >= pScreen->width ? (pScreen->width - 1) : px);
-	py = (py >= pScreen->height ? (pScreen->height - 1) : py);
+        px = (px >= pScreen->width ? (pScreen->width - 1) : px);
+        py = (py >= pScreen->height ? (pScreen->height - 1) : py);
 
-	xf86SetViewport(pScreen, px, py);
+        xf86SetViewport(pScreen, px, py);
 
 /* FIXME: we don't have a new video ABI yet */
-	(*pScreen->SetCursorPosition) (
+        (*pScreen->SetCursorPosition) (
 #if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 3
-                                        inputInfo.pointer,
+                                          inputInfo.pointer,
 #endif
-	    pScreen, px, py, FALSE);
+                                          pScreen, px, py, FALSE);
     }
 
     return TRUE;
@@ -341,23 +343,23 @@ GXRandRInit(ScreenPtr pScreen, int rotation)
     rrScrPrivPtr rp;
 
     if (GXRandRGeneration != serverGeneration) {
-	GXRandRGeneration = serverGeneration;
+        GXRandRGeneration = serverGeneration;
     }
 #if OLD_VIDEODRV_INTERFACE
     GXRandRIndex = AllocateScreenPrivateIndex();
 #endif
 #if HAS_DIXREGISTERPRIVATEKEY
     if (!dixRegisterPrivateKey(&GXRandRIndex, PRIVATE_SCREEN, 0))
-	return FALSE;
+        return FALSE;
 #endif
 
     pRandr = calloc(1, sizeof(XF86RandRInfoRec));
     if (pRandr == NULL)
-	return FALSE;
+        return FALSE;
 
     if (!RRScreenInit(pScreen)) {
-	free(pRandr);
-	return FALSE;
+        free(pRandr);
+        return FALSE;
     }
 
     rp = rrGetScrPriv(pScreen);
diff --git a/src/gx_regacc.c b/src/gx_regacc.c
index 3156726..c7ba64a 100644
--- a/src/gx_regacc.c
+++ b/src/gx_regacc.c
@@ -66,11 +66,12 @@ unsigned long gfx_read_vid32(unsigned long offset);
 unsigned long gfx_read_vip32(unsigned long offset);
 void gfx_write_vip32(unsigned long offset, unsigned long value);
 void gfx_mono_bitmap_to_screen_blt_swp(unsigned short srcx,
-    unsigned short srcy,
-    unsigned short dstx,
-    unsigned short dsty,
-    unsigned short width,
-    unsigned short height, unsigned char *data, short pitch);
+                                       unsigned short srcy,
+                                       unsigned short dstx,
+                                       unsigned short dsty,
+                                       unsigned short width,
+                                       unsigned short height,
+                                       unsigned char *data, short pitch);
 unsigned int GetVideoMemSize(void);
 
 /* ROUTINES added accessing hardware reg */
@@ -91,6 +92,7 @@ gfx_write_reg32(unsigned long offset, unsigned long value)
 {
     WRITE_REG32(offset, value);
 }
+
 unsigned short
 gfx_read_reg16(unsigned long offset)
 {
@@ -99,6 +101,7 @@ gfx_read_reg16(unsigned long offset)
     value = READ_REG16(offset);
     return value;
 }
+
 unsigned long
 gfx_read_reg32(unsigned long offset)
 {
@@ -113,6 +116,7 @@ gfx_write_vid32(unsigned long offset, unsigned long value)
 {
     WRITE_VID32(offset, value);
 }
+
 unsigned long
 gfx_read_vid32(unsigned long offset)
 {
@@ -155,31 +159,31 @@ gfx_write_vip32(unsigned long offset, unsigned long value)
 
 void
 gfx_mono_bitmap_to_screen_blt_swp(unsigned short srcx, unsigned short srcy,
-    unsigned short dstx, unsigned short dsty,
-    unsigned short width, unsigned short height,
-    unsigned char *data, short pitch)
+                                  unsigned short dstx, unsigned short dsty,
+                                  unsigned short width, unsigned short height,
+                                  unsigned char *data, short pitch)
 {
     unsigned long dstoffset, size, bytes;
     unsigned long offset, temp_offset, temp1 = 0, temp2 = 0;
     unsigned long i, j = 0, fifo_lines, dwords_extra, bytes_extra;
     unsigned long shift = 0;
 
-    size = (((unsigned long)width) << 16) | height;
+    size = (((unsigned long) width) << 16) | height;
 
     /* CALCULATE STARTING OFFSETS */
 
-    offset = (unsigned long)srcy *pitch + ((unsigned long)srcx >> 3);
+    offset = (unsigned long) srcy *pitch + ((unsigned long) srcx >> 3);
 
-    dstoffset = (unsigned long)dsty *gu2_pitch +
-	(((unsigned long)dstx) << gu2_xshift);
+    dstoffset = (unsigned long) dsty *gu2_pitch +
+        (((unsigned long) dstx) << gu2_xshift);
 
     /* CHECK IF PATTERN ORIGINS NEED TO BE SET */
 
     if (GFXpatternFlags) {
-	/* COMBINE X AND Y PATTERN ORIGINS WITH OFFSET */
+        /* COMBINE X AND Y PATTERN ORIGINS WITH OFFSET */
 
-	dstoffset |= ((unsigned long)(dstx & 7)) << 26;
-	dstoffset |= ((unsigned long)(dsty & 7)) << 29;
+        dstoffset |= ((unsigned long) (dstx & 7)) << 26;
+        dstoffset |= ((unsigned long) (dsty & 7)) << 29;
     }
 
     bytes = ((srcx & 7) + width + 7) >> 3;
@@ -195,12 +199,11 @@ gfx_mono_bitmap_to_screen_blt_swp(unsigned short srcx, unsigned short srcy,
 
     GU2_WAIT_PENDING;
     WRITE_GP32(MGP_RASTER_MODE, gu2_rop32);
-    WRITE_GP32(MGP_SRC_OFFSET, ((unsigned long)srcx & 7) << 26);
+    WRITE_GP32(MGP_SRC_OFFSET, ((unsigned long) srcx & 7) << 26);
     WRITE_GP32(MGP_DST_OFFSET, dstoffset);
     WRITE_GP32(MGP_WID_HEIGHT, size);
     WRITE_GP32(MGP_STRIDE, gu2_pitch);
-    WRITE_GP16(MGP_BLT_MODE,
-	gu2_blt_mode | MGP_BM_SRC_HOST | MGP_BM_SRC_MONO);
+    WRITE_GP16(MGP_BLT_MODE, gu2_blt_mode | MGP_BM_SRC_HOST | MGP_BM_SRC_MONO);
 
     /* WAIT FOR BLT TO BE LATCHED */
 
@@ -209,34 +212,34 @@ gfx_mono_bitmap_to_screen_blt_swp(unsigned short srcx, unsigned short srcy,
     /* WRITE ALL OF THE DATA TO THE HOST SOURCE REGISTER */
 
     while (height--) {
-	temp_offset = offset;
+        temp_offset = offset;
 
-	/* WRITE ALL FULL FIFO LINES */
+        /* WRITE ALL FULL FIFO LINES */
 
-	for (i = 0; i < fifo_lines; i++) {
-	    GU2_WAIT_HALF_EMPTY;
-	    WRITE_GPREG_STRING32_SWP(MGP_HST_SOURCE, 8, j, data, temp_offset,
-		temp1);
-	    temp_offset += 32;
-	}
+        for (i = 0; i < fifo_lines; i++) {
+            GU2_WAIT_HALF_EMPTY;
+            WRITE_GPREG_STRING32_SWP(MGP_HST_SOURCE, 8, j, data, temp_offset,
+                                     temp1);
+            temp_offset += 32;
+        }
 
-	/* WRITE ALL FULL DWORDS */
+        /* WRITE ALL FULL DWORDS */
 
-	GU2_WAIT_HALF_EMPTY;
-	if (dwords_extra) {
-	    WRITE_GPREG_STRING32_SWP(MGP_HST_SOURCE, dwords_extra, i, data,
-		temp_offset, temp1);
-	    temp_offset += (dwords_extra << 2);
-	}
+        GU2_WAIT_HALF_EMPTY;
+        if (dwords_extra) {
+            WRITE_GPREG_STRING32_SWP(MGP_HST_SOURCE, dwords_extra, i, data,
+                                     temp_offset, temp1);
+            temp_offset += (dwords_extra << 2);
+        }
 
-	/* WRITE REMAINING BYTES */
+        /* WRITE REMAINING BYTES */
 
-	shift = 0;
-	if (bytes_extra)
-	    WRITE_GPREG_STRING8(MGP_HST_SOURCE, bytes_extra, shift, i, data,
-		temp_offset, temp1, temp2);
+        shift = 0;
+        if (bytes_extra)
+            WRITE_GPREG_STRING8(MGP_HST_SOURCE, bytes_extra, shift, i, data,
+                                temp_offset, temp1, temp2);
 
-	offset += pitch;
+        offset += pitch;
     }
 }
 
@@ -260,37 +263,37 @@ GetVideoMemSize(void)
     /* Calculate total memory size for GXm. */
 
     for (i = 0; i < 2; i++) {
-	if (((mcBankCfg >> dimmShift) & 0x7) != 0x7) {
-	    switch ((mcBankCfg >> (dimmShift + 4)) & 0x7) {
-	    case 0:
-		totalMem += 0x400000;
-		break;
-	    case 1:
-		totalMem += 0x800000;
-		break;
-	    case 2:
-		totalMem += 0x1000000;
-		break;
-	    case 3:
-		totalMem += 0x2000000;
-		break;
-	    case 4:
-		totalMem += 0x4000000;
-		break;
-	    case 5:
-		totalMem += 0x8000000;
-		break;
-	    case 6:
-		totalMem += 0x10000000;
-		break;
-	    case 7:
-		totalMem += 0x20000000;
-		break;
-	    default:
-		break;
-	    }
-	}
-	dimmShift += 16;
+        if (((mcBankCfg >> dimmShift) & 0x7) != 0x7) {
+            switch ((mcBankCfg >> (dimmShift + 4)) & 0x7) {
+            case 0:
+                totalMem += 0x400000;
+                break;
+            case 1:
+                totalMem += 0x800000;
+                break;
+            case 2:
+                totalMem += 0x1000000;
+                break;
+            case 3:
+                totalMem += 0x2000000;
+                break;
+            case 4:
+                totalMem += 0x4000000;
+                break;
+            case 5:
+                totalMem += 0x8000000;
+                break;
+            case 6:
+                totalMem += 0x10000000;
+                break;
+            case 7:
+                totalMem += 0x20000000;
+                break;
+            default:
+                break;
+            }
+        }
+        dimmShift += 16;
     }
 
     /* Calculate graphics memory base address */
diff --git a/src/gx_rotate.c b/src/gx_rotate.c
index e473a34..9eb39e7 100644
--- a/src/gx_rotate.c
+++ b/src/gx_rotate.c
@@ -33,7 +33,7 @@
 
 static void *
 GXWindowLinear(ScreenPtr pScreen, CARD32 row, CARD32 offset, int mode,
-    CARD32 * size, void *closure)
+               CARD32 *size, void *closure)
 {
     ScrnInfoPtr pScrni = xf86Screens[pScreen->myNum];
     GeodeRec *pGeode = GEODEPTR(pScrni);
@@ -41,7 +41,7 @@ GXWindowLinear(ScreenPtr pScreen, CARD32 row, CARD32 offset, int mode,
     *size = pGeode->displayPitch;
 
     return (pGeode->FBBase + pGeode->displayOffset) +
-	row * pGeode->displayPitch + offset;
+        row * pGeode->displayPitch + offset;
 }
 
 static void
@@ -54,35 +54,35 @@ GXUpdate(ScreenPtr pScreen, shadowBufPtr pBuf)
     switch (rotate) {
     case RR_Rotate_90:
 
-	if (pScrni->bitsPerPixel == 8)
-	    shadowUpdateRotate8_90(pScreen, pBuf);
-	else if (pScrni->bitsPerPixel == 16)
-	    shadowUpdateRotate16_90(pScreen, pBuf);
-	else
-	    shadowUpdateRotate32_90(pScreen, pBuf);
+        if (pScrni->bitsPerPixel == 8)
+            shadowUpdateRotate8_90(pScreen, pBuf);
+        else if (pScrni->bitsPerPixel == 16)
+            shadowUpdateRotate16_90(pScreen, pBuf);
+        else
+            shadowUpdateRotate32_90(pScreen, pBuf);
 
-	break;
+        break;
 
     case RR_Rotate_180:
 
-	if (pScrni->bitsPerPixel == 8)
-	    shadowUpdateRotate8_180(pScreen, pBuf);
-	else if (pScrni->bitsPerPixel == 16)
-	    shadowUpdateRotate16_180(pScreen, pBuf);
-	else
-	    shadowUpdateRotate32_180(pScreen, pBuf);
+        if (pScrni->bitsPerPixel == 8)
+            shadowUpdateRotate8_180(pScreen, pBuf);
+        else if (pScrni->bitsPerPixel == 16)
+            shadowUpdateRotate16_180(pScreen, pBuf);
+        else
+            shadowUpdateRotate32_180(pScreen, pBuf);
 
-	break;
+        break;
 
     case RR_Rotate_270:
-	if (pScrni->bitsPerPixel == 8)
-	    shadowUpdateRotate8_270(pScreen, pBuf);
-	else if (pScrni->bitsPerPixel == 16)
-	    shadowUpdateRotate16_270(pScreen, pBuf);
-	else
-	    shadowUpdateRotate32_270(pScreen, pBuf);
-
-	break;
+        if (pScrni->bitsPerPixel == 8)
+            shadowUpdateRotate8_270(pScreen, pBuf);
+        else if (pScrni->bitsPerPixel == 16)
+            shadowUpdateRotate16_270(pScreen, pBuf);
+        else
+            shadowUpdateRotate32_270(pScreen, pBuf);
+
+        break;
     }
 }
 
@@ -101,88 +101,93 @@ GXRotate(ScrnInfoPtr pScrni, DisplayModePtr mode)
     /* Leave if we have nothing to do */
 
     if (pGeode->rotation == curr && pGeode->curMode == mode) {
-	return TRUE;
+        return TRUE;
     }
 
     shadowRemove(pScrni->pScreen, NULL);
 
     switch (pGeode->rotation) {
     case RR_Rotate_0:
-	ErrorF("Rotate to 0 degrees\n");
-	pScrni->displayWidth = pGeode->displayWidth;
-	pGeode->Pitch = pGeode->displayPitch;
-	break;
+        ErrorF("Rotate to 0 degrees\n");
+        pScrni->displayWidth = pGeode->displayWidth;
+        pGeode->Pitch = pGeode->displayPitch;
+        break;
 
     case RR_Rotate_90:
-	ErrorF("Rotate to 90 degrees\n");
-	pScrni->displayWidth = pScrni->pScreen->width;
-	break;
+        ErrorF("Rotate to 90 degrees\n");
+        pScrni->displayWidth = pScrni->pScreen->width;
+        break;
 
     case RR_Rotate_180:
-	ErrorF("Rotate to 180 degrees\n");
-	pScrni->displayWidth = pGeode->displayWidth;
-	break;
+        ErrorF("Rotate to 180 degrees\n");
+        pScrni->displayWidth = pGeode->displayWidth;
+        break;
 
     case RR_Rotate_270:
-	ErrorF("Rotate to 270 degrees\n");
-	pScrni->displayWidth = pScrni->pScreen->width;
-	break;
+        ErrorF("Rotate to 270 degrees\n");
+        pScrni->displayWidth = pScrni->pScreen->width;
+        break;
     }
 
     if (pGeode->rotation != RR_Rotate_0) {
 
-	ret =
-	    shadowAdd(pScrni->pScreen, pPixmap, GXUpdate, GXWindowLinear,
-	    pGeode->rotation, NULL);
+        ret =
+            shadowAdd(pScrni->pScreen, pPixmap, GXUpdate, GXWindowLinear,
+                      pGeode->rotation, NULL);
 
-	if (!ret) {
-	    ErrorF("shadowAdd failed\n");
-	    goto error;
-	}
+        if (!ret) {
+            ErrorF("shadowAdd failed\n");
+            goto error;
+        }
     }
 
     if (pGeode->rotation == RR_Rotate_0)
-	pScrni->fbOffset = pGeode->displayOffset;
+        pScrni->fbOffset = pGeode->displayOffset;
     else
-	pScrni->fbOffset = pGeode->shadowOffset;
+        pScrni->fbOffset = pGeode->shadowOffset;
 
     pScrni->pScreen->ModifyPixmapHeader(pPixmap,
-	pScrni->pScreen->width,
-	pScrni->pScreen->height,
-	pScrni->pScreen->rootDepth,
-	pScrni->bitsPerPixel,
-	PixmapBytePad(pScrni->displayWidth, pScrni->pScreen->rootDepth),
-	(pointer) (pGeode->FBBase + pScrni->fbOffset));
+                                        pScrni->pScreen->width,
+                                        pScrni->pScreen->height,
+                                        pScrni->pScreen->rootDepth,
+                                        pScrni->bitsPerPixel,
+                                        PixmapBytePad(pScrni->displayWidth,
+                                                      pScrni->pScreen->
+                                                      rootDepth),
+                                        (pointer) (pGeode->FBBase +
+                                                   pScrni->fbOffset));
 
     /* Don't use XAA pixmap cache or offscreen pixmaps when rotated */
 
     if (pGeode->AccelInfoRec) {
-	if (pGeode->rotation == RR_Rotate_0) {
-	    pGeode->AccelInfoRec->Flags =
-		LINEAR_FRAMEBUFFER | OFFSCREEN_PIXMAPS | PIXMAP_CACHE;
-	    pGeode->AccelInfoRec->UsingPixmapCache = TRUE;
-	    pGeode->AccelInfoRec->maxOffPixWidth = 0;
-	    pGeode->AccelInfoRec->maxOffPixHeight = 0;
-	} else {
-	    pGeode->AccelInfoRec->Flags = LINEAR_FRAMEBUFFER;
-	    pGeode->AccelInfoRec->UsingPixmapCache = FALSE;
-	    pGeode->AccelInfoRec->maxOffPixWidth = 1;
-	    pGeode->AccelInfoRec->maxOffPixHeight = 1;
-	}
+        if (pGeode->rotation == RR_Rotate_0) {
+            pGeode->AccelInfoRec->Flags =
+                LINEAR_FRAMEBUFFER | OFFSCREEN_PIXMAPS | PIXMAP_CACHE;
+            pGeode->AccelInfoRec->UsingPixmapCache = TRUE;
+            pGeode->AccelInfoRec->maxOffPixWidth = 0;
+            pGeode->AccelInfoRec->maxOffPixHeight = 0;
+        }
+        else {
+            pGeode->AccelInfoRec->Flags = LINEAR_FRAMEBUFFER;
+            pGeode->AccelInfoRec->UsingPixmapCache = FALSE;
+            pGeode->AccelInfoRec->maxOffPixWidth = 1;
+            pGeode->AccelInfoRec->maxOffPixHeight = 1;
+        }
     }
 
     return TRUE;
 
-  error:
+ error:
     /* Restore the old rotation */
     pScrni->displayWidth = curdw;
 
     if (curr & (RR_Rotate_0 | RR_Rotate_180)) {
-	pScrni->pScreen->width = pScrni->virtualX;
-	pScrni->pScreen->height = pScrni->virtualY;
-    } else {
-	pScrni->pScreen->width = pScrni->virtualY;
-	pScrni->pScreen->height = pScrni->virtualX;
+        pScrni->pScreen->width = pScrni->virtualX;
+        pScrni->pScreen->height = pScrni->virtualY;
+    }
+    else {
+        pScrni->pScreen->width = pScrni->virtualY;
+        pScrni->pScreen->height = pScrni->virtualX;
     }
 
     pGeode->rotation = curr;
diff --git a/src/gx_vga.c b/src/gx_vga.c
index e5d6427..48d08d5 100644
--- a/src/gx_vga.c
+++ b/src/gx_vga.c
@@ -57,7 +57,7 @@ static unsigned int palette[256];
 static unsigned int ATTRregs[32];
 static unsigned char *font_data = NULL;
 
-#define VGA_BLOCK 0x40000	       /* 256 k */
+#define VGA_BLOCK 0x40000       /* 256 k */
 
 void gu2_vga_extcrtc(char offset, int reset);
 int gu2_get_vga_active(void);
@@ -78,7 +78,7 @@ gu2_get_vga_active(void)
     int data = gfx_read_reg32(MDC_GENERAL_CFG);
 
     if (data & MDC_GCFG_VGAE)
-	return 1;
+        return 1;
 
     return 0;
 }
@@ -87,17 +87,18 @@ void
 gu2_vga_font_data(int flag)
 {
     if (flag == 0) {
-	if (font_data == NULL) {
-	    font_data = malloc(VGA_BLOCK);
-	}
-
-	DEBUGMSG(1, (0, X_NONE, "Saving VGA Data\n"));
-	memcpy(font_data, gfx_virt_fbptr, VGA_BLOCK);
-    } else if (font_data) {
-	DEBUGMSG(1, (0, X_NONE, "Restore VGA Data\n"));
-	memcpy(gfx_virt_fbptr, font_data, VGA_BLOCK);
-	free(font_data);
-	font_data = NULL;
+        if (font_data == NULL) {
+            font_data = malloc(VGA_BLOCK);
+        }
+
+        DEBUGMSG(1, (0, X_NONE, "Saving VGA Data\n"));
+        memcpy(font_data, gfx_virt_fbptr, VGA_BLOCK);
+    }
+    else if (font_data) {
+        DEBUGMSG(1, (0, X_NONE, "Restore VGA Data\n"));
+        memcpy(gfx_virt_fbptr, font_data, VGA_BLOCK);
+        free(font_data);
+        font_data = NULL;
     }
 }
 
@@ -107,9 +108,9 @@ gu2_set_vga(int reset)
     int data = gfx_read_reg32(MDC_GENERAL_CFG);
 
     if (reset)
-	data |= MDC_GCFG_VGAE;
+        data |= MDC_GCFG_VGAE;
     else
-	data &= ~MDC_GCFG_VGAE;
+        data &= ~MDC_GCFG_VGAE;
 
     gfx_write_reg32(MDC_GENERAL_CFG, data);
 }
@@ -135,9 +136,9 @@ gu2_vga_attr_ctrl(int reset)
     int tmp;
 
     tmp = gfx_inb(0x3DA);
-    gfx_outb(0x3C0, (unsigned char)(reset ? 0x00 : 0x20));
+    gfx_outb(0x3C0, (unsigned char) (reset ? 0x00 : 0x20));
     if (reset)
-	tmp = gfx_inb(0x3DA);
+        tmp = gfx_inb(0x3DA);
 
     return (GFX_STATUS_OK);
 }
@@ -194,7 +195,7 @@ int
 gu2_vga_seq_reset(int reset)
 {
     gfx_outb(0x3C4, 0);
-    gfx_outb(0x3C5, (unsigned char)(reset ? 0x00 : 0x03));
+    gfx_outb(0x3C5, (unsigned char) (reset ? 0x00 : 0x03));
     return (GFX_STATUS_OK);
 }
 
@@ -218,65 +219,65 @@ gu2_vga_save(gfx_vga_struct * vga, int flags)
     /* CHECK MISCELLANEOUS OUTPUT FLAG */
 
     if (flags & GU2_VGA_FLAG_MISC_OUTPUT) {
-	/* SAVE MISCCELLANEOUS OUTPUT REGISTER */
-	vga->miscOutput = gfx_inb(0x3CC);
+        /* SAVE MISCCELLANEOUS OUTPUT REGISTER */
+        vga->miscOutput = gfx_inb(0x3CC);
     }
 
     /* CHECK SEQ */
 
     if (flags & GU2_VGA_FLAG_SEQ) {
-	/* SAVE STANDARD CRTC REGISTERS */
-	for (i = 1; i < GU2_SEQ_REGS; i++) {
-	    gfx_outb(0x3C4, (unsigned char)i);
-	    SEQregs[i] = gfx_inb(0x3C5);
-	}
+        /* SAVE STANDARD CRTC REGISTERS */
+        for (i = 1; i < GU2_SEQ_REGS; i++) {
+            gfx_outb(0x3C4, (unsigned char) i);
+            SEQregs[i] = gfx_inb(0x3C5);
+        }
     }
 
     /* CHECK STANDARD CRTC FLAG */
 
     if (flags & GU2_VGA_FLAG_STD_CRTC) {
-	/* SAVE STANDARD CRTC REGISTERS */
-	for (i = 0; i < GU2_STD_CRTC_REGS; i++) {
-	    gfx_outb(crtcindex, (unsigned char)i);
-	    vga->stdCRTCregs[i] = gfx_inb(crtcdata);
-	}
+        /* SAVE STANDARD CRTC REGISTERS */
+        for (i = 0; i < GU2_STD_CRTC_REGS; i++) {
+            gfx_outb(crtcindex, (unsigned char) i);
+            vga->stdCRTCregs[i] = gfx_inb(crtcdata);
+        }
     }
 
     /* CHECK GDC */
 
     if (flags & GU2_VGA_FLAG_GDC) {
-	/* SAVE STANDARD CRTC REGISTERS */
-	for (i = 0; i < GU2_GDC_REGS; i++) {
-	    gfx_outb(0x3CE, (unsigned char)i);
-	    GDCregs[i] = gfx_inb(0x3CF);
-	}
+        /* SAVE STANDARD CRTC REGISTERS */
+        for (i = 0; i < GU2_GDC_REGS; i++) {
+            gfx_outb(0x3CE, (unsigned char) i);
+            GDCregs[i] = gfx_inb(0x3CF);
+        }
     }
 
     /* CHECK EXTENDED CRTC FLAG */
 
     if (flags & GU2_VGA_FLAG_EXT_CRTC) {
-	/* SAVE EXTENDED CRTC REGISTERS */
-	for (i = 0; i < GU2_EXT_CRTC_REGS; i++) {
-	    gfx_outb(crtcindex, (unsigned char)(0x40 + i));
-	    vga->extCRTCregs[i] = gfx_inb(crtcdata);
-	}
+        /* SAVE EXTENDED CRTC REGISTERS */
+        for (i = 0; i < GU2_EXT_CRTC_REGS; i++) {
+            gfx_outb(crtcindex, (unsigned char) (0x40 + i));
+            vga->extCRTCregs[i] = gfx_inb(crtcdata);
+        }
     }
 
     if (flags & GU2_VGA_FLAG_PALETTE) {
-	/* SAVE PALETTE DATA */
-	for (i = 0; i < 0x100; i++) {
-	    gfx_outb(0x3C7, i);
-	    palette[i] = gfx_inb(0x3C9);
-	}
+        /* SAVE PALETTE DATA */
+        for (i = 0; i < 0x100; i++) {
+            gfx_outb(0x3C7, i);
+            palette[i] = gfx_inb(0x3C9);
+        }
     }
 
     if (flags & GU2_VGA_FLAG_ATTR) {
-	/* SAVE Attribute  DATA */
-	for (i = 0; i < 21; i++) {
-	    gfx_inb(0x3DA);
-	    gfx_outb(0x3C0, i);
-	    ATTRregs[i] = gfx_inb(0x3C1);
-	}
+        /* SAVE Attribute  DATA */
+        for (i = 0; i < 21; i++) {
+            gfx_inb(0x3DA);
+            gfx_outb(0x3C0, i);
+            ATTRregs[i] = gfx_inb(0x3C1);
+        }
     }
 
     /* save the VGA data */
@@ -304,8 +305,8 @@ gu2_vga_clear_extended(void)
     gfx_outb(crtcdata, 0x57);
     gfx_outb(crtcdata, 0x4C);
     for (i = 0x41; i <= 0x4F; i++) {
-	gfx_outb(crtcindex, (unsigned char)i);
-	gfx_outb(crtcdata, 0);
+        gfx_outb(crtcindex, (unsigned char) i);
+        gfx_outb(crtcdata, 0);
     }
 
     gfx_outb(crtcindex, 0x30);
@@ -352,100 +353,100 @@ gu2_vga_restore(gfx_vga_struct * vga, int flags)
     /* CHECK MISCELLANEOUS OUTPUT FLAG */
 
     if (flags & GU2_VGA_FLAG_MISC_OUTPUT) {
-	/* RESTORE MISCELLANEOUS OUTPUT REGISTER VALUE */
-	gfx_outb(0x3C2, vga->miscOutput);
+        /* RESTORE MISCELLANEOUS OUTPUT REGISTER VALUE */
+        gfx_outb(0x3C2, vga->miscOutput);
     }
 
     /* CHECK SEQ */
 
     if (flags & GU2_VGA_FLAG_SEQ) {
-	/* RESTORE STANDARD CRTC REGISTERS */
-	for (i = 1; i < GU2_SEQ_REGS; i++) {
-	    gfx_outb(0x3C4, (unsigned char)i);
-	    gfx_outb(0x3C5, SEQregs[i]);
-	}
+        /* RESTORE STANDARD CRTC REGISTERS */
+        for (i = 1; i < GU2_SEQ_REGS; i++) {
+            gfx_outb(0x3C4, (unsigned char) i);
+            gfx_outb(0x3C5, SEQregs[i]);
+        }
     }
 
     /* CHECK STANDARD CRTC FLAG */
 
     if (flags & GU2_VGA_FLAG_STD_CRTC) {
-	/* UNLOCK STANDARD CRTC REGISTERS */
-	gfx_outb(crtcindex, 0x11);
-	gfx_outb(crtcdata, 0);
+        /* UNLOCK STANDARD CRTC REGISTERS */
+        gfx_outb(crtcindex, 0x11);
+        gfx_outb(crtcdata, 0);
 
-	/* RESTORE STANDARD CRTC REGISTERS */
+        /* RESTORE STANDARD CRTC REGISTERS */
 
-	for (i = 0; i < GU2_STD_CRTC_REGS; i++) {
-	    gfx_outb(crtcindex, (unsigned char)i);
-	    gfx_outb(crtcdata, vga->stdCRTCregs[i]);
-	}
+        for (i = 0; i < GU2_STD_CRTC_REGS; i++) {
+            gfx_outb(crtcindex, (unsigned char) i);
+            gfx_outb(crtcdata, vga->stdCRTCregs[i]);
+        }
     }
 
     /* CHECK GDC */
 
     if (flags & GU2_VGA_FLAG_GDC) {
-	/* SAVE STANDARD CRTC REGISTERS */
-	for (i = 0; i < GU2_GDC_REGS; i++) {
-	    gfx_outb(0x3CE, (unsigned char)i);
-	    gfx_outb(0x3CF, GDCregs[i]);
-	}
+        /* SAVE STANDARD CRTC REGISTERS */
+        for (i = 0; i < GU2_GDC_REGS; i++) {
+            gfx_outb(0x3CE, (unsigned char) i);
+            gfx_outb(0x3CF, GDCregs[i]);
+        }
     }
 
     /* CHECK EXTENDED CRTC FLAG */
 
     if (flags & GU2_VGA_FLAG_EXT_CRTC) {
-	/* UNLOCK EXTENDED CRTC REGISTERS */
-	gfx_outb(crtcindex, 0x30);
-	gfx_outb(crtcdata, 0x57);
-	gfx_outb(crtcdata, 0x4C);
+        /* UNLOCK EXTENDED CRTC REGISTERS */
+        gfx_outb(crtcindex, 0x30);
+        gfx_outb(crtcdata, 0x57);
+        gfx_outb(crtcdata, 0x4C);
 
-	/* RESTORE EXTENDED CRTC REGISTERS */
+        /* RESTORE EXTENDED CRTC REGISTERS */
 
-	for (i = 1; i < GU2_EXT_CRTC_REGS; i++) {
-	    gfx_outb(crtcindex, (unsigned char)(0x40 + i));
-	    gfx_outb(crtcdata, vga->extCRTCregs[i]);
-	}
+        for (i = 1; i < GU2_EXT_CRTC_REGS; i++) {
+            gfx_outb(crtcindex, (unsigned char) (0x40 + i));
+            gfx_outb(crtcdata, vga->extCRTCregs[i]);
+        }
 
-	/* LOCK EXTENDED CRTC REGISTERS */
+        /* LOCK EXTENDED CRTC REGISTERS */
 
-	gfx_outb(crtcindex, 0x30);
-	gfx_outb(crtcdata, 0x00);
+        gfx_outb(crtcindex, 0x30);
+        gfx_outb(crtcdata, 0x00);
 
-	/* CHECK IF DIRECT FRAME BUFFER MODE (VESA MODE) */
+        /* CHECK IF DIRECT FRAME BUFFER MODE (VESA MODE) */
 
-	if (vga->extCRTCregs[0x03] & 1) {
-	    /* SET BORDER COLOR TO BLACK */
-	    /* This really should be another thing saved/restored, but */
-	    /* Durango currently doesn't do the attr controller registers. */
+        if (vga->extCRTCregs[0x03] & 1) {
+            /* SET BORDER COLOR TO BLACK */
+            /* This really should be another thing saved/restored, but */
+            /* Durango currently doesn't do the attr controller registers. */
 
-	    gfx_inb(0x3BA);	       /* Reset flip-flop */
-	    gfx_inb(0x3DA);
-	    gfx_outb(0x3C0, 0x11);
-	    gfx_outb(0x3C0, 0x00);
-	}
+            gfx_inb(0x3BA);     /* Reset flip-flop */
+            gfx_inb(0x3DA);
+            gfx_outb(0x3C0, 0x11);
+            gfx_outb(0x3C0, 0x00);
+        }
     }
 
     if (flags & GU2_VGA_FLAG_PALETTE) {
-	/* RESTORE PALETTE DATA */
-	for (i = 0; i < 0x100; i++) {
-	    gfx_outb(0x3C8, i);
-	    gfx_outb(0x3C9, palette[i]);
-	}
+        /* RESTORE PALETTE DATA */
+        for (i = 0; i < 0x100; i++) {
+            gfx_outb(0x3C8, i);
+            gfx_outb(0x3C9, palette[i]);
+        }
     }
 
     if (flags & GU2_VGA_FLAG_ATTR) {
-	/* RESTORE Attribute  DATA */
-	for (i = 0; i < 21; i++) {
-	    gfx_inb(0x3DA);
-	    gfx_outb(0x3C0, i);
-	    gfx_outb(0x3C0, ATTRregs[i]);
-	}
-	/* SAVE Attribute  DATA */
-
-	for (i = 0; i < 21; i++) {
-	    gfx_inb(0x3DA);
-	    gfx_outb(0x3C0, i);
-	}
+        /* RESTORE Attribute  DATA */
+        for (i = 0; i < 21; i++) {
+            gfx_inb(0x3DA);
+            gfx_outb(0x3C0, i);
+            gfx_outb(0x3C0, ATTRregs[i]);
+        }
+        /* SAVE Attribute  DATA */
+
+        for (i = 0; i < 21; i++) {
+            gfx_inb(0x3DA);
+            gfx_outb(0x3C0, i);
+        }
     }
 
     /* restore the VGA data */
diff --git a/src/gx_video.c b/src/gx_video.c
index f475bb6..fef7764 100644
--- a/src/gx_video.c
+++ b/src/gx_video.c
@@ -60,7 +60,7 @@
 #include "fourcc.h"
 #include "geode_fourcc.h"
 
-#define OFF_DELAY 		200    /* milliseconds */
+#define OFF_DELAY 		200     /* milliseconds */
 #define FREE_DELAY 		60000
 
 #define OFF_TIMER 		0x01
@@ -97,15 +97,16 @@ static void GXStopVideo(ScrnInfoPtr, pointer, Bool);
 static int GXSetPortAttribute(ScrnInfoPtr, Atom, INT32, pointer);
 static int GXGetPortAttribute(ScrnInfoPtr, Atom, INT32 *, pointer);
 static void GXQueryBestSize(ScrnInfoPtr, Bool,
-    short, short, short, short, unsigned int *, unsigned int *, pointer);
+                            short, short, short, short, unsigned int *,
+                            unsigned int *, pointer);
 static int GXPutImage(ScrnInfoPtr, short, short, short, short, short, short,
-    short, short, int, unsigned char *, short, short, Bool,
-    RegionPtr, pointer, DrawablePtr pDraw);
+                      short, short, int, unsigned char *, short, short, Bool,
+                      RegionPtr, pointer, DrawablePtr pDraw);
 
 static void GXBlockHandler(int, pointer, pointer, pointer);
 void GXSetVideoPosition(int x, int y, int width, int height,
-    short src_w, short src_h, short drw_w,
-    short drw_h, int id, int offset, ScrnInfoPtr pScrni);
+                        short src_w, short src_h, short drw_w,
+                        short drw_h, int id, int offset, ScrnInfoPtr pScrni);
 
 extern void GXAccelSync(ScrnInfoPtr pScrni);
 
@@ -118,9 +119,9 @@ static int lutflag = 0;
 
 static Atom xvColorKey, xvColorKeyMode, xvFilter
 #if DBUF
-   , xvDoubleBuffer
+, xvDoubleBuffer
 #endif
-   ;
+;
 
 #define PALETTE_ADDRESS   0x038
 #define PALETTE_DATA      0x040
@@ -136,7 +137,7 @@ get_gamma_ram(unsigned long *lut)
     gfx_write_vid32(PALETTE_ADDRESS, 0);
 
     for (i = 0; i < 256; i++)
-	lut[i] = gfx_read_vid32(PALETTE_DATA);
+        lut[i] = gfx_read_vid32(PALETTE_DATA);
 }
 
 /*----------------------------------------------------------------------------
@@ -166,50 +167,50 @@ GXInitVideo(ScreenPtr pScrn)
     pGeode = GEODEPTR(pScrni);
 
     if (!pGeode->NoAccel) {
-	XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
-	XF86VideoAdaptorPtr newAdaptor = NULL;
-
-	int num_adaptors;
-
-	newAdaptor = GXSetupImageVideo(pScrn);
-	GXInitOffscreenImages(pScrn);
-
-	num_adaptors = xf86XVListGenericAdaptors(pScrni, &adaptors);
-
-	if (newAdaptor) {
-	    if (!num_adaptors) {
-		num_adaptors = 1;
-		adaptors = &newAdaptor;
-	    } else {
-		newAdaptors =	       /* need to free this someplace */
-		    malloc((num_adaptors +
-			1) * sizeof(XF86VideoAdaptorPtr *));
-		if (newAdaptors) {
-		    memcpy(newAdaptors, adaptors, num_adaptors *
-			sizeof(XF86VideoAdaptorPtr));
-		    newAdaptors[num_adaptors] = newAdaptor;
-		    adaptors = newAdaptors;
-		    num_adaptors++;
-		}
-	    }
-	}
-
-	if (num_adaptors)
-	    xf86XVScreenInit(pScrn, adaptors, num_adaptors);
-
-	if (newAdaptors)
-	    free(newAdaptors);
+        XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
+        XF86VideoAdaptorPtr newAdaptor = NULL;
+
+        int num_adaptors;
+
+        newAdaptor = GXSetupImageVideo(pScrn);
+        GXInitOffscreenImages(pScrn);
+
+        num_adaptors = xf86XVListGenericAdaptors(pScrni, &adaptors);
+
+        if (newAdaptor) {
+            if (!num_adaptors) {
+                num_adaptors = 1;
+                adaptors = &newAdaptor;
+            }
+            else {
+                newAdaptors =   /* need to free this someplace */
+                    malloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr *));
+                if (newAdaptors) {
+                    memcpy(newAdaptors, adaptors, num_adaptors *
+                           sizeof(XF86VideoAdaptorPtr));
+                    newAdaptors[num_adaptors] = newAdaptor;
+                    adaptors = newAdaptors;
+                    num_adaptors++;
+                }
+            }
+        }
+
+        if (num_adaptors)
+            xf86XVScreenInit(pScrn, adaptors, num_adaptors);
+
+        if (newAdaptors)
+            free(newAdaptors);
     }
 }
 
 /* client libraries expect an encoding */
 static XF86VideoEncodingRec DummyEncoding[1] = {
     {
-	    0,
-	    "XV_IMAGE",
-	    1024, 1024,
-	    {1, 1}
-	}
+     0,
+     "XV_IMAGE",
+     1024, 1024,
+     {1, 1}
+     }
 };
 
 #define NUM_FORMATS 4
@@ -246,8 +247,7 @@ static XF86ImageRec Images[NUM_IMAGES] = {
     XVIMAGE_RGB565
 };
 
-typedef struct
-{
+typedef struct {
     void *area;
     int offset;
     RegionRec clip;
@@ -291,35 +291,35 @@ GXSetColorkey(ScrnInfoPtr pScrni, GeodePortPrivRec * pPriv)
 
     switch (pScrni->depth) {
     case 8:
-	GFX(get_display_palette_entry(pPriv->colorKey & 0xFF, &key));
-	red = ((key >> 16) & 0xFF);
-	green = ((key >> 8) & 0xFF);
-	blue = (key & 0xFF);
-	break;
+        GFX(get_display_palette_entry(pPriv->colorKey & 0xFF, &key));
+        red = ((key >> 16) & 0xFF);
+        green = ((key >> 8) & 0xFF);
+        blue = (key & 0xFF);
+        break;
     case 16:
-	red = (pPriv->colorKey & pScrni->mask.red) >>
-	    pScrni->offset.red << (8 - pScrni->weight.red);
-	green = (pPriv->colorKey & pScrni->mask.green) >>
-	    pScrni->offset.green << (8 - pScrni->weight.green);
-	blue = (pPriv->colorKey & pScrni->mask.blue) >>
-	    pScrni->offset.blue << (8 - pScrni->weight.blue);
-	break;
+        red = (pPriv->colorKey & pScrni->mask.red) >>
+            pScrni->offset.red << (8 - pScrni->weight.red);
+        green = (pPriv->colorKey & pScrni->mask.green) >>
+            pScrni->offset.green << (8 - pScrni->weight.green);
+        blue = (pPriv->colorKey & pScrni->mask.blue) >>
+            pScrni->offset.blue << (8 - pScrni->weight.blue);
+        break;
     default:
-	/* for > 16 bpp we send in the mask in xf86SetWeight. This
-	 * function is providing the offset by 1 more. So we take
-	 * this as a special case and subtract 1 for > 16
-	 */
-	red = (pPriv->colorKey & pScrni->mask.red) >>
-	    (pScrni->offset.red - 1) << (8 - pScrni->weight.red);
-	green = (pPriv->colorKey & pScrni->mask.green) >>
-	    (pScrni->offset.green - 1) << (8 - pScrni->weight.green);
-	blue = (pPriv->colorKey & pScrni->mask.blue) >>
-	    (pScrni->offset.blue - 1) << (8 - pScrni->weight.blue);
-	break;
+        /* for > 16 bpp we send in the mask in xf86SetWeight. This
+         * function is providing the offset by 1 more. So we take
+         * this as a special case and subtract 1 for > 16
+         */
+        red = (pPriv->colorKey & pScrni->mask.red) >>
+            (pScrni->offset.red - 1) << (8 - pScrni->weight.red);
+        green = (pPriv->colorKey & pScrni->mask.green) >>
+            (pScrni->offset.green - 1) << (8 - pScrni->weight.green);
+        blue = (pPriv->colorKey & pScrni->mask.blue) >>
+            (pScrni->offset.blue - 1) << (8 - pScrni->weight.blue);
+        break;
     }
 
     GFX(set_video_color_key((blue | (green << 8) | (red << 16)), 0xFFFFFF,
-	    (pPriv->colorKeyMode == 0)));
+                            (pPriv->colorKeyMode == 0)));
     REGION_EMPTY(pScrni->pScreen, &pPriv->clip);
     return 0;
 }
@@ -344,11 +344,11 @@ GXResetVideo(ScrnInfoPtr pScrni)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (!pGeode->NoAccel) {
-	GeodePortPrivRec *pPriv = pGeode->adaptor->pPortPrivates[0].ptr;
+        GeodePortPrivRec *pPriv = pGeode->adaptor->pPortPrivates[0].ptr;
 
-	GXAccelSync(pScrni);
-	GXSetColorkey(pScrni, pPriv);
-	GFX(set_video_filter(pPriv->filter, pPriv->filter));
+        GXAccelSync(pScrni);
+        GXSetColorkey(pScrni, pPriv);
+        GFX(set_video_filter(pPriv->filter, pPriv->filter));
     }
 }
 
@@ -375,8 +375,8 @@ GXSetupImageVideo(ScreenPtr pScrn)
     GeodePortPrivRec *pPriv;
 
     if (!(adapt = calloc(1, sizeof(XF86VideoAdaptorRec) +
-		sizeof(GeodePortPrivRec) + sizeof(DevUnion))))
-	return NULL;
+                         sizeof(GeodePortPrivRec) + sizeof(DevUnion))))
+        return NULL;
 
     adapt->type = XvWindowMask | XvInputMask | XvImageMask;
     adapt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
@@ -410,7 +410,7 @@ GXSetupImageVideo(ScreenPtr pScrn)
     pPriv->videoStatus = 0;
 #if DBUF
     pPriv->doubleBuffer = TRUE;
-    pPriv->currentBuffer = 0;	       /* init to first buffer */
+    pPriv->currentBuffer = 0;   /* init to first buffer */
 #endif
 
     /* gotta uninit this someplace */
@@ -463,39 +463,40 @@ GXStopVideo(ScrnInfoPtr pScrni, pointer data, Bool exit)
 
     GXAccelSync(pScrni);
     if (exit) {
-	if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
-	    GFX(set_video_enable(0));
+        if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
+            GFX(set_video_enable(0));
 
-	    /* If we have saved graphics LUT data - restore it */
-	    /* Otherwise, turn bypass on */
+            /* If we have saved graphics LUT data - restore it */
+            /* Otherwise, turn bypass on */
 
-	    if (lutflag)
-		GFX(set_graphics_palette(graphics_lut));
-	    else
-		GFX(set_video_palette_bypass(1));
+            if (lutflag)
+                GFX(set_graphics_palette(graphics_lut));
+            else
+                GFX(set_video_palette_bypass(1));
 
-	    lutflag = 0;
-	}
+            lutflag = 0;
+        }
 
-	if (pPriv->area) {
+        if (pPriv->area) {
 #ifdef XF86EXA
-	    if (pGeode->useEXA)
-		exaOffscreenFree(pScrni->pScreen, pPriv->area);
+            if (pGeode->useEXA)
+                exaOffscreenFree(pScrni->pScreen, pPriv->area);
 #endif
 
-	    if (!pGeode->useEXA)
-		xf86FreeOffscreenArea(pPriv->area);
+            if (!pGeode->useEXA)
+                xf86FreeOffscreenArea(pPriv->area);
 
-	    pPriv->area = NULL;
-	}
+            pPriv->area = NULL;
+        }
 
-	pPriv->videoStatus = 0;
-	pGeode->OverlayON = FALSE;
-    } else {
-	if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
-	    pPriv->videoStatus |= OFF_TIMER;
-	    pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
-	}
+        pPriv->videoStatus = 0;
+        pGeode->OverlayON = FALSE;
+    }
+    else {
+        if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
+            pPriv->videoStatus |= OFF_TIMER;
+            pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
+        }
     }
 }
 
@@ -518,31 +519,33 @@ GXStopVideo(ScrnInfoPtr pScrni, pointer data, Bool exit)
  */
 static int
 GXSetPortAttribute(ScrnInfoPtr pScrni,
-    Atom attribute, INT32 value, pointer data)
+                   Atom attribute, INT32 value, pointer data)
 {
     GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
 
     GXAccelSync(pScrni);
     if (attribute == xvColorKey) {
-	pPriv->colorKey = value;
-	GXSetColorkey(pScrni, pPriv);
+        pPriv->colorKey = value;
+        GXSetColorkey(pScrni, pPriv);
     }
 #if DBUF
     else if (attribute == xvDoubleBuffer) {
-	if ((value < 0) || (value > 1))
-	    return BadValue;
-	pPriv->doubleBuffer = value;
+        if ((value < 0) || (value > 1))
+            return BadValue;
+        pPriv->doubleBuffer = value;
     }
 #endif
     else if (attribute == xvColorKeyMode) {
-	pPriv->colorKeyMode = value;
-	GXSetColorkey(pScrni, pPriv);
-    } else if (attribute == xvFilter) {
-	if ((value < 0) || (value > 1))
-	    return BadValue;
-	pPriv->filter = value;
-    } else
-	return BadMatch;
+        pPriv->colorKeyMode = value;
+        GXSetColorkey(pScrni, pPriv);
+    }
+    else if (attribute == xvFilter) {
+        if ((value < 0) || (value > 1))
+            return BadValue;
+        pPriv->filter = value;
+    }
+    else
+        return BadMatch;
 
     return Success;
 }
@@ -566,24 +569,26 @@ GXSetPortAttribute(ScrnInfoPtr pScrni,
  */
 static int
 GXGetPortAttribute(ScrnInfoPtr pScrni,
-    Atom attribute, INT32 * value, pointer data)
+                   Atom attribute, INT32 *value, pointer data)
 {
     GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
 
     if (attribute == xvColorKey) {
-	*value = pPriv->colorKey;
+        *value = pPriv->colorKey;
     }
 #if DBUF
     else if (attribute == xvDoubleBuffer) {
-	*value = (pPriv->doubleBuffer) ? 1 : 0;
+        *value = (pPriv->doubleBuffer) ? 1 : 0;
     }
 #endif
     else if (attribute == xvColorKeyMode) {
-	*value = pPriv->colorKeyMode;
-    } else if (attribute == xvFilter) {
-	*value = pPriv->filter;
-    } else
-	return BadMatch;
+        *value = pPriv->colorKeyMode;
+    }
+    else if (attribute == xvFilter) {
+        *value = pPriv->filter;
+    }
+    else
+        return BadMatch;
 
     return Success;
 }
@@ -610,16 +615,16 @@ GXGetPortAttribute(ScrnInfoPtr pScrni,
  */
 static void
 GXQueryBestSize(ScrnInfoPtr pScrni,
-    Bool motion,
-    short vid_w, short vid_h,
-    short drw_w, short drw_h,
-    unsigned int *p_w, unsigned int *p_h, pointer data)
+                Bool motion,
+                short vid_w, short vid_h,
+                short drw_w, short drw_h,
+                unsigned int *p_w, unsigned int *p_h, pointer data)
 {
     *p_w = drw_w;
     *p_h = drw_h;
 
     if (*p_w > 16384)
-	*p_w = 16384;
+        *p_w = 16384;
 }
 
 /*----------------------------------------------------------------------------
@@ -641,12 +646,12 @@ GXQueryBestSize(ScrnInfoPtr pScrni,
  */
 static void
 GXCopyData420(unsigned char *src, unsigned char *dst,
-    int srcPitch, int dstPitch, int h, int w)
+              int srcPitch, int dstPitch, int h, int w)
 {
     while (h--) {
-	memcpy(dst, src, w);
-	src += srcPitch;
-	dst += dstPitch;
+        memcpy(dst, src, w);
+        src += srcPitch;
+        dst += dstPitch;
     }
 }
 
@@ -669,13 +674,13 @@ GXCopyData420(unsigned char *src, unsigned char *dst,
  */
 static void
 GXCopyData422(unsigned char *src, unsigned char *dst,
-    int srcPitch, int dstPitch, int h, int w)
+              int srcPitch, int dstPitch, int h, int w)
 {
     w <<= 1;
     while (h--) {
-	memcpy(dst, src, w);
-	src += srcPitch;
-	dst += dstPitch;
+        memcpy(dst, src, w);
+        src += srcPitch;
+        dst += dstPitch;
     }
 }
 
@@ -687,7 +692,7 @@ GXVideoSave(ScreenPtr pScreen, ExaOffscreenArea * area)
     GeodePortPrivRec *pPriv = GET_PORT_PRIVATE(pScrni);
 
     if (area == pPriv->area)
-	pPriv->area = NULL;
+        pPriv->area = NULL;
 }
 #endif
 
@@ -702,59 +707,60 @@ GXAllocateMemory(ScrnInfoPtr pScrni, void **memp, int numlines)
 
 #if XF86EXA
     if (pGeode->useEXA) {
-	ExaOffscreenArea *area = *memp;
+        ExaOffscreenArea *area = *memp;
 
-	if (area != NULL) {
-	    if (area->size >= size)
-		return area->offset;
+        if (area != NULL) {
+            if (area->size >= size)
+                return area->offset;
 
-	    exaOffscreenFree(pScrni->pScreen, area);
-	}
+            exaOffscreenFree(pScrni->pScreen, area);
+        }
 
-	area = exaOffscreenAlloc(pScrni->pScreen, size, 16,
-	    TRUE, GXVideoSave, NULL);
-	*memp = area;
+        area = exaOffscreenAlloc(pScrni->pScreen, size, 16,
+                                 TRUE, GXVideoSave, NULL);
+        *memp = area;
 
-	return area == NULL ? 0 : area->offset;
+        return area == NULL ? 0 : area->offset;
     }
 #endif
 
     if (!pGeode->useEXA) {
-	FBAreaPtr area = *memp;
-	FBAreaPtr new_area;
+        FBAreaPtr area = *memp;
+        FBAreaPtr new_area;
 
-	if (area) {
-	    if ((area->box.y2 - area->box.y1) >= numlines)
-		return (area->box.y1 * pGeode->Pitch);
+        if (area) {
+            if ((area->box.y2 - area->box.y1) >= numlines)
+                return (area->box.y1 * pGeode->Pitch);
 
-	    if (xf86ResizeOffscreenArea(area, pGeode->displayWidth, numlines))
-		return (area->box.y1 * pGeode->Pitch);
+            if (xf86ResizeOffscreenArea(area, pGeode->displayWidth, numlines))
+                return (area->box.y1 * pGeode->Pitch);
 
-	    xf86FreeOffscreenArea(area);
-	}
+            xf86FreeOffscreenArea(area);
+        }
 
-	new_area = xf86AllocateOffscreenArea(pScrn, pGeode->displayWidth,
-	    numlines, 0, NULL, NULL, NULL);
+        new_area = xf86AllocateOffscreenArea(pScrn, pGeode->displayWidth,
+                                             numlines, 0, NULL, NULL, NULL);
 
-	if (!new_area) {
-	    int max_w, max_h;
+        if (!new_area) {
+            int max_w, max_h;
 
-	    xf86QueryLargestOffscreenArea(pScrn, &max_w, &max_h, 0,
-		FAVOR_WIDTH_THEN_AREA, PRIORITY_EXTREME);
+            xf86QueryLargestOffscreenArea(pScrn, &max_w, &max_h, 0,
+                                          FAVOR_WIDTH_THEN_AREA,
+                                          PRIORITY_EXTREME);
 
-	    if ((max_w < pGeode->displayWidth) || (max_h < numlines)) {
-		xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		    "No room - how sad %x, %x, %x, %x\n", max_w,
-		    pGeode->displayWidth, max_h, numlines);
-		return 0;
-	    }
+            if ((max_w < pGeode->displayWidth) || (max_h < numlines)) {
+                xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                           "No room - how sad %x, %x, %x, %x\n", max_w,
+                           pGeode->displayWidth, max_h, numlines);
+                return 0;
+            }
 
-	    xf86PurgeUnlockedOffscreenAreas(pScrn);
-	    new_area = xf86AllocateOffscreenArea(pScrn, pGeode->displayWidth,
-		numlines, 0, NULL, NULL, NULL);
-	}
+            xf86PurgeUnlockedOffscreenAreas(pScrn);
+            new_area = xf86AllocateOffscreenArea(pScrn, pGeode->displayWidth,
+                                                 numlines, 0, NULL, NULL, NULL);
+        }
 
-	return (new_area->box.y1 * pGeode->Pitch);
+        return (new_area->box.y1 * pGeode->Pitch);
     }
 
     return 0;
@@ -776,12 +782,12 @@ RegionsIntersect(BoxPtr pRcl1, BoxPtr pRcl2, BoxPtr pRclResult)
     pRclResult->x2 = min(pRcl1->x2, pRcl2->x2);
 
     if (pRclResult->x1 <= pRclResult->x2) {
-	pRclResult->y1 = max(pRcl1->y1, pRcl2->y1);
-	pRclResult->y2 = min(pRcl1->y2, pRcl2->y2);
+        pRclResult->y1 = max(pRcl1->y1, pRcl2->y1);
+        pRclResult->y2 = min(pRcl1->y2, pRcl2->y2);
 
-	if (pRclResult->y1 <= pRclResult->y2) {
-	    return (TRUE);
-	}
+        if (pRclResult->y1 <= pRclResult->y2) {
+            return (TRUE);
+        }
     }
 
     return (FALSE);
@@ -790,8 +796,8 @@ RegionsIntersect(BoxPtr pRcl1, BoxPtr pRcl2, BoxPtr pRclResult)
 
 void
 GXSetVideoPosition(int x, int y, int width, int height,
-    short src_w, short src_h, short drw_w, short drw_h,
-    int id, int offset, ScrnInfoPtr pScrni)
+                   short src_w, short src_h, short drw_w, short drw_h,
+                   int id, int offset, ScrnInfoPtr pScrni)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
     long ystart, xend, yend;
@@ -817,49 +823,52 @@ GXSetVideoPosition(int x, int y, int width, int height,
     /* Thhis code is pretty dang broken - comment it out for now */
 
     if (pGeode->Panel) {
-	ovly.x1 = x;
-	ovly.x2 = x + pGeode->video_dstw;
-	ovly.y1 = y;
-	ovly.y2 = y + pGeode->video_dsth;
-
-	display.x1 = DeltaX;
-	display.x2 = DeltaX + pGeode->FPBX;
-	display.y1 = DeltaY;
-	display.y2 = DeltaY + pGeode->FPBY;
-	x = xend = 0;
-	if (RegionsIntersect(&display, &ovly, &result)) {
-	    x = ovly.x1 - DeltaX;
-	    xend = ovly.x2 - DeltaX;
-	    y = ovly.y1 - DeltaY;
-	    yend = ovly.y2 - DeltaY;
-	}
+        ovly.x1 = x;
+        ovly.x2 = x + pGeode->video_dstw;
+        ovly.y1 = y;
+        ovly.y2 = y + pGeode->video_dsth;
+
+        display.x1 = DeltaX;
+        display.x2 = DeltaX + pGeode->FPBX;
+        display.y1 = DeltaY;
+        display.y2 = DeltaY + pGeode->FPBY;
+        x = xend = 0;
+        if (RegionsIntersect(&display, &ovly, &result)) {
+            x = ovly.x1 - DeltaX;
+            xend = ovly.x2 - DeltaX;
+            y = ovly.y1 - DeltaY;
+            yend = ovly.y2 - DeltaY;
+        }
     }
 #endif
 
     /*  TOP CLIPPING */
 
     if (y < 0) {
-	if (src_h < drw_h)
-	    lines = (-y) * src_h / drw_h;
-	else
-	    lines = (-y);
-	ystart = 0;
-	drw_h += y;
-	y_extra = lines * dstPitch;
-	uv_extra = (lines >> 1) * (dstPitch2);
-    } else {
-	ystart = y;
-	lines = 0;
-	y_extra = 0;
+        if (src_h < drw_h)
+            lines = (-y) * src_h / drw_h;
+        else
+            lines = (-y);
+        ystart = 0;
+        drw_h += y;
+        y_extra = lines * dstPitch;
+        uv_extra = (lines >> 1) * (dstPitch2);
+    }
+    else {
+        ystart = y;
+        lines = 0;
+        y_extra = 0;
     }
 
     GFX(set_video_window(x, ystart, xend - x, yend - ystart));
 
     if ((id == FOURCC_Y800) || (id == FOURCC_I420) || (id == FOURCC_YV12)) {
-	GFX(set_video_yuv_offsets(offset + y_extra,
-		offset + d3offset + uv_extra, offset + d2offset + uv_extra));
-    } else {
-	GFX(set_video_offset(offset + y_extra));
+        GFX(set_video_yuv_offsets(offset + y_extra,
+                                  offset + d3offset + uv_extra,
+                                  offset + d2offset + uv_extra));
+    }
+    else {
+        GFX(set_video_offset(offset + y_extra));
     }
 }
 
@@ -880,12 +889,13 @@ GXSetVideoPosition(int x, int y, int width, int height,
 
 static void
 GXDisplayVideo(ScrnInfoPtr pScrni,
-    int id,
-    int offset,
-    short width, short height,
-    int pitch,
-    int x1, int y1, int x2, int y2,
-    BoxPtr dstBox, short src_w, short src_h, short drw_w, short drw_h)
+               int id,
+               int offset,
+               short width, short height,
+               int pitch,
+               int x1, int y1, int x2, int y2,
+               BoxPtr dstBox, short src_w, short src_h, short drw_w,
+               short drw_h)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
     unsigned long dcfg, misc;
@@ -897,74 +907,74 @@ GXDisplayVideo(ScrnInfoPtr pScrni,
      */
 
     if (id != FOURCC_RGB565) {
-	dcfg = gfx_read_vid32(DISPLAY_CONFIG);
-	misc = gfx_read_vid32(MISC);
+        dcfg = gfx_read_vid32(DISPLAY_CONFIG);
+        misc = gfx_read_vid32(MISC);
 
-	lutflag = (!(misc & 1) && (dcfg & (1 << 21)));
+        lutflag = (!(misc & 1) && (dcfg & (1 << 21)));
 
-	if (lutflag)
-	    get_gamma_ram(graphics_lut);
+        if (lutflag)
+            get_gamma_ram(graphics_lut);
 
-	/* Set the video gamma ram */
-	GFX(set_video_palette(NULL));
+        /* Set the video gamma ram */
+        GFX(set_video_palette(NULL));
     }
 
     GFX(set_video_enable(1));
 
     switch (id) {
-    case FOURCC_UYVY:		       /* UYVY */
-	GFX(set_video_format(VIDEO_FORMAT_UYVY));
-	GFX(set_video_size(width, height));
-	break;
-    case FOURCC_Y800:		       /* Y800 - greyscale - we munge it! */
-    case FOURCC_YV12:		       /* YV12 */
-    case FOURCC_I420:		       /* I420 */
-	GFX(set_video_format(VIDEO_FORMAT_Y0Y1Y2Y3));
-	GFX(set_video_size(width, height));
-	GFX(set_video_yuv_pitch(dstPitch, dstPitch2));
-	break;
-    case FOURCC_YUY2:		       /* YUY2 */
-	GFX(set_video_format(VIDEO_FORMAT_YUYV));
-	GFX(set_video_size(width, height));
-	break;
-    case FOURCC_Y2YU:		       /* Y2YU */
-	GFX(set_video_format(VIDEO_FORMAT_Y2YU));
-	GFX(set_video_size(width, height));
-	break;
-    case FOURCC_YVYU:		       /* YVYU */
-	GFX(set_video_format(VIDEO_FORMAT_YVYU));
-	GFX(set_video_size(width, height));
-	break;
+    case FOURCC_UYVY:          /* UYVY */
+        GFX(set_video_format(VIDEO_FORMAT_UYVY));
+        GFX(set_video_size(width, height));
+        break;
+    case FOURCC_Y800:          /* Y800 - greyscale - we munge it! */
+    case FOURCC_YV12:          /* YV12 */
+    case FOURCC_I420:          /* I420 */
+        GFX(set_video_format(VIDEO_FORMAT_Y0Y1Y2Y3));
+        GFX(set_video_size(width, height));
+        GFX(set_video_yuv_pitch(dstPitch, dstPitch2));
+        break;
+    case FOURCC_YUY2:          /* YUY2 */
+        GFX(set_video_format(VIDEO_FORMAT_YUYV));
+        GFX(set_video_size(width, height));
+        break;
+    case FOURCC_Y2YU:          /* Y2YU */
+        GFX(set_video_format(VIDEO_FORMAT_Y2YU));
+        GFX(set_video_size(width, height));
+        break;
+    case FOURCC_YVYU:          /* YVYU */
+        GFX(set_video_format(VIDEO_FORMAT_YVYU));
+        GFX(set_video_size(width, height));
+        break;
     case FOURCC_RGB565:
-	GFX(set_video_format(VIDEO_FORMAT_RGB));
-	GFX(set_video_size(width, height));
-	break;
+        GFX(set_video_format(VIDEO_FORMAT_RGB));
+        GFX(set_video_size(width, height));
+        break;
 
     }
 
     if (pGeode->Panel) {
-	pGeode->video_x = dstBox->x1;
-	pGeode->video_y = dstBox->y1;
-	pGeode->video_w = width;
-	pGeode->video_h = height;
-	pGeode->video_srcw = src_w;
-	pGeode->video_srch = src_h;
-	pGeode->video_dstw = drw_w;
-	pGeode->video_dsth = drw_h;
-	pGeode->video_offset = offset;
-	pGeode->video_id = id;
-	pGeode->video_scrnptr = pScrni;
+        pGeode->video_x = dstBox->x1;
+        pGeode->video_y = dstBox->y1;
+        pGeode->video_w = width;
+        pGeode->video_h = height;
+        pGeode->video_srcw = src_w;
+        pGeode->video_srch = src_h;
+        pGeode->video_dstw = drw_w;
+        pGeode->video_dsth = drw_h;
+        pGeode->video_offset = offset;
+        pGeode->video_id = id;
+        pGeode->video_scrnptr = pScrni;
     }
 
     if ((drw_w >= src_w) && (drw_h >= src_h))
-	GFX(set_video_scale(width, height, drw_w, drw_h));
+        GFX(set_video_scale(width, height, drw_w, drw_h));
     else if (drw_w < src_w)
-	GFX(set_video_scale(drw_w, height, drw_w, drw_h));
+        GFX(set_video_scale(drw_w, height, drw_w, drw_h));
     else if (drw_h < src_h)
-	GFX(set_video_scale(width, drw_h, drw_w, drw_h));
+        GFX(set_video_scale(width, drw_h, drw_w, drw_h));
 
     GXSetVideoPosition(dstBox->x1, dstBox->y1, width, height, src_w,
-	src_h, drw_w, drw_h, id, offset, pScrni);
+                       src_h, drw_w, drw_h, id, offset, pScrni);
 }
 
 /* Used by LX as well */
@@ -977,23 +987,23 @@ RegionsEqual(RegionPtr A, RegionPtr B)
 
     num = REGION_NUM_RECTS(A);
     if (num != REGION_NUM_RECTS(B)) {
-	return FALSE;
+        return FALSE;
     }
 
     if ((A->extents.x1 != B->extents.x1) ||
-	(A->extents.x2 != B->extents.x2) ||
-	(A->extents.y1 != B->extents.y1) || (A->extents.y2 != B->extents.y2))
-	return FALSE;
+        (A->extents.x2 != B->extents.x2) ||
+        (A->extents.y1 != B->extents.y1) || (A->extents.y2 != B->extents.y2))
+        return FALSE;
 
-    dataA = (int *)REGION_RECTS(A);
-    dataB = (int *)REGION_RECTS(B);
+    dataA = (int *) REGION_RECTS(A);
+    dataB = (int *) REGION_RECTS(B);
 
     while (num--) {
-	if ((dataA[0] != dataB[0]) || (dataA[1] != dataB[1]))
-	    return FALSE;
+        if ((dataA[0] != dataB[0]) || (dataA[1] != dataB[1]))
+            return FALSE;
 
-	dataA += 2;
-	dataB += 2;
+        dataA += 2;
+        dataB += 2;
     }
 
     return TRUE;
@@ -1022,13 +1032,13 @@ RegionsEqual(RegionPtr A, RegionPtr B)
 
 static int
 GXPutImage(ScrnInfoPtr pScrni,
-    short src_x, short src_y,
-    short drw_x, short drw_y,
-    short src_w, short src_h,
-    short drw_w, short drw_h,
-    int id, unsigned char *buf,
-    short width, short height, Bool sync, RegionPtr clipBoxes, pointer data,
-    DrawablePtr pDraw)
+           short src_x, short src_y,
+           short drw_x, short drw_y,
+           short src_w, short src_h,
+           short drw_w, short drw_h,
+           int id, unsigned char *buf,
+           short width, short height, Bool sync, RegionPtr clipBoxes,
+           pointer data, DrawablePtr pDraw)
 {
     GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
     GeodeRec *pGeode = GEODEPTR(pScrni);
@@ -1049,173 +1059,172 @@ GXPutImage(ScrnInfoPtr pScrni,
 #if REINIT
 /* update cliplist */
     if (!RegionsEqual(&pPriv->clip, clipBoxes)) {
-	ReInitVideo = TRUE;
+        ReInitVideo = TRUE;
     }
 
     if (DoReinitAgain)
-	ReInitVideo = TRUE;
+        ReInitVideo = TRUE;
 
     if (ReInitVideo) {
-	DEBUGMSG(1, (0, X_NONE, "Regional Not Equal - Init\n"));
+        DEBUGMSG(1, (0, X_NONE, "Regional Not Equal - Init\n"));
 #endif
-	DoReinitAgain = ~DoReinitAgain;
-	if (drw_w > 16384)
-	    drw_w = 16384;
-
-	/* Clip */
-	Bx1 = src_x;
-	Bx2 = src_x + src_w;
-	By1 = src_y;
-	By2 = src_y + src_h;
-
-	if ((Bx1 >= Bx2) || (By1 >= By2))
-	    return Success;
-
-	dstBox.x1 = drw_x;
-	dstBox.x2 = drw_x + drw_w;
-	dstBox.y1 = drw_y;
-	dstBox.y2 = drw_y + drw_h;
-
-	dstBox.x1 -= pScrni->frameX0;
-	dstBox.x2 -= pScrni->frameX0;
-	dstBox.y1 -= pScrni->frameY0;
-	dstBox.y2 -= pScrni->frameY0;
-
-	switch (id) {
-	case FOURCC_YV12:
-	case FOURCC_I420:
-	    srcPitch = (width + 3) & ~3;	/* of luma */
-	    dstPitch = (width + 31) & ~31;
-
-	    s2offset = srcPitch * height;
-	    d2offset = dstPitch * height;
-
-	    srcPitch2 = ((width >> 1) + 3) & ~3;
-	    dstPitch2 = ((width >> 1) + 15) & ~15;
-
-	    s3offset = (srcPitch2 * (height >> 1)) + s2offset;
-	    d3offset = (dstPitch2 * (height >> 1)) + d2offset;
-
-	    new_h = dstPitch * height; /* Y */
-	    new_h += (dstPitch2 * height);	/* U+V */
-	    new_h += pGeode->Pitch - 1;
-	    new_h /= pGeode->Pitch;
-	    break;
-	case FOURCC_UYVY:
-	case FOURCC_YUY2:
-	case FOURCC_Y800:
-	case FOURCC_RGB565:
-	default:
-	    dstPitch = ((width << 1) + 3) & ~3;
-	    srcPitch = (width << 1);
-	    new_h = ((dstPitch * height) + pGeode->Pitch - 1) / pGeode->Pitch;
-	    break;
-	}
+        DoReinitAgain = ~DoReinitAgain;
+        if (drw_w > 16384)
+            drw_w = 16384;
+
+        /* Clip */
+        Bx1 = src_x;
+        Bx2 = src_x + src_w;
+        By1 = src_y;
+        By2 = src_y + src_h;
+
+        if ((Bx1 >= Bx2) || (By1 >= By2))
+            return Success;
+
+        dstBox.x1 = drw_x;
+        dstBox.x2 = drw_x + drw_w;
+        dstBox.y1 = drw_y;
+        dstBox.y2 = drw_y + drw_h;
+
+        dstBox.x1 -= pScrni->frameX0;
+        dstBox.x2 -= pScrni->frameX0;
+        dstBox.y1 -= pScrni->frameY0;
+        dstBox.y2 -= pScrni->frameY0;
+
+        switch (id) {
+        case FOURCC_YV12:
+        case FOURCC_I420:
+            srcPitch = (width + 3) & ~3;        /* of luma */
+            dstPitch = (width + 31) & ~31;
+
+            s2offset = srcPitch * height;
+            d2offset = dstPitch * height;
+
+            srcPitch2 = ((width >> 1) + 3) & ~3;
+            dstPitch2 = ((width >> 1) + 15) & ~15;
+
+            s3offset = (srcPitch2 * (height >> 1)) + s2offset;
+            d3offset = (dstPitch2 * (height >> 1)) + d2offset;
+
+            new_h = dstPitch * height;  /* Y */
+            new_h += (dstPitch2 * height);      /* U+V */
+            new_h += pGeode->Pitch - 1;
+            new_h /= pGeode->Pitch;
+            break;
+        case FOURCC_UYVY:
+        case FOURCC_YUY2:
+        case FOURCC_Y800:
+        case FOURCC_RGB565:
+        default:
+            dstPitch = ((width << 1) + 3) & ~3;
+            srcPitch = (width << 1);
+            new_h = ((dstPitch * height) + pGeode->Pitch - 1) / pGeode->Pitch;
+            break;
+        }
 #if DBUF
-	if (pPriv->doubleBuffer)
-	    new_h <<= 1;
+        if (pPriv->doubleBuffer)
+            new_h <<= 1;
 #endif
 
-	if (!(pPriv->offset = GXAllocateMemory(pScrni, &pPriv->area, new_h))) {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Could not allocate area of size %d\n", new_h);
-	    return BadAlloc;
-	}
+        if (!(pPriv->offset = GXAllocateMemory(pScrni, &pPriv->area, new_h))) {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Could not allocate area of size %d\n", new_h);
+            return BadAlloc;
+        }
 
-	/* copy data */
-	top = By1;
-	left = Bx1 & ~1;
-	npixels = ((Bx2 + 1) & ~1) - left;
+        /* copy data */
+        top = By1;
+        left = Bx1 & ~1;
+        npixels = ((Bx2 + 1) & ~1) - left;
 
-	switch (id) {
-	case FOURCC_YV12:
-	case FOURCC_I420:
-	    {
-		int tmp;
+        switch (id) {
+        case FOURCC_YV12:
+        case FOURCC_I420:
+        {
+            int tmp;
 
-		top &= ~1;
+            top &= ~1;
 
-		offset = pPriv->offset + (top * dstPitch);
+            offset = pPriv->offset + (top * dstPitch);
 
 #if DBUF
-		if (pPriv->doubleBuffer && pPriv->currentBuffer)
-		    offset += (new_h >> 1) * pGeode->Pitch;
+            if (pPriv->doubleBuffer && pPriv->currentBuffer)
+                offset += (new_h >> 1) * pGeode->Pitch;
 #endif
-		dst_start = pGeode->FBBase + offset + left;
-		tmp = ((top >> 1) * srcPitch2) + (left >> 1);
-		s2offset += tmp;
-		s3offset += tmp;
-		if (id == FOURCC_I420) {
-		    tmp = s2offset;
-		    s2offset = s3offset;
-		    s3offset = tmp;
-		}
-		nlines = ((By2 + 1) & ~1) - top;
-	    }
-	    break;
-	case FOURCC_UYVY:
-	case FOURCC_YUY2:
-	case FOURCC_Y800:
-	case FOURCC_RGB565:
-	default:
-	    left <<= 1;
-	    buf += (top * srcPitch) + left;
-	    nlines = By2 - top;
-	    offset = (pPriv->offset) + (top * dstPitch);
+            dst_start = pGeode->FBBase + offset + left;
+            tmp = ((top >> 1) * srcPitch2) + (left >> 1);
+            s2offset += tmp;
+            s3offset += tmp;
+            if (id == FOURCC_I420) {
+                tmp = s2offset;
+                s2offset = s3offset;
+                s3offset = tmp;
+            }
+            nlines = ((By2 + 1) & ~1) - top;
+        }
+            break;
+        case FOURCC_UYVY:
+        case FOURCC_YUY2:
+        case FOURCC_Y800:
+        case FOURCC_RGB565:
+        default:
+            left <<= 1;
+            buf += (top * srcPitch) + left;
+            nlines = By2 - top;
+            offset = (pPriv->offset) + (top * dstPitch);
 
 #if DBUF
-	    if (pPriv->doubleBuffer && pPriv->currentBuffer)
-		offset += (new_h >> 1) * pGeode->Pitch;
+            if (pPriv->doubleBuffer && pPriv->currentBuffer)
+                offset += (new_h >> 1) * pGeode->Pitch;
 #endif
-	    dst_start = pGeode->FBBase + offset + left;
-	    break;
-	}
-	s1offset = (top * srcPitch) + left;
+            dst_start = pGeode->FBBase + offset + left;
+            break;
+        }
+        s1offset = (top * srcPitch) + left;
 #if REINIT
-	/* update cliplist */
-	REGION_COPY(pScrni->pScreen, &pPriv->clip, clipBoxes);
+        /* update cliplist */
+        REGION_COPY(pScrni->pScreen, &pPriv->clip, clipBoxes);
 
-	if (pPriv->colorKeyMode == 0) {
-	    xf86XVFillKeyHelper(pScrni->pScreen, pPriv->colorKey, clipBoxes);
-	}
+        if (pPriv->colorKeyMode == 0) {
+            xf86XVFillKeyHelper(pScrni->pScreen, pPriv->colorKey, clipBoxes);
+        }
 
-	GXDisplayVideo(pScrni, id, offset, width, height, dstPitch,
-	    Bx1, By1, Bx2, By2, &dstBox, src_w, src_h, drw_w, drw_h);
+        GXDisplayVideo(pScrni, id, offset, width, height, dstPitch,
+                       Bx1, By1, Bx2, By2, &dstBox, src_w, src_h, drw_w, drw_h);
     }
 #endif
     switch (id) {
     case FOURCC_Y800:
-	/* This is shared between LX and GX, so it lives in amd_common.c */
-	GeodeCopyGreyscale(buf, dst_start, srcPitch, dstPitch, nlines,
-	    npixels);
-	break;
+        /* This is shared between LX and GX, so it lives in amd_common.c */
+        GeodeCopyGreyscale(buf, dst_start, srcPitch, dstPitch, nlines, npixels);
+        break;
     case FOURCC_YV12:
     case FOURCC_I420:
-	GXCopyData420(buf + s1offset, dst_start, srcPitch, dstPitch, nlines,
-	    npixels);
-	GXCopyData420(buf + s2offset, dst_start + d2offset, srcPitch2,
-	    dstPitch2, nlines >> 1, npixels >> 1);
-	GXCopyData420(buf + s3offset, dst_start + d3offset, srcPitch2,
-	    dstPitch2, nlines >> 1, npixels >> 1);
-	break;
+        GXCopyData420(buf + s1offset, dst_start, srcPitch, dstPitch, nlines,
+                      npixels);
+        GXCopyData420(buf + s2offset, dst_start + d2offset, srcPitch2,
+                      dstPitch2, nlines >> 1, npixels >> 1);
+        GXCopyData420(buf + s3offset, dst_start + d3offset, srcPitch2,
+                      dstPitch2, nlines >> 1, npixels >> 1);
+        break;
     case FOURCC_UYVY:
     case FOURCC_YUY2:
     case FOURCC_RGB565:
     default:
-	GXCopyData422(buf, dst_start, srcPitch, dstPitch, nlines, npixels);
-	break;
+        GXCopyData422(buf, dst_start, srcPitch, dstPitch, nlines, npixels);
+        break;
     }
 #if !REINIT
     /* update cliplist */
     REGION_COPY(pScrni->pScreen, &pPriv->clip, clipBoxes);
     if (pPriv->colorKeyMode == 0) {
-	/* draw these */
-	XAAFillSolidRects(pScrni, pPriv->colorKey, GXcopy, ~0,
-	    REGION_NUM_RECTS(clipBoxes), REGION_RECTS(clipBoxes));
+        /* draw these */
+        XAAFillSolidRects(pScrni, pPriv->colorKey, GXcopy, ~0,
+                          REGION_NUM_RECTS(clipBoxes), REGION_RECTS(clipBoxes));
     }
 
     GXDisplayVideo(pScrni, id, offset, width, height, dstPitch,
-	Bx1, By1, Bx2, By2, &dstBox, src_w, src_h, drw_w, drw_h);
+                   Bx1, By1, Bx2, By2, &dstBox, src_w, src_h, drw_w, drw_h);
 #endif
 
 #if XV_PROFILE
@@ -1254,7 +1263,8 @@ GXPutImage(ScrnInfoPtr pScrni,
 
 int
 GeodeQueryImageAttributes(ScrnInfoPtr pScrni,
-    int id, unsigned short *w, unsigned short *h, int *pitches, int *offsets)
+                          int id, unsigned short *w, unsigned short *h,
+                          int *pitches, int *offsets)
 {
     int size;
     int tmp;
@@ -1262,47 +1272,47 @@ GeodeQueryImageAttributes(ScrnInfoPtr pScrni,
     DEBUGMSG(0, (0, X_NONE, "QueryImageAttributes %X\n", id));
 
     if (*w > 1024)
-	*w = 1024;
+        *w = 1024;
     if (*h > 1024)
-	*h = 1024;
+        *h = 1024;
 
     *w = (*w + 1) & ~1;
     if (offsets)
-	offsets[0] = 0;
+        offsets[0] = 0;
 
     switch (id) {
     case FOURCC_YV12:
     case FOURCC_I420:
-	*h = (*h + 1) & ~1;
-	size = (*w + 3) & ~3;
-	if (pitches)
-	    pitches[0] = size;
-
-	size *= *h;
-	if (offsets)
-	    offsets[1] = size;
-
-	tmp = ((*w >> 1) + 3) & ~3;
-	if (pitches)
-	    pitches[1] = pitches[2] = tmp;
-
-	tmp *= (*h >> 1);
-	size += tmp;
-	if (offsets)
-	    offsets[2] = size;
-
-	size += tmp;
-	break;
+        *h = (*h + 1) & ~1;
+        size = (*w + 3) & ~3;
+        if (pitches)
+            pitches[0] = size;
+
+        size *= *h;
+        if (offsets)
+            offsets[1] = size;
+
+        tmp = ((*w >> 1) + 3) & ~3;
+        if (pitches)
+            pitches[1] = pitches[2] = tmp;
+
+        tmp *= (*h >> 1);
+        size += tmp;
+        if (offsets)
+            offsets[2] = size;
+
+        size += tmp;
+        break;
     case FOURCC_UYVY:
     case FOURCC_YUY2:
     case FOURCC_Y800:
     default:
-	size = *w << 1;
-	if (pitches)
-	    pitches[0] = size;
+        size = *w << 1;
+        if (pitches)
+            pitches[0] = size;
 
-	size *= *h;
-	break;
+        size *= *h;
+        break;
     }
     return size;
 }
@@ -1320,49 +1330,49 @@ GXBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
     pScrn->BlockHandler = GXBlockHandler;
 
     if (pPriv->videoStatus & TIMER_MASK) {
-	GXAccelSync(pScrni);
-	UpdateCurrentTime();
-	if (pPriv->videoStatus & OFF_TIMER) {
-	    if (pPriv->offTime < currentTime.milliseconds) {
-		GFX(set_video_enable(0));
-
-		/* If we have saved graphics LUT data - restore it */
-		/* Otherwise, turn bypass on */
-
-		if (lutflag)
-		    GFX(set_graphics_palette(graphics_lut));
-		else
-		    GFX(set_video_palette_bypass(1));
-
-		lutflag = 0;
-
-		pPriv->videoStatus = FREE_TIMER;
-		pPriv->freeTime = currentTime.milliseconds + FREE_DELAY;
-	    }
-	} else {		       /* FREE_TIMER */
-	    if (pPriv->freeTime < currentTime.milliseconds) {
-
-		if (pPriv->area) {
+        GXAccelSync(pScrni);
+        UpdateCurrentTime();
+        if (pPriv->videoStatus & OFF_TIMER) {
+            if (pPriv->offTime < currentTime.milliseconds) {
+                GFX(set_video_enable(0));
+
+                /* If we have saved graphics LUT data - restore it */
+                /* Otherwise, turn bypass on */
+
+                if (lutflag)
+                    GFX(set_graphics_palette(graphics_lut));
+                else
+                    GFX(set_video_palette_bypass(1));
+
+                lutflag = 0;
+
+                pPriv->videoStatus = FREE_TIMER;
+                pPriv->freeTime = currentTime.milliseconds + FREE_DELAY;
+            }
+        }
+        else {                  /* FREE_TIMER */
+            if (pPriv->freeTime < currentTime.milliseconds) {
+
+                if (pPriv->area) {
 #ifdef XF86EXA
-		    if (pGeode->useEXA)
-			exaOffscreenFree(pScrn, pPriv->area);
+                    if (pGeode->useEXA)
+                        exaOffscreenFree(pScrn, pPriv->area);
 #endif
-		    if (!pGeode->useEXA)
-			xf86FreeOffscreenArea(pPriv->area);
+                    if (!pGeode->useEXA)
+                        xf86FreeOffscreenArea(pPriv->area);
 
-		    pPriv->area = NULL;
-		}
+                    pPriv->area = NULL;
+                }
 
-		pPriv->videoStatus = 0;
-	    }
-	}
+                pPriv->videoStatus = 0;
+            }
+        }
     }
 }
 
 /****************** Offscreen stuff ***************/
 
-typedef struct
-{
+typedef struct {
     void *area;
     int offset;
     Bool isOn;
@@ -1383,14 +1393,15 @@ typedef struct
  */
 static int
 GXAllocateSurface(ScrnInfoPtr pScrni,
-    int id, unsigned short w, unsigned short h, XF86SurfacePtr surface)
+                  int id, unsigned short w, unsigned short h,
+                  XF86SurfacePtr surface)
 {
     void *area = NULL;
     int pitch, fbpitch, numlines;
     OffscreenPrivRec *pPriv;
 
     if ((w > 1024) || (h > 1024))
-	return BadAlloc;
+        return BadAlloc;
 
     w = (w + 1) & ~1;
     pitch = ((w << 1) + 15) & ~15;
@@ -1398,23 +1409,23 @@ GXAllocateSurface(ScrnInfoPtr pScrni,
     numlines = ((pitch * h) + fbpitch - 1) / fbpitch;
 
     if (!(offset = GXAllocateMemory(pScrni, &area, numlines)))
-	return BadAlloc;
+        return BadAlloc;
 
     surface->width = w;
     surface->height = h;
 
     if (!(surface->pitches = malloc(sizeof(int))))
-	return BadAlloc;
+        return BadAlloc;
 
     if (!(surface->offsets = malloc(sizeof(int)))) {
-	free(surface->pitches);
-	return BadAlloc;
+        free(surface->pitches);
+        return BadAlloc;
     }
 
     if (!(pPriv = malloc(sizeof(OffscreenPrivRec)))) {
-	free(surface->pitches);
-	free(surface->offsets);
-	return BadAlloc;
+        free(surface->pitches);
+        free(surface->offsets);
+        return BadAlloc;
     }
 
     pPriv->area = area;
@@ -1437,7 +1448,7 @@ GXStopSurface(XF86SurfacePtr surface)
     OffscreenPrivRec *pPriv = (OffscreenPrivRec *) surface->devPrivate.ptr;
 
     if (pPriv->isOn) {
-	pPriv->isOn = FALSE;
+        pPriv->isOn = FALSE;
     }
 
     return Success;
@@ -1449,7 +1460,7 @@ GXFreeSurface(XF86SurfacePtr surface)
     OffscreenPrivRec *pPriv = (OffscreenPrivRec *) surface->devPrivate.ptr;
 
     if (pPriv->isOn)
-	GXStopSurface(surface);
+        GXStopSurface(surface);
 
     xf86FreeOffscreenArea(pPriv->area);
     free(surface->pitches);
@@ -1460,24 +1471,25 @@ GXFreeSurface(XF86SurfacePtr surface)
 }
 
 static int
-GXGetSurfaceAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 * value)
+GXGetSurfaceAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 *value)
 {
     return GXGetPortAttribute(pScrni, attribute, value,
-	(pointer) (GET_PORT_PRIVATE(pScrni)));
+                              (pointer) (GET_PORT_PRIVATE(pScrni)));
 }
 
 static int
 GXSetSurfaceAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 value)
 {
     return GXSetPortAttribute(pScrni, attribute, value,
-	(pointer) (GET_PORT_PRIVATE(pScrni)));
+                              (pointer) (GET_PORT_PRIVATE(pScrni)));
 }
 
 static int
 GXDisplaySurface(XF86SurfacePtr surface,
-    short src_x, short src_y,
-    short drw_x, short drw_y,
-    short src_w, short src_h, short drw_w, short drw_h, RegionPtr clipBoxes)
+                 short src_x, short src_y,
+                 short drw_x, short drw_y,
+                 short src_w, short src_h, short drw_w, short drw_h,
+                 RegionPtr clipBoxes)
 {
     OffscreenPrivRec *pPriv = (OffscreenPrivRec *) surface->devPrivate.ptr;
     ScrnInfoPtr pScrni = surface->pScrn;
@@ -1497,7 +1509,7 @@ GXDisplaySurface(XF86SurfacePtr surface,
     dstBox.y2 = drw_y + drw_h;
 
     if ((x1 >= x2) || (y1 >= y2))
-	return Success;
+        return Success;
 
     dstBox.x1 -= pScrni->frameX0;
     dstBox.x2 -= pScrni->frameX0;
@@ -1507,15 +1519,15 @@ GXDisplaySurface(XF86SurfacePtr surface,
     xf86XVFillKeyHelper(pScrni->pScreen, portPriv->colorKey, clipBoxes);
 
     GXDisplayVideo(pScrni, surface->id, surface->offsets[0],
-	surface->width, surface->height, surface->pitches[0],
-	x1, y1, x2, y2, &dstBox, src_w, src_h, drw_w, drw_h);
+                   surface->width, surface->height, surface->pitches[0],
+                   x1, y1, x2, y2, &dstBox, src_w, src_h, drw_w, drw_h);
 
     pPriv->isOn = TRUE;
     if (portPriv->videoStatus & CLIENT_VIDEO_ON) {
-	REGION_EMPTY(pScrni->pScreen, &portPriv->clip);
-	UpdateCurrentTime();
-	portPriv->videoStatus = FREE_TIMER;
-	portPriv->freeTime = currentTime.milliseconds + FREE_DELAY;
+        REGION_EMPTY(pScrni->pScreen, &portPriv->clip);
+        UpdateCurrentTime();
+        portPriv->videoStatus = FREE_TIMER;
+        portPriv->freeTime = currentTime.milliseconds + FREE_DELAY;
     }
 
     return Success;
@@ -1543,7 +1555,7 @@ GXInitOffscreenImages(ScreenPtr pScrn)
 
     /* need to free this someplace */
     if (!(offscreenImages = malloc(sizeof(XF86OffscreenImageRec))))
-	return;
+        return;
 
     offscreenImages[0].image = &Images[0];
     offscreenImages[0].flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
@@ -1561,4 +1573,4 @@ GXInitOffscreenImages(ScreenPtr pScrn)
     xf86XVRegisterOffscreenImages(pScrn, offscreenImages, 1);
 }
 
-#endif /* !XvExtension */
+#endif                          /* !XvExtension */
diff --git a/src/lx_cursor.c b/src/lx_cursor.c
index 23205c0..fe1149a 100644
--- a/src/lx_cursor.c
+++ b/src/lx_cursor.c
@@ -36,20 +36,20 @@ Bool
 LXCursorInit(ScreenPtr pScrn)
 {
     return xf86_cursors_init(pScrn,
-        LX_CURSOR_MAX_WIDTH, LX_CURSOR_MAX_HEIGHT,
-	HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
-	HARDWARE_CURSOR_INVERT_MASK |
-	HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
-	HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_32 |
-	HARDWARE_CURSOR_ARGB);
+                             LX_CURSOR_MAX_WIDTH, LX_CURSOR_MAX_HEIGHT,
+                             HARDWARE_CURSOR_TRUECOLOR_AT_8BPP |
+                             HARDWARE_CURSOR_INVERT_MASK |
+                             HARDWARE_CURSOR_AND_SOURCE_WITH_MASK |
+                             HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_32 |
+                             HARDWARE_CURSOR_ARGB);
 }
 
 void
 LXLoadARGBCursorImage(ScrnInfoPtr pScrni, unsigned char *src)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
+
     vg_set_color_cursor_shape(pGeode->CursorStartOffset, src,
-				  LX_CURSOR_MAX_WIDTH, LX_CURSOR_MAX_HEIGHT,
-				  LX_CURSOR_MAX_WIDTH * 4, 0, 0);
+                              LX_CURSOR_MAX_WIDTH, LX_CURSOR_MAX_HEIGHT,
+                              LX_CURSOR_MAX_WIDTH * 4, 0, 0);
 }
-
diff --git a/src/lx_display.c b/src/lx_display.c
index b46fa17..997d53d 100644
--- a/src/lx_display.c
+++ b/src/lx_display.c
@@ -33,8 +33,7 @@
 #include "cim/cim_defs.h"
 #include "cim/cim_regs.h"
 
-typedef struct _LXOutputPrivateRec
-{
+typedef struct _LXOutputPrivateRec {
     int video_enable;
     unsigned long video_flags;
     GeodeMemPtr rotate_mem;
@@ -50,14 +49,14 @@ lx_enable_dac_power(ScrnInfoPtr pScrni, int option)
     /* Turn off the DAC if we don't need the CRT */
 
     if (option && (!(pGeode->Output & OUTPUT_CRT))) {
-	unsigned int misc = READ_VID32(DF_VID_MISC);
+        unsigned int misc = READ_VID32(DF_VID_MISC);
 
-	misc |= DF_DAC_POWER_DOWN;
-	WRITE_VID32(DF_VID_MISC, misc);
+        misc |= DF_DAC_POWER_DOWN;
+        WRITE_VID32(DF_VID_MISC, misc);
     }
 
     if (pGeode->Output & OUTPUT_PANEL)
-	df_set_panel_enable(1);
+        df_set_panel_enable(1);
 }
 
 static void
@@ -66,15 +65,15 @@ lx_disable_dac_power(ScrnInfoPtr pScrni, int option)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pGeode->Output & OUTPUT_PANEL)
-	df_set_panel_enable(0);
+        df_set_panel_enable(0);
 
     if (pGeode->Output & OUTPUT_CRT) {
 
-	/* Wait for the panel to finish its procedure */
+        /* Wait for the panel to finish its procedure */
 
-	if (pGeode->Output & OUTPUT_PANEL)
-	    while ((READ_VID32(DF_POWER_MANAGEMENT) & 2) == 0) ;
-	df_set_crt_enable(option);
+        if (pGeode->Output & OUTPUT_PANEL)
+            while ((READ_VID32(DF_POWER_MANAGEMENT) & 2) == 0);
+        df_set_crt_enable(option);
     }
 }
 
@@ -107,7 +106,7 @@ lx_set_panel_mode(VG_DISPLAY_MODE * mode, DisplayModePtr pMode)
     mode->vblankend_even = pMode->VTotal;
     mode->vtotal_even = pMode->VTotal;
 
-    mode->frequency = (int)((pMode->Clock / 1000.0) * 0x10000);
+    mode->frequency = (int) ((pMode->Clock / 1000.0) * 0x10000);
 
     /* In panel mode, Cimarron purposely swizzles these,
      * so we swizzle them first  */
@@ -148,7 +147,7 @@ lx_set_crt_mode(VG_DISPLAY_MODE * mode, DisplayModePtr pMode)
     mode->vblankend_even = pMode->CrtcVBlankEnd;
     mode->vtotal_even = pMode->CrtcVTotal;
 
-    mode->frequency = (int)((pMode->Clock / 1000.0) * 0x10000);
+    mode->frequency = (int) ((pMode->Clock / 1000.0) * 0x10000);
 
     hsync = (pMode->Flags & V_NHSYNC) ? 1 : 0;
     vsync = (pMode->Flags & V_NVSYNC) ? 1 : 0;
@@ -169,15 +168,15 @@ lx_set_mode(ScrnInfoPtr pScrni, DisplayModePtr pMode, int bpp)
     mode.flags |= pGeode->Output & OUTPUT_CRT ? VG_MODEFLAG_CRT_AND_FP : 0;
 
     if (pGeode->Output & OUTPUT_PANEL) {
-	mode.flags |= VG_MODEFLAG_PANELOUT;
-	if (pGeode->Output & OUTPUT_CRT)
-	    mode.flags |= VG_MODEFLAG_CRT_AND_FP;
+        mode.flags |= VG_MODEFLAG_PANELOUT;
+        if (pGeode->Output & OUTPUT_CRT)
+            mode.flags |= VG_MODEFLAG_CRT_AND_FP;
     }
 
     if (pGeode->Output & OUTPUT_PANEL && pGeode->Scale)
-	lx_set_panel_mode(&mode, pGeode->panelMode);
+        lx_set_panel_mode(&mode, pGeode->panelMode);
     else
-	lx_set_crt_mode(&mode, pMode);
+        lx_set_crt_mode(&mode, pMode);
 
     mode.src_width = pMode->HDisplay;
     mode.src_height = pMode->VDisplay;
@@ -196,24 +195,24 @@ lx_crtc_dpms(xf86CrtcPtr crtc, int mode)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pGeode->Output & OUTPUT_DCON)
-	DCONDPMSSet(pScrni, mode);
+        DCONDPMSSet(pScrni, mode);
 
     switch (mode) {
     case DPMSModeOn:
-	lx_enable_dac_power(pScrni, 1);
-	break;
+        lx_enable_dac_power(pScrni, 1);
+        break;
 
     case DPMSModeStandby:
-	lx_disable_dac_power(pScrni, DF_CRT_STANDBY);
-	break;
+        lx_disable_dac_power(pScrni, DF_CRT_STANDBY);
+        break;
 
     case DPMSModeSuspend:
-	lx_disable_dac_power(pScrni, DF_CRT_SUSPEND);
-	break;
+        lx_disable_dac_power(pScrni, DF_CRT_SUSPEND);
+        break;
 
     case DPMSModeOff:
-	lx_disable_dac_power(pScrni, DF_CRT_DISABLE);
-	break;
+        lx_disable_dac_power(pScrni, DF_CRT_DISABLE);
+        break;
     }
 }
 
@@ -240,7 +239,7 @@ lx_crtc_prepare(xf86CrtcPtr crtc)
     df_get_video_enable(&lx_crtc->video_enable, &lx_crtc->video_flags);
 
     if (lx_crtc->video_enable)
-	df_set_video_enable(0, 0);
+        df_set_video_enable(0, 0);
 
     /* Turn off compression */
     vg_set_compression_enable(0);
@@ -254,14 +253,14 @@ lx_crtc_prepare(xf86CrtcPtr crtc)
 
 static Bool
 lx_crtc_mode_fixup(xf86CrtcPtr crtc, DisplayModePtr mode,
-    DisplayModePtr adjusted_mode)
+                   DisplayModePtr adjusted_mode)
 {
     return TRUE;
 }
 
 static void
 lx_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
-    DisplayModePtr adjusted_mode, int x, int y)
+                 DisplayModePtr adjusted_mode, int x, int y)
 {
     ScrnInfoPtr pScrni = crtc->scrn;
     GeodeRec *pGeode = GEODEPTR(pScrni);
@@ -275,7 +274,7 @@ lx_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
      */
 
     if (lx_set_mode(pScrni, adjusted_mode, pScrni->bitsPerPixel))
-	ErrorF("ERROR!  Unable to set the mode!\n");
+        ErrorF("ERROR!  Unable to set the mode!\n");
 
     /* The output gets turned in in the output code as
      * per convention */
@@ -284,19 +283,19 @@ lx_crtc_mode_set(xf86CrtcPtr crtc, DisplayModePtr mode,
      * the retire frame as dirty.
      */
     if (crtc->rotatedData != NULL) {
-	rpitch = pScrni->displayWidth * (pScrni->bitsPerPixel / 8);
-	vg_set_display_pitch(rpitch);
+        rpitch = pScrni->displayWidth * (pScrni->bitsPerPixel / 8);
+        vg_set_display_pitch(rpitch);
     }
     else
-    vg_set_display_pitch(pGeode->Pitch);
+        vg_set_display_pitch(pGeode->Pitch);
     gp_set_bpp(pScrni->bitsPerPixel);
 
     /* Set the acceleration offset if we are drawing to a shadow */
     if (crtc->rotatedData != NULL)
-	vg_set_display_offset((unsigned int)((char *)crtc->rotatedData -
-		(char *)pGeode->FBBase));
+        vg_set_display_offset((unsigned int) ((char *) crtc->rotatedData -
+                                              (char *) pGeode->FBBase));
     else
-	vg_set_display_offset(0);
+        vg_set_display_offset(0);
 
     /* FIXME: Whats up with X and Y?  Does that come into play
      * here? */
@@ -319,29 +318,29 @@ lx_crtc_commit(xf86CrtcPtr crtc)
     /* Turn on compression */
 
     if (pGeode->Compression) {
-	vg_configure_compression(&(pGeode->CBData));
-	vg_set_compression_enable(1);
+        vg_configure_compression(&(pGeode->CBData));
+        vg_set_compression_enable(1);
     }
 
     /* Load the cursor */
     if (crtc->scrn->pScreen != NULL) {
-	xf86_reload_cursors(crtc->scrn->pScreen);
-	crtc->funcs->hide_cursor(crtc);
-	crtc->cursor_shown = FALSE;
+        xf86_reload_cursors(crtc->scrn->pScreen);
+        crtc->funcs->hide_cursor(crtc);
+        crtc->cursor_shown = FALSE;
     }
 
     /* Renable the video */
 
     if (lx_crtc->video_enable)
-	df_set_video_enable(lx_crtc->video_enable, lx_crtc->video_flags);
+        df_set_video_enable(lx_crtc->video_enable, lx_crtc->video_flags);
 
     lx_crtc->video_enable = 0;
     lx_crtc->video_flags = 0;
 }
 
 static void
-lx_crtc_gamma_set(xf86CrtcPtr crtc, CARD16 * red, CARD16 * green,
-    CARD16 * blue, int size)
+lx_crtc_gamma_set(xf86CrtcPtr crtc, CARD16 *red, CARD16 *green,
+                  CARD16 *blue, int size)
 {
     unsigned int dcfg;
     int i;
@@ -355,12 +354,13 @@ lx_crtc_gamma_set(xf86CrtcPtr crtc, CARD16 * red, CARD16 * green,
 
     for (i = 0; i < 256; i++) {
         unsigned int val;
+
         (*red) &= 0xff00;
         (*green) &= 0xff00;
         (*blue) &= 0xff00;
         val = (*(red++) << 8) | *(green++) | (*(blue++) >> 8);
 
-	df_set_video_palette_entry(i, val);
+        df_set_video_palette_entry(i, val);
     }
 
     /* df_set_video_palette_entry automatically turns on
@@ -384,27 +384,25 @@ lx_crtc_gamma_set(xf86CrtcPtr crtc, CARD16 * red, CARD16 * green,
      */
 static PixmapPtr
 lx_create_bo_pixmap(ScreenPtr pScreen,
-		int width, int height,
-		int depth, int bpp,
-		int pitch, pointer pPixData)
+                    int width, int height,
+                    int depth, int bpp, int pitch, pointer pPixData)
 {
     PixmapPtr pixmap;
 
-
 #if XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,5,0,0,0)
-    pixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, depth, 0);
+    pixmap = (*pScreen->CreatePixmap) (pScreen, 0, 0, depth, 0);
 #else
-    pixmap = (*pScreen->CreatePixmap)(pScreen, 0, 0, depth);
+    pixmap = (*pScreen->CreatePixmap) (pScreen, 0, 0, depth);
 #endif
 
     if (!pixmap)
-	return NULL;
-    if (!(*pScreen->ModifyPixmapHeader)(pixmap, width, height,
-					depth, bpp, pitch, pPixData)) {
-    /* ModifyPixmapHeader failed, so we can't use it as scratch pixmap
-     */
-	(*pScreen->DestroyPixmap)(pixmap);
-	return NULL;
+        return NULL;
+    if (!(*pScreen->ModifyPixmapHeader) (pixmap, width, height,
+                                         depth, bpp, pitch, pPixData)) {
+        /* ModifyPixmapHeader failed, so we can't use it as scratch pixmap
+         */
+        (*pScreen->DestroyPixmap) (pixmap);
+        return NULL;
     }
 
     return pixmap;
@@ -415,7 +413,7 @@ lx_destory_bo_pixmap(PixmapPtr pixmap)
 {
     ScreenPtr pScreen = pixmap->drawable.pScreen;
 
-    (*pScreen->DestroyPixmap)(pixmap);
+    (*pScreen->DestroyPixmap) (pixmap);
 }
 
     /* Allocates shadow memory, and allocating a new space for Rotation.
@@ -429,19 +427,18 @@ LXAllocShadow(ScrnInfoPtr pScrni, int size)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pGeode->shadowArea) {
-	if (pGeode->shadowArea->size != size) {
-		exaOffscreenFree(pScrni->pScreen, pGeode->shadowArea);
-		pGeode->shadowArea = NULL;
-	}
+        if (pGeode->shadowArea->size != size) {
+            exaOffscreenFree(pScrni->pScreen, pGeode->shadowArea);
+            pGeode->shadowArea = NULL;
+        }
     }
 
     if (pGeode->shadowArea == NULL) {
-	pGeode->shadowArea =
-		exaOffscreenAlloc(pScrni->pScreen, size, 4, TRUE,
-		NULL, NULL);
+        pGeode->shadowArea =
+            exaOffscreenAlloc(pScrni->pScreen, size, 4, TRUE, NULL, NULL);
 
-	if (pGeode->shadowArea == NULL)
-		return FALSE;
+        if (pGeode->shadowArea == NULL)
+            return FALSE;
     }
 
     pScrni->fbOffset = pGeode->shadowArea->offset;
@@ -460,13 +457,13 @@ lx_crtc_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
 
     /* Allocate shadow memory */
     if (LXAllocShadow(pScrni, size) == FALSE) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "Couldn't allocate the shadow memory for rotation\n");
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    " You need 0x%x bytes, but only 0x%x bytes are available\n",
-	    size, GeodeOffscreenFreeSize(pGeode));
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "Couldn't allocate the shadow memory for rotation\n");
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   " You need 0x%x bytes, but only 0x%x bytes are available\n",
+                   size, GeodeOffscreenFreeSize(pGeode));
 
-	return NULL;
+        return NULL;
     }
 
     memset(pGeode->FBBase + pGeode->shadowArea->offset, 0, size);
@@ -482,15 +479,15 @@ lx_crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
 
     rpitch = pScrni->displayWidth * (pScrni->bitsPerPixel / 8);
     if (!data)
-	data = lx_crtc_shadow_allocate(crtc, width, height);
+        data = lx_crtc_shadow_allocate(crtc, width, height);
 
     rpixmap = lx_create_bo_pixmap(pScrni->pScreen,
-	width, height, pScrni->depth, pScrni->bitsPerPixel, rpitch,
-	data);
+                                  width, height, pScrni->depth,
+                                  pScrni->bitsPerPixel, rpitch, data);
 
     if (rpixmap == NULL) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "Couldn't allocate shadow pixmap for rotated CRTC\n");
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "Couldn't allocate shadow pixmap for rotated CRTC\n");
     }
 
     return rpixmap;
@@ -503,15 +500,15 @@ lx_crtc_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rpixmap, void *data)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (rpixmap)
-	lx_destory_bo_pixmap(rpixmap);
+        lx_destory_bo_pixmap(rpixmap);
 
     /* Free shadow memory */
     if (data) {
-	gp_wait_until_idle();
-	if (pGeode->shadowArea != NULL) {
-	exaOffscreenFree(pScrni->pScreen, pGeode->shadowArea);
-	pGeode->shadowArea = NULL;
-	}
+        gp_wait_until_idle();
+        if (pGeode->shadowArea != NULL) {
+            exaOffscreenFree(pScrni->pScreen, pGeode->shadowArea);
+            pGeode->shadowArea = NULL;
+        }
     }
 }
 
@@ -525,6 +522,7 @@ static void
 lx_crtc_set_cursor_position(xf86CrtcPtr crtc, int x, int y)
 {
     VG_PANNING_COORDINATES panning;
+
     vg_set_cursor_position(x, y, &panning);
 }
 
@@ -574,16 +572,16 @@ LXSetupCrtc(ScrnInfoPtr pScrni)
     crtc = xf86CrtcCreate(pScrni, &lx_crtc_funcs);
 
     if (crtc == NULL) {
-	ErrorF("ERROR - failed to create a CRTC\n");
-	return;
+        ErrorF("ERROR - failed to create a CRTC\n");
+        return;
     }
 
     lxpriv = xnfcalloc(1, sizeof(LXCrtcPrivateRec));
 
     if (!lxpriv) {
-	xf86CrtcDestroy(crtc);
-	ErrorF("unable to allocate memory for lxpriv\n");
-	return;
+        xf86CrtcDestroy(crtc);
+        ErrorF("unable to allocate memory for lxpriv\n");
+        return;
     }
 
     crtc->driver_private = lxpriv;
diff --git a/src/lx_driver.c b/src/lx_driver.c
index 146d7c3..44ab2a4 100644
--- a/src/lx_driver.c
+++ b/src/lx_driver.c
@@ -80,7 +80,7 @@ LXSaveScreen(ScreenPtr pScrn, int mode)
     GeodePtr pGeode = GEODEPTR(pScrni);
 
     if (pGeode->useVGA && !pScrni->vtSema)
-	return vgaHWSaveScreen(pScrn, mode);
+        return vgaHWSaveScreen(pScrn, mode);
 
     return TRUE;
 }
@@ -123,11 +123,11 @@ static void
 LXReadMSR(unsigned long addr, unsigned long *lo, unsigned long *hi)
 {
     if (GeodeReadMSR(addr, lo, hi) == -1) {
-	unsigned int l, h;
+        unsigned int l, h;
 
-	LX_MSR_READ(addr, l, h);
-	*lo = l;
-	*hi = h;
+        LX_MSR_READ(addr, l, h);
+        *lo = l;
+        *hi = h;
     }
 }
 
@@ -135,7 +135,7 @@ static void
 LXWriteMSR(unsigned long addr, unsigned long lo, unsigned long hi)
 {
     if (GeodeWriteMSR(addr, lo, hi) == -1)
-	LX_MSR_WRITE(addr, lo, hi);
+        LX_MSR_WRITE(addr, lo, hi);
 }
 
 static unsigned int
@@ -144,30 +144,29 @@ LXCalcPitch(ScrnInfoPtr pScrni)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pGeode->tryCompression)
-	return
-	    GeodeCalculatePitchBytes(pScrni->virtualX, pScrni->bitsPerPixel);
+        return GeodeCalculatePitchBytes(pScrni->virtualX, pScrni->bitsPerPixel);
     else
-	return ((pScrni->virtualX + 3) & ~3) * (pScrni->bitsPerPixel >> 3);
+        return ((pScrni->virtualX + 3) & ~3) * (pScrni->bitsPerPixel >> 3);
 }
 
 #ifdef XSERVER_LIBPCIACCESS
 static inline void *
 map_pci_mem(ScrnInfoPtr pScrni, int vram,
-    struct pci_device *dev, int bar, int size)
+            struct pci_device *dev, int bar, int size)
 {
     void *ptr;
-    void **result = (void **)&ptr;
+    void **result = (void **) &ptr;
     int map_size = size ? size : dev->regions[bar].size;
 
     int err = pci_device_map_range(dev,
-	dev->regions[bar].base_addr,
-	map_size,
-	PCI_DEV_MAP_FLAG_WRITABLE |
-	(vram ? PCI_DEV_MAP_FLAG_WRITE_COMBINE : 0),
-	result);
+                                   dev->regions[bar].base_addr,
+                                   map_size,
+                                   PCI_DEV_MAP_FLAG_WRITABLE |
+                                   (vram ? PCI_DEV_MAP_FLAG_WRITE_COMBINE : 0),
+                                   result);
 
     if (err)
-	return NULL;
+        return NULL;
     return ptr;
 }
 
@@ -193,41 +192,47 @@ LXMapMem(ScrnInfoPtr pScrni)
 
     tag = pciTag(pci->bus, pci->device, pci->func);
 
-    cim_gp_ptr = (unsigned char *)xf86MapPciMem(index, VIDMEM_MMIO,
-	tag, pci->memBase[1], LX_GP_REG_SIZE);
+    cim_gp_ptr = (unsigned char *) xf86MapPciMem(index, VIDMEM_MMIO,
+                                                 tag, pci->memBase[1],
+                                                 LX_GP_REG_SIZE);
 
-    cim_vg_ptr = (unsigned char *)xf86MapPciMem(index, VIDMEM_MMIO,
-	tag, pci->memBase[2], LX_VG_REG_SIZE);
+    cim_vg_ptr = (unsigned char *) xf86MapPciMem(index, VIDMEM_MMIO,
+                                                 tag, pci->memBase[2],
+                                                 LX_VG_REG_SIZE);
 
-    cim_vid_ptr = (unsigned char *)xf86MapPciMem(index, VIDMEM_MMIO,
-	tag, pci->memBase[3], LX_VID_REG_SIZE);
+    cim_vid_ptr = (unsigned char *) xf86MapPciMem(index, VIDMEM_MMIO,
+                                                  tag, pci->memBase[3],
+                                                  LX_VID_REG_SIZE);
 
-    cim_vip_ptr = (unsigned char *)xf86MapPciMem(index, VIDMEM_MMIO,
-	tag, pci->memBase[4], LX_VIP_REG_SIZE);
+    cim_vip_ptr = (unsigned char *) xf86MapPciMem(index, VIDMEM_MMIO,
+                                                  tag, pci->memBase[4],
+                                                  LX_VIP_REG_SIZE);
 
-    cim_fb_ptr = (unsigned char *)xf86MapPciMem(index, VIDMEM_FRAMEBUFFER,
-	tag, pci->memBase[0], pGeode->FBAvail + CIM_CMD_BFR_SZ);
+    cim_fb_ptr = (unsigned char *) xf86MapPciMem(index, VIDMEM_FRAMEBUFFER,
+                                                 tag, pci->memBase[0],
+                                                 pGeode->FBAvail +
+                                                 CIM_CMD_BFR_SZ);
 #else
     cim_gp_ptr = map_pci_mem(pScrni, 0, pci, 1, LX_GP_REG_SIZE);
     cim_vg_ptr = map_pci_mem(pScrni, 0, pci, 2, LX_VG_REG_SIZE);
     cim_vid_ptr = map_pci_mem(pScrni, 0, pci, 3, LX_VID_REG_SIZE);
     cim_vip_ptr = map_pci_mem(pScrni, 0, pci, 4, LX_VIP_REG_SIZE);
     cim_fb_ptr =
-	map_pci_mem(pScrni, 1, pci, 0, pGeode->FBAvail + CIM_CMD_BFR_SZ);
+        map_pci_mem(pScrni, 1, pci, 0, pGeode->FBAvail + CIM_CMD_BFR_SZ);
 #endif
 
     if (pScrni->memPhysBase == 0)
-	pScrni->memPhysBase = PCI_REGION_BASE(pci, 0, REGION_MEM);
+        pScrni->memPhysBase = PCI_REGION_BASE(pci, 0, REGION_MEM);
 
     cmd_bfr_phys = PCI_REGION_BASE(pci, 0, REGION_MEM) + pGeode->CmdBfrOffset;
     cim_cmd_base_ptr = cim_fb_ptr + pGeode->CmdBfrOffset;
 
     if (!cim_gp_ptr || !cim_vg_ptr || !cim_vid_ptr || !cim_fb_ptr ||
-	!cim_vip_ptr)
-	return FALSE;
+        !cim_vip_ptr)
+        return FALSE;
 
     gp_set_frame_buffer_base(PCI_REGION_BASE(pci, 0, REGION_MEM),
-	pGeode->FBAvail);
+                             pGeode->FBAvail);
     gp_set_command_buffer_base(cmd_bfr_phys, 0, pGeode->CmdBfrSize);
 
     XpressROMPtr = xf86MapVidMem(index, VIDMEM_FRAMEBUFFER, 0xF0000, 0x10000);
@@ -235,10 +240,10 @@ LXMapMem(ScrnInfoPtr pScrni)
     pGeode->FBBase = cim_fb_ptr;
 
     if (!pGeode->NoAccel)
-	pGeode->pExa->memoryBase = pGeode->FBBase;
+        pGeode->pExa->memoryBase = pGeode->FBBase;
 
     xf86DrvMsg(index, X_INFO, "Geode LX video memory %x bytes at %p\n",
-	pGeode->FBAvail, pGeode->FBBase);
+               pGeode->FBAvail, pGeode->FBBase);
 
     return TRUE;
 }
@@ -256,11 +261,11 @@ LXCheckVGA(ScrnInfoPtr pScrni)
     int ret;
 
     ptr =
-	xf86MapVidMem(pScrni->scrnIndex, VIDMEM_FRAMEBUFFER, 0xC001E,
-	strlen(vgasig));
+        xf86MapVidMem(pScrni->scrnIndex, VIDMEM_FRAMEBUFFER, 0xC001E,
+                      strlen(vgasig));
 
     if (ptr == NULL)
-	return FALSE;
+        return FALSE;
 
     ret = memcmp(ptr, vgasig, strlen(vgasig));
     xf86UnMapVidMem(pScrni->scrnIndex, (pointer) ptr, strlen(vgasig));
@@ -288,34 +293,34 @@ LXPreInit(ScrnInfoPtr pScrni, int flags)
     char *s;
 
     if (pScrni->numEntities != 1)
-	return FALSE;
+        return FALSE;
 
     pEnt = xf86GetEntityInfo(pScrni->entityList[0]);
 #ifndef XSERVER_LIBPCIACCESS
     if (pEnt->resources)
-	return FALSE;
+        return FALSE;
 #endif
     if (flags & PROBE_DETECT) {
-	GeodeProbeDDC(pScrni, pEnt->index);
-	return TRUE;
+        GeodeProbeDDC(pScrni, pEnt->index);
+        return TRUE;
     }
 
     pGeode = pScrni->driverPrivate = xnfcalloc(1, sizeof(GeodeRec));
 
     if (pGeode == NULL)
-	return FALSE;
+        return FALSE;
 
     pGeode->useVGA = LXCheckVGA(pScrni);
     pGeode->VGAActive = FALSE;
     pGeode->pEnt = pEnt;
 
     if (pGeode->useVGA) {
-	if (!xf86LoadSubModule(pScrni, "vgahw") || !vgaHWGetHWRec(pScrni))
-	    pGeode->useVGA = FALSE;
-	else
-	    vgaHWSetStdFuncs(VGAHWPTR(pScrni));
+        if (!xf86LoadSubModule(pScrni, "vgahw") || !vgaHWGetHWRec(pScrni))
+            pGeode->useVGA = FALSE;
+        else
+            vgaHWSetStdFuncs(VGAHWPTR(pScrni));
 
-	pGeode->vesa = calloc(1, sizeof(VESARec));
+        pGeode->vesa = calloc(1, sizeof(VESARec));
     }
 
     cim_rdmsr = LXReadMSR;
@@ -334,39 +339,40 @@ LXPreInit(ScrnInfoPtr pScrni, int flags)
     pScrni->monitor = pScrni->confScreen->monitor;
 
     if (!xf86SetDepthBpp(pScrni, 16, 16, 16, Support24bppFb | Support32bppFb))
-	return FALSE;
+        return FALSE;
 
     switch (pScrni->depth) {
     case 8:
-	pScrni->rgbBits = 8;
+        pScrni->rgbBits = 8;
     case 16:
     case 24:
     case 32:
-	break;
+        break;
     default:
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "The driver does not support %d as a depth.\n", pScrni->depth);
-	return FALSE;
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "The driver does not support %d as a depth.\n",
+                   pScrni->depth);
+        return FALSE;
     }
 
     xf86PrintDepthBpp(pScrni);
 
     if (!xf86SetWeight(pScrni, defaultWeight, defaultWeight))
-	return FALSE;
+        return FALSE;
 
     if (!xf86SetDefaultVisual(pScrni, -1))
-	return FALSE;
+        return FALSE;
 
     /*
      * If the driver can do gamma correction, it should call xf86SetGamma()
      * here.
      */
     {
-	Gamma zeros = { 0.0, 0.0, 0.0 };
+        Gamma zeros = { 0.0, 0.0, 0.0 };
 
-	if (!xf86SetGamma(pScrni, zeros)) {
-	    return FALSE;
-	}
+        if (!xf86SetGamma(pScrni, zeros)) {
+            return FALSE;
+        }
     }
 
     pScrni->progClock = TRUE;
@@ -383,59 +389,57 @@ LXPreInit(ScrnInfoPtr pScrni, int flags)
 #if (EXA_VERSION_MAJOR < 2)
     pGeode->NoAccel = TRUE;
     xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	"*** This driver was compiled with EXA version %d\n");
+               "*** This driver was compiled with EXA version %d\n");
     xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	"*** we need version 2 or greater\n");
+               "*** we need version 2 or greater\n");
     xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	"*** All accelerations are being turned off.\n");
+               "*** All accelerations are being turned off.\n");
 #else
     pGeode->NoAccel = FALSE;
 #endif
 
     pGeode->exaBfrSz = DEFAULT_EXA_SCRATCH_BFRSZ;
 
-    xf86GetOptValBool(GeodeOptions, LX_OPTION_HW_CURSOR,
-	&pGeode->tryHWCursor);
+    xf86GetOptValBool(GeodeOptions, LX_OPTION_HW_CURSOR, &pGeode->tryHWCursor);
 
     if (!xf86GetOptValInteger(GeodeOptions, LX_OPTION_FBSIZE,
-	    (int *)&(pGeode->FBAvail)))
-	pGeode->FBAvail = 0;
+                              (int *) &(pGeode->FBAvail)))
+        pGeode->FBAvail = 0;
 
     /* For compatability - allow SWCursor too */
 
     if (xf86ReturnOptValBool(GeodeOptions, LX_OPTION_SW_CURSOR, FALSE))
-	pGeode->tryHWCursor = FALSE;
+        pGeode->tryHWCursor = FALSE;
 
     if (xf86ReturnOptValBool(GeodeOptions, LX_OPTION_NOCOMPRESSION, FALSE))
-	pGeode->tryCompression = FALSE;
+        pGeode->tryCompression = FALSE;
 
     if (xf86ReturnOptValBool(GeodeOptions, LX_OPTION_NOACCEL, FALSE))
-	pGeode->NoAccel = TRUE;
+        pGeode->NoAccel = TRUE;
 
     pGeode->rotation = RR_Rotate_0;
 
     if ((s = xf86GetOptValString(GeodeOptions, LX_OPTION_ROTATE))) {
 
-	if (!xf86NameCmp(s, "LEFT"))
-	    pGeode->rotation = RR_Rotate_90;
-	else if (!xf86NameCmp(s, "INVERT"))
-	    pGeode->rotation = RR_Rotate_180;
-	else if (!xf86NameCmp(s, "CCW"))
-	    pGeode->rotation = RR_Rotate_270;
-	else
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Invalid rotation %s.\n", s);
+        if (!xf86NameCmp(s, "LEFT"))
+            pGeode->rotation = RR_Rotate_90;
+        else if (!xf86NameCmp(s, "INVERT"))
+            pGeode->rotation = RR_Rotate_180;
+        else if (!xf86NameCmp(s, "CCW"))
+            pGeode->rotation = RR_Rotate_270;
+        else
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR, "Invalid rotation %s.\n", s);
     }
 
     xf86GetOptValInteger(GeodeOptions, LX_OPTION_EXA_SCRATCH_BFRSZ,
-	(int *)&(pGeode->exaBfrSz));
+                         (int *) &(pGeode->exaBfrSz));
 
     if (pGeode->exaBfrSz <= 0)
-	pGeode->exaBfrSz = 0;
+        pGeode->exaBfrSz = 0;
 
     if (pGeode->Output & OUTPUT_PANEL) {
-	if (xf86ReturnOptValBool(GeodeOptions, LX_OPTION_NOPANEL, FALSE))
-	    pGeode->Output &= ~OUTPUT_PANEL;
+        if (xf86ReturnOptValBool(GeodeOptions, LX_OPTION_NOPANEL, FALSE))
+            pGeode->Output &= ~OUTPUT_PANEL;
     }
 
     /* Panel detection code -
@@ -446,53 +450,54 @@ LXPreInit(ScrnInfoPtr pScrni, int flags)
      */
 
     if (dcon_init(pScrni)) {
-	pGeode->Output = OUTPUT_PANEL | OUTPUT_DCON;
-    } else if (pGeode->Output & OUTPUT_PANEL) {
-	char *pmode = xf86GetOptValString(GeodeOptions, LX_OPTION_PANEL_MODE);
+        pGeode->Output = OUTPUT_PANEL | OUTPUT_DCON;
+    }
+    else if (pGeode->Output & OUTPUT_PANEL) {
+        char *pmode = xf86GetOptValString(GeodeOptions, LX_OPTION_PANEL_MODE);
 
-	if (pmode != NULL)
-	    pGeode->panelMode = LXGetManualPanelMode(pmode);
+        if (pmode != NULL)
+            pGeode->panelMode = LXGetManualPanelMode(pmode);
 
-	if (pGeode->panelMode == NULL)
-	    pGeode->panelMode = LXGetLegacyPanelMode(pScrni);
+        if (pGeode->panelMode == NULL)
+            pGeode->panelMode = LXGetLegacyPanelMode(pScrni);
 
-	if (pGeode->panelMode == NULL)
-	    pGeode->Output &= ~OUTPUT_PANEL;
+        if (pGeode->panelMode == NULL)
+            pGeode->Output &= ~OUTPUT_PANEL;
     }
 
     /* Default to turn scaling on for panels */
 
     if (pGeode->Output & OUTPUT_PANEL)
-	pGeode->Scale = TRUE;
+        pGeode->Scale = TRUE;
 
     xf86DrvMsg(pScrni->scrnIndex, X_INFO, "LX output options:\n");
     xf86DrvMsg(pScrni->scrnIndex, X_INFO, " CRT: %s\n",
-	pGeode->Output & OUTPUT_CRT ? "YES" : "NO");
+               pGeode->Output & OUTPUT_CRT ? "YES" : "NO");
 
     xf86DrvMsg(pScrni->scrnIndex, X_INFO, " PANEL: %s\n",
-	pGeode->Output & OUTPUT_PANEL ? "YES" : "NO");
+               pGeode->Output & OUTPUT_PANEL ? "YES" : "NO");
 
     xf86DrvMsg(pScrni->scrnIndex, X_INFO, " DCON: %s\n",
-	pGeode->Output & OUTPUT_DCON ? "YES" : "NO");
+               pGeode->Output & OUTPUT_DCON ? "YES" : "NO");
 
     xf86DrvMsg(pScrni->scrnIndex, X_INFO, " VGA: %s\n",
-	pGeode->useVGA ? "YES" : "NO");
+               pGeode->useVGA ? "YES" : "NO");
 
     /* Set up VGA */
 
     if (pGeode->useVGA) {
-	VESARec *pVesa;
+        VESARec *pVesa;
 
-	if (!xf86LoadSubModule(pScrni, "int10"))
-	    return FALSE;
+        if (!xf86LoadSubModule(pScrni, "int10"))
+            return FALSE;
 
-	pVesa = pGeode->vesa;
+        pVesa = pGeode->vesa;
 
-	if ((pVesa->pInt = xf86InitInt10(pGeode->pEnt->index)) == NULL) {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Unable to initialize 1NT10 support\n");
-	    pGeode->useVGA = FALSE;
-	}
+        if ((pVesa->pInt = xf86InitInt10(pGeode->pEnt->index)) == NULL) {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Unable to initialize 1NT10 support\n");
+            pGeode->useVGA = FALSE;
+        }
     }
 
     /* Read the amount of framebuffer memory */
@@ -501,36 +506,36 @@ LXPreInit(ScrnInfoPtr pScrni, int flags)
      */
 
     if (pGeode->FBAvail == 0) {
-	if (GeodeGetSizeFromFB(&pGeode->FBAvail)) {
-	    unsigned long value;
+        if (GeodeGetSizeFromFB(&pGeode->FBAvail)) {
+            unsigned long value;
 
-	    cim_outw(0xAC1C, 0xFC53);
-	    cim_outw(0xAC1C, 0x0200);
+            cim_outw(0xAC1C, 0xFC53);
+            cim_outw(0xAC1C, 0x0200);
 
-	    value = (unsigned long)(cim_inw(0xAC1E)) & 0xFE;
-	    pGeode->FBAvail = value << 20;
-	}
+            value = (unsigned long) (cim_inw(0xAC1E)) & 0xFE;
+            pGeode->FBAvail = value << 20;
+        }
     }
 
     pScrni->fbOffset = 0;
 
     if (pGeode->pEnt->device->videoRam == 0)
-	pScrni->videoRam = pGeode->FBAvail / 1024;
+        pScrni->videoRam = pGeode->FBAvail / 1024;
     else {
-	pScrni->videoRam = pGeode->pEnt->device->videoRam;
-	pGeode->FBAvail = pScrni->videoRam << 10;
+        pScrni->videoRam = pGeode->pEnt->device->videoRam;
+        pGeode->FBAvail = pScrni->videoRam << 10;
     }
 
     /* If we have <= 16Mb of memory then compression is going
        to hurt - so warn and disable */
 
-    if (pGeode->tryCompression &&
-	pGeode->FBAvail <= 0x1000000) {
-    	xf86DrvMsg(pScrni->scrnIndex, X_INFO,
-	"%x bytes of video memory is less then optimal\n", pGeode->FBAvail);
-    	xf86DrvMsg(pScrni->scrnIndex, X_INFO,
-	"when compression is on. Disabling compression.\n");
-	pGeode->tryCompression = FALSE;
+    if (pGeode->tryCompression && pGeode->FBAvail <= 0x1000000) {
+        xf86DrvMsg(pScrni->scrnIndex, X_INFO,
+                   "%x bytes of video memory is less then optimal\n",
+                   pGeode->FBAvail);
+        xf86DrvMsg(pScrni->scrnIndex, X_INFO,
+                   "when compression is on. Disabling compression.\n");
+        pGeode->tryCompression = FALSE;
     }
 
     /* Carve out some memory for the command buffer */
@@ -552,8 +557,8 @@ LXPreInit(ScrnInfoPtr pScrni, int flags)
     LXSetupOutput(pScrni);
 
     if (!xf86InitialConfiguration(pScrni, FALSE)) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR, "No valid modes.\n");
-	return FALSE;
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR, "No valid modes.\n");
+        return FALSE;
     }
 
     xf86PrintModes(pScrni);
@@ -567,18 +572,18 @@ LXPreInit(ScrnInfoPtr pScrni, int flags)
     /* Load the modules we'll need */
 
     if (xf86LoadSubModule(pScrni, "fb") == NULL) {
-	return FALSE;
+        return FALSE;
     }
 
     if (!pGeode->NoAccel) {
-	if (!xf86LoadSubModule(pScrni, "exa"))
-	    return FALSE;
+        if (!xf86LoadSubModule(pScrni, "exa"))
+            return FALSE;
     }
 #ifndef XSERVER_LIBPCIACCESS
     if (xf86RegisterResources(pGeode->pEnt->index, NULL, ResExclusive)) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "Couldn't register the resources.\n");
-	return FALSE;
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "Couldn't register the resources.\n");
+        return FALSE;
     }
 #endif
     return TRUE;
@@ -590,11 +595,11 @@ LXRestore(ScrnInfoPtr pScrni)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pGeode->useVGA) {
-	vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
+        vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
 
-	vgaHWProtect(pScrni, TRUE);
-	vgaHWRestore(pScrni, &pvgaHW->SavedReg, VGA_SR_ALL);
-	vgaHWProtect(pScrni, FALSE);
+        vgaHWProtect(pScrni, TRUE);
+        vgaHWRestore(pScrni, &pvgaHW->SavedReg, VGA_SR_ALL);
+        vgaHWProtect(pScrni, FALSE);
     }
 }
 
@@ -604,10 +609,8 @@ LXUnmapMem(ScrnInfoPtr pScrni)
 #ifndef XSERVER_LIBPCIACCESS
     xf86UnMapVidMem(pScrni->scrnIndex, (pointer) cim_gp_ptr, LX_GP_REG_SIZE);
     xf86UnMapVidMem(pScrni->scrnIndex, (pointer) cim_vg_ptr, LX_VG_REG_SIZE);
-    xf86UnMapVidMem(pScrni->scrnIndex, (pointer) cim_vid_ptr,
-	LX_VID_REG_SIZE);
-    xf86UnMapVidMem(pScrni->scrnIndex, (pointer) cim_vip_ptr,
-	LX_VIP_REG_SIZE);
+    xf86UnMapVidMem(pScrni->scrnIndex, (pointer) cim_vid_ptr, LX_VID_REG_SIZE);
+    xf86UnMapVidMem(pScrni->scrnIndex, (pointer) cim_vip_ptr, LX_VIP_REG_SIZE);
 #else
     GeodeRec *pGeode = GEODEPTR(pScrni);
     pciVideoPtr pci = xf86GetPciInfoForEntity(pGeode->pEnt->index);
@@ -659,14 +662,14 @@ LXLeaveGraphics(ScrnInfoPtr pScrni)
     gp_wait_until_idle();
 
     vg_set_custom_mode(&(pGeode->FBcimdisplaytiming.vgDisplayMode),
-	pGeode->FBcimdisplaytiming.wBpp);
+                       pGeode->FBcimdisplaytiming.wBpp);
 
     vg_set_compression_enable(0);
 
     /* Restore the previous Compression state */
     if (pGeode->FBCompressionEnable) {
-	vg_configure_compression(&(pGeode->FBCBData));
-	vg_set_compression_enable(1);
+        vg_configure_compression(&(pGeode->FBCBData));
+        vg_set_compression_enable(1);
     }
 
     vg_set_display_pitch(pGeode->FBcimdisplaytiming.wPitch);
@@ -674,16 +677,16 @@ LXLeaveGraphics(ScrnInfoPtr pScrni)
 
     /* Restore Cursor */
     vg_set_cursor_position(pGeode->FBCursor.cursor_x,
-	pGeode->FBCursor.cursor_y, &panning);
+                           pGeode->FBCursor.cursor_y, &panning);
 
     LXRestore(pScrni);
 
     if (pGeode->useVGA && pGeode->VGAActive) {
-	pGeode->vesa->pInt->num = 0x10;
-	pGeode->vesa->pInt->ax = 0x0 | pGeode->FBBIOSMode;
-	pGeode->vesa->pInt->bx = 0;
-	xf86ExecX86int10(pGeode->vesa->pInt);
-	vg_delay_milliseconds(3);
+        pGeode->vesa->pInt->num = 0x10;
+        pGeode->vesa->pInt->ax = 0x0 | pGeode->FBBIOSMode;
+        pGeode->vesa->pInt->bx = 0;
+        xf86ExecX86int10(pGeode->vesa->pInt);
+        vg_delay_milliseconds(3);
     }
 
     pScrni->vtSema = FALSE;
@@ -696,12 +699,12 @@ LXCloseScreen(int scrnIndex, ScreenPtr pScrn)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pScrni->vtSema)
-	LXLeaveGraphics(pScrni);
+        LXLeaveGraphics(pScrni);
 
     if (pGeode->pExa) {
-	exaDriverFini(pScrn);
-	free(pGeode->pExa);
-	pGeode->pExa = NULL;
+        exaDriverFini(pScrn);
+        free(pGeode->pExa);
+        pGeode->pExa = NULL;
     }
 
     /* Unmap the offscreen allocations */
@@ -710,13 +713,13 @@ LXCloseScreen(int scrnIndex, ScreenPtr pScrn)
     LXUnmapMem(pScrni);
 
     if (pGeode->useVGA)
-	vgaHWUnmapMem(pScrni);
+        vgaHWUnmapMem(pScrni);
 
     pScrni->PointerMoved = pGeode->PointerMoved;
     pScrn->CloseScreen = pGeode->CloseScreen;
 
     if (pScrn->CloseScreen)
-	return (*pScrn->CloseScreen) (scrnIndex, pScrn);
+        return (*pScrn->CloseScreen) (scrnIndex, pScrn);
 
     return TRUE;
 }
@@ -732,7 +735,7 @@ LXEnterGraphics(ScreenPtr pScrn, ScrnInfoPtr pScrni)
     gp_wait_until_idle();
 
     vg_get_current_display_mode(&pGeode->FBcimdisplaytiming.vgDisplayMode,
-	&bpp);
+                                &bpp);
 
     pGeode->FBcimdisplaytiming.wBpp = bpp;
     pGeode->FBcimdisplaytiming.wPitch = vg_get_display_pitch();
@@ -740,9 +743,9 @@ LXEnterGraphics(ScreenPtr pScrn, ScrnInfoPtr pScrni)
     pGeode->FBDisplayOffset = vg_get_display_offset();
 
     if (pGeode->useVGA && pGeode->VGAActive) {
-	vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
+        vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
 
-	pGeode->FBBIOSMode = pvgaHW->readCrtc(pvgaHW, 0x040);
+        pGeode->FBBIOSMode = pvgaHW->readCrtc(pvgaHW, 0x040);
     }
 
     pGeode->FBCompressionEnable = vg_get_compression_enable();
@@ -754,33 +757,33 @@ LXEnterGraphics(ScreenPtr pScrn, ScrnInfoPtr pScrni)
     /* Turn off the VGA */
 
     if (pGeode->useVGA) {
-	unsigned short sequencer;
-	vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
+        unsigned short sequencer;
+        vgaHWPtr pvgaHW = VGAHWPTR(pScrni);
 
-	/* Unlock VGA registers */
-	vgaHWUnlock(pvgaHW);
+        /* Unlock VGA registers */
+        vgaHWUnlock(pvgaHW);
 
-	/* Save the current state and setup the current mode */
-	vgaHWSave(pScrni, &VGAHWPTR(pScrni)->SavedReg, VGA_SR_ALL);
+        /* Save the current state and setup the current mode */
+        vgaHWSave(pScrni, &VGAHWPTR(pScrni)->SavedReg, VGA_SR_ALL);
 
-	/* DISABLE VGA SEQUENCER */
-	/* This allows the VGA state machine to terminate. We must delay */
-	/* such that there are no pending MBUS requests.  */
+        /* DISABLE VGA SEQUENCER */
+        /* This allows the VGA state machine to terminate. We must delay */
+        /* such that there are no pending MBUS requests.  */
 
-	cim_outb(DC3_SEQUENCER_INDEX, DC3_SEQUENCER_CLK_MODE);
-	sequencer = cim_inb(DC3_SEQUENCER_DATA);
-	sequencer |= DC3_CLK_MODE_SCREEN_OFF;
-	cim_outb(DC3_SEQUENCER_DATA, sequencer);
+        cim_outb(DC3_SEQUENCER_INDEX, DC3_SEQUENCER_CLK_MODE);
+        sequencer = cim_inb(DC3_SEQUENCER_DATA);
+        sequencer |= DC3_CLK_MODE_SCREEN_OFF;
+        cim_outb(DC3_SEQUENCER_DATA, sequencer);
 
-	vg_delay_milliseconds(1);
+        vg_delay_milliseconds(1);
 
-	/* BLANK THE VGA DISPLAY */
-	cim_outw(DC3_SEQUENCER_INDEX, DC3_SEQUENCER_RESET);
-	sequencer = cim_inb(DC3_SEQUENCER_DATA);
-	sequencer &= ~DC3_RESET_VGA_DISP_ENABLE;
-	cim_outb(DC3_SEQUENCER_DATA, sequencer);
+        /* BLANK THE VGA DISPLAY */
+        cim_outw(DC3_SEQUENCER_INDEX, DC3_SEQUENCER_RESET);
+        sequencer = cim_inb(DC3_SEQUENCER_DATA);
+        sequencer &= ~DC3_RESET_VGA_DISP_ENABLE;
+        cim_outb(DC3_SEQUENCER_DATA, sequencer);
 
-	vg_delay_milliseconds(1);
+        vg_delay_milliseconds(1);
     }
 
     /* Clear the framebuffer */
@@ -788,7 +791,7 @@ LXEnterGraphics(ScreenPtr pScrn, ScrnInfoPtr pScrni)
 
     /* Set the modes */
     if (!xf86SetDesiredModes(pScrni))
-	return FALSE;
+        return FALSE;
 
     pScrni->vtSema = TRUE;
 
@@ -797,17 +800,17 @@ LXEnterGraphics(ScreenPtr pScrn, ScrnInfoPtr pScrni)
 
 static void
 LXLoadPalette(ScrnInfoPtr pScrni,
-    int numColors, int *indizes, LOCO * colors, VisualPtr pVisual)
+              int numColors, int *indizes, LOCO * colors, VisualPtr pVisual)
 {
     int i, index, color;
 
     for (i = 0; i < numColors; i++) {
-	index = indizes[i] & 0xFF;
-	color = (((unsigned long)(colors[index].red & 0xFF)) << 16) |
-	    (((unsigned long)(colors[index].green & 0xFF)) << 8) |
-	    ((unsigned long)(colors[index].blue & 0xFF));
+        index = indizes[i] & 0xFF;
+        color = (((unsigned long) (colors[index].red & 0xFF)) << 16) |
+            (((unsigned long) (colors[index].green & 0xFF)) << 8) |
+            ((unsigned long) (colors[index].blue & 0xFF));
 
-	vg_set_display_palette_entry(index, color);
+        vg_set_display_palette_entry(index, color);
     }
 }
 
@@ -825,65 +828,68 @@ LXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
 
     if (pGeode->useVGA) {
 
-	if (!vgaHWMapMem(pScrni))
-	    return FALSE;
+        if (!vgaHWMapMem(pScrni))
+            return FALSE;
 
-	vgaHWGetIOBase(VGAHWPTR(pScrni));
+        vgaHWGetIOBase(VGAHWPTR(pScrni));
     }
 
     if (!pGeode->NoAccel) {
 
-	pGeode->pExa = exaDriverAlloc();
+        pGeode->pExa = exaDriverAlloc();
 
-	if (pGeode->pExa) {
+        if (pGeode->pExa) {
 
-	    pGeode->pExa->memoryBase = 0;
-	    pGeode->pExa->memorySize = 0;
+            pGeode->pExa->memoryBase = 0;
+            pGeode->pExa->memorySize = 0;
 
-	    pGeode->pExa->pixmapOffsetAlign = 32;
-	    pGeode->pExa->pixmapPitchAlign = 32;
-	    pGeode->pExa->flags = EXA_OFFSCREEN_PIXMAPS;
-	    pGeode->pExa->maxX = LX_MAX_WIDTH - 1;
-	    pGeode->pExa->maxY = LX_MAX_HEIGHT - 1;
-	} else {
-	    xf86DrvMsg(scrnIndex, X_ERROR,
-		"Couldn't allocate the EXA structure.\n");
-	    pGeode->NoAccel = TRUE;
-	}
+            pGeode->pExa->pixmapOffsetAlign = 32;
+            pGeode->pExa->pixmapPitchAlign = 32;
+            pGeode->pExa->flags = EXA_OFFSCREEN_PIXMAPS;
+            pGeode->pExa->maxX = LX_MAX_WIDTH - 1;
+            pGeode->pExa->maxY = LX_MAX_HEIGHT - 1;
+        }
+        else {
+            xf86DrvMsg(scrnIndex, X_ERROR,
+                       "Couldn't allocate the EXA structure.\n");
+            pGeode->NoAccel = TRUE;
+        }
     }
 
     /* Map the memory here before doing anything else */
 
     if (!LXMapMem(pScrni))
-	return FALSE;
+        return FALSE;
 
     LXInitOffscreen(pScrni);
 
     /* XXX FIXME - Take down any of the structures on failure? */
     if (!LXEnterGraphics(pScrn, pScrni))
-	return FALSE;
+        return FALSE;
 
     miClearVisualTypes();
 
     /* XXX Again - take down anything? */
 
     if (pScrni->bitsPerPixel > 8) {
-	if (!miSetVisualTypes(pScrni->depth,
-		TrueColorMask, pScrni->rgbBits, pScrni->defaultVisual)) {
-	    return FALSE;
-	}
-    } else {
-	if (!miSetVisualTypes(pScrni->depth,
-		miGetDefaultVisualMask(pScrni->depth),
-		pScrni->rgbBits, pScrni->defaultVisual)) {
-	    return FALSE;
-	}
+        if (!miSetVisualTypes(pScrni->depth,
+                              TrueColorMask, pScrni->rgbBits,
+                              pScrni->defaultVisual)) {
+            return FALSE;
+        }
+    }
+    else {
+        if (!miSetVisualTypes(pScrni->depth,
+                              miGetDefaultVisualMask(pScrni->depth),
+                              pScrni->rgbBits, pScrni->defaultVisual)) {
+            return FALSE;
+        }
     }
 
     miSetPixmapDepths();
 
     if (pScrni->virtualX > pScrni->displayWidth)
-	pScrni->displayWidth = pScrni->virtualX;
+        pScrni->displayWidth = pScrni->virtualX;
 
     /* Point at the visible area to start */
 
@@ -895,35 +901,36 @@ LXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
     dwidth = pGeode->Pitch / ((pScrni->bitsPerPixel + 7) / 8);
 
     ret = fbScreenInit(pScrn, pGeode->FBBase,
-	pScrni->virtualX, pScrni->virtualY,
-	pScrni->xDpi, pScrni->yDpi, dwidth, pScrni->bitsPerPixel);
+                       pScrni->virtualX, pScrni->virtualY,
+                       pScrni->xDpi, pScrni->yDpi, dwidth,
+                       pScrni->bitsPerPixel);
 
     if (!ret)
-	return FALSE;
+        return FALSE;
 
     xf86SetBlackWhitePixels(pScrn);
 
     /* Set up the color ordering */
     if (pScrni->bitsPerPixel > 8) {
-	VisualPtr visual = pScrn->visuals + pScrn->numVisuals;
-
-	while (--visual >= pScrn->visuals) {
-	    if ((visual->class | DynamicClass) == DirectColor) {
-		visual->offsetRed = pScrni->offset.red;
-		visual->offsetGreen = pScrni->offset.green;
-		visual->offsetBlue = pScrni->offset.blue;
-		visual->redMask = pScrni->mask.red;
-		visual->greenMask = pScrni->mask.green;
-		visual->blueMask = pScrni->mask.blue;
-	    }
-	}
+        VisualPtr visual = pScrn->visuals + pScrn->numVisuals;
+
+        while (--visual >= pScrn->visuals) {
+            if ((visual->class | DynamicClass) == DirectColor) {
+                visual->offsetRed = pScrni->offset.red;
+                visual->offsetGreen = pScrni->offset.green;
+                visual->offsetBlue = pScrni->offset.blue;
+                visual->redMask = pScrni->mask.red;
+                visual->greenMask = pScrni->mask.green;
+                visual->blueMask = pScrni->mask.blue;
+            }
+        }
     }
 
     /* Must follow the color ordering */
     fbPictureInit(pScrn, 0, 0);
 
     if (!pGeode->NoAccel)
-	pGeode->NoAccel = LXExaInit(pScrn) ? FALSE : TRUE;
+        pGeode->NoAccel = LXExaInit(pScrn) ? FALSE : TRUE;
 
     miInitializeBackingStore(pScrn);
     xf86SetBackingStore(pScrn);
@@ -934,24 +941,25 @@ LXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
     /* Set up the HW cursor - must follow the soft cursor init */
 
     if (pGeode->tryHWCursor) {
-	if (!LXCursorInit(pScrn))
-	    xf86DrvMsg(scrnIndex, X_ERROR,
-		"Hardware cursor initialization failed.\n");
+        if (!LXCursorInit(pScrn))
+            xf86DrvMsg(scrnIndex, X_ERROR,
+                       "Hardware cursor initialization failed.\n");
     }
 
     /* Set up the color map */
 
     if (!miCreateDefColormap(pScrn))
-	return FALSE;
+        return FALSE;
 
     if (pScrni->bitsPerPixel == 8) {
-	/* Must follow initialization of the default colormap */
-
-	if (!xf86HandleColormaps(pScrn, 256, 8,
-		LXLoadPalette, NULL,
-		CMAP_PALETTED_TRUECOLOR | CMAP_RELOAD_ON_MODE_SWITCH)) {
-	    return FALSE;
-	}
+        /* Must follow initialization of the default colormap */
+
+        if (!xf86HandleColormaps(pScrn, 256, 8,
+                                 LXLoadPalette, NULL,
+                                 CMAP_PALETTED_TRUECOLOR |
+                                 CMAP_RELOAD_ON_MODE_SWITCH)) {
+            return FALSE;
+        }
     }
     xf86DPMSInit(pScrn, xf86DPMSSet, 0);
 
@@ -965,12 +973,12 @@ LXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
     pScrn->SaveScreen = LXSaveScreen;
 
     if (!xf86CrtcScreenInit(pScrn)) {
-	xf86DrvMsg(scrnIndex, X_ERROR, "CRTCScreenInit failed.\n");
-	return FALSE;
+        xf86DrvMsg(scrnIndex, X_ERROR, "CRTCScreenInit failed.\n");
+        return FALSE;
     }
 
     if (serverGeneration == 1)
-	xf86ShowUnusedOptions(pScrni->scrnIndex, pScrni->options);
+        xf86ShowUnusedOptions(pScrni->scrnIndex, pScrni->options);
 
     pGeode->starting = FALSE;
 
diff --git a/src/lx_exa.c b/src/lx_exa.c
index ef90d6b..57fd8e1 100644
--- a/src/lx_exa.c
+++ b/src/lx_exa.c
@@ -61,8 +61,7 @@ do {                                    \
 #define GEODE_FALLBACK(x) return FALSE
 #endif
 
-static const struct exa_format_t
-{
+static const struct exa_format_t {
     int exa;
     int bpp;
     int fmt;
@@ -89,8 +88,7 @@ static const struct exa_format_t
 #define COMP_TYPE_TWOPASS 3
 #define COMP_TYPE_ROTATE  5
 
-static struct
-{
+static struct {
     int type;
 
     unsigned int srcOffset;
@@ -135,10 +133,10 @@ static int
 lx_fill_flags(int x0, int y0, int w, int h, int rop)
 {
     int x1 = x0 + w, y1 = y0 + h;
-    int n = ((rop ^ (rop >> 1)) & 0x55) == 0 ||	/* no dst */
-	x0 >= lx1 || y0 >= ly1 ||      /* rght/below */
-	x1 <= lx0 || y1 <= ly0 ?       /* left/above */
-	0 : CIMGP_BLTFLAGS_HAZARD;
+    int n = ((rop ^ (rop >> 1)) & 0x55) == 0 || /* no dst */
+        x0 >= lx1 || y0 >= ly1 ||       /* rght/below */
+        x1 <= lx0 || y1 <= ly0 ?        /* left/above */
+        0 : CIMGP_BLTFLAGS_HAZARD;
 
     lx0 = x0;
     ly0 = y0;
@@ -155,11 +153,11 @@ lx_copy_flags(int x0, int y0, int x1, int y1, int w, int h, int rop)
 
     /* dst not hazzard and src not hazzard */
     int n = (((rop ^ (rop >> 1)) & 0x55) == 0 ||
-	x1 >= lx1 || y1 >= ly1 ||
-	x2 <= lx0 || y2 <= ly0) &&
-	(((rop ^ (rop >> 2)) & 0x33) == 0 ||
-	x0 >= lx1 || y0 >= ly1 ||
-	x0 + w <= lx0 || y0 + h <= ly0) ? 0 : CIMGP_BLTFLAGS_HAZARD;
+             x1 >= lx1 || y1 >= ly1 ||
+             x2 <= lx0 || y2 <= ly0) &&
+        (((rop ^ (rop >> 2)) & 0x33) == 0 ||
+         x0 >= lx1 || y0 >= ly1 ||
+         x0 + w <= lx0 || y0 + h <= ly0) ? 0 : CIMGP_BLTFLAGS_HAZARD;
 
     lx0 = x1;
     ly0 = y1;
@@ -176,8 +174,9 @@ lx_copy_flags(int x0, int y0, int x1, int y1, int w, int h, int rop)
 /* exaGetPixelFromRGBA (exa_render.c) */
 
 static Bool
-_GetPixelFromRGBA(CARD32 * pixel,
-    CARD16 red, CARD16 green, CARD16 blue, CARD16 alpha, CARD32 format)
+_GetPixelFromRGBA(CARD32 *pixel,
+                  CARD16 red, CARD16 green, CARD16 blue, CARD16 alpha,
+                  CARD32 format)
 {
     int rbits, bbits, gbits, abits;
     int rshift, bshift, gshift, ashift;
@@ -185,7 +184,7 @@ _GetPixelFromRGBA(CARD32 * pixel,
     *pixel = 0;
 
     if (!PICT_FORMAT_COLOR(format))
-	return FALSE;
+        return FALSE;
 
     rbits = PICT_FORMAT_R(format);
     gbits = PICT_FORMAT_G(format);
@@ -193,15 +192,16 @@ _GetPixelFromRGBA(CARD32 * pixel,
     abits = PICT_FORMAT_A(format);
 
     if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
-	bshift = 0;
-	gshift = bbits;
-	rshift = gshift + gbits;
-	ashift = rshift + rbits;
-    } else {			       /* PICT_TYPE_ABGR */
-	rshift = 0;
-	gshift = rbits;
-	bshift = gshift + gbits;
-	ashift = bshift + bbits;
+        bshift = 0;
+        gshift = bbits;
+        rshift = gshift + gbits;
+        ashift = rshift + rbits;
+    }
+    else {                      /* PICT_TYPE_ABGR */
+        rshift = 0;
+        gshift = rbits;
+        bshift = gshift + gbits;
+        ashift = bshift + bbits;
     }
 
     *pixel |= (blue >> (16 - bbits)) << bshift;
@@ -216,14 +216,14 @@ _GetPixelFromRGBA(CARD32 * pixel,
 
 static Bool
 _GetRGBAFromPixel(CARD32 pixel,
-    CARD16 * red,
-    CARD16 * green, CARD16 * blue, CARD16 * alpha, CARD32 format)
+                  CARD16 *red,
+                  CARD16 *green, CARD16 *blue, CARD16 *alpha, CARD32 format)
 {
     int rbits, bbits, gbits, abits;
     int rshift, bshift, gshift, ashift;
 
     if (!PICT_FORMAT_COLOR(format))
-	return FALSE;
+        return FALSE;
 
     rbits = PICT_FORMAT_R(format);
     gbits = PICT_FORMAT_G(format);
@@ -231,43 +231,45 @@ _GetRGBAFromPixel(CARD32 pixel,
     abits = PICT_FORMAT_A(format);
 
     if (PICT_FORMAT_TYPE(format) == PICT_TYPE_ARGB) {
-	bshift = 0;
-	gshift = bbits;
-	rshift = gshift + gbits;
-	ashift = rshift + rbits;
-    } else {			       /* PICT_TYPE_ABGR */
-	rshift = 0;
-	gshift = rbits;
-	bshift = gshift + gbits;
-	ashift = bshift + bbits;
+        bshift = 0;
+        gshift = bbits;
+        rshift = gshift + gbits;
+        ashift = rshift + rbits;
+    }
+    else {                      /* PICT_TYPE_ABGR */
+        rshift = 0;
+        gshift = rbits;
+        bshift = gshift + gbits;
+        ashift = bshift + bbits;
     }
 
     *red = ((pixel >> rshift) & ((1 << rbits) - 1)) << (16 - rbits);
     while (rbits < 16) {
-	*red |= *red >> rbits;
-	rbits <<= 1;
+        *red |= *red >> rbits;
+        rbits <<= 1;
     }
 
     *green = ((pixel >> gshift) & ((1 << gbits) - 1)) << (16 - gbits);
     while (gbits < 16) {
-	*green |= *green >> gbits;
-	gbits <<= 1;
+        *green |= *green >> gbits;
+        gbits <<= 1;
     }
 
     *blue = ((pixel >> bshift) & ((1 << bbits) - 1)) << (16 - bbits);
     while (bbits < 16) {
-	*blue |= *blue >> bbits;
-	bbits <<= 1;
+        *blue |= *blue >> bbits;
+        bbits <<= 1;
     }
 
     if (abits) {
-	*alpha = ((pixel >> ashift) & ((1 << abits) - 1)) << (16 - abits);
-	while (abits < 16) {
-	    *alpha |= *alpha >> abits;
-	    abits <<= 1;
-	}
-    } else
-	*alpha = 0xffff;
+        *alpha = ((pixel >> ashift) & ((1 << abits) - 1)) << (16 - abits);
+        while (abits < 16) {
+            *alpha |= *alpha >> abits;
+            abits <<= 1;
+        }
+    }
+    else
+        *alpha = 0xffff;
 
     return TRUE;
 }
@@ -305,7 +307,7 @@ lx_prepare_solid(PixmapPtr pxMap, int alu, Pixel planemask, Pixel fg)
     gp_set_raster_operation(op);
 
     if (planemask != ~0U)
-	gp_set_solid_pattern(planemask);
+        gp_set_solid_pattern(planemask);
 
     exaScratch.op = op;
 
@@ -321,8 +323,7 @@ lx_do_solid(PixmapPtr pxMap, int x1, int y1, int x2, int y2)
 {
     int bpp = (pxMap->drawable.bitsPerPixel + 7) / 8;
     int pitch = exaGetPixmapPitch(pxMap);
-    unsigned int offset =
-	exaGetPixmapOffset(pxMap) + (pitch * y1) + (bpp * x1);
+    unsigned int offset = exaGetPixmapOffset(pxMap) + (pitch * y1) + (bpp * x1);
 
     gp_declare_blt(lx_fill_flags(x1, y1, x2 - x1, y2 - y1, exaScratch.op));
     gp_pattern_fill(offset, x2 - x1, y2 - y1);
@@ -330,7 +331,7 @@ lx_do_solid(PixmapPtr pxMap, int x1, int y1, int x2, int y2)
 
 static Bool
 lx_prepare_copy(PixmapPtr pxSrc, PixmapPtr pxDst, int dx, int dy,
-    int alu, Pixel planemask)
+                int alu, Pixel planemask)
 {
     int dpitch = exaGetPixmapPitch(pxDst);
     int op = (planemask == ~0U) ? SDfn[alu] : SDfn_PM[alu];
@@ -341,7 +342,7 @@ lx_prepare_copy(PixmapPtr pxSrc, PixmapPtr pxDst, int dx, int dy,
     gp_set_raster_operation(op);
 
     if (planemask != ~0U)
-	gp_set_solid_pattern(planemask);
+        gp_set_solid_pattern(planemask);
 
     exaScratch.srcOffset = exaGetPixmapOffset(pxSrc);
     exaScratch.srcPitch = exaGetPixmapPitch(pxSrc);
@@ -356,27 +357,25 @@ lx_prepare_copy(PixmapPtr pxSrc, PixmapPtr pxDst, int dx, int dy,
 
 static void
 lx_do_copy(PixmapPtr pxDst, int srcX, int srcY,
-    int dstX, int dstY, int w, int h)
+           int dstX, int dstY, int w, int h)
 {
     int dstBpp = (pxDst->drawable.bitsPerPixel + 7) / 8;
     int dstPitch = exaGetPixmapPitch(pxDst);
     unsigned int srcOffset, dstOffset;
     int flags = 0;
 
-    gp_declare_blt(lx_copy_flags(srcX, srcY, dstX, dstY, w, h,
-	    exaScratch.op));
+    gp_declare_blt(lx_copy_flags(srcX, srcY, dstX, dstY, w, h, exaScratch.op));
 
     srcOffset = exaScratch.srcOffset + (exaScratch.srcPitch * srcY) +
-	(exaScratch.srcBpp) * srcX;
+        (exaScratch.srcBpp) * srcX;
 
-    dstOffset = exaGetPixmapOffset(pxDst) +
-	(dstPitch * dstY) + (dstBpp * dstX);
+    dstOffset = exaGetPixmapOffset(pxDst) + (dstPitch * dstY) + (dstBpp * dstX);
 
     if (dstX > srcX)
-	flags |= CIMGP_NEGXDIR;
+        flags |= CIMGP_NEGXDIR;
 
     if (dstY > srcY)
-	flags |= CIMGP_NEGYDIR;
+        flags |= CIMGP_NEGYDIR;
 
     gp_screen_to_screen_blt(dstOffset, srcOffset, w, h, flags);
 }
@@ -403,8 +402,7 @@ PictOpAtop
 PictOpXor
 */
 
-struct blend_ops_t
-{
+struct blend_ops_t {
     int operation;
     int type;
     int channel;
@@ -413,51 +411,51 @@ struct blend_ops_t
     {
     CIMGP_ALPHA_TIMES_A, CIMGP_CONSTANT_ALPHA, CIMGP_CHANNEL_A_SOURCE}, {
     },
-	/* PictOpSrc */
+        /* PictOpSrc */
     {
     CIMGP_ALPHA_TIMES_A, CIMGP_ALPHA_EQUALS_ONE, CIMGP_CHANNEL_A_SOURCE}, {
     },
-	/* PictOpDst */
+        /* PictOpDst */
     {
     CIMGP_ALPHA_TIMES_A, CIMGP_ALPHA_EQUALS_ONE, CIMGP_CHANNEL_A_DEST}, {
     },
-	/* PictOpOver */
+        /* PictOpOver */
     {
     CIMGP_A_PLUS_BETA_B, CIMGP_CHANNEL_A_ALPHA, CIMGP_CHANNEL_A_SOURCE}, {
     CIMGP_ALPHA_TIMES_A, CIMGP_CONVERTED_ALPHA, CIMGP_CHANNEL_A_SOURCE},
-	/* PictOpOverReverse */
+        /* PictOpOverReverse */
     {
     CIMGP_A_PLUS_BETA_B, CIMGP_CHANNEL_A_ALPHA, CIMGP_CHANNEL_A_DEST}, {
     CIMGP_ALPHA_TIMES_A, CIMGP_CONVERTED_ALPHA, CIMGP_CHANNEL_A_SOURCE},
-	/* PictOpIn */
+        /* PictOpIn */
     {
     CIMGP_ALPHA_TIMES_A, CIMGP_CHANNEL_B_ALPHA, CIMGP_CHANNEL_A_SOURCE}, {
     CIMGP_ALPHA_TIMES_A, CIMGP_CONVERTED_ALPHA, CIMGP_CHANNEL_A_SOURCE},
-	/* PictOpInReverse */
+        /* PictOpInReverse */
     {
     CIMGP_ALPHA_TIMES_A, CIMGP_CHANNEL_B_ALPHA, CIMGP_CHANNEL_A_DEST}, {
     CIMGP_ALPHA_TIMES_A, CIMGP_CONVERTED_ALPHA, CIMGP_CHANNEL_A_SOURCE},
-	/* PictOpOut */
+        /* PictOpOut */
     {
     CIMGP_BETA_TIMES_B, CIMGP_CHANNEL_A_ALPHA, CIMGP_CHANNEL_A_DEST}, {
     CIMGP_ALPHA_TIMES_A, CIMGP_CONVERTED_ALPHA, CIMGP_CHANNEL_A_SOURCE},
-	/* PictOpOutReverse */
+        /* PictOpOutReverse */
     {
     CIMGP_BETA_TIMES_B, CIMGP_CHANNEL_A_ALPHA, CIMGP_CHANNEL_A_SOURCE}, {
     CIMGP_ALPHA_TIMES_A, CIMGP_CONVERTED_ALPHA, CIMGP_CHANNEL_A_SOURCE},
-	/* SrcAtop */
+        /* SrcAtop */
     {
     CIMGP_ALPHA_TIMES_A, CIMGP_CHANNEL_B_ALPHA, CIMGP_CHANNEL_A_DEST}, {
     CIMGP_BETA_TIMES_B, CIMGP_CHANNEL_A_ALPHA, CIMGP_CHANNEL_A_SOURCE},
-	/* SrcAtopReverse */
+        /* SrcAtopReverse */
     {
     CIMGP_ALPHA_TIMES_A, CIMGP_CHANNEL_B_ALPHA, CIMGP_CHANNEL_A_SOURCE}, {
     CIMGP_BETA_TIMES_B, CIMGP_CHANNEL_A_ALPHA, CIMGP_CHANNEL_A_DEST},
-	/* Xor */
+        /* Xor */
     {
     CIMGP_BETA_TIMES_B, CIMGP_CHANNEL_A_ALPHA, CIMGP_CHANNEL_A_SOURCE}, {
     CIMGP_BETA_TIMES_B, CIMGP_CHANNEL_A_ALPHA, CIMGP_CHANNEL_A_SOURCE},
-	/* PictOpAdd */
+        /* PictOpAdd */
     {
     CIMGP_A_PLUS_BETA_B, CIMGP_CONSTANT_ALPHA, CIMGP_CHANNEL_A_SOURCE}, {
     }
@@ -472,8 +470,8 @@ lx_get_format(PicturePtr p)
     unsigned int format = p->format;
 
     for (i = 0; i < ARRAY_SIZE(lx_exa_formats); i++)
-	if (lx_exa_formats[i].exa == format)
-	    return (&lx_exa_formats[i]);
+        if (lx_exa_formats[i].exa == format)
+            return (&lx_exa_formats[i]);
 
     return NULL;
 }
@@ -492,10 +490,9 @@ lx_process_transform(PicturePtr pSrc)
      * translate coordinates */
 
     if (t->matrix[0][0] == 0 &&
-	t->matrix[0][1] == 0 &&
-	t->matrix[1][0] == 0 && t->matrix[1][1] == 0) {
-	exaScratch.transform = pSrc->transform;
-	return TRUE;
+        t->matrix[0][1] == 0 && t->matrix[1][0] == 0 && t->matrix[1][1] == 0) {
+        exaScratch.transform = pSrc->transform;
+        return TRUE;
     }
 
     /* Otherwise, see if this is a simple
@@ -503,7 +500,7 @@ lx_process_transform(PicturePtr pSrc)
      * we have to punt back to software */
 
     if (t->matrix[2][2] != F(1))
-	return FALSE;
+        return FALSE;
 
     /* The rotate matrix looks like this:
      * [ cos X   -sin x 
@@ -517,22 +514,22 @@ lx_process_transform(PicturePtr pSrc)
      */
 
     if ((c0 != c1) || (s0 != -s1))
-	return FALSE;
+        return FALSE;
 
     /* Now, figure out what angle we want - we
      * can only accelerate right angle rotations,
      * so this turns into an easy set of if statements */
 
     if (c0 == F(1) && s1 == F(0))
-	exaScratch.rotate = RR_Rotate_0;
+        exaScratch.rotate = RR_Rotate_0;
     else if (c0 == F(0) && s1 == F(1))
-	exaScratch.rotate = RR_Rotate_90;
+        exaScratch.rotate = RR_Rotate_90;
     else if (c0 == F(-1) && s1 == F(0))
-	exaScratch.rotate = RR_Rotate_180;
+        exaScratch.rotate = RR_Rotate_180;
     else if (c0 == F(0) && s1 == F(-1))
-	exaScratch.rotate = RR_Rotate_270;
+        exaScratch.rotate = RR_Rotate_270;
     else
-	return FALSE;
+        return FALSE;
 
     exaScratch.transform = pSrc->transform;
 
@@ -546,29 +543,29 @@ lx_check_composite(int op, PicturePtr pSrc, PicturePtr pMsk, PicturePtr pDst)
     const struct exa_format_t *srcFmt, *dstFmt;
 
     if (op > PictOpAdd)
-	GEODE_FALLBACK(("Operation %d is not supported\n", op));
+        GEODE_FALLBACK(("Operation %d is not supported\n", op));
 
     /* FIXME: Meet this conditions from the debug for PictOpAdd.
      * Any Other possibilities? Add a judge for the future supplement */
     if (op == PictOpAdd && pSrc->format == PICT_a8r8g8b8 &&
-	pDst->format == PICT_a8 && !pMsk)
-	return TRUE;
+        pDst->format == PICT_a8 && !pMsk)
+        return TRUE;
 
     if (op == PictOpAdd && pSrc->format == PICT_x8r8g8b8 &&
-	pDst->format == PICT_a8 && !pMsk)
-	return TRUE;
+        pDst->format == PICT_a8 && !pMsk)
+        return TRUE;
 
     if (op == PictOpAdd && pSrc->format == PICT_r5g6b5 &&
-	pDst->format == PICT_a8 && !pMsk)
-	return TRUE;
+        pDst->format == PICT_a8 && !pMsk)
+        return TRUE;
 
     if (usesPasses(op)) {
-	if (pGeode->exaBfrOffset == 0 || !pMsk)
-	    GEODE_FALLBACK(("Multipass operation requires off-screen buffer\n"));
+        if (pGeode->exaBfrOffset == 0 || !pMsk)
+            GEODE_FALLBACK(("Multipass operation requires off-screen buffer\n"));
     }
 
     if (pMsk && op == PictOpAdd)
-	GEODE_FALLBACK(("PictOpAdd with mask is not supported\n"));
+        GEODE_FALLBACK(("PictOpAdd with mask is not supported\n"));
 
     /* Check that the filter matches what we support */
 
@@ -577,18 +574,18 @@ lx_check_composite(int op, PicturePtr pSrc, PicturePtr pMsk, PicturePtr pDst)
     case PictFilterFast:
     case PictFilterGood:
     case PictFilterBest:
-	break;
+        break;
 
     default:
-	GEODE_FALLBACK(("Bilinear or convolution filters are not supported\n"));
+        GEODE_FALLBACK(("Bilinear or convolution filters are not supported\n"));
     }
 
     if (pMsk && pMsk->transform)
-	GEODE_FALLBACK(("Mask transforms are not supported\n"));
+        GEODE_FALLBACK(("Mask transforms are not supported\n"));
 
     /* XXX - don't know if we can do any hwaccel on solid fills or gradient types */
     if (pSrc->pSourcePict || (pMsk && pMsk->pSourcePict))
-	GEODE_FALLBACK(("Solid fills or gradient types are not supported\n"));
+        GEODE_FALLBACK(("Solid fills or gradient types are not supported\n"));
 
     /* Keep an eye out for source rotation transforms - those we can
      * do something about */
@@ -597,74 +594,75 @@ lx_check_composite(int op, PicturePtr pSrc, PicturePtr pMsk, PicturePtr pDst)
     exaScratch.transform = NULL;
 
     if (pSrc->transform && !lx_process_transform(pSrc))
-	GEODE_FALLBACK(("Transform operation is non-trivial\n"));
+        GEODE_FALLBACK(("Transform operation is non-trivial\n"));
 
     /* XXX - I don't understand PICT_a8 enough - so I'm punting */
     if ((op != PictOpAdd) && (pSrc->format == PICT_a8 ||
-	pDst->format == PICT_a8))
-	GEODE_FALLBACK(("PICT_a8 as src or dst format is unsupported\n"));
+                              pDst->format == PICT_a8))
+        GEODE_FALLBACK(("PICT_a8 as src or dst format is unsupported\n"));
 
     if (pMsk && op != PictOpClear) {
-	struct blend_ops_t *opPtr = &lx_alpha_ops[op * 2];
-	int direction = (opPtr->channel == CIMGP_CHANNEL_A_SOURCE) ? 0 : 1;
-
-	/* Direction 0 indicates src->dst, 1 indiates dst->src */
-	if (((direction == 0) && (pSrc->pDrawable->bitsPerPixel < 16)) ||
-	    ((direction == 1) && (pDst->pDrawable->bitsPerPixel < 16))) {
-	    ErrorF("Mask blending unsupported with <16bpp\n");
-	    return FALSE;
-	}
-	if (pMsk->format != PICT_a8 && pMsk->format != PICT_a4)
-	    GEODE_FALLBACK(("Masks can be only done with a 8bpp or 4bpp depth\n"));
-
-	/* The pSrc should be 1x1 pixel if the pMsk is not zero */
-	if (pSrc->pDrawable->width != 1 || pSrc->pDrawable->height != 1)
-	    GEODE_FALLBACK(("pSrc should be 1x1 pixel if pMsk is not zero\n"));
-	/* FIXME: In lx_prepare_composite, there are no variables to record the
-	 * one pixel source's width and height when the mask is not zero.
-	 * That will lead to bigger region to render instead of one pixel in lx
-	 * _do_composite, so we should fallback currently to avoid this */
-	if (!pSrc->repeat)
-	    GEODE_FALLBACK(("FIXME: unzero mask might lead to bigger rendering region than 1x1 pixels\n"));
+        struct blend_ops_t *opPtr = &lx_alpha_ops[op * 2];
+        int direction = (opPtr->channel == CIMGP_CHANNEL_A_SOURCE) ? 0 : 1;
+
+        /* Direction 0 indicates src->dst, 1 indiates dst->src */
+        if (((direction == 0) && (pSrc->pDrawable->bitsPerPixel < 16)) ||
+            ((direction == 1) && (pDst->pDrawable->bitsPerPixel < 16))) {
+            ErrorF("Mask blending unsupported with <16bpp\n");
+            return FALSE;
+        }
+        if (pMsk->format != PICT_a8 && pMsk->format != PICT_a4)
+            GEODE_FALLBACK(("Masks can be only done with a 8bpp or 4bpp depth\n"));
+
+        /* The pSrc should be 1x1 pixel if the pMsk is not zero */
+        if (pSrc->pDrawable->width != 1 || pSrc->pDrawable->height != 1)
+            GEODE_FALLBACK(("pSrc should be 1x1 pixel if pMsk is not zero\n"));
+        /* FIXME: In lx_prepare_composite, there are no variables to record the
+         * one pixel source's width and height when the mask is not zero.
+         * That will lead to bigger region to render instead of one pixel in lx
+         * _do_composite, so we should fallback currently to avoid this */
+        if (!pSrc->repeat)
+            GEODE_FALLBACK(("FIXME: unzero mask might lead to bigger rendering region than 1x1 pixels\n"));
     }
 
     /* Get the formats for the source and destination */
 
     if ((srcFmt = lx_get_format(pSrc)) == NULL) {
-	ErrorF("EXA: Invalid source format %x\n", pSrc->format);
-	return FALSE;
+        ErrorF("EXA: Invalid source format %x\n", pSrc->format);
+        return FALSE;
     }
 
     if ((dstFmt = lx_get_format(pDst)) == NULL) {
-	ErrorF("EXA: Invalid destination format %x\n", pDst->format);
-	return FALSE;
+        ErrorF("EXA: Invalid destination format %x\n", pDst->format);
+        return FALSE;
     }
 
     /* Make sure operations that need alpha bits have them */
     /* If a mask is enabled, the alpha will come from there */
 
     if (!pMsk && (!srcFmt->alphabits && usesSrcAlpha(op)))
-	GEODE_FALLBACK(("Operation requires src alpha, but alphabits is unset\n"));
+        GEODE_FALLBACK(("Operation requires src alpha, but alphabits is unset\n"));
 
     if (!pMsk && (!dstFmt->alphabits && usesDstAlpha(op)))
-	GEODE_FALLBACK(("Operation requires dst alpha, but alphabits is unset\n"));
+        GEODE_FALLBACK(("Operation requires dst alpha, but alphabits is unset\n"));
 
     /* FIXME: See a way around this! */
     if (srcFmt->alphabits == 0 && dstFmt->alphabits != 0)
-	GEODE_FALLBACK(("src_alphabits=0, dst_alphabits!=0\n"));
+        GEODE_FALLBACK(("src_alphabits=0, dst_alphabits!=0\n"));
 
     /* If this is a rotate operation, then make sure the src and dst
      * formats are the same */
     if (exaScratch.rotate != RR_Rotate_0 && srcFmt != dstFmt) {
-	ErrorF("EXA: Unable to rotate and convert formats at the same time\n");
-	return FALSE;
+        ErrorF("EXA: Unable to rotate and convert formats at the same time\n");
+        return FALSE;
     }
     return TRUE;
 }
 
 static Bool
 lx_prepare_composite(int op, PicturePtr pSrc, PicturePtr pMsk,
-    PicturePtr pDst, PixmapPtr pxSrc, PixmapPtr pxMsk, PixmapPtr pxDst)
+                     PicturePtr pDst, PixmapPtr pxSrc, PixmapPtr pxMsk,
+                     PixmapPtr pxDst)
 {
     GeodeRec *pGeode = GEODEPTR_FROM_PIXMAP(pxDst);
     const struct exa_format_t *srcFmt, *dstFmt;
@@ -676,60 +674,60 @@ lx_prepare_composite(int op, PicturePtr pSrc, PicturePtr pMsk,
 
     /* Set up the scratch buffer with the information we need */
 
-    exaScratch.srcFormat = (struct exa_format_t *)srcFmt;
-    exaScratch.dstFormat = (struct exa_format_t *)dstFmt;
+    exaScratch.srcFormat = (struct exa_format_t *) srcFmt;
+    exaScratch.dstFormat = (struct exa_format_t *) dstFmt;
     exaScratch.op = op;
     exaScratch.repeat = pSrc->repeat;
     exaScratch.bufferOffset = pGeode->exaBfrOffset;
 
     if (pMsk && op != PictOpClear) {
-	/* Get the source color */
-	/* If the op is PictOpOver(or PictOpOutReverse, PictOpInReverse,
-	 * PictOpIn, PictOpOut, PictOpOverReverse), we should get the
-	 * ARGB32 source format */
-
-	if ((op == PictOpOver || op == PictOpOutReverse || op ==
-	    PictOpInReverse || op == PictOpIn || op == PictOpOut ||
-	    op == PictOpOverReverse) && (srcFmt->alphabits != 0))
-	    exaScratch.srcColor = exaGetPixmapFirstPixel(pxSrc);
-	else if ((op == PictOpOver || op == PictOpOutReverse || op ==
-	    PictOpInReverse || op == PictOpIn || op == PictOpOut ||
-	    op == PictOpOverReverse) &&
-	    (srcFmt->alphabits == 0))
-	    exaScratch.srcColor = lx_get_source_color(pxSrc, pSrc->format,
-		PICT_a8r8g8b8);
-	else
-	    exaScratch.srcColor = lx_get_source_color(pxSrc, pSrc->format,
-		pDst->format);
-
-	/* Save off the info we need (reuse the source values to save space) */
-
-	exaScratch.type = COMP_TYPE_MASK;
-	exaScratch.maskrepeat = pMsk->repeat;
-
-	exaScratch.srcOffset = exaGetPixmapOffset(pxMsk);
-	exaScratch.srcPitch = exaGetPixmapPitch(pxMsk);
-	exaScratch.srcBpp = (pxMsk->drawable.bitsPerPixel + 7) / 8;
-
-	exaScratch.srcWidth = pMsk->pDrawable->width;
-	exaScratch.srcHeight = pMsk->pDrawable->height;
-
-	/* Flag to indicate if this a 8BPP or a 4BPP mask */
-	exaScratch.fourBpp = (pxMsk->drawable.bitsPerPixel == 4) ? 1 : 0;
-    } else {
-	if (usesPasses(op))
-	    exaScratch.type = COMP_TYPE_TWOPASS;
-	else if (exaScratch.rotate != RR_Rotate_0)
-	    exaScratch.type = COMP_TYPE_ROTATE;
-	else
-	    exaScratch.type = COMP_TYPE_ONEPASS;
-
-	exaScratch.srcOffset = exaGetPixmapOffset(pxSrc);
-	exaScratch.srcPitch = exaGetPixmapPitch(pxSrc);
-	exaScratch.srcBpp = (pxSrc->drawable.bitsPerPixel + 7) / 8;
-
-	exaScratch.srcWidth = pSrc->pDrawable->width;
-	exaScratch.srcHeight = pSrc->pDrawable->height;
+        /* Get the source color */
+        /* If the op is PictOpOver(or PictOpOutReverse, PictOpInReverse,
+         * PictOpIn, PictOpOut, PictOpOverReverse), we should get the
+         * ARGB32 source format */
+
+        if ((op == PictOpOver || op == PictOpOutReverse || op ==
+             PictOpInReverse || op == PictOpIn || op == PictOpOut ||
+             op == PictOpOverReverse) && (srcFmt->alphabits != 0))
+            exaScratch.srcColor = exaGetPixmapFirstPixel(pxSrc);
+        else if ((op == PictOpOver || op == PictOpOutReverse || op ==
+                  PictOpInReverse || op == PictOpIn || op == PictOpOut ||
+                  op == PictOpOverReverse) && (srcFmt->alphabits == 0))
+            exaScratch.srcColor = lx_get_source_color(pxSrc, pSrc->format,
+                                                      PICT_a8r8g8b8);
+        else
+            exaScratch.srcColor = lx_get_source_color(pxSrc, pSrc->format,
+                                                      pDst->format);
+
+        /* Save off the info we need (reuse the source values to save space) */
+
+        exaScratch.type = COMP_TYPE_MASK;
+        exaScratch.maskrepeat = pMsk->repeat;
+
+        exaScratch.srcOffset = exaGetPixmapOffset(pxMsk);
+        exaScratch.srcPitch = exaGetPixmapPitch(pxMsk);
+        exaScratch.srcBpp = (pxMsk->drawable.bitsPerPixel + 7) / 8;
+
+        exaScratch.srcWidth = pMsk->pDrawable->width;
+        exaScratch.srcHeight = pMsk->pDrawable->height;
+
+        /* Flag to indicate if this a 8BPP or a 4BPP mask */
+        exaScratch.fourBpp = (pxMsk->drawable.bitsPerPixel == 4) ? 1 : 0;
+    }
+    else {
+        if (usesPasses(op))
+            exaScratch.type = COMP_TYPE_TWOPASS;
+        else if (exaScratch.rotate != RR_Rotate_0)
+            exaScratch.type = COMP_TYPE_ROTATE;
+        else
+            exaScratch.type = COMP_TYPE_ONEPASS;
+
+        exaScratch.srcOffset = exaGetPixmapOffset(pxSrc);
+        exaScratch.srcPitch = exaGetPixmapPitch(pxSrc);
+        exaScratch.srcBpp = (pxSrc->drawable.bitsPerPixel + 7) / 8;
+
+        exaScratch.srcWidth = pSrc->pDrawable->width;
+        exaScratch.srcHeight = pSrc->pDrawable->height;
     }
 
     return TRUE;
@@ -742,21 +740,21 @@ lx_get_bpp_from_format(int format)
     switch (format) {
     case CIMGP_SOURCE_FMT_8_8_8_8:
     case CIMGP_SOURCE_FMT_32BPP_BGR:
-	return 32;
+        return 32;
 
     case CIMGP_SOURCE_FMT_4_4_4_4:
-	return 12;
+        return 12;
 
     case CIMGP_SOURCE_FMT_0_5_6_5:
     case CIMGP_SOURCE_FMT_16BPP_BGR:
-	return 16;
+        return 16;
 
     case CIMGP_SOURCE_FMT_1_5_5_5:
     case CIMGP_SOURCE_FMT_15BPP_BGR:
-	return 15;
+        return 15;
 
     case CIMGP_SOURCE_FMT_3_3_2:
-	return 8;
+        return 8;
     }
 
     return 0;
@@ -771,11 +769,11 @@ static void
 lx_set_source_format(int srcFormat, int dstFormat)
 {
     if (!(srcFormat & 0x10) && (dstFormat & 0x10))
-	gp_set_source_format(srcFormat | 0x10);
+        gp_set_source_format(srcFormat | 0x10);
     else if ((srcFormat & 0x10) && (dstFormat & 0x10))
-	gp_set_source_format(srcFormat & ~0x10);
+        gp_set_source_format(srcFormat & ~0x10);
     else
-	gp_set_source_format(srcFormat);
+        gp_set_source_format(srcFormat);
 }
 
 /* If we are converting colors and we need the channel A alpha,
@@ -787,7 +785,7 @@ static inline int
 get_op_type(struct exa_format_t *src, struct exa_format_t *dst, int type)
 {
     return (type == CIMGP_CHANNEL_A_ALPHA &&
-	src->alphabits != dst->alphabits) ? CIMGP_CONVERTED_ALPHA : type;
+            src->alphabits != dst->alphabits) ? CIMGP_CONVERTED_ALPHA : type;
 }
 
 /* Note - this is the preferred onepass method.  The other will remain
@@ -803,8 +801,8 @@ get_op_type(struct exa_format_t *src, struct exa_format_t *dst, int type)
 
 static void
 lx_composite_onepass_add_a8(PixmapPtr pxDst, unsigned long dstOffset,
-    unsigned long srcOffset, int width, int height, int opX, int opY,
-    int srcX, int srcY)
+                            unsigned long srcOffset, int width, int height,
+                            int opX, int opY, int srcX, int srcY)
 {
     struct blend_ops_t *opPtr;
     int apply, type;
@@ -821,46 +819,50 @@ lx_composite_onepass_add_a8(PixmapPtr pxDst, unsigned long dstOffset,
     gp_wait_until_idle();
 
     if (opX % 4 == 0 && srcX % 4 == 0) {
-	/* HW acceleration */
-	opPtr = &lx_alpha_ops[exaScratch.op * 2];
-	apply = CIMGP_APPLY_BLEND_TO_ALL;
-	gp_declare_blt(0);
-	gp_set_bpp(32);
-	gp_set_strides(exaGetPixmapPitch(pxDst), exaScratch.srcPitch);
-	gp_set_source_format(8);
-	type = opPtr->type;
-	gp_set_alpha_operation(opPtr->operation, type, opPtr->channel, apply, 0);
-	gp_screen_to_screen_convert(dstOffset, srcOffset, width / 4, height, 0);
-	/* Calculate the pixels in the tail of each line */
-	for (j = srcY; j < srcY + height; j++)
-	    for (i = srcX + (width / 4) * 4; i < srcX + width; i++) {
-		srcOffset = GetSrcOffset(i, j);
-		optempX = opX + i - srcX;
-		optempY = opY + j - srcY;
-		dstOffset = pixmapOffset + pixmapPitch * optempY +
-		    calBitsPixel * optempX;
-		*(cim_fb_ptr + dstOffset) = (*(cim_fb_ptr + srcOffset)
-		    + *(cim_fb_ptr + dstOffset) <= 0xff) ?
-		    *(cim_fb_ptr + srcOffset) + *(cim_fb_ptr + dstOffset) : 0xff;
-	}
-    } else {
-	for (j = srcY; j < srcY + height; j++)
-	    for (i = srcX; i < srcX + width; i++) {
-		srcOffset = GetSrcOffset(i, j);
-		optempX = opX + i - srcX;
-		optempY = opY + j - srcY;
-		dstOffset = pixmapOffset + pixmapPitch * optempY +
-		    calBitsPixel * optempX;
-		*(cim_fb_ptr + dstOffset) = (*(cim_fb_ptr + srcOffset) +
-		    *(cim_fb_ptr + dstOffset) <= 0xff) ?
-		    *(cim_fb_ptr + srcOffset) + *(cim_fb_ptr + dstOffset) : 0xff;
-	}
+        /* HW acceleration */
+        opPtr = &lx_alpha_ops[exaScratch.op * 2];
+        apply = CIMGP_APPLY_BLEND_TO_ALL;
+        gp_declare_blt(0);
+        gp_set_bpp(32);
+        gp_set_strides(exaGetPixmapPitch(pxDst), exaScratch.srcPitch);
+        gp_set_source_format(8);
+        type = opPtr->type;
+        gp_set_alpha_operation(opPtr->operation, type, opPtr->channel, apply,
+                               0);
+        gp_screen_to_screen_convert(dstOffset, srcOffset, width / 4, height, 0);
+        /* Calculate the pixels in the tail of each line */
+        for (j = srcY; j < srcY + height; j++)
+            for (i = srcX + (width / 4) * 4; i < srcX + width; i++) {
+                srcOffset = GetSrcOffset(i, j);
+                optempX = opX + i - srcX;
+                optempY = opY + j - srcY;
+                dstOffset = pixmapOffset + pixmapPitch * optempY +
+                    calBitsPixel * optempX;
+                *(cim_fb_ptr + dstOffset) = (*(cim_fb_ptr + srcOffset)
+                                             + *(cim_fb_ptr + dstOffset) <=
+                                             0xff) ? *(cim_fb_ptr + srcOffset) +
+                    *(cim_fb_ptr + dstOffset) : 0xff;
+            }
+    }
+    else {
+        for (j = srcY; j < srcY + height; j++)
+            for (i = srcX; i < srcX + width; i++) {
+                srcOffset = GetSrcOffset(i, j);
+                optempX = opX + i - srcX;
+                optempY = opY + j - srcY;
+                dstOffset = pixmapOffset + pixmapPitch * optempY +
+                    calBitsPixel * optempX;
+                *(cim_fb_ptr + dstOffset) = (*(cim_fb_ptr + srcOffset) +
+                                             *(cim_fb_ptr + dstOffset) <=
+                                             0xff) ? *(cim_fb_ptr + srcOffset) +
+                    *(cim_fb_ptr + dstOffset) : 0xff;
+            }
     }
 }
 
 static void
 lx_composite_onepass(PixmapPtr pxDst, unsigned long dstOffset,
-    unsigned long srcOffset, int width, int height)
+                     unsigned long srcOffset, int width, int height)
 {
     struct blend_ops_t *opPtr;
     int apply, type;
@@ -868,18 +870,16 @@ lx_composite_onepass(PixmapPtr pxDst, unsigned long dstOffset,
     opPtr = &lx_alpha_ops[exaScratch.op * 2];
 
     apply = (exaScratch.dstFormat->alphabits != 0 &&
-	exaScratch.srcFormat->alphabits != 0) ?
-	CIMGP_APPLY_BLEND_TO_ALL : CIMGP_APPLY_BLEND_TO_RGB;
+             exaScratch.srcFormat->alphabits != 0) ?
+        CIMGP_APPLY_BLEND_TO_ALL : CIMGP_APPLY_BLEND_TO_RGB;
 
     gp_declare_blt(0);
     gp_set_bpp(lx_get_bpp_from_format(exaScratch.dstFormat->fmt));
     gp_set_strides(exaGetPixmapPitch(pxDst), exaScratch.srcPitch);
 
-    lx_set_source_format(exaScratch.srcFormat->fmt,
-	exaScratch.dstFormat->fmt);
+    lx_set_source_format(exaScratch.srcFormat->fmt, exaScratch.dstFormat->fmt);
 
-    type =
-	get_op_type(exaScratch.srcFormat, exaScratch.dstFormat, opPtr->type);
+    type = get_op_type(exaScratch.srcFormat, exaScratch.dstFormat, opPtr->type);
 
     gp_set_alpha_operation(opPtr->operation, type, opPtr->channel, apply, 0);
 
@@ -894,14 +894,12 @@ lx_composite_all_black(unsigned long srcOffset, int width, int height)
 
     opPtr = &lx_alpha_ops[0];
     apply = (exaScratch.srcFormat->alphabits != 0) ?
-	CIMGP_APPLY_BLEND_TO_ALL : CIMGP_APPLY_BLEND_TO_RGB;
+        CIMGP_APPLY_BLEND_TO_ALL : CIMGP_APPLY_BLEND_TO_RGB;
     gp_declare_blt(0);
     gp_set_bpp(lx_get_bpp_from_format(exaScratch.srcFormat->fmt));
     gp_set_strides(exaScratch.srcPitch, exaScratch.srcPitch);
-    lx_set_source_format(exaScratch.srcFormat->fmt,
-	exaScratch.srcFormat->fmt);
-    type =
-	get_op_type(exaScratch.srcFormat, exaScratch.srcFormat, opPtr->type);
+    lx_set_source_format(exaScratch.srcFormat->fmt, exaScratch.srcFormat->fmt);
+    type = get_op_type(exaScratch.srcFormat, exaScratch.srcFormat, opPtr->type);
     gp_set_alpha_operation(opPtr->operation, type, opPtr->channel, apply, 0);
     gp_screen_to_screen_convert(srcOffset, srcOffset, width, height, 0);
 
@@ -909,7 +907,7 @@ lx_composite_all_black(unsigned long srcOffset, int width, int height)
 
 static void
 lx_composite_onepass_special(PixmapPtr pxDst, int width, int height, int opX,
-    int opY, int srcX, int srcY)
+                             int opY, int srcX, int srcY)
 {
     struct blend_ops_t *opPtr;
     int apply, type;
@@ -921,65 +919,72 @@ lx_composite_onepass_special(PixmapPtr pxDst, int width, int height, int opX,
     optempY = opY;
 
     /* Make sure srcX and srcY are in source region */
-    srcX = ((srcX % (int)exaScratch.srcWidth) + (int)exaScratch.srcWidth)
-	% (int)exaScratch.srcWidth;
-    srcY = ((srcY % (int)exaScratch.srcHeight) + (int)exaScratch.srcHeight)
-	% (int)exaScratch.srcHeight;
+    srcX = ((srcX % (int) exaScratch.srcWidth) + (int) exaScratch.srcWidth)
+        % (int) exaScratch.srcWidth;
+    srcY = ((srcY % (int) exaScratch.srcHeight) + (int) exaScratch.srcHeight)
+        % (int) exaScratch.srcHeight;
 
     opWidth = exaScratch.srcWidth - srcX;
-    opHeight = exaScratch.srcHeight -  srcY;
+    opHeight = exaScratch.srcHeight - srcY;
 
     srcOffset = GetSrcOffset(srcX, srcY);
 
     if (width < opWidth)
-	opWidth = width;
+        opWidth = width;
     if (height < opHeight)
-	opHeight = height;
+        opHeight = height;
 
     while (1) {
-	gp_wait_until_idle();
-	dstOffset = GetPixmapOffset(pxDst, optempX, optempY);
-	opPtr = &lx_alpha_ops[exaScratch.op * 2];
-	apply = (exaScratch.dstFormat->alphabits != 0 &&
-	    exaScratch.srcFormat->alphabits != 0) ?
-	    CIMGP_APPLY_BLEND_TO_ALL : CIMGP_APPLY_BLEND_TO_RGB;
-	gp_declare_blt(0);
-	gp_set_bpp(lx_get_bpp_from_format(exaScratch.dstFormat->fmt));
-	gp_set_strides(exaGetPixmapPitch(pxDst), exaScratch.srcPitch);
-	lx_set_source_format(exaScratch.srcFormat->fmt,
-	    exaScratch.dstFormat->fmt);
-	type = get_op_type(exaScratch.srcFormat, exaScratch.dstFormat,
-	    opPtr->type);
-	gp_set_alpha_operation(opPtr->operation, type, opPtr->channel,
-	    apply, 0);
-	gp_screen_to_screen_convert(dstOffset, srcOffset, opWidth, opHeight, 0);
-
-	optempX += opWidth;
-	if (optempX >= opX + width) {
-	    optempX = opX;
-	    optempY += opHeight;
-	    if (optempY >= opY + height)
-		break;
-	}
-	if (optempX == opX) {
-	    srcOffset = GetSrcOffset(srcX, 0);
-	    opWidth = ((opX + width) - optempX) > (exaScratch.srcWidth - srcX)
-		? (exaScratch.srcWidth - srcX) : ((opX + width) - optempX);
-	    opHeight = ((opY + height) - optempY) > exaScratch.srcHeight
-		? exaScratch.srcHeight : ((opY + height) - optempY);
-	} else if (optempY == opY) {
-	    srcOffset = GetSrcOffset(0, srcY);
-	    opWidth = ((opX + width) - optempX) > exaScratch.srcWidth
-		? exaScratch.srcWidth : ((opX + width) - optempX);
-	    opHeight = ((opY + height) - optempY) > (exaScratch.srcHeight -
-		srcY) ? (exaScratch.srcHeight - srcY) : ((opY + height) - optempY);
-	} else {
-	    srcOffset = GetSrcOffset(0, 0);
-	    opWidth = ((opX + width) - optempX) > exaScratch.srcWidth
-		? exaScratch.srcWidth : ((opX + width) - optempX);
-	    opHeight = ((opY + height) - optempY) > exaScratch.srcHeight
-		? exaScratch.srcHeight : ((opY + height) - optempY);
-	}
+        gp_wait_until_idle();
+        dstOffset = GetPixmapOffset(pxDst, optempX, optempY);
+        opPtr = &lx_alpha_ops[exaScratch.op * 2];
+        apply = (exaScratch.dstFormat->alphabits != 0 &&
+                 exaScratch.srcFormat->alphabits != 0) ?
+            CIMGP_APPLY_BLEND_TO_ALL : CIMGP_APPLY_BLEND_TO_RGB;
+        gp_declare_blt(0);
+        gp_set_bpp(lx_get_bpp_from_format(exaScratch.dstFormat->fmt));
+        gp_set_strides(exaGetPixmapPitch(pxDst), exaScratch.srcPitch);
+        lx_set_source_format(exaScratch.srcFormat->fmt,
+                             exaScratch.dstFormat->fmt);
+        type = get_op_type(exaScratch.srcFormat, exaScratch.dstFormat,
+                           opPtr->type);
+        gp_set_alpha_operation(opPtr->operation, type, opPtr->channel,
+                               apply, 0);
+        gp_screen_to_screen_convert(dstOffset, srcOffset, opWidth, opHeight, 0);
+
+        optempX += opWidth;
+        if (optempX >= opX + width) {
+            optempX = opX;
+            optempY += opHeight;
+            if (optempY >= opY + height)
+                break;
+        }
+        if (optempX == opX) {
+            srcOffset = GetSrcOffset(srcX, 0);
+            opWidth = ((opX + width) - optempX) > (exaScratch.srcWidth - srcX)
+                ? (exaScratch.srcWidth - srcX) : ((opX + width) - optempX);
+            opHeight = ((opY + height) - optempY) > exaScratch.srcHeight
+                ? exaScratch.srcHeight : ((opY + height) - optempY);
+        }
+        else if (optempY == opY) {
+            srcOffset = GetSrcOffset(0, srcY);
+            opWidth = ((opX + width) - optempX) > exaScratch.srcWidth
+                ? exaScratch.srcWidth : ((opX + width) - optempX);
+            opHeight = ((opY + height) - optempY) > (exaScratch.srcHeight -
+                                                     srcY) ? (exaScratch.
+                                                              srcHeight -
+                                                              srcY) : ((opY +
+                                                                        height)
+                                                                       -
+                                                                       optempY);
+        }
+        else {
+            srcOffset = GetSrcOffset(0, 0);
+            opWidth = ((opX + width) - optempX) > exaScratch.srcWidth
+                ? exaScratch.srcWidth : ((opX + width) - optempX);
+            opHeight = ((opY + height) - optempY) > exaScratch.srcHeight
+                ? exaScratch.srcHeight : ((opY + height) - optempY);
+        }
     }
 }
 
@@ -987,7 +992,7 @@ lx_composite_onepass_special(PixmapPtr pxDst, int width, int height, int opX,
 
 static void
 lx_composite_multipass(PixmapPtr pxDst, unsigned long dstOffset,
-    unsigned long srcOffset, int width, int height)
+                       unsigned long srcOffset, int width, int height)
 {
     struct blend_ops_t *opPtr;
     int sbpp = lx_get_bpp_from_format(exaScratch.srcFormat->fmt);
@@ -1008,7 +1013,7 @@ lx_composite_multipass(PixmapPtr pxDst, unsigned long dstOffset,
     gp_set_raster_operation(0xCC);
     gp_set_strides(exaScratch.srcPitch, exaGetPixmapPitch(pxDst));
     gp_screen_to_screen_convert(exaScratch.bufferOffset, dstOffset,
-	width, height, 0);
+                                width, height, 0);
 
     /* Do the first blend from the source to the scratch buffer */
 
@@ -1020,40 +1025,38 @@ lx_composite_multipass(PixmapPtr pxDst, unsigned long dstOffset,
     opPtr = &lx_alpha_ops[exaScratch.op * 2];
 
     apply = (exaScratch.srcFormat->alphabits == 0) ?
-	CIMGP_APPLY_BLEND_TO_RGB : CIMGP_APPLY_BLEND_TO_ALL;
+        CIMGP_APPLY_BLEND_TO_RGB : CIMGP_APPLY_BLEND_TO_ALL;
 
     /* If we're destroying the source alpha bits, then make sure we
      * use the alpha before the color conversion
      */
 
     gp_screen_to_screen_blt(exaScratch.bufferOffset, srcOffset, width, height,
-	0);
+                            0);
 
     /* Finally, do the second blend back to the destination */
 
     opPtr = &lx_alpha_ops[(exaScratch.op * 2) + 1];
 
     apply = (exaScratch.dstFormat->alphabits == 0) ?
-	CIMGP_APPLY_BLEND_TO_RGB : CIMGP_APPLY_BLEND_TO_ALL;
+        CIMGP_APPLY_BLEND_TO_RGB : CIMGP_APPLY_BLEND_TO_ALL;
 
     gp_declare_blt(CIMGP_BLTFLAGS_HAZARD);
     gp_set_bpp(lx_get_bpp_from_format(exaScratch.dstFormat->fmt));
 
-    lx_set_source_format(exaScratch.srcFormat->fmt,
-	exaScratch.dstFormat->fmt);
+    lx_set_source_format(exaScratch.srcFormat->fmt, exaScratch.dstFormat->fmt);
 
-    type =
-	get_op_type(exaScratch.srcFormat, exaScratch.dstFormat, opPtr->type);
+    type = get_op_type(exaScratch.srcFormat, exaScratch.dstFormat, opPtr->type);
 
     gp_set_alpha_operation(opPtr->operation, type, opPtr->channel, apply, 0);
 
     gp_screen_to_screen_convert(dstOffset, exaScratch.bufferOffset,
-	width, height, 0);
+                                width, height, 0);
 }
 
 static void
 lx_composite_rotate(PixmapPtr pxDst, unsigned long dstOffset,
-    unsigned int srcOffset, int width, int height)
+                    unsigned int srcOffset, int width, int height)
 {
     int degrees = 0;
 
@@ -1061,8 +1064,7 @@ lx_composite_rotate(PixmapPtr pxDst, unsigned long dstOffset,
     gp_set_bpp(lx_get_bpp_from_format(exaScratch.dstFormat->fmt));
     gp_set_strides(exaGetPixmapPitch(pxDst), exaScratch.srcPitch);
 
-    lx_set_source_format(exaScratch.srcFormat->fmt,
-	exaScratch.dstFormat->fmt);
+    lx_set_source_format(exaScratch.srcFormat->fmt, exaScratch.dstFormat->fmt);
 
     gp_set_raster_operation(0xCC);
 
@@ -1071,14 +1073,14 @@ lx_composite_rotate(PixmapPtr pxDst, unsigned long dstOffset,
 
     switch (exaScratch.rotate) {
     case RR_Rotate_90:
-	degrees = 270;
-	break;
+        degrees = 270;
+        break;
     case RR_Rotate_180:
-	degrees = 180;
-	break;
+        degrees = 180;
+        break;
     case RR_Rotate_270:
-	degrees = 90;
-	break;
+        degrees = 90;
+        break;
     }
 
     gp_rotate_blt(dstOffset, srcOffset, width, height, degrees);
@@ -1086,7 +1088,7 @@ lx_composite_rotate(PixmapPtr pxDst, unsigned long dstOffset,
 
 static void
 lx_do_composite_mask(PixmapPtr pxDst, unsigned long dstOffset,
-    unsigned int maskOffset, int width, int height)
+                     unsigned int maskOffset, int width, int height)
 {
     struct blend_ops_t *opPtr = &lx_alpha_ops[exaScratch.op * 2];
 
@@ -1098,13 +1100,14 @@ lx_do_composite_mask(PixmapPtr pxDst, unsigned long dstOffset,
     gp_set_solid_source(exaScratch.srcColor);
 
     gp_blend_mask_blt(dstOffset, 0, width, height, maskOffset,
-	exaScratch.srcPitch, opPtr->operation, exaScratch.fourBpp);
+                      exaScratch.srcPitch, opPtr->operation,
+                      exaScratch.fourBpp);
 }
 
 static void
 lx_do_composite_mask_two_pass(PixmapPtr pxDst, unsigned long dstOffset,
-    unsigned int maskOffset, int width, int height, int opX, int opY,
-    xPointFixed srcPoint)
+                              unsigned int maskOffset, int width, int height,
+                              int opX, int opY, xPointFixed srcPoint)
 {
     int apply, type;
     struct blend_ops_t *opPtr;
@@ -1120,62 +1123,64 @@ lx_do_composite_mask_two_pass(PixmapPtr pxDst, unsigned long dstOffset,
      * of the Pitch(stride) parameter, so we use maximun width of mask picture.
      * that is to say it is a scanline rendering process */
     if (width * height * 4 > DEFAULT_EXA_SCRATCH_BFRSZ) {
-	opWidth = width;
-	opHeight = DEFAULT_EXA_SCRATCH_BFRSZ / (width * 4);
-    } else {
-	opWidth = width;
-	opHeight = height;
+        opWidth = width;
+        opHeight = DEFAULT_EXA_SCRATCH_BFRSZ / (width * 4);
+    }
+    else {
+        opWidth = width;
+        opHeight = height;
     }
 
     while (1) {
 
-	/* Wait until the GP is idle - this will ensure that the scratch buffer
-	 * isn't occupied */
-
-	gp_wait_until_idle();
-
-	/* Copy the source to the scratch buffer, and do a src * mask raster
-	 * operation */
-
-	gp_declare_blt(0);
-	opPtr = &lx_alpha_ops[(exaScratch.op * 2) + 1];
-	gp_set_source_format(CIMGP_SOURCE_FMT_8_8_8_8);
-	gp_set_strides(opWidth * 4, exaScratch.srcPitch);
-	gp_set_bpp(lx_get_bpp_from_format(CIMGP_SOURCE_FMT_8_8_8_8));
-	gp_set_solid_source(exaScratch.srcColor);
-	gp_blend_mask_blt(exaScratch.bufferOffset, 0, opWidth, opHeight,
-	    maskOffset, exaScratch.srcPitch, opPtr->operation,
-	    exaScratch.fourBpp);
-
-	/* Do a relative operation(refer rendercheck ops.c), and copy the
-	 * operation result to destination */
-
-	gp_declare_blt(CIMGP_BLTFLAGS_HAZARD);
-	opPtr = &lx_alpha_ops[exaScratch.op * 2];
-	apply = (exaScratch.dstFormat->alphabits == 0) ?
-	    CIMGP_APPLY_BLEND_TO_RGB : CIMGP_APPLY_BLEND_TO_ALL;
-	gp_set_source_format(CIMGP_SOURCE_FMT_8_8_8_8);
-	gp_set_strides(exaGetPixmapPitch(pxDst), opWidth * 4);
-	gp_set_bpp(lx_get_bpp_from_format(exaScratch.dstFormat->fmt));
-	type = CIMGP_CONVERTED_ALPHA;
-	gp_set_alpha_operation(opPtr->operation, type, opPtr->channel,
-	    apply, 0);
-	gp_screen_to_screen_convert(dstOffset, exaScratch.bufferOffset,
-	    opWidth, opHeight, 0);
-
-	if (width * height * 4 > DEFAULT_EXA_SCRATCH_BFRSZ) {
-	    /* Finish the rendering */
-	    if (opoverY + opHeight == opY + height)
-		break;
-	    /* Recalculate the Dest and Mask rendering start point */
-	    srcPoint.y = srcPoint.y + F(opHeight);
-	    opoverY = opoverY + opHeight;
-	    if (opoverY + opHeight > opY + height)
-		opHeight = opY + height - opoverY;
-	    dstOffset = GetPixmapOffset(pxDst, opoverX, opoverY);
-	    maskOffset = GetSrcOffset(I(srcPoint.x), I(srcPoint.y));
-	} else
-	    break;
+        /* Wait until the GP is idle - this will ensure that the scratch buffer
+         * isn't occupied */
+
+        gp_wait_until_idle();
+
+        /* Copy the source to the scratch buffer, and do a src * mask raster
+         * operation */
+
+        gp_declare_blt(0);
+        opPtr = &lx_alpha_ops[(exaScratch.op * 2) + 1];
+        gp_set_source_format(CIMGP_SOURCE_FMT_8_8_8_8);
+        gp_set_strides(opWidth * 4, exaScratch.srcPitch);
+        gp_set_bpp(lx_get_bpp_from_format(CIMGP_SOURCE_FMT_8_8_8_8));
+        gp_set_solid_source(exaScratch.srcColor);
+        gp_blend_mask_blt(exaScratch.bufferOffset, 0, opWidth, opHeight,
+                          maskOffset, exaScratch.srcPitch, opPtr->operation,
+                          exaScratch.fourBpp);
+
+        /* Do a relative operation(refer rendercheck ops.c), and copy the
+         * operation result to destination */
+
+        gp_declare_blt(CIMGP_BLTFLAGS_HAZARD);
+        opPtr = &lx_alpha_ops[exaScratch.op * 2];
+        apply = (exaScratch.dstFormat->alphabits == 0) ?
+            CIMGP_APPLY_BLEND_TO_RGB : CIMGP_APPLY_BLEND_TO_ALL;
+        gp_set_source_format(CIMGP_SOURCE_FMT_8_8_8_8);
+        gp_set_strides(exaGetPixmapPitch(pxDst), opWidth * 4);
+        gp_set_bpp(lx_get_bpp_from_format(exaScratch.dstFormat->fmt));
+        type = CIMGP_CONVERTED_ALPHA;
+        gp_set_alpha_operation(opPtr->operation, type, opPtr->channel,
+                               apply, 0);
+        gp_screen_to_screen_convert(dstOffset, exaScratch.bufferOffset,
+                                    opWidth, opHeight, 0);
+
+        if (width * height * 4 > DEFAULT_EXA_SCRATCH_BFRSZ) {
+            /* Finish the rendering */
+            if (opoverY + opHeight == opY + height)
+                break;
+            /* Recalculate the Dest and Mask rendering start point */
+            srcPoint.y = srcPoint.y + F(opHeight);
+            opoverY = opoverY + opHeight;
+            if (opoverY + opHeight > opY + height)
+                opHeight = opY + height - opoverY;
+            dstOffset = GetPixmapOffset(pxDst, opoverX, opoverY);
+            maskOffset = GetSrcOffset(I(srcPoint.x), I(srcPoint.y));
+        }
+        else
+            break;
     }
 }
 
@@ -1189,7 +1194,7 @@ transformPoint(PictTransform * t, xPointFixed * point)
     v.vector[2] = xFixed1;
 
     if (t != NULL)
-	PictureTransformPoint(t, &v);
+        PictureTransformPoint(t, &v);
 
     point->x = v.vector[0];
     point->y = v.vector[1];
@@ -1197,7 +1202,7 @@ transformPoint(PictTransform * t, xPointFixed * point)
 
 static void
 lx_do_composite(PixmapPtr pxDst, int srcX, int srcY, int maskX,
-    int maskY, int dstX, int dstY, int width, int height)
+                int maskY, int dstX, int dstY, int width, int height)
 {
     unsigned int dstOffset, srcOffset = 0;
 
@@ -1211,11 +1216,12 @@ lx_do_composite(PixmapPtr pxDst, int srcX, int srcY, int maskX,
     /* Transform the source coordinates */
 
     if (exaScratch.type == COMP_TYPE_MASK) {
-	srcPoint.x = F(maskX);
-	srcPoint.y = F(maskY);
-    } else {
-	srcPoint.x = F(srcX);
-	srcPoint.y = F(srcY);
+        srcPoint.x = F(maskX);
+        srcPoint.y = F(maskY);
+    }
+    else {
+        srcPoint.x = F(srcX);
+        srcPoint.y = F(srcY);
     }
 
     /* srcX, srcY point to the upper right side of the bounding box
@@ -1225,26 +1231,26 @@ lx_do_composite(PixmapPtr pxDst, int srcX, int srcY, int maskX,
 
     switch (exaScratch.rotate) {
     case RR_Rotate_270:
-	srcPoint.x += F(width);
+        srcPoint.x += F(width);
 
-	opWidth = height;
-	opHeight = width;
-	break;
+        opWidth = height;
+        opHeight = width;
+        break;
 
     case RR_Rotate_180:
-	srcPoint.x += F(width);
-	srcPoint.y += F(height);
+        srcPoint.x += F(width);
+        srcPoint.y += F(height);
 
-	srcX += width;
-	srcY += height;
-	break;
+        srcX += width;
+        srcY += height;
+        break;
 
     case RR_Rotate_90:
-	srcPoint.y += F(height);
+        srcPoint.y += F(height);
 
-	opWidth = height;
-	opHeight = width;
-	break;
+        opWidth = height;
+        opHeight = width;
+        break;
     }
 
     transformPoint(exaScratch.transform, &srcPoint);
@@ -1252,13 +1258,13 @@ lx_do_composite(PixmapPtr pxDst, int srcX, int srcY, int maskX,
     /* Adjust the point to fit into the pixmap */
 
     if (I(srcPoint.x) < 0) {
-	opWidth += I(srcPoint.x);
-	srcPoint.x = F(0);
+        opWidth += I(srcPoint.x);
+        srcPoint.x = F(0);
     }
 
     if (I(srcPoint.y) < 0) {
-	opHeight += I(srcPoint.y);
-	srcPoint.y = F(0);
+        opHeight += I(srcPoint.y);
+        srcPoint.y = F(0);
     }
 
     /* Get the source point offset position */
@@ -1278,166 +1284,188 @@ lx_do_composite(PixmapPtr pxDst, int srcX, int srcY, int maskX,
      * exaScratch.srcWidth and exaScratch.srcHeight */
 
     if (exaScratch.type == COMP_TYPE_MASK) {
-	if ((exaScratch.srcWidth - maskX) < opWidth)
-	    opWidth = exaScratch.srcWidth - maskX;
-	if ((exaScratch.srcHeight - maskY) < opHeight)
-	    opHeight = exaScratch.srcHeight - maskY;
-    } else {
-	if (exaScratch.type == COMP_TYPE_ONEPASS) {
-	    /* This is the condition srcX or/and srcY is/are out of source
-	     * region */
-	    if (((srcX >= 0 && srcY >= exaScratch.srcHeight)
-		|| (srcX >= exaScratch.srcWidth  && srcY >= 0)) &&
-		(exaScratch.op == PictOpOver || exaScratch.op == PictOpSrc)) {
-		if (exaScratch.repeat == 1) {
-		    opWidth = width;
-		    opHeight = height;
-		} else {
-		    if (exaScratch.op == PictOpOver)
-			return ;
-		    else {
-			exaScratch.op = PictOpClear;
-			opWidth = width;
-			opHeight = height;
-		    }
-		}
-	    /* This is the condition srcX or/and srcY is/are in the source
-	     * region */
-	    } else if (srcX >= 0 && srcY >= 0 &&
-		(exaScratch.op == PictOpOver || exaScratch.op == PictOpSrc)) {
-		if (exaScratch.repeat == 1) {
-		    opWidth = width;
-		    opHeight = height;
-		} else {
-		    if ((exaScratch.srcWidth - srcX) < opWidth)
-			opWidth = exaScratch.srcWidth - srcX;
-		    if ((exaScratch.srcHeight - srcY) < opHeight)
-			opHeight = exaScratch.srcHeight - srcY;
-		}
-	    /* This is the condition srcX or/and srcY is/are negative */
-	    } else if ((srcX < 0 || srcY < 0) &&
-		(exaScratch.op == PictOpOver || exaScratch.op == PictOpSrc)) {
-		if (exaScratch.repeat == 1) {
-		    opWidth = width;
-		    opHeight = height;
-		} else {
-		/* Have not met this condition till now */
-		    return ;
-		}
-	    } else {
-		if (exaScratch.srcWidth < opWidth)
-		    opWidth = exaScratch.srcWidth;
-		if (exaScratch.srcHeight < opHeight)
-		    opHeight = exaScratch.srcHeight;
-	    }
-	} else {
-	    if (exaScratch.rotate == RR_Rotate_180) {
-	    } else {
-		if ((exaScratch.srcWidth - srcY) < opWidth)
-		    opWidth = exaScratch.srcWidth - srcY;
-		if ((exaScratch.srcHeight - srcX) < opHeight)
-		    opHeight = exaScratch.srcHeight - srcX;
-	    }
-	}
+        if ((exaScratch.srcWidth - maskX) < opWidth)
+            opWidth = exaScratch.srcWidth - maskX;
+        if ((exaScratch.srcHeight - maskY) < opHeight)
+            opHeight = exaScratch.srcHeight - maskY;
+    }
+    else {
+        if (exaScratch.type == COMP_TYPE_ONEPASS) {
+            /* This is the condition srcX or/and srcY is/are out of source
+             * region */
+            if (((srcX >= 0 && srcY >= exaScratch.srcHeight)
+                 || (srcX >= exaScratch.srcWidth && srcY >= 0)) &&
+                (exaScratch.op == PictOpOver || exaScratch.op == PictOpSrc)) {
+                if (exaScratch.repeat == 1) {
+                    opWidth = width;
+                    opHeight = height;
+                }
+                else {
+                    if (exaScratch.op == PictOpOver)
+                        return;
+                    else {
+                        exaScratch.op = PictOpClear;
+                        opWidth = width;
+                        opHeight = height;
+                    }
+                }
+                /* This is the condition srcX or/and srcY is/are in the source
+                 * region */
+            }
+            else if (srcX >= 0 && srcY >= 0 &&
+                     (exaScratch.op == PictOpOver ||
+                      exaScratch.op == PictOpSrc)) {
+                if (exaScratch.repeat == 1) {
+                    opWidth = width;
+                    opHeight = height;
+                }
+                else {
+                    if ((exaScratch.srcWidth - srcX) < opWidth)
+                        opWidth = exaScratch.srcWidth - srcX;
+                    if ((exaScratch.srcHeight - srcY) < opHeight)
+                        opHeight = exaScratch.srcHeight - srcY;
+                }
+                /* This is the condition srcX or/and srcY is/are negative */
+            }
+            else if ((srcX < 0 || srcY < 0) &&
+                     (exaScratch.op == PictOpOver ||
+                      exaScratch.op == PictOpSrc)) {
+                if (exaScratch.repeat == 1) {
+                    opWidth = width;
+                    opHeight = height;
+                }
+                else {
+                    /* Have not met this condition till now */
+                    return;
+                }
+            }
+            else {
+                if (exaScratch.srcWidth < opWidth)
+                    opWidth = exaScratch.srcWidth;
+                if (exaScratch.srcHeight < opHeight)
+                    opHeight = exaScratch.srcHeight;
+            }
+        }
+        else {
+            if (exaScratch.rotate == RR_Rotate_180) {
+            }
+            else {
+                if ((exaScratch.srcWidth - srcY) < opWidth)
+                    opWidth = exaScratch.srcWidth - srcY;
+                if ((exaScratch.srcHeight - srcX) < opHeight)
+                    opHeight = exaScratch.srcHeight - srcX;
+            }
+        }
     }
 
     while (1) {
 
-	dstOffset = GetPixmapOffset(pxDst, opX, opY);
-
-	switch (exaScratch.type) {
-
-	case COMP_TYPE_MASK:{
-	    if (exaScratch.op == PictOpOver || exaScratch.op ==
-		PictOpOutReverse || exaScratch.op == PictOpInReverse ||
-		exaScratch.op == PictOpIn || exaScratch.op == PictOpOut ||
-		exaScratch.op == PictOpOverReverse)
-		lx_do_composite_mask_two_pass(pxDst, dstOffset,
-		    srcOffset, opWidth, opHeight, opX, opY, srcPoint);
-	    else
-		lx_do_composite_mask(pxDst, dstOffset, srcOffset,
-		    opWidth, opHeight);
-	    }
-	    break;
-
-	case COMP_TYPE_ONEPASS:
-	    if ((exaScratch.op == PictOpOver || exaScratch.op == PictOpSrc)
-		&& (exaScratch.repeat == 1)) {
-		lx_composite_onepass_special(pxDst, opWidth, opHeight, opX, opY,
-		    srcX, srcY);
-		return ;
-	    } else if ((exaScratch.op == PictOpAdd) && (exaScratch.srcFormat->exa
-		== PICT_a8) && (exaScratch.dstFormat->exa == PICT_a8))
-		lx_composite_onepass_add_a8(pxDst, dstOffset, srcOffset,
-		    opWidth, opHeight, opX, opY, srcX, srcY);
-	    else
-		lx_composite_onepass(pxDst, dstOffset, srcOffset, opWidth,
-		    opHeight);
-	    break;
-
-	case COMP_TYPE_TWOPASS:
-	    lx_composite_multipass(pxDst, dstOffset, srcOffset, opWidth,
-		opHeight);
-
-	case COMP_TYPE_ROTATE:
-	    lx_composite_rotate(pxDst, dstOffset, srcOffset, opWidth,
-		opHeight);
-	    break;
-	}
-
-	opX += opWidth;
-
-	if (opX >= dstX + width) {
-	    opX = dstX;
-	    opY += opHeight;
-
-	    if (opY >= dstY + height)
-		break;
-	}
-
-	/* FIXME:  Please add the code to handle the condition when the maskX
-	 * and maskY coordinate are negative or greater than
-	 * exaScratch.srcWidth and exaScratch.srcHeight */
-
-	if (exaScratch.type == COMP_TYPE_MASK) {
-	    opWidth = ((dstX + width) - opX) > (exaScratch.srcWidth - maskX)
-		? (exaScratch.srcWidth - maskX) : (dstX + width) - opX;
-	    opHeight = ((dstY + height) - opY) > (exaScratch.srcHeight - maskY)
-		? (exaScratch.srcHeight - maskY) : (dstY + height) - opY;
-	    /* All black out of the mask */
-	    if (!exaScratch.maskrepeat)
-		exaScratch.srcColor = 0x0;
-	} else {
-	    if (exaScratch.type == COMP_TYPE_ONEPASS) {
-		if (srcX >= 0 && srcY >= 0 && (exaScratch.op == PictOpOver ||
-		    exaScratch.op == PictOpSrc || exaScratch.op ==
-		    PictOpClear)) {
-		    opWidth = ((dstX + width) - opX) > (exaScratch.srcWidth -
-			srcX) ? (exaScratch.srcWidth - srcX) : (dstX + width)
-			- opX;
-		    opHeight = ((dstY + height) - opY) >
-		    (exaScratch.srcHeight - srcY) ?
-		    (exaScratch.srcHeight - srcY) : (dstY + height) - opY;
-		} else {
-		opWidth = ((dstX + width) - opX) > exaScratch.srcWidth ?
-		    exaScratch.srcWidth : (dstX + width) - opX;
-		opHeight = ((dstY + height) - opY) > exaScratch.srcHeight ?
-		    exaScratch.srcHeight : (dstY + height) - opY;
-		}
-	    } else {
-		opWidth = ((dstX + width) - opX) > (exaScratch.srcWidth - srcY)
-		    ? (exaScratch.srcWidth - srcY) : (dstX + width) - opX;
-		opHeight = ((dstY + height) - opY) > (exaScratch.srcHeight - srcX
-		    ) ? (exaScratch.srcHeight - srcX) : (dstY + height) - opY;
-	    }
-	    /* All black out of the source */
-	    if (!exaScratch.repeat && (exaScratch.type == COMP_TYPE_ONEPASS)) {
-		    lx_composite_all_black(srcOffset, exaScratch.srcWidth,
-			exaScratch.srcHeight);
-	    }
-	    if (!exaScratch.repeat && (exaScratch.type == COMP_TYPE_ROTATE))
-		    break;
-	}
+        dstOffset = GetPixmapOffset(pxDst, opX, opY);
+
+        switch (exaScratch.type) {
+
+        case COMP_TYPE_MASK:{
+            if (exaScratch.op == PictOpOver || exaScratch.op ==
+                PictOpOutReverse || exaScratch.op == PictOpInReverse ||
+                exaScratch.op == PictOpIn || exaScratch.op == PictOpOut ||
+                exaScratch.op == PictOpOverReverse)
+                lx_do_composite_mask_two_pass(pxDst, dstOffset,
+                                              srcOffset, opWidth, opHeight, opX,
+                                              opY, srcPoint);
+            else
+                lx_do_composite_mask(pxDst, dstOffset, srcOffset,
+                                     opWidth, opHeight);
+        }
+            break;
+
+        case COMP_TYPE_ONEPASS:
+            if ((exaScratch.op == PictOpOver || exaScratch.op == PictOpSrc)
+                && (exaScratch.repeat == 1)) {
+                lx_composite_onepass_special(pxDst, opWidth, opHeight, opX, opY,
+                                             srcX, srcY);
+                return;
+            }
+            else if ((exaScratch.op == PictOpAdd) && (exaScratch.srcFormat->exa
+                                                      == PICT_a8) &&
+                     (exaScratch.dstFormat->exa == PICT_a8))
+                lx_composite_onepass_add_a8(pxDst, dstOffset, srcOffset,
+                                            opWidth, opHeight, opX, opY, srcX,
+                                            srcY);
+            else
+                lx_composite_onepass(pxDst, dstOffset, srcOffset, opWidth,
+                                     opHeight);
+            break;
+
+        case COMP_TYPE_TWOPASS:
+            lx_composite_multipass(pxDst, dstOffset, srcOffset, opWidth,
+                                   opHeight);
+
+        case COMP_TYPE_ROTATE:
+            lx_composite_rotate(pxDst, dstOffset, srcOffset, opWidth, opHeight);
+            break;
+        }
+
+        opX += opWidth;
+
+        if (opX >= dstX + width) {
+            opX = dstX;
+            opY += opHeight;
+
+            if (opY >= dstY + height)
+                break;
+        }
+
+        /* FIXME:  Please add the code to handle the condition when the maskX
+         * and maskY coordinate are negative or greater than
+         * exaScratch.srcWidth and exaScratch.srcHeight */
+
+        if (exaScratch.type == COMP_TYPE_MASK) {
+            opWidth = ((dstX + width) - opX) > (exaScratch.srcWidth - maskX)
+                ? (exaScratch.srcWidth - maskX) : (dstX + width) - opX;
+            opHeight = ((dstY + height) - opY) > (exaScratch.srcHeight - maskY)
+                ? (exaScratch.srcHeight - maskY) : (dstY + height) - opY;
+            /* All black out of the mask */
+            if (!exaScratch.maskrepeat)
+                exaScratch.srcColor = 0x0;
+        }
+        else {
+            if (exaScratch.type == COMP_TYPE_ONEPASS) {
+                if (srcX >= 0 && srcY >= 0 && (exaScratch.op == PictOpOver ||
+                                               exaScratch.op == PictOpSrc ||
+                                               exaScratch.op == PictOpClear)) {
+                    opWidth =
+                        ((dstX + width) - opX) >
+                        (exaScratch.srcWidth - srcX) ? (exaScratch.srcWidth -
+                                                        srcX) : (dstX + width)
+                        - opX;
+                    opHeight = ((dstY + height) - opY) >
+                        (exaScratch.srcHeight - srcY) ?
+                        (exaScratch.srcHeight - srcY) : (dstY + height) - opY;
+                }
+                else {
+                    opWidth = ((dstX + width) - opX) > exaScratch.srcWidth ?
+                        exaScratch.srcWidth : (dstX + width) - opX;
+                    opHeight = ((dstY + height) - opY) > exaScratch.srcHeight ?
+                        exaScratch.srcHeight : (dstY + height) - opY;
+                }
+            }
+            else {
+                opWidth = ((dstX + width) - opX) > (exaScratch.srcWidth - srcY)
+                    ? (exaScratch.srcWidth - srcY) : (dstX + width) - opX;
+                opHeight =
+                    ((dstY + height) - opY) >
+                    (exaScratch.srcHeight - srcX) ? (exaScratch.srcHeight -
+                                                     srcX) : (dstY + height) -
+                    opY;
+            }
+            /* All black out of the source */
+            if (!exaScratch.repeat && (exaScratch.type == COMP_TYPE_ONEPASS)) {
+                lx_composite_all_black(srcOffset, exaScratch.srcWidth,
+                                       exaScratch.srcHeight);
+            }
+            if (!exaScratch.repeat && (exaScratch.type == COMP_TYPE_ROTATE))
+                break;
+        }
     }
 }
 
@@ -1455,7 +1483,7 @@ lx_done(PixmapPtr ptr)
 #if 0
 static void
 lx_upload_to_screen(PixmapPtr pxDst, int x, int y, int w, int h,
-    char *src, int src_pitch)
+                    char *src, int src_pitch)
 {
     GeodeRec *pGeode = GEODEPTR_FROM_PIXMAP(pxDst);
     int dst_pitch = exaGetPixmapPitch(pxDst);
@@ -1464,13 +1492,13 @@ lx_upload_to_screen(PixmapPtr pxDst, int x, int y, int w, int h,
     char *dst;
     int offset = exaGetPixmapOffset(pxDst);
 
-    dst = (char *)(pGeode->FBBase + offset + (y * dst_pitch) + (x * cpp));
+    dst = (char *) (pGeode->FBBase + offset + (y * dst_pitch) + (x * cpp));
     int i;
 
     for (i = 0; i < h; i++) {
-	memcpy(dst, src, w * cpp);
-	dst += dst_pitch;
-	src += src_pitch;
+        memcpy(dst, src, w * cpp);
+        dst += dst_pitch;
+        src += src_pitch;
     }
 }
 #endif
@@ -1482,14 +1510,14 @@ lx_exa_pixmap_is_offscreen(PixmapPtr pPixmap)
 {
     ScrnInfoPtr pScrni = xf86Screens[pPixmap->drawable.pScreen->myNum];
     GeodeRec *pGeode = GEODEPTR(pScrni);
-    void *start = (void *)(pGeode->FBBase);
+    void *start = (void *) (pGeode->FBBase);
     void *end =
-	(void *)(pGeode->FBBase + pGeode->offscreenStart +
-	pGeode->offscreenSize);
+        (void *) (pGeode->FBBase + pGeode->offscreenStart +
+                  pGeode->offscreenSize);
 
-    if ((void *)pPixmap->devPrivate.ptr >= start &&
-	(void *)pPixmap->devPrivate.ptr < end)
-	return TRUE;
+    if ((void *) pPixmap->devPrivate.ptr >= start &&
+        (void *) pPixmap->devPrivate.ptr < end)
+        return TRUE;
 
     return FALSE;
 }
diff --git a/src/lx_memory.c b/src/lx_memory.c
index d833caa..f26d280 100644
--- a/src/lx_memory.c
+++ b/src/lx_memory.c
@@ -45,11 +45,11 @@ GeodeOffscreenFreeSize(GeodeRec * pGeode)
     GeodeMemPtr ptr = pGeode->offscreenList;
 
     if (ptr == NULL)
-	return pGeode->offscreenSize;
+        return pGeode->offscreenSize;
 
-    for (; ptr->next; ptr = ptr->next) ;
+    for (; ptr->next; ptr = ptr->next);
     return (pGeode->offscreenStart + pGeode->offscreenSize)
-	    - (ptr->offset + ptr->size);
+        - (ptr->offset + ptr->size);
 }
 
 void
@@ -62,12 +62,12 @@ GeodeFreeOffscreen(GeodeRec * pGeode, GeodeMemPtr ptr)
      */
 
     if (ptr->prev == NULL)
-	pGeode->offscreenList = ptr->next;
+        pGeode->offscreenList = ptr->next;
     else
-	ptr->prev->next = ptr->next;
+        ptr->prev->next = ptr->next;
 
     if (ptr->next)
-	ptr->next->prev = ptr->prev;
+        ptr->next->prev = ptr->prev;
 
     free(ptr);
 }
@@ -83,22 +83,22 @@ GeodeAllocRemainder(GeodeRec * pGeode)
     GeodeMemPtr nptr, ptr = pGeode->offscreenList;
 
     if (!pGeode->offscreenList) {
-	pGeode->offscreenList = calloc(1, sizeof(*nptr));
-	pGeode->offscreenList->offset = pGeode->offscreenStart;
-	pGeode->offscreenList->size = pGeode->offscreenSize;
-	pGeode->offscreenList->next = NULL;
-	pGeode->offscreenList->prev = NULL;
+        pGeode->offscreenList = calloc(1, sizeof(*nptr));
+        pGeode->offscreenList->offset = pGeode->offscreenStart;
+        pGeode->offscreenList->size = pGeode->offscreenSize;
+        pGeode->offscreenList->next = NULL;
+        pGeode->offscreenList->prev = NULL;
 
-	return pGeode->offscreenList;
+        return pGeode->offscreenList;
     }
 
     /* Go to the end of the list of allocated stuff */
-    for (; ptr->next; ptr = ptr->next) ;
+    for (; ptr->next; ptr = ptr->next);
 
     nptr = calloc(1, sizeof(*nptr));
     nptr->offset = ptr->offset + ptr->size;
     nptr->size = pGeode->offscreenSize -
-	(nptr->offset - pGeode->offscreenStart);
+        (nptr->offset - pGeode->offscreenStart);
 
     nptr->next = ptr->next;
     nptr->prev = ptr;
@@ -120,46 +120,46 @@ GeodeAllocOffscreen(GeodeRec * pGeode, int size, int align)
 
     if (!pGeode->offscreenList) {
 
-	if (size > pGeode->offscreenSize)
-	    return NULL;
+        if (size > pGeode->offscreenSize)
+            return NULL;
 
-	offset = ALIGN(pGeode->offscreenStart, align);
+        offset = ALIGN(pGeode->offscreenStart, align);
 
-	pGeode->offscreenList = calloc(1, sizeof(*nptr));
-	pGeode->offscreenList->offset = offset;
-	pGeode->offscreenList->size = size;
-	pGeode->offscreenList->next = NULL;
+        pGeode->offscreenList = calloc(1, sizeof(*nptr));
+        pGeode->offscreenList->offset = offset;
+        pGeode->offscreenList->size = size;
+        pGeode->offscreenList->next = NULL;
 
-	return pGeode->offscreenList;
+        return pGeode->offscreenList;
     }
 
     while (ptr) {
-	unsigned int gap;
+        unsigned int gap;
 
-	if (ptr->next == NULL)
-	    gap = pGeode->offscreenSize + pGeode->offscreenStart;
+        if (ptr->next == NULL)
+            gap = pGeode->offscreenSize + pGeode->offscreenStart;
 
-	else
-	    gap = ptr->next->offset;
+        else
+            gap = ptr->next->offset;
 
-	gap = gap - (ptr->offset + ptr->size);
-	gap = ALIGN(gap, align);
+        gap = gap - (ptr->offset + ptr->size);
+        gap = ALIGN(gap, align);
 
-	if (size < gap) {
-	    offset = ptr->offset + ptr->size;
-	    offset = ALIGN(ptr->offset + ptr->size, align);
+        if (size < gap) {
+            offset = ptr->offset + ptr->size;
+            offset = ALIGN(ptr->offset + ptr->size, align);
 
-	    nptr = calloc(1, sizeof(*nptr));
-	    nptr->offset = offset;
-	    nptr->size = size;
-	    nptr->next = ptr->next;
-	    nptr->prev = ptr;
-	    ptr->next = nptr;
+            nptr = calloc(1, sizeof(*nptr));
+            nptr->offset = offset;
+            nptr->size = size;
+            nptr->next = ptr->next;
+            nptr->prev = ptr;
+            ptr->next = nptr;
 
-	    return nptr;
-	}
+            return nptr;
+        }
 
-	ptr = ptr->next;
+        ptr = ptr->next;
     }
 
     return NULL;
@@ -182,115 +182,118 @@ LXInitOffscreen(ScrnInfoPtr pScrni)
     fbavail = pGeode->FBAvail - GP3_SCRATCH_BUFFER_SIZE;
 
     pGeode->displaySize = MAX(pScrni->virtualX, pScrni->virtualY)
-	* pGeode->Pitch;
+        * pGeode->Pitch;
 
     pGeode->offscreenStart = pGeode->displaySize;
     pGeode->offscreenSize = fbavail - pGeode->displaySize;
 
     /* Allocate the usual memory suspects */
     if (pGeode->tryCompression) {
-	int size = pScrni->virtualY * LX_CB_PITCH;
-
-	/* The compression buffer needs to be 16 byte aligned */
-	ptr = GeodeAllocOffscreen(pGeode, size, 16);
-
-	if (ptr != NULL) {
-	    pGeode->CBData.compression_offset = ptr->offset;
-	    pGeode->CBData.size = LX_CB_PITCH;
-	    pGeode->CBData.pitch = LX_CB_PITCH;
-
-	    pGeode->Compression = TRUE;
-	} else {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Not enough memory for compression\n");
-	    pGeode->Compression = FALSE;
-	}
+        int size = pScrni->virtualY * LX_CB_PITCH;
+
+        /* The compression buffer needs to be 16 byte aligned */
+        ptr = GeodeAllocOffscreen(pGeode, size, 16);
+
+        if (ptr != NULL) {
+            pGeode->CBData.compression_offset = ptr->offset;
+            pGeode->CBData.size = LX_CB_PITCH;
+            pGeode->CBData.pitch = LX_CB_PITCH;
+
+            pGeode->Compression = TRUE;
+        }
+        else {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Not enough memory for compression\n");
+            pGeode->Compression = FALSE;
+        }
     }
 
     if (pGeode->tryHWCursor) {
-	ptr = GeodeAllocOffscreen(pGeode,
-		LX_CURSOR_HW_WIDTH * 4 * LX_CURSOR_HW_HEIGHT, 4);
-
-	if (ptr != NULL) {
-	    pGeode->CursorStartOffset = ptr->offset;
-	    pGeode->HWCursor = TRUE;
-	} else {
-	    xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		"Not enough memory for the hardware cursor\n");
-	    pGeode->HWCursor = FALSE;
-	}
+        ptr = GeodeAllocOffscreen(pGeode,
+                                  LX_CURSOR_HW_WIDTH * 4 * LX_CURSOR_HW_HEIGHT,
+                                  4);
+
+        if (ptr != NULL) {
+            pGeode->CursorStartOffset = ptr->offset;
+            pGeode->HWCursor = TRUE;
+        }
+        else {
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                       "Not enough memory for the hardware cursor\n");
+            pGeode->HWCursor = FALSE;
+        }
     }
 
     if (!pGeode->NoAccel && pGeode->pExa) {
-	int size;
+        int size;
 
-	/* Try to get the scratch buffer for blending */
-	pGeode->exaBfrOffset = 0;
+        /* Try to get the scratch buffer for blending */
+        pGeode->exaBfrOffset = 0;
 
-	if (pGeode->exaBfrSz > 0) {
-	    ptr = GeodeAllocOffscreen(pGeode, pGeode->exaBfrSz, 4);
-	    if (ptr != NULL)
-		pGeode->exaBfrOffset = ptr->offset;
-	}
+        if (pGeode->exaBfrSz > 0) {
+            ptr = GeodeAllocOffscreen(pGeode, pGeode->exaBfrSz, 4);
+            if (ptr != NULL)
+                pGeode->exaBfrOffset = ptr->offset;
+        }
 
-	pGeode->pExa->offScreenBase = 0;
-	pGeode->pExa->memorySize = 0;
+        pGeode->pExa->offScreenBase = 0;
+        pGeode->pExa->memorySize = 0;
 
-	/* This might cause complaints - in order to avoid using
+        /* This might cause complaints - in order to avoid using
            xorg.conf as much as possible, we make assumptions about
            what a "default" memory map would look like.  After
            discussion, we agreed that the default driver should assume
            the user will want to use rotation and video overlays, and
-	   EXA will get whatever is leftover. 
-        */
+           EXA will get whatever is leftover. 
+         */
 
-	/* Get the amount of offscreen memory still left */
-	size = GeodeOffscreenFreeSize(pGeode);
+        /* Get the amount of offscreen memory still left */
+        size = GeodeOffscreenFreeSize(pGeode);
 
-	/* Align the size to a K boundary */	
-	size &= ~1023;
+        /* Align the size to a K boundary */
+        size &= ~1023;
 
-	/* Allocate the EXA offscreen space */
-	ptr = GeodeAllocOffscreen(pGeode, size, 4);
+        /* Allocate the EXA offscreen space */
+        ptr = GeodeAllocOffscreen(pGeode, size, 4);
 
-	if (ptr == NULL) {
-	    /* If we couldn't allocate what we wanted,
-	     * then allocate whats left */
+        if (ptr == NULL) {
+            /* If we couldn't allocate what we wanted,
+             * then allocate whats left */
 
-	    ptr = GeodeAllocRemainder(pGeode);
-	}
+            ptr = GeodeAllocRemainder(pGeode);
+        }
 
-	if (ptr != NULL) {
-	    pGeode->pExa->offScreenBase = ptr->offset;
-	    pGeode->pExa->memorySize = ptr->offset + ptr->size;
-	}
+        if (ptr != NULL) {
+            pGeode->pExa->offScreenBase = ptr->offset;
+            pGeode->pExa->memorySize = ptr->offset + ptr->size;
+        }
     }
 
     /* Show the memory map for diagnostic purposes */
 
     xf86DrvMsg(pScrni->scrnIndex, X_INFO, "LX video memory:\n");
     xf86DrvMsg(pScrni->scrnIndex, X_INFO, " Display: 0x%x bytes\n",
-	pGeode->displaySize);
+               pGeode->displaySize);
 
     if (pGeode->Compression)
-	xf86DrvMsg(pScrni->scrnIndex, X_INFO, " Compression: 0x%x bytes\n",
-	    pScrni->virtualY * LX_CB_PITCH);
+        xf86DrvMsg(pScrni->scrnIndex, X_INFO, " Compression: 0x%x bytes\n",
+                   pScrni->virtualY * LX_CB_PITCH);
 
     if (pGeode->HWCursor)
-	xf86DrvMsg(pScrni->scrnIndex, X_INFO, " Cursor: 0x%x bytes\n",
-	    LX_CURSOR_HW_WIDTH * 4 * LX_CURSOR_HW_HEIGHT);
+        xf86DrvMsg(pScrni->scrnIndex, X_INFO, " Cursor: 0x%x bytes\n",
+                   LX_CURSOR_HW_WIDTH * 4 * LX_CURSOR_HW_HEIGHT);
 
     if (pGeode->exaBfrSz)
-	xf86DrvMsg(pScrni->scrnIndex, X_INFO, " ExaBfrSz: 0x%x bytes\n",
-	    pGeode->exaBfrSz);
+        xf86DrvMsg(pScrni->scrnIndex, X_INFO, " ExaBfrSz: 0x%x bytes\n",
+                   pGeode->exaBfrSz);
 
     if (pGeode->pExa && pGeode->pExa->offScreenBase)
-	xf86DrvMsg(pScrni->scrnIndex, X_INFO, " EXA: 0x%x bytes\n",
-	    (unsigned int)(pGeode->pExa->memorySize -
-		pGeode->pExa->offScreenBase));
+        xf86DrvMsg(pScrni->scrnIndex, X_INFO, " EXA: 0x%x bytes\n",
+                   (unsigned int) (pGeode->pExa->memorySize -
+                                   pGeode->pExa->offScreenBase));
 
     xf86DrvMsg(pScrni->scrnIndex, X_INFO, " FREE: 0x%x bytes\n",
-	GeodeOffscreenFreeSize(pGeode));
+               GeodeOffscreenFreeSize(pGeode));
 }
 
 /* Called as we go down, so blitz everybody */
@@ -303,9 +306,9 @@ GeodeCloseOffscreen(ScrnInfoPtr pScrni)
     GeodeMemPtr nptr;
 
     while (ptr) {
-	nptr = ptr->next;
-	free(ptr);
-	ptr = nptr;
+        nptr = ptr->next;
+        free(ptr);
+        ptr = nptr;
     }
 
     pGeode->offscreenList = NULL;
diff --git a/src/lx_output.c b/src/lx_output.c
index 6e36426..40455ce 100644
--- a/src/lx_output.c
+++ b/src/lx_output.c
@@ -37,8 +37,7 @@
 
 #define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
 
-typedef struct _LXOutputPrivateRec
-{
+typedef struct _LXOutputPrivateRec {
     I2CBusPtr pDDCBus;
 } LXOutputPrivateRec, *LXOutputPrivatePtr;
 
@@ -55,30 +54,31 @@ lx_create_resources(xf86OutputPtr output)
     /* Scaling is only used for panels */
 
     if (!(pGeode->Output & OUTPUT_PANEL))
-	return;
+        return;
 
     scale_atom = MAKE_ATOM("scale");
     ret = RRConfigureOutputProperty(output->randr_output,
-	scale_atom, FALSE, FALSE, FALSE, 0, NULL);
+                                    scale_atom, FALSE, FALSE, FALSE, 0, NULL);
 
     if (ret) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "RRConfigureOutputProperty error %d\n", ret);
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "RRConfigureOutputProperty error %d\n", ret);
     }
 
     s = "on";
     ret = RRChangeOutputProperty(output->randr_output, scale_atom,
-	XA_STRING, 8, PropModeReplace, strlen(s), (pointer) s, FALSE, FALSE);
+                                 XA_STRING, 8, PropModeReplace, strlen(s),
+                                 (pointer) s, FALSE, FALSE);
 
     if (ret) {
-	xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-	    "RRCharOutputProperty error %d\n", ret);
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                   "RRCharOutputProperty error %d\n", ret);
     }
 }
 
 static Bool
 lx_output_set_property(xf86OutputPtr output, Atom property,
-    RRPropertyValuePtr value)
+                       RRPropertyValuePtr value)
 {
     ScrnInfoPtr pScrni = output->scrn;
     GeodeRec *pGeode = GEODEPTR(pScrni);
@@ -87,33 +87,34 @@ lx_output_set_property(xf86OutputPtr output, Atom property,
     int ret;
 
     if (property != scale_atom)
-	return FALSE;
+        return FALSE;
 
     if (value->type != XA_STRING || value->format != 8)
-	return FALSE;
+        return FALSE;
 
-    s = (char *)value->data;
+    s = (char *) value->data;
 
     if (value->size == 2 && !strncmp("on", s, 2))
-	pGeode->Scale = TRUE;
+        pGeode->Scale = TRUE;
     else if (value->size == 3 && !strncmp("off", s, 3))
-	pGeode->Scale = FALSE;
+        pGeode->Scale = FALSE;
 
     if (pGeode->Scale != scale && output->crtc) {
-	xf86CrtcPtr crtc = output->crtc;
+        xf86CrtcPtr crtc = output->crtc;
 
-	if (crtc->enabled) {
-	    ret = xf86CrtcSetMode(crtc, &crtc->desiredMode,
-		crtc->desiredRotation, crtc->desiredX, crtc->desiredY);
+        if (crtc->enabled) {
+            ret = xf86CrtcSetMode(crtc, &crtc->desiredMode,
+                                  crtc->desiredRotation, crtc->desiredX,
+                                  crtc->desiredY);
 
-	    if (!ret) {
-		xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
-		    "Failed to set mode after property change!\n");
+            if (!ret) {
+                xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
+                           "Failed to set mode after property change!\n");
 
-		pGeode->Scale = scale;
-		return FALSE;
-	    }
-	}
+                pGeode->Scale = scale;
+                return FALSE;
+            }
+        }
     }
 
     return TRUE;
@@ -187,14 +188,14 @@ lx_output_mode_valid(xf86OutputPtr output, DisplayModePtr pMode)
 
 static Bool
 lx_output_mode_fixup(xf86OutputPtr output, DisplayModePtr mode,
-    DisplayModePtr adjusted_mode)
+                     DisplayModePtr adjusted_mode)
 {
     return TRUE;
 }
 
 static void
 lx_output_mode_set(xf86OutputPtr output, DisplayModePtr mode,
-    DisplayModePtr adjusted_mode)
+                   DisplayModePtr adjusted_mode)
 {
     ScrnInfoPtr pScrni = output->scrn;
     GeodeRec *pGeode = GEODEPTR(pScrni);
@@ -202,10 +203,10 @@ lx_output_mode_set(xf86OutputPtr output, DisplayModePtr mode,
     /* Configure the output path */
 
     if (pGeode->Output & OUTPUT_PANEL)
-	df_set_output_path((pGeode->Output & OUTPUT_CRT) ?
-	    DF_DISPLAY_CRT_FP : DF_DISPLAY_FP);
+        df_set_output_path((pGeode->Output & OUTPUT_CRT) ?
+                           DF_DISPLAY_CRT_FP : DF_DISPLAY_FP);
     else
-	df_set_output_path(DF_DISPLAY_CRT);
+        df_set_output_path(DF_DISPLAY_CRT);
 }
 
 static xf86OutputStatus
@@ -228,11 +229,12 @@ lx_output_get_modes(xf86OutputPtr output)
     DisplayModePtr modes;
 
     if (!(pGeode->Output & OUTPUT_PANEL)) {
-	mon = xf86OutputGetEDID(output, lx_output->pDDCBus);
-	xf86OutputSetEDID(output, mon);
-	modes = xf86OutputGetEDIDModes(output);
-    } else {
-	modes = xf86DuplicateMode(pGeode->panelMode);
+        mon = xf86OutputGetEDID(output, lx_output->pDDCBus);
+        xf86OutputSetEDID(output, mon);
+        modes = xf86OutputGetEDIDModes(output);
+    }
+    else {
+        modes = xf86DuplicateMode(pGeode->panelMode);
     }
 
     return modes;
@@ -242,19 +244,19 @@ static void
 lx_output_destroy(xf86OutputPtr output)
 {
     if (output->driver_private)
-	free(output->driver_private);
+        free(output->driver_private);
 
     output->driver_private = NULL;
 }
 
 #ifdef RANDR_GET_CRTC_INTERFACE
-static xf86CrtcPtr lx_output_get_crtc(xf86OutputPtr output)
+static xf86CrtcPtr
+lx_output_get_crtc(xf86OutputPtr output)
 {
     return output->crtc;
 }
 #endif
 
-
 static const xf86OutputFuncsRec lx_output_funcs = {
     .create_resources = lx_create_resources,
     .dpms = lx_output_dpms,
@@ -286,8 +288,8 @@ LXSetupOutput(ScrnInfoPtr pScrni)
     lxpriv = xnfcalloc(1, sizeof(LXOutputPrivateRec));
 
     if (!lxpriv) {
-	xf86OutputDestroy(output);
-	return;
+        xf86OutputDestroy(output);
+        return;
     }
 
     output->driver_private = lxpriv;
@@ -299,13 +301,14 @@ LXSetupOutput(ScrnInfoPtr pScrni)
     GeodeI2CInit(pScrni, &lxpriv->pDDCBus, "CS5536 DDC");
 
     if (pScrni->monitor->widthmm && pScrni->monitor->heightmm) {
-	/* prioritize the admin's screen size */
-	output->mm_width = pScrni->monitor->widthmm;
-	output->mm_height = pScrni->monitor->heightmm;
-    } else if (pGeode->mm_width && pGeode->mm_height) {
-	/* if we have a panel that we're certain of the size of, set it */
-	output->mm_width = pScrni->monitor->widthmm = pGeode->mm_width;
-	output->mm_height = pScrni->monitor->heightmm = pGeode->mm_height;
+        /* prioritize the admin's screen size */
+        output->mm_width = pScrni->monitor->widthmm;
+        output->mm_height = pScrni->monitor->heightmm;
+    }
+    else if (pGeode->mm_width && pGeode->mm_height) {
+        /* if we have a panel that we're certain of the size of, set it */
+        output->mm_width = pScrni->monitor->widthmm = pGeode->mm_width;
+        output->mm_height = pScrni->monitor->heightmm = pGeode->mm_height;
     }
 
     /* We only have one CRTC, and this output is tied to it */
diff --git a/src/lx_panel.c b/src/lx_panel.c
index 95cf0b3..6b5d4ed 100644
--- a/src/lx_panel.c
+++ b/src/lx_panel.c
@@ -49,29 +49,29 @@
 
 DisplayModeRec lx_panel_modes[] = {
     {MODEPREFIX, 31200, 320, 354, 384, 400, 0, 240, 249, 253, 260, 0,
-	V_NHSYNC | V_NVSYNC, MODESUFFIX}
-    ,				       /* 320x200@75 */
+     V_NHSYNC | V_NVSYNC, MODESUFFIX}
+    ,                           /* 320x200@75 */
     {MODEPREFIX, 25175, 640, 656, 744, 800, 0, 480, 490, 492, 525, 0,
-	V_NHSYNC | V_NVSYNC, MODESUFFIX}
-    ,				       /* 640x480@60 */
+     V_NHSYNC | V_NVSYNC, MODESUFFIX}
+    ,                           /* 640x480@60 */
     {MODEPREFIX, 40000, 800, 840, 968, 1056, 0, 600, 601, 605, 628, 0,
-	V_NHSYNC | V_NVSYNC, MODESUFFIX}
-    ,				       /* 880x600@60 */
+     V_NHSYNC | V_NVSYNC, MODESUFFIX}
+    ,                           /* 880x600@60 */
     {MODEPREFIX, 65000, 1024, 1048, 1184, 1344, 0, 768, 771, 777, 806, 0,
-	V_NHSYNC | V_NVSYNC, MODESUFFIX}
-    ,				       /* 1024x768@60 */
+     V_NHSYNC | V_NVSYNC, MODESUFFIX}
+    ,                           /* 1024x768@60 */
     {MODEPREFIX, 81600, 1152, 1216, 1336, 1520, 0, 864, 865, 868, 895, 0,
-	V_NHSYNC | V_NVSYNC, MODESUFFIX}
-    ,				       /* 1152x864@60 */
+     V_NHSYNC | V_NVSYNC, MODESUFFIX}
+    ,                           /* 1152x864@60 */
     {MODEPREFIX, 108000, 1280, 1328, 1440, 1688, 0, 1024, 1025, 1028, 1066, 0,
-	V_NHSYNC | V_NVSYNC, MODESUFFIX}
-    ,				       /* 1280x1024@60 */
+     V_NHSYNC | V_NVSYNC, MODESUFFIX}
+    ,                           /* 1280x1024@60 */
     {MODEPREFIX, 162000, 1600, 1664, 1856, 2160, 0, 1200, 1201, 1204, 1250, 0,
-	V_NHSYNC | V_NVSYNC, MODESUFFIX}
-    ,				       /* 1600x1200@60 */
+     V_NHSYNC | V_NVSYNC, MODESUFFIX}
+    ,                           /* 1600x1200@60 */
     {MODEPREFIX, 48960, 1024, 1064, 1168, 1312, 0, 600, 601, 604, 622, 0,
-        V_NHSYNC | V_NVSYNC, MODESUFFIX}
-    ,				       /* 1024x600@60 wide panels */
+     V_NHSYNC | V_NVSYNC, MODESUFFIX}
+    ,                           /* 1024x600@60 wide panels */
 };
 
 /* Get the legacy panel size from VSA, and return the associated mode rec */
@@ -81,25 +81,26 @@ LXGetLegacyPanelMode(ScrnInfoPtr pScrni)
 {
     unsigned short reg = LX_READ_VG(0x00);
     unsigned char ret = (reg >> 8) & 0x07;
+
     if ((ret == 1 || ret == 5)) {
 
-	reg = LX_READ_VG(0x02);
-	ret = (reg >> 3) & 0x07;
+        reg = LX_READ_VG(0x02);
+        ret = (reg >> 3) & 0x07;
 
-	/* FIXME: 7 is reserved in default. We use this value to support
- 	 * wide screen resolution 1024x600@80 now for panel. If you want to use
- 	 * that resolution, please assign ret to 7 manually here:
- 	 * "reg = 7"
- 	 * The user can use this entry for other wide screen resolutions.
-	 */
+        /* FIXME: 7 is reserved in default. We use this value to support
+         * wide screen resolution 1024x600@80 now for panel. If you want to use
+         * that resolution, please assign ret to 7 manually here:
+         * "reg = 7"
+         * The user can use this entry for other wide screen resolutions.
+         */
 
-	if (ret < 8) {
-	    xf86DrvMsg(pScrni->scrnIndex, X_INFO,
-		" VSA Panel Mode is: %dx%d, pixel clock freq(kHz) is %d\n",
-		lx_panel_modes[ret].HDisplay, lx_panel_modes[ret].VDisplay,
-		lx_panel_modes[ret].Clock);
-	    return &lx_panel_modes[ret];
-	}
+        if (ret < 8) {
+            xf86DrvMsg(pScrni->scrnIndex, X_INFO,
+                       " VSA Panel Mode is: %dx%d, pixel clock freq(kHz) is %d\n",
+                       lx_panel_modes[ret].HDisplay,
+                       lx_panel_modes[ret].VDisplay, lx_panel_modes[ret].Clock);
+            return &lx_panel_modes[ret];
+        }
 
     }
 
@@ -118,17 +119,17 @@ LXGetManualPanelMode(char *modestr)
     char sname[32];
 
     int ret = sscanf(modestr, "%d %d %d %d %d %d %d %d %d",
-	&clock,
-	&hactive, &hsstart, &hsend, &htotal,
-	&vactive, &vsstart, &vsend, &vtotal);
+                     &clock,
+                     &hactive, &hsstart, &hsend, &htotal,
+                     &vactive, &vsstart, &vsend, &vtotal);
 
     if (ret != 9)
-	return NULL;
+        return NULL;
 
     mode = xnfcalloc(1, sizeof(DisplayModeRec));
 
     if (mode == NULL)
-	return NULL;
+        return NULL;
 
     sprintf(sname, "%dx%d", hactive, vactive);
 
diff --git a/src/lx_video.c b/src/lx_video.c
index 35e3ffa..cf1c380 100644
--- a/src/lx_video.c
+++ b/src/lx_video.c
@@ -67,8 +67,9 @@
 static void LXStopVideo(ScrnInfoPtr pScrni, pointer data, Bool exit);
 
 static void
+
 LXDisplayVideo(ScrnInfoPtr pScrni, int id, short width, short height,
-    BoxPtr dstBox, short srcW, short srcH, short drawW, short drawH);
+               BoxPtr dstBox, short srcW, short srcH, short drawW, short drawH);
 
 static void LXResetVideo(ScrnInfoPtr pScrni);
 
@@ -97,8 +98,7 @@ static XF86ImageRec Images[] = {
     XVIMAGE_RGB565
 };
 
-typedef struct
-{
+typedef struct {
     ExaOffscreenArea *vidmem;
     RegionRec clip;
     CARD32 filter;
@@ -115,7 +115,7 @@ typedef struct
 
 static void
 LXCopyFromSys(GeodeRec * pGeode, unsigned char *src, unsigned int dst,
-    int dstPitch, int srcPitch, int h, int w)
+              int dstPitch, int srcPitch, int h, int w)
 {
 
     gp_declare_blt(0);
@@ -136,36 +136,36 @@ LXSetColorkey(ScrnInfoPtr pScrni, GeodePortPrivRec * pPriv)
 
     switch (pScrni->depth) {
     case 8:
-	vg_get_display_palette_entry(pPriv->colorKey & 0xFF, &key);
-	red = ((key >> 16) & 0xFF);
-	green = ((key >> 8) & 0xFF);
-	blue = (key & 0xFF);
-	break;
+        vg_get_display_palette_entry(pPriv->colorKey & 0xFF, &key);
+        red = ((key >> 16) & 0xFF);
+        green = ((key >> 8) & 0xFF);
+        blue = (key & 0xFF);
+        break;
     case 16:
-	red = (pPriv->colorKey & pScrni->mask.red) >>
-	    pScrni->offset.red << (8 - pScrni->weight.red);
-	green = (pPriv->colorKey & pScrni->mask.green) >>
-	    pScrni->offset.green << (8 - pScrni->weight.green);
-	blue = (pPriv->colorKey & pScrni->mask.blue) >>
-	    pScrni->offset.blue << (8 - pScrni->weight.blue);
-	break;
+        red = (pPriv->colorKey & pScrni->mask.red) >>
+            pScrni->offset.red << (8 - pScrni->weight.red);
+        green = (pPriv->colorKey & pScrni->mask.green) >>
+            pScrni->offset.green << (8 - pScrni->weight.green);
+        blue = (pPriv->colorKey & pScrni->mask.blue) >>
+            pScrni->offset.blue << (8 - pScrni->weight.blue);
+        break;
     default:
-	/* for > 16 bpp we send in the mask in xf86SetWeight. This
-	 * function is providing the offset by 1 more. So we take
-	 * this as a special case and subtract 1 for > 16
-	 */
-
-	red = (pPriv->colorKey & pScrni->mask.red) >>
-	    (pScrni->offset.red - 1) << (8 - pScrni->weight.red);
-	green = (pPriv->colorKey & pScrni->mask.green) >>
-	    (pScrni->offset.green - 1) << (8 - pScrni->weight.green);
-	blue = (pPriv->colorKey & pScrni->mask.blue) >>
-	    (pScrni->offset.blue - 1) << (8 - pScrni->weight.blue);
-	break;
+        /* for > 16 bpp we send in the mask in xf86SetWeight. This
+         * function is providing the offset by 1 more. So we take
+         * this as a special case and subtract 1 for > 16
+         */
+
+        red = (pPriv->colorKey & pScrni->mask.red) >>
+            (pScrni->offset.red - 1) << (8 - pScrni->weight.red);
+        green = (pPriv->colorKey & pScrni->mask.green) >>
+            (pScrni->offset.green - 1) << (8 - pScrni->weight.green);
+        blue = (pPriv->colorKey & pScrni->mask.blue) >>
+            (pScrni->offset.blue - 1) << (8 - pScrni->weight.blue);
+        break;
     }
 
     df_set_video_color_key((blue | (green << 8) | (red << 16)),
-	0xFFFFFF, (pPriv->colorKeyMode == 0));
+                           0xFFFFFF, (pPriv->colorKeyMode == 0));
 
     REGION_EMPTY(pScrni->pScreen, &pPriv->clip);
 }
@@ -176,8 +176,7 @@ LXSetColorkey(ScrnInfoPtr pScrni, GeodePortPrivRec * pPriv)
    the structure, and possibly cause us cache issues.
 */
 
-struct
-{
+struct {
     unsigned int dstOffset;
     unsigned int dstPitch;
     unsigned int UVPitch;
@@ -188,30 +187,30 @@ struct
 /* Copy planar YUV data */
 
 static Bool
-LXAllocateVidMem(ScrnInfoPtr pScrni, GeodePortPrivRec *pPriv, int size)
+LXAllocateVidMem(ScrnInfoPtr pScrni, GeodePortPrivRec * pPriv, int size)
 {
-    if (!pPriv->vidmem || pPriv->vidmem->size < size) { 
-	if (pPriv->vidmem) {
-		exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
-		pPriv->vidmem = NULL;
-	}
-
-	pPriv->vidmem = exaOffscreenAlloc(pScrni->pScreen, size, 4,
-			TRUE, NULL, NULL);
-
-    	if (pPriv->vidmem == NULL) {
-		ErrorF("Could not allocate memory for the video\n");
-		return FALSE;
-    	}
+    if (!pPriv->vidmem || pPriv->vidmem->size < size) {
+        if (pPriv->vidmem) {
+            exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
+            pPriv->vidmem = NULL;
+        }
+
+        pPriv->vidmem = exaOffscreenAlloc(pScrni->pScreen, size, 4,
+                                          TRUE, NULL, NULL);
+
+        if (pPriv->vidmem == NULL) {
+            ErrorF("Could not allocate memory for the video\n");
+            return FALSE;
+        }
     }
 
     return TRUE;
-}	
+}
 
 static Bool
 LXCopyPlanar(ScrnInfoPtr pScrni, int id, unsigned char *buf,
-    short x1, short y1, short x2, short y2,
-    int width, int height, pointer data)
+             short x1, short y1, short x2, short y2,
+             int width, int height, pointer data)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
     GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
@@ -240,8 +239,8 @@ LXCopyPlanar(ScrnInfoPtr pScrni, int id, unsigned char *buf,
     size += UVDstPitch * height;
 
     if (LXAllocateVidMem(pScrni, pPriv, size) == FALSE) {
-	ErrorF("Error allocating an offscreen Planar region.\n");
-	return FALSE;
+        ErrorF("Error allocating an offscreen Planar region.\n");
+        return FALSE;
     }
 
     /* The top of the source region we want to copy */
@@ -268,14 +267,14 @@ LXCopyPlanar(ScrnInfoPtr pScrni, int id, unsigned char *buf,
     /* Copy Y */
 
     LXCopyFromSys(pGeode, buf + YSrcOffset,
-	pPriv->vidmem->offset + YDstOffset, YDstPitch, YSrcPitch, lines,
-	pixels);
+                  pPriv->vidmem->offset + YDstOffset, YDstPitch, YSrcPitch,
+                  lines, pixels);
 
     /* Copy U + V at the same time */
 
     LXCopyFromSys(pGeode, buf + USrcOffset,
-	pPriv->vidmem->offset + UDstOffset, UVDstPitch, UVSrcPitch, lines,
-	pixels >> 1);
+                  pPriv->vidmem->offset + UDstOffset, UVDstPitch, UVSrcPitch,
+                  lines, pixels >> 1);
 
     videoScratch.dstOffset = pPriv->vidmem->offset + YDstOffset;
     videoScratch.dstPitch = YDstPitch;
@@ -288,8 +287,8 @@ LXCopyPlanar(ScrnInfoPtr pScrni, int id, unsigned char *buf,
 
 static Bool
 LXCopyPacked(ScrnInfoPtr pScrni, int id, unsigned char *buf,
-    short x1, short y1, short x2, short y2,
-    int width, int height, pointer data)
+             short x1, short y1, short x2, short y2,
+             int width, int height, pointer data)
 {
     GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
     GeodeRec *pGeode = GEODEPTR(pScrni);
@@ -303,8 +302,8 @@ LXCopyPacked(ScrnInfoPtr pScrni, int id, unsigned char *buf,
     lines = ((dstPitch * height) + pGeode->Pitch - 1) / pGeode->Pitch;
 
     if (LXAllocateVidMem(pScrni, pPriv, dstPitch * height) == FALSE) {
-	ErrorF("Error allocating an offscreen Packed region.\n");
-	return FALSE;
+        ErrorF("Error allocating an offscreen Packed region.\n");
+        return FALSE;
     }
 
     /* The top of the source region we want to copy */
@@ -326,17 +325,18 @@ LXCopyPacked(ScrnInfoPtr pScrni, int id, unsigned char *buf,
 
     if (id == FOURCC_Y800) {
 
-	/* Use the shared (unaccelerated) greyscale copy - you could probably
-	 * accelerate it using a 2 pass blit and patterns, but it doesn't really
-	 * seem worth it
-	 */
+        /* Use the shared (unaccelerated) greyscale copy - you could probably
+         * accelerate it using a 2 pass blit and patterns, but it doesn't really
+         * seem worth it
+         */
 
-	GeodeCopyGreyscale(buf + srcOffset, pGeode->FBBase + dstOffset,
-	    srcPitch, dstPitch, height, pixels >> 1);
-    } else
-	/* FIXME: should lines be used here instead of height? */
-	LXCopyFromSys(pGeode, buf + srcOffset, dstOffset, dstPitch, srcPitch,
-	    height, pixels);
+        GeodeCopyGreyscale(buf + srcOffset, pGeode->FBBase + dstOffset,
+                           srcPitch, dstPitch, height, pixels >> 1);
+    }
+    else
+        /* FIXME: should lines be used here instead of height? */
+        LXCopyFromSys(pGeode, buf + srcOffset, dstOffset, dstPitch, srcPitch,
+                      height, pixels);
 
     videoScratch.dstOffset = dstOffset;
     videoScratch.dstPitch = dstPitch;
@@ -346,7 +346,7 @@ LXCopyPacked(ScrnInfoPtr pScrni, int id, unsigned char *buf,
 
 static void
 LXDisplayVideo(ScrnInfoPtr pScrni, int id, short width, short height,
-    BoxPtr dstBox, short srcW, short srcH, short drawW, short drawH)
+               BoxPtr dstBox, short srcW, short srcH, short drawW, short drawH)
 {
     long ystart, xend, yend;
     unsigned long lines = 0;
@@ -361,26 +361,26 @@ LXDisplayVideo(ScrnInfoPtr pScrni, int id, short width, short height,
 
     switch (id) {
     case FOURCC_UYVY:
-	vSrcParams.video_format = DF_VIDFMT_UYVY;
-	break;
+        vSrcParams.video_format = DF_VIDFMT_UYVY;
+        break;
 
     case FOURCC_Y800:
     case FOURCC_YV12:
     case FOURCC_I420:
-	vSrcParams.video_format = DF_VIDFMT_Y0Y1Y2Y3;
-	break;
+        vSrcParams.video_format = DF_VIDFMT_Y0Y1Y2Y3;
+        break;
     case FOURCC_YUY2:
-	vSrcParams.video_format = DF_VIDFMT_YUYV;
-	break;
+        vSrcParams.video_format = DF_VIDFMT_YUYV;
+        break;
     case FOURCC_Y2YU:
-	vSrcParams.video_format = DF_VIDFMT_Y2YU;
-	break;
+        vSrcParams.video_format = DF_VIDFMT_Y2YU;
+        break;
     case FOURCC_YVYU:
-	vSrcParams.video_format = DF_VIDFMT_YVYU;
-	break;
+        vSrcParams.video_format = DF_VIDFMT_YVYU;
+        break;
     case FOURCC_RGB565:
-	vSrcParams.video_format = DF_VIDFMT_RGB;
-	break;
+        vSrcParams.video_format = DF_VIDFMT_RGB;
+        break;
     }
 
     vSrcParams.width = width;
@@ -392,11 +392,11 @@ LXDisplayVideo(ScrnInfoPtr pScrni, int id, short width, short height,
     df_set_video_filter_coefficients(NULL, 1);
 
     err = df_set_video_scale(width, height, drawW, drawH,
-	DF_SCALEFLAG_CHANGEX | DF_SCALEFLAG_CHANGEY);
+                             DF_SCALEFLAG_CHANGEX | DF_SCALEFLAG_CHANGEY);
     if (err != CIM_STATUS_OK) {
-	/* Note the problem, but do nothing for now. */
-	ErrorF("Video scale factor too large: %dx%d -> %dx%d\n",
-	    width, height, drawW, drawH);
+        /* Note the problem, but do nothing for now. */
+        ErrorF("Video scale factor too large: %dx%d -> %dx%d\n",
+               width, height, drawW, drawH);
     }
 
     /* Figure out clipping */
@@ -405,16 +405,17 @@ LXDisplayVideo(ScrnInfoPtr pScrni, int id, short width, short height,
     yend = dstBox->y2;
 
     if (dstBox->y1 < 0) {
-	if (srcH < drawH)
-	    lines = ((-dstBox->y1) * srcH) / drawH;
-	else
-	    lines = (-dstBox->y1);
-
-	ystart = 0;
-	drawH += dstBox->y1;
-    } else {
-	ystart = dstBox->y1;
-	lines = 0;
+        if (srcH < drawH)
+            lines = ((-dstBox->y1) * srcH) / drawH;
+        else
+            lines = (-dstBox->y1);
+
+        ystart = 0;
+        drawH += dstBox->y1;
+    }
+    else {
+        ystart = dstBox->y1;
+        lines = 0;
     }
 
     yExtra = lines * videoScratch.dstPitch;
@@ -434,17 +435,17 @@ LXDisplayVideo(ScrnInfoPtr pScrni, int id, short width, short height,
     switch (id) {
     case FOURCC_Y800:
     case FOURCC_I420:
-	vSrcParams.u_offset = videoScratch.UDstOffset + uvExtra;
-	vSrcParams.v_offset = videoScratch.VDstOffset + uvExtra;
-	break;
+        vSrcParams.u_offset = videoScratch.UDstOffset + uvExtra;
+        vSrcParams.v_offset = videoScratch.VDstOffset + uvExtra;
+        break;
     case FOURCC_YV12:
-	vSrcParams.v_offset = videoScratch.UDstOffset + uvExtra;
-	vSrcParams.u_offset = videoScratch.VDstOffset + uvExtra;
-	break;
+        vSrcParams.v_offset = videoScratch.UDstOffset + uvExtra;
+        vSrcParams.u_offset = videoScratch.VDstOffset + uvExtra;
+        break;
 
     default:
-	vSrcParams.u_offset = vSrcParams.v_offset = 0;
-	break;
+        vSrcParams.u_offset = vSrcParams.v_offset = 0;
+        break;
     }
 
     vSrcParams.flags = DF_SOURCEFLAG_IMPLICITSCALING;
@@ -457,11 +458,11 @@ LXDisplayVideo(ScrnInfoPtr pScrni, int id, short width, short height,
 
 static int
 LXPutImage(ScrnInfoPtr pScrni,
-    short srcX, short srcY, short drawX, short drawY,
-    short srcW, short srcH, short drawW, short drawH,
-    int id, unsigned char *buf,
-    short width, short height, Bool sync, RegionPtr clipBoxes,
-    pointer data, DrawablePtr pDraw)
+           short srcX, short srcY, short drawX, short drawY,
+           short srcW, short srcH, short drawW, short drawH,
+           int id, unsigned char *buf,
+           short width, short height, Bool sync, RegionPtr clipBoxes,
+           pointer data, DrawablePtr pDraw)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
     GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
@@ -470,18 +471,18 @@ LXPutImage(ScrnInfoPtr pScrni,
     Bool ret;
 
     if (pGeode->rotation != RR_Rotate_0)
-	return Success;
+        return Success;
 
     if (srcW <= 0 || srcH <= 0) {
-	return Success;
+        return Success;
     }
 
     if (drawW <= 0 || drawH <= 0) {
-	return Success;
+        return Success;
     }
 
     if (drawW > 16384)
-	drawW = 16384;
+        drawW = 16384;
 
     memset(&videoScratch, 0, sizeof(videoScratch));
 
@@ -501,27 +502,27 @@ LXPutImage(ScrnInfoPtr pScrni,
     dstBox.y2 -= pScrni->frameY0;
 
     if (id == FOURCC_YV12 || id == FOURCC_I420)
-	ret = LXCopyPlanar(pScrni, id, buf, x1, y1, x2, y2, width,
-			height, data);
+        ret = LXCopyPlanar(pScrni, id, buf, x1, y1, x2, y2, width,
+                           height, data);
     else
-	ret = LXCopyPacked(pScrni, id, buf, x1, y1, x2, y2, width,
-			height, data);
+        ret = LXCopyPacked(pScrni, id, buf, x1, y1, x2, y2, width,
+                           height, data);
 
     if (ret == FALSE)
-	return BadAlloc;
-	
+        return BadAlloc;
+
     if (!RegionsEqual(&pPriv->clip, clipBoxes) ||
-	(drawW != pPriv->pwidth || drawH != pPriv->pheight)) {
-	REGION_COPY(pScrni->pScreen, &pPriv->clip, clipBoxes);
+        (drawW != pPriv->pwidth || drawH != pPriv->pheight)) {
+        REGION_COPY(pScrni->pScreen, &pPriv->clip, clipBoxes);
 
-	if (pPriv->colorKeyMode == 0) {
-	    xf86XVFillKeyHelper(pScrni->pScreen, pPriv->colorKey, clipBoxes);
-	}
+        if (pPriv->colorKeyMode == 0) {
+            xf86XVFillKeyHelper(pScrni->pScreen, pPriv->colorKey, clipBoxes);
+        }
 
-	LXDisplayVideo(pScrni, id, width, height, &dstBox,
-	    srcW, srcH, drawW, drawH);
-	pPriv->pwidth = drawW;
-	pPriv->pheight = drawH;
+        LXDisplayVideo(pScrni, id, width, height, &dstBox,
+                       srcW, srcH, drawW, drawH);
+        pPriv->pwidth = drawW;
+        pPriv->pheight = drawH;
     }
 
     pPriv->videoStatus = CLIENT_VIDEO_ON;
@@ -531,8 +532,8 @@ LXPutImage(ScrnInfoPtr pScrni,
 
 static void
 LXQueryBestSize(ScrnInfoPtr pScrni, Bool motion,
-    short vidW, short vidH, short drawW, short drawH,
-    unsigned int *retW, unsigned int *retH, pointer data)
+                short vidW, short vidH, short drawW, short drawH,
+                unsigned int *retW, unsigned int *retH, pointer data)
 {
     *retW = drawW > 16384 ? 16384 : drawW;
     *retH = drawH;
@@ -542,42 +543,45 @@ static Atom xvColorKey, xvColorKeyMode, xvFilter;
 
 static int
 LXGetPortAttribute(ScrnInfoPtr pScrni,
-    Atom attribute, INT32 * value, pointer data)
+                   Atom attribute, INT32 *value, pointer data)
 {
     GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
 
     if (attribute == xvColorKey)
-	*value = pPriv->colorKey;
+        *value = pPriv->colorKey;
     else if (attribute == xvColorKeyMode)
-	*value = pPriv->colorKeyMode;
+        *value = pPriv->colorKeyMode;
     else if (attribute == xvFilter)
-	*value = pPriv->filter;
+        *value = pPriv->filter;
     else
-	return BadMatch;
+        return BadMatch;
 
     return Success;
 }
 
 static int
 LXSetPortAttribute(ScrnInfoPtr pScrni,
-    Atom attribute, INT32 value, pointer data)
+                   Atom attribute, INT32 value, pointer data)
 {
     GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
 
     gp_wait_until_idle();
 
     if (attribute == xvColorKey) {
-	pPriv->colorKey = value;
-	LXSetColorkey(pScrni, pPriv);
-    } else if (attribute == xvColorKeyMode) {
-	pPriv->colorKeyMode = value;
-	LXSetColorkey(pScrni, pPriv);
-    } else if (attribute == xvFilter) {
-	if ((value < 0) || (value > 1))
-	    return BadValue;
-	pPriv->filter = value;
-    } else
-	return BadMatch;
+        pPriv->colorKey = value;
+        LXSetColorkey(pScrni, pPriv);
+    }
+    else if (attribute == xvColorKeyMode) {
+        pPriv->colorKeyMode = value;
+        LXSetColorkey(pScrni, pPriv);
+    }
+    else if (attribute == xvFilter) {
+        if ((value < 0) || (value > 1))
+            return BadValue;
+        pPriv->filter = value;
+    }
+    else
+        return BadMatch;
 
     return Success;
 }
@@ -588,32 +592,33 @@ LXStopVideo(ScrnInfoPtr pScrni, pointer data, Bool exit)
     GeodePortPrivRec *pPriv = (GeodePortPrivRec *) data;
 
     if (pPriv->videoStatus == 0)
-	return;
+        return;
 
     REGION_EMPTY(pScrni->pScreen, &pPriv->clip);
     gp_wait_until_idle();
 
     if (exit) {
-	if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
-	    unsigned int val;
-
-	    df_set_video_enable(0, 0);
-	    /* Put the LUT back in bypass */
-	    val = READ_VID32(DF_VID_MISC);
-	    WRITE_VID32(DF_VID_MISC, val | DF_GAMMA_BYPASS_BOTH);
-	}
-
-	if (pPriv->vidmem) {
-	    exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
-	    pPriv->vidmem = NULL;
-	}
-
-	pPriv->videoStatus = 0;
-
-	/* Eh? */
-    } else if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
-	pPriv->videoStatus |= OFF_TIMER;
-	pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
+        if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
+            unsigned int val;
+
+            df_set_video_enable(0, 0);
+            /* Put the LUT back in bypass */
+            val = READ_VID32(DF_VID_MISC);
+            WRITE_VID32(DF_VID_MISC, val | DF_GAMMA_BYPASS_BOTH);
+        }
+
+        if (pPriv->vidmem) {
+            exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
+            pPriv->vidmem = NULL;
+        }
+
+        pPriv->videoStatus = 0;
+
+        /* Eh? */
+    }
+    else if (pPriv->videoStatus & CLIENT_VIDEO_ON) {
+        pPriv->videoStatus |= OFF_TIMER;
+        pPriv->offTime = currentTime.milliseconds + OFF_DELAY;
     }
 }
 
@@ -623,18 +628,17 @@ LXResetVideo(ScrnInfoPtr pScrni)
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (!pGeode->NoAccel) {
-	GeodePortPrivRec *pPriv = pGeode->adaptor->pPortPrivates[0].ptr;
+        GeodePortPrivRec *pPriv = pGeode->adaptor->pPortPrivates[0].ptr;
 
-	gp_wait_until_idle();
-	df_set_video_palette(NULL);
+        gp_wait_until_idle();
+        df_set_video_palette(NULL);
 
-	LXSetColorkey(pScrni, pPriv);
+        LXSetColorkey(pScrni, pPriv);
     }
 }
 
 static void
-LXVidBlockHandler(int i, pointer blockData, pointer pTimeout,
-    pointer pReadmask)
+LXVidBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
 {
     ScreenPtr pScrn = screenInfo.screens[i];
     ScrnInfoPtr pScrni = xf86Screens[i];
@@ -646,33 +650,34 @@ LXVidBlockHandler(int i, pointer blockData, pointer pTimeout,
     pScrn->BlockHandler = LXVidBlockHandler;
 
     if (pPriv->videoStatus & TIMER_MASK) {
-	Time now = currentTime.milliseconds;
-
-	if (pPriv->videoStatus & OFF_TIMER) {
-	    gp_wait_until_idle();
-
-	    if (pPriv->offTime < now) {
-		unsigned int val;
-
-		df_set_video_enable(0, 0);
-		pPriv->videoStatus = FREE_TIMER;
-		pPriv->freeTime = now + FREE_DELAY;
-
-		/* Turn off the video palette */
-		val = READ_VID32(DF_VID_MISC);
-		WRITE_VID32(DF_VID_MISC, val | DF_GAMMA_BYPASS_BOTH);
-	    }
-	} else {
-	    if (pPriv->freeTime < now) {
-
-		if (pPriv->vidmem) {
-		    exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
-		    pPriv->vidmem = NULL;
-		}
-
-		pPriv->videoStatus = 0;
-	    }
-	}
+        Time now = currentTime.milliseconds;
+
+        if (pPriv->videoStatus & OFF_TIMER) {
+            gp_wait_until_idle();
+
+            if (pPriv->offTime < now) {
+                unsigned int val;
+
+                df_set_video_enable(0, 0);
+                pPriv->videoStatus = FREE_TIMER;
+                pPriv->freeTime = now + FREE_DELAY;
+
+                /* Turn off the video palette */
+                val = READ_VID32(DF_VID_MISC);
+                WRITE_VID32(DF_VID_MISC, val | DF_GAMMA_BYPASS_BOTH);
+            }
+        }
+        else {
+            if (pPriv->freeTime < now) {
+
+                if (pPriv->vidmem) {
+                    exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
+                    pPriv->vidmem = NULL;
+                }
+
+                pPriv->videoStatus = 0;
+            }
+        }
     }
 }
 
@@ -685,11 +690,11 @@ LXSetupImageVideo(ScreenPtr pScrn)
     GeodePortPrivRec *pPriv;
 
     adapt = calloc(1, sizeof(XF86VideoAdaptorRec) +
-	sizeof(GeodePortPrivRec) + sizeof(DevUnion));
+                   sizeof(GeodePortPrivRec) + sizeof(DevUnion));
 
     if (adapt == NULL) {
-	ErrorF("Couldn't create the rec\n");
-	return NULL;
+        ErrorF("Couldn't create the rec\n");
+        return NULL;
     }
 
     adapt->type = XvWindowMask | XvInputMask | XvImageMask;
@@ -747,19 +752,19 @@ LXSetupImageVideo(ScreenPtr pScrn)
 
 /* Offscreen surface allocation */
 
-struct OffscreenPrivRec
-{
+struct OffscreenPrivRec {
     ExaOffscreenArea *vidmem;
     Bool isOn;
 };
 
 static int
 LXDisplaySurface(XF86SurfacePtr surface,
-    short srcX, short srcY, short drawX, short drawY,
-    short srcW, short srcH, short drawW, short drawH, RegionPtr clipBoxes)
+                 short srcX, short srcY, short drawX, short drawY,
+                 short srcW, short srcH, short drawW, short drawH,
+                 RegionPtr clipBoxes)
 {
     struct OffscreenPrivRec *pPriv =
-	(struct OffscreenPrivRec *)surface->devPrivate.ptr;
+        (struct OffscreenPrivRec *) surface->devPrivate.ptr;
 
     ScrnInfoPtr pScrni = surface->pScrn;
     GeodePortPrivRec *portPriv = GET_PORT_PRIVATE(pScrni);
@@ -772,7 +777,7 @@ LXDisplaySurface(XF86SurfacePtr surface,
     dstBox.y2 = drawY + drawH;
 
     if ((drawW <= 0) | (drawH <= 0))
-	return Success;
+        return Success;
 
     /* Is this still valid? */
 
@@ -787,15 +792,15 @@ LXDisplaySurface(XF86SurfacePtr surface,
     videoScratch.dstPitch = surface->pitches[0];
 
     LXDisplayVideo(pScrni, surface->id, surface->width, surface->height,
-	&dstBox, srcW, srcH, drawW, drawH);
+                   &dstBox, srcW, srcH, drawW, drawH);
 
     pPriv->isOn = TRUE;
 
     if (portPriv->videoStatus & CLIENT_VIDEO_ON) {
-	REGION_EMPTY(pScrni->pScreen, &portPriv->clip);
-	UpdateCurrentTime();
-	portPriv->videoStatus = FREE_TIMER;
-	portPriv->freeTime = currentTime.milliseconds + FREE_DELAY;
+        REGION_EMPTY(pScrni->pScreen, &portPriv->clip);
+        UpdateCurrentTime();
+        portPriv->videoStatus = FREE_TIMER;
+        portPriv->freeTime = currentTime.milliseconds + FREE_DELAY;
     }
 
     return Success;
@@ -803,7 +808,7 @@ LXDisplaySurface(XF86SurfacePtr surface,
 
 static int
 LXAllocateSurface(ScrnInfoPtr pScrni, int id, unsigned short w,
-    unsigned short h, XF86SurfacePtr surface)
+                  unsigned short h, XF86SurfacePtr surface)
 {
     GeodeRec *pGeode = GEODEPTR(pScrni);
     int pitch, lines;
@@ -811,7 +816,7 @@ LXAllocateSurface(ScrnInfoPtr pScrni, int id, unsigned short w,
     struct OffscreenPrivRec *pPriv;
 
     if (w > 1024 || h > 1024)
-	return BadAlloc;
+        return BadAlloc;
 
     /* The width needs to be word aligned */
     w = (w + 1) & ~1;
@@ -821,12 +826,11 @@ LXAllocateSurface(ScrnInfoPtr pScrni, int id, unsigned short w,
 
     /* FIXME: is lines the right parameter to use here,
      * or should it be height * pitch? */
-    vidmem = exaOffscreenAlloc(pScrni->pScreen, lines, 4, TRUE,
-		NULL, NULL);
+    vidmem = exaOffscreenAlloc(pScrni->pScreen, lines, 4, TRUE, NULL, NULL);
 
     if (vidmem == NULL) {
-	ErrorF("Error while allocating an offscreen region.\n");
-	return BadAlloc;
+        ErrorF("Error while allocating an offscreen region.\n");
+        return BadAlloc;
     }
 
     surface->width = w;
@@ -840,28 +844,28 @@ LXAllocateSurface(ScrnInfoPtr pScrni, int id, unsigned short w,
 
     if (pPriv && surface->pitches && surface->offsets) {
 
-	pPriv->vidmem = vidmem;
+        pPriv->vidmem = vidmem;
 
-	pPriv->isOn = FALSE;
+        pPriv->isOn = FALSE;
 
-	surface->pScrn = pScrni;
-	surface->id = id;
-	surface->pitches[0] = pitch;
-	surface->offsets[0] = vidmem->offset;
-	surface->devPrivate.ptr = (pointer) pPriv;
+        surface->pScrn = pScrni;
+        surface->id = id;
+        surface->pitches[0] = pitch;
+        surface->offsets[0] = vidmem->offset;
+        surface->devPrivate.ptr = (pointer) pPriv;
 
-	return Success;
+        return Success;
     }
 
     if (surface->offsets)
-	free(surface->offsets);
+        free(surface->offsets);
 
     if (surface->pitches)
-	free(surface->pitches);
+        free(surface->pitches);
 
     if (vidmem) {
-	exaOffscreenFree(pScrni->pScreen, vidmem);
-	vidmem = NULL;
+        exaOffscreenFree(pScrni->pScreen, vidmem);
+        vidmem = NULL;
     }
 
     return BadAlloc;
@@ -871,7 +875,7 @@ static int
 LXStopSurface(XF86SurfacePtr surface)
 {
     struct OffscreenPrivRec *pPriv = (struct OffscreenPrivRec *)
-	surface->devPrivate.ptr;
+        surface->devPrivate.ptr;
 
     pPriv->isOn = FALSE;
     return Success;
@@ -881,15 +885,15 @@ static int
 LXFreeSurface(XF86SurfacePtr surface)
 {
     struct OffscreenPrivRec *pPriv = (struct OffscreenPrivRec *)
-	surface->devPrivate.ptr;
+        surface->devPrivate.ptr;
     ScrnInfoPtr pScrni = surface->pScrn;
 
     if (pPriv->isOn)
-	LXStopSurface(surface);
+        LXStopSurface(surface);
 
     if (pPriv->vidmem) {
-	exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
-	pPriv->vidmem = NULL;
+        exaOffscreenFree(pScrni->pScreen, pPriv->vidmem);
+        pPriv->vidmem = NULL;
     }
 
     free(surface->pitches);
@@ -900,17 +904,17 @@ LXFreeSurface(XF86SurfacePtr surface)
 }
 
 static int
-LXGetSurfaceAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 * value)
+LXGetSurfaceAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 *value)
 {
     return LXGetPortAttribute(pScrni, attribute, value,
-	(pointer) (GET_PORT_PRIVATE(pScrni)));
+                              (pointer) (GET_PORT_PRIVATE(pScrni)));
 }
 
 static int
 LXSetSurfaceAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 value)
 {
     return LXSetPortAttribute(pScrni, attribute, value,
-	(pointer) (GET_PORT_PRIVATE(pScrni)));
+                              (pointer) (GET_PORT_PRIVATE(pScrni)));
 }
 
 static void
@@ -920,7 +924,7 @@ LXInitOffscreenImages(ScreenPtr pScrn)
 
     /* need to free this someplace */
     if (!(offscreenImages = malloc(sizeof(XF86OffscreenImageRec))))
-	return;
+        return;
 
     offscreenImages[0].image = &Images[0];
     offscreenImages[0].flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
@@ -950,13 +954,13 @@ LXInitVideo(ScreenPtr pScrn)
     pGeode = GEODEPTR(pScrni);
 
     if (pGeode->NoAccel) {
-	ErrorF("Cannot run Xv without accelerations!\n");
-	return;
+        ErrorF("Cannot run Xv without accelerations!\n");
+        return;
     }
 
     if (!(newAdaptor = LXSetupImageVideo(pScrn))) {
-	ErrorF("Error while setting up the adaptor.\n");
-	return;
+        ErrorF("Error while setting up the adaptor.\n");
+        return;
     }
 
     LXInitOffscreenImages(pScrn);
@@ -964,25 +968,27 @@ LXInitVideo(ScreenPtr pScrn)
     num_adaptors = xf86XVListGenericAdaptors(pScrni, &adaptors);
 
     if (!num_adaptors) {
-	num_adaptors = 1;
-	adaptors = &newAdaptor;
-    } else {
-	newAdaptors =
-	    malloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr *));
-
-	if (newAdaptors) {
-	    memcpy(newAdaptors, adaptors, num_adaptors *
-		sizeof(XF86VideoAdaptorPtr));
-	    newAdaptors[num_adaptors] = newAdaptor;
-	    adaptors = newAdaptors;
-	    num_adaptors++;
-	} else
-	    ErrorF("Memory error while setting up the adaptor\n");
+        num_adaptors = 1;
+        adaptors = &newAdaptor;
+    }
+    else {
+        newAdaptors =
+            malloc((num_adaptors + 1) * sizeof(XF86VideoAdaptorPtr *));
+
+        if (newAdaptors) {
+            memcpy(newAdaptors, adaptors, num_adaptors *
+                   sizeof(XF86VideoAdaptorPtr));
+            newAdaptors[num_adaptors] = newAdaptor;
+            adaptors = newAdaptors;
+            num_adaptors++;
+        }
+        else
+            ErrorF("Memory error while setting up the adaptor\n");
     }
 
     if (num_adaptors)
-	xf86XVScreenInit(pScrn, adaptors, num_adaptors);
+        xf86XVScreenInit(pScrn, adaptors, num_adaptors);
 
     if (newAdaptors)
-	free(newAdaptors);
+        free(newAdaptors);
 }
diff --git a/src/panel.c b/src/panel.c
index b7eb88f..206fc78 100644
--- a/src/panel.c
+++ b/src/panel.c
@@ -45,11 +45,11 @@
 #include "gfx_defs.h"
 #include "geode.h"
 
-#define PLATFORM_DYNAMIC		1	/* runtime selection            */
-#define PLATFORM_DRACO			0	/* Draco + 9210                         */
-#define PLATFORM_CENTAURUS		1	/* Centaurus + 9211 RevA        */
-#define PLATFORM_DORADO			1	/* Dorado + 9211 RevC           */
-#define PLATFORM_GX2BASED		1	/* Redcloud                             */
+#define PLATFORM_DYNAMIC		1       /* runtime selection            */
+#define PLATFORM_DRACO			0       /* Draco + 9210                         */
+#define PLATFORM_CENTAURUS		1       /* Centaurus + 9211 RevA        */
+#define PLATFORM_DORADO			1       /* Dorado + 9211 RevC           */
+#define PLATFORM_GX2BASED		1       /* Redcloud                             */
 
 unsigned char *XpressROMPtr;
 
diff --git a/src/panel/92xx.h b/src/panel/92xx.h
index f10fa09..b7b0e25 100644
--- a/src/panel/92xx.h
+++ b/src/panel/92xx.h
@@ -114,8 +114,7 @@ typedef unsigned char UCHAR;
 /* GPIO Control */
 int Pnl_Rev_ID;
 
-typedef struct
-{
+typedef struct {
     /* DISPLAY MODE PARAMETERS */
     int xres;
     int yres;
@@ -140,12 +139,10 @@ typedef struct
     unsigned long frm_memory_data;
     unsigned long memory_control;
 
-}
-CS92xx_MODE;
+} CS92xx_MODE;
 
 /* VALUES USED TO SAVE AND RESTORE 9211 REGISTERS. */
-typedef struct
-{
+typedef struct {
     unsigned long panel_state;
     /* VALUES USED TO SET THE FLAT PANEL DISPLAY CONTROLLER */
     unsigned long panel_timing1;
@@ -157,8 +154,7 @@ typedef struct
     unsigned long frm_memory_index;
     unsigned long frm_memory_data;
     unsigned long memory_control;
-}
-CS92xx_REGS;
+} CS92xx_REGS;
 
 CS92xx_REGS cs9211_regs;
 
@@ -171,200 +167,200 @@ CS92xx_REGS cs9211_regs;
 CS92xx_MODE FPModeParams[] = {
 
     {640, 480, 8, PNL_SSTN, PNL_COLOR_PANEL,    /* display parameters */
-            0x01e00000, 0x00034000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C                                        */
-            0x00000050,                /* dither and frame rate control        */
-            0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
-            0x21446450, 0x21446450,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C                                                     */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000000,                /* memory control                                       */
-        },
+     0x01e00000, 0x00034000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C                                        */
+     0x00000050,                /* dither and frame rate control        */
+     0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
+     0x21446450, 0x21446450,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C                                                     */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000000,                /* memory control                                       */
+     },
 
     {640, 480, 12, PNL_TFT, PNL_COLOR_PANEL,    /* display parameters */
-            0x01e00000, 0x0f100000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C                                        */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* block select 1, block select 2       */
-            0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C                                             */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000000,                /* memory control                                       */
-        },
+     0x01e00000, 0x0f100000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C                                        */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* block select 1, block select 2       */
+     0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C                                             */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000000,                /* memory control                                       */
+     },
 
     {640, 480, 18, PNL_TFT, PNL_COLOR_PANEL,    /* display parameters */
-            0x01e00000, 0x0f100000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C                                        */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* block select 1, block select 2       */
-            0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000000,                /* memory control                                       */
-        },
+     0x01e00000, 0x0f100000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C                                        */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* block select 1, block select 2       */
+     0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000000,                /* memory control                                       */
+     },
 
     {640, 480, 16, PNL_DSTN, PNL_COLOR_PANEL,   /* display parameters */
-            0x01e00000, 0x00014000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x048c26ae, 0x048c26ae,    /* block select 1, block select 2       */
-            0x02468ace, 0x13579bdf,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C */
-            0x0000004b,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000007,                /* memory control                                       */
-        },
+     0x01e00000, 0x00014000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x048c26ae, 0x048c26ae,    /* block select 1, block select 2       */
+     0x02468ace, 0x13579bdf,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C */
+     0x0000004b,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000007,                /* memory control                                       */
+     },
 
     {640, 480, 8, PNL_DSTN, PNL_MONO_PANEL,     /* display parameters */
-            0x01e00000, 0x00084000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C */
-            0x0000004b,                /* dither and frame rate control        */
-            0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
-            0x21446450, 0x21446450,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C  */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000007,                /* memory control                                       */
-        },
+     0x01e00000, 0x00084000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C */
+     0x0000004b,                /* dither and frame rate control        */
+     0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
+     0x21446450, 0x21446450,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C  */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000007,                /* memory control                                       */
+     },
 
     {640, 480, 16, PNL_DSTN, PNL_MONO_PANEL,    /* display parameters */
-            0x01e00000, 0x00094000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
-            0x81a5d470, 0x29cfb63e,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000007,                /* memory control                                       */
-        },
+     0x01e00000, 0x00094000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
+     0x81a5d470, 0x29cfb63e,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000007,                /* memory control                                       */
+     },
 
     {800, 600, 12, PNL_TFT, PNL_COLOR_PANEL,    /* display parameters */
-            0x02580000, 0x0f100000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* block select 1, block select 2       */
-            0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000000,                /* memory control                                       */
-        },
+     0x02580000, 0x0f100000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* block select 1, block select 2       */
+     0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000000,                /* memory control                                       */
+     },
 
     {800, 600, 18, PNL_TFT, PNL_COLOR_PANEL,    /* display parameters */
-            0x02580000, 0x0f100000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* block select 1, block select 2       */
-            0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000000,                /* memory control                                       */
-        },
+     0x02580000, 0x0f100000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* block select 1, block select 2       */
+     0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000000,                /* memory control                                       */
+     },
 
     {800, 600, 16, PNL_DSTN, PNL_COLOR_PANEL,   /* display parameters */
-            0x02580000, 0x00014000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x048c26ae, 0x048c26ae,    /* block select 1, block select 2       */
-            0x02468ace, 0x13579bdf,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C */
-            0x0000004b,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000007,                /* memory control                                       */
-        },
+     0x02580000, 0x00014000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x048c26ae, 0x048c26ae,    /* block select 1, block select 2       */
+     0x02468ace, 0x13579bdf,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C */
+     0x0000004b,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000007,                /* memory control                                       */
+     },
 
     {800, 600, 8, PNL_DSTN, PNL_MONO_PANEL,     /* display parameters */
-            0x02580000, 0x00084000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
-            0x21446450, 0x21446450,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C */
-            0x0000004b,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000007,                /* memory control                                       */
-        },
+     0x02580000, 0x00084000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
+     0x21446450, 0x21446450,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C */
+     0x0000004b,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000007,                /* memory control                                       */
+     },
 
     {800, 600, 16, PNL_DSTN, PNL_MONO_PANEL,    /* display parameters */
-            0x02580000, 0x00094000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /* The next 5 values are prior to revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
-            0x81a5d470, 0x29cfb63e,    /* dispersion 1, dispersion 2           */
-            /* The next 5 values are for revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000007,                /* memory control                                       */
-        },
+     0x02580000, 0x00094000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /* The next 5 values are prior to revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x25cf3096, 0xad47b81e,    /* block select 1, block select 2       */
+     0x81a5d470, 0x29cfb63e,    /* dispersion 1, dispersion 2           */
+     /* The next 5 values are for revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000007,                /* memory control                                       */
+     },
 
     {1024, 768, 18, PNL_TFT, PNL_COLOR_PANEL,   /* display parameters */
-            0x03000000, 0x0f100000,    /* panel timing reg 1, panel timing */
-            /* reg 2                                                        */
-            0x01000000,                /* power management                             */
-            /*The next 5 values are prior to revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* block select 1, block select 2       */
-            0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
-            /*The next 5 values are for revision C */
-            0x00000050,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000000,                /* memory control                                       */
-        },
+     0x03000000, 0x0f100000,    /* panel timing reg 1, panel timing */
+     /* reg 2                                                        */
+     0x01000000,                /* power management                             */
+     /*The next 5 values are prior to revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* block select 1, block select 2       */
+     0x00000000, 0x00000000,    /* dispersion 1, dispersion 2           */
+     /*The next 5 values are for revision C */
+     0x00000050,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000000,                /* memory control                                       */
+     },
 
     {1024, 768, 24, PNL_DSTN, PNL_COLOR_PANEL,  /* display parameters */
-            0x03000000, 0x80024000,    /* panel timing reg 1, panel timing reg 2 */
-            0x01000000,                /* power management                             */
-            /*The next 5 values are prior to revision C                                         */
-            0x00000050,                /* dither and frame rate control        */
-            0x048c26ae, 0x048c26ae,    /* block select 1, block select 2       */
-            0x02468ace, 0x13579bdf,    /* dispersion 1, dispersion 2           */
-            /*The next 5 values are for revision C */
-            0x0000004b,                /* dither and frame rate control        */
-            0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
-            0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
-            0x00000005,                /* memory control                                       */
-        }
+     0x03000000, 0x80024000,    /* panel timing reg 1, panel timing reg 2 */
+     0x01000000,                /* power management                             */
+     /*The next 5 values are prior to revision C                                         */
+     0x00000050,                /* dither and frame rate control        */
+     0x048c26ae, 0x048c26ae,    /* block select 1, block select 2       */
+     0x02468ace, 0x13579bdf,    /* dispersion 1, dispersion 2           */
+     /*The next 5 values are for revision C */
+     0x0000004b,                /* dither and frame rate control        */
+     0x00000000, 0x00000000,    /* blue LSFR, red and green LSFR        */
+     0x00000000, 0x00000000,    /* FRM memory index, FRM memory data */
+     0x00000005,                /* memory control                                       */
+     }
 };
 
-#endif /* !_92XX_h */
+#endif                          /* !_92XX_h */
 
 /* END OF FILE */
diff --git a/src/panel/cen9211.c b/src/panel/cen9211.c
index 3abc7d5..d9cbc42 100644
--- a/src/panel/cen9211.c
+++ b/src/panel/cen9211.c
@@ -62,7 +62,7 @@ init_Centaurus_GPIO(void)
     /* set to bank 0 */
     if (reg_val & CENT_GPIO_BANK_SELECT) {
         gfx_outb(CENT_CONFIG_DATA,
-            (unsigned char)(reg_val & ~CENT_GPIO_BANK_SELECT));
+                 (unsigned char) (reg_val & ~CENT_GPIO_BANK_SELECT));
     }
 
     /* If this is the first time we have modified sioc2, we must 
@@ -108,7 +108,7 @@ init_Centaurus_GPIO(void)
     gfx_outb(CENT_PORT2_OUTPUT_TYPE, reg_val);
     return CENT_PASS;
 
-}                                      /* end init_GPIO() */
+}                               /* end init_GPIO() */
 
 /*********************************************************************
  *
@@ -135,7 +135,7 @@ init_Centaurus_9211(void)
     gfx_outb(CENT_97317_CHIP_SELECT, ReadData);
     return (CENT_PASS);
 
-}                                      /*end init_9211() */
+}                               /*end init_9211() */
 
 /******************************************************************
  *
@@ -166,10 +166,10 @@ restore_Centaurus_97317_SIOC2(void)
         else
             return (CENT_FAIL);
 
-    }                                  /* end if() */
+    }                           /* end if() */
     return (CENT_FAIL);
 
-}                                      /* end restore_97317_SIOC2bank() */
+}                               /* end restore_97317_SIOC2bank() */
 
 /* -----------------------------------------------------------------------
  *
@@ -199,11 +199,11 @@ set_Centaurus_92xx_mode(Pnl_PanelStat * pstat)
             /* SET THE 92xx FOR THE SELECTED MODE */
             set_Centaurus_92xx_mode_params(mode);
             return (CENT_PASS);
-        }                              /* end if() */
-    }                                  /* end for() */
+        }                       /* end if() */
+    }                           /* end for() */
     return (CENT_FAIL);
 
-}                                      /* end set_Centaurus_92xx_mode() */
+}                               /* end set_Centaurus_92xx_mode() */
 
 /*-------------------------------------------------------------------
  *
@@ -228,51 +228,53 @@ set_Centaurus_92xx_mode_params(int mode)
     /* set 9211 registers using the desired panel settings */
 
     Centaurus_write_gpio(FOUR_BYTES,
-        CS92xx_LCD_PAN_TIMING1, pMode->panel_timing1);
+                         CS92xx_LCD_PAN_TIMING1, pMode->panel_timing1);
 
     Centaurus_write_gpio(FOUR_BYTES,
-        CS92xx_LCD_PAN_TIMING2, pMode->panel_timing2);
+                         CS92xx_LCD_PAN_TIMING2, pMode->panel_timing2);
 
     if (Pnl_Rev_ID == PNL_9211_C) {
 
         /* load the LSFR seeds */
         Centaurus_write_gpio(FOUR_BYTES,
-            CS92xx_LCD_DITH_FR_CNTRL, pMode->rev_C_dither_frc);
+                             CS92xx_LCD_DITH_FR_CNTRL, pMode->rev_C_dither_frc);
 
         Centaurus_write_gpio(FOUR_BYTES,
-            CS92xx_BLUE_LSFR_SEED, pMode->blue_lsfr_seed);
+                             CS92xx_BLUE_LSFR_SEED, pMode->blue_lsfr_seed);
 
         Centaurus_write_gpio(FOUR_BYTES,
-            CS92xx_RED_GREEN_LSFR_SEED, pMode->red_green_lsfr_seed);
-    } else {
+                             CS92xx_RED_GREEN_LSFR_SEED,
+                             pMode->red_green_lsfr_seed);
+    }
+    else {
 
         Centaurus_write_gpio(FOUR_BYTES,
-            CS92xx_LCD_DITH_FR_CNTRL, pMode->pre_C_dither_frc);
+                             CS92xx_LCD_DITH_FR_CNTRL, pMode->pre_C_dither_frc);
 
         Centaurus_write_gpio(FOUR_BYTES,
-            CS92xx_LCD_BLOCK_SEL1, pMode->block_select1);
+                             CS92xx_LCD_BLOCK_SEL1, pMode->block_select1);
 
         Centaurus_write_gpio(FOUR_BYTES,
-            CS92xx_LCD_BLOCK_SEL2, pMode->block_select2);
+                             CS92xx_LCD_BLOCK_SEL2, pMode->block_select2);
 
         Centaurus_write_gpio(FOUR_BYTES,
-            CS92xx_LCD_DISPER1, pMode->dispersion1);
+                             CS92xx_LCD_DISPER1, pMode->dispersion1);
 
         Centaurus_write_gpio(FOUR_BYTES,
-            CS92xx_LCD_DISPER2, pMode->dispersion2);
+                             CS92xx_LCD_DISPER2, pMode->dispersion2);
 
         CentaurusProgramFRMload();
     }
 
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_LCD_MEM_CNTRL,
-        pMode->memory_control);
+                         pMode->memory_control);
 
     /* Set the power register last. This will turn the panel on at the 9211. */
 
     Centaurus_write_gpio(FOUR_BYTES,
-        CS92xx_LCD_PWR_MAN, pMode->power_management);
+                         CS92xx_LCD_PWR_MAN, pMode->power_management);
 
-}                                      /* end set_Centaurus_92xx_mode_params() */
+}                               /* end set_Centaurus_92xx_mode_params() */
 
 void
 Centaurus_write_gpio(int width, ULONG address, unsigned long data)
@@ -291,7 +293,7 @@ Centaurus_write_gpio(int width, ULONG address, unsigned long data)
 
     /* Write the 12-bit address */
     for (count = 0; count < 12; count++) {
-        write_Centaurus_CX9211_GPIO((unsigned char)(Addr & 0x01));
+        write_Centaurus_CX9211_GPIO((unsigned char) (Addr & 0x01));
         /*the 9211 expects data LSB->MSB */
         Addr = Addr >> 1;
     }
@@ -309,7 +311,7 @@ Centaurus_write_gpio(int width, ULONG address, unsigned long data)
     }
     return;
 
-}                                      /* end Centaurus_write_gpio() */
+}                               /* end Centaurus_write_gpio() */
 
 unsigned long
 Centaurus_read_gpio(int width, unsigned long address)
@@ -329,7 +331,7 @@ Centaurus_read_gpio(int width, unsigned long address)
 
     /* Write the 12-bit address */
     for (count = 0; count < 12; count++) {
-        write_Centaurus_CX9211_GPIO((unsigned char)(Addr & 0x01));
+        write_Centaurus_CX9211_GPIO((unsigned char) (Addr & 0x01));
 
         /*the 9211 expects data LSB->MSB */
         Addr = Addr >> 1;
@@ -347,7 +349,7 @@ Centaurus_read_gpio(int width, unsigned long address)
     }
     return data;
 
-}                                      /* end Centaurus_read_gpio() */
+}                               /* end Centaurus_read_gpio() */
 
 /*******************************************************************
  *
@@ -365,9 +367,9 @@ enable_Centaurus_9211_chip_select(void)
     /* Set the chip select (GPIO20) high */
     cs_port_val = gfx_inb(CENT_97317_CHIP_SELECT);
     gfx_outb(CENT_97317_CHIP_SELECT,
-        (unsigned char)(cs_port_val | CENT_97317_CHIP_SEL_MASK));
+             (unsigned char) (cs_port_val | CENT_97317_CHIP_SEL_MASK));
     return;
-}                                      /* end enable_Centaurus_9211_chip_select() */
+}                               /* end enable_Centaurus_9211_chip_select() */
 
 /********************************************************************
  *
@@ -385,10 +387,10 @@ disable_Centaurus_9211_chip_select(void)
     /* Set the chip select (GPIO20) low */
     cs_port_val = gfx_inb(CENT_97317_CHIP_SELECT);
     gfx_outb(CENT_97317_CHIP_SELECT,
-        (unsigned char)(cs_port_val & ~CENT_97317_CHIP_SEL_MASK));
+             (unsigned char) (cs_port_val & ~CENT_97317_CHIP_SEL_MASK));
     return;
 
-}                                      /* end disable_Centaurus_9211_chip_select() */
+}                               /* end disable_Centaurus_9211_chip_select() */
 
 /**********************************************************************
  *
@@ -410,13 +412,13 @@ toggle_Centaurus_9211_clock(void)
     port_val = gfx_inb(CENT_97317_CLOCK_PORT);
     /* set the clock bit high */
     gfx_outb(CENT_97317_CLOCK_PORT,
-        (unsigned char)(port_val | CENT_97317_CLOCK_MASK));
+             (unsigned char) (port_val | CENT_97317_CLOCK_MASK));
 
     /* set the clock bit low */
     gfx_outb(CENT_97317_CLOCK_PORT,
-        (unsigned char)(port_val & ~CENT_97317_CLOCK_MASK));
+             (unsigned char) (port_val & ~CENT_97317_CLOCK_MASK));
 
-}                                      /* end toggle_Centaurus_9211_clock() */
+}                               /* end toggle_Centaurus_9211_clock() */
 
 /********************************************************************
  *
@@ -448,7 +450,7 @@ write_Centaurus_CX9211_GPIO(unsigned char databit)
     toggle_Centaurus_9211_clock();
     return;
 
-}                                      /* end write_Centaurus_CX9211_GPIO() */
+}                               /* end write_Centaurus_CX9211_GPIO() */
 
 /*****************************************************************
  *
@@ -473,14 +475,14 @@ write_Centaurus_CX9211_DWdata(unsigned long data)
 
     /* Now write the 32-bit Data */
     for (count = 0; count < 32; count++) {
-        write_Centaurus_CX9211_GPIO((unsigned char)(data & 0x01));
+        write_Centaurus_CX9211_GPIO((unsigned char) (data & 0x01));
 
         /* the 9211 expects the data LSB->MSB */
         data >>= 1;
     }
     return;
 
-}                                      /* end write_Centaurus_CX9211_DWdata() */
+}                               /* end write_Centaurus_CX9211_DWdata() */
 
 /*********************************************************************
  *
@@ -505,7 +507,7 @@ read_Centaurus_CX9211_GPIO(void)
     data_port_val >>= 1;
     return (data_port_val & 0x1);
 
-}                                      /* end read_Centaurus_CX9211_GPIO() */
+}                               /* end read_Centaurus_CX9211_GPIO() */
 
 /**********************************************************************
  *
@@ -541,12 +543,12 @@ read_Centaurus_CX9211_DWdata(void)
     for (count = 0; count < 32; count++) {
         ReadData = read_Centaurus_CX9211_GPIO();
         /* 9211 sends data  LSB->MSB */
-        Data = Data | (((unsigned long)ReadData) << count);
-    }                                  /* end for() */
+        Data = Data | (((unsigned long) ReadData) << count);
+    }                           /* end for() */
 
     return Data;
 
-}                                      /* end read_Centaurus_CX9211_DWdata() */
+}                               /* end read_Centaurus_CX9211_DWdata() */
 
 void
 Centaurus_Get_9211_Details(unsigned long flags, Pnl_PanelParams * pParam)
@@ -576,7 +578,8 @@ Centaurus_Get_9211_Details(unsigned long flags, Pnl_PanelParams * pParam)
                 pParam->PanelChip = PNL_9211_A;
             else
                 pParam->PanelChip = PNL_UNKNOWN_CHIP;
-        } else {                       /* no 9211 present */
+        }
+        else {                  /* no 9211 present */
             pParam->PanelChip = PNL_UNKNOWN_CHIP;
         }
         Pnl_Rev_ID = pParam->PanelChip;
@@ -770,7 +773,7 @@ Centaurus_Power_Up(void)
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_LCD_PWR_MAN, off_data);
     return;
 
-}                                      /* Centaurus_Disable_Power */
+}                               /* Centaurus_Disable_Power */
 
 /***********************************************************************
  *
@@ -788,7 +791,7 @@ Centaurus_Power_Down(void)
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_LCD_PWR_MAN, off_data);
     return;
 
-}                                      /* Centaurus_Disable_Power */
+}                               /* Centaurus_Disable_Power */
 
 void
 Centaurus_9211init(Pnl_PanelStat * pstat)
@@ -839,28 +842,28 @@ Centaurus_Restore_Panel_State(void)
     /* set 9211 registers using the desired panel settings */
 
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_LCD_PAN_TIMING1,
-        cs9211_regs.panel_timing1);
+                         cs9211_regs.panel_timing1);
 
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_LCD_PAN_TIMING2,
-        cs9211_regs.panel_timing2);
+                         cs9211_regs.panel_timing2);
 
     /* load the LSFR seeds */
 
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_LCD_DITH_FR_CNTRL,
-        cs9211_regs.dither_frc_ctrl);
+                         cs9211_regs.dither_frc_ctrl);
 
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_BLUE_LSFR_SEED,
-        cs9211_regs.blue_lsfr_seed);
+                         cs9211_regs.blue_lsfr_seed);
 
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_RED_GREEN_LSFR_SEED,
-        cs9211_regs.red_green_lsfr_seed);
+                         cs9211_regs.red_green_lsfr_seed);
 
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_LCD_MEM_CNTRL,
-        cs9211_regs.memory_control);
+                         cs9211_regs.memory_control);
 
     /* Set the power register last. This will turn the panel on at the 9211 */
 
     Centaurus_write_gpio(FOUR_BYTES, CS92xx_LCD_PWR_MAN,
-        cs9211_regs.power_management);
+                         cs9211_regs.power_management);
 
 }
diff --git a/src/panel/cen9211.h b/src/panel/cen9211.h
index 1ab21e8..c3e5d08 100644
--- a/src/panel/cen9211.h
+++ b/src/panel/cen9211.h
@@ -78,8 +78,7 @@ void disable_Centaurus_9211_chip_select(void);
 void toggle_Centaurus_9211_clock(void);
 void write_Centaurus_CX9211_GPIO(unsigned char databit);
 void write_Centaurus_CX9211_DWdata(unsigned long data);
-void Centaurus_write_gpio(int width, unsigned long address,
-    unsigned long data);
+void Centaurus_write_gpio(int width, unsigned long address, unsigned long data);
 void Centaurus_Power_Up(void);
 void Centaurus_Power_Down(void);
 unsigned long Centaurus_read_gpio(int width, unsigned long address);
@@ -90,12 +89,11 @@ unsigned char init_Centaurus_GPIO(void);
 unsigned char init_Centaurus_9211(void);
 unsigned char set_Centaurus_92xx_mode(Pnl_PanelStat * pstat);
 void CentaurusProgramFRMload(void);
-void Centaurus_Get_9211_Details(unsigned long flags,
-    Pnl_PanelParams * pParam);
+void Centaurus_Get_9211_Details(unsigned long flags, Pnl_PanelParams * pParam);
 void Centaurus_Save_Panel_State(void);
 void Centaurus_Restore_Panel_State(void);
 void Centaurus_9211init(Pnl_PanelStat * pstat);
 
-#endif /* !_CEN9211_h */
+#endif                          /* !_CEN9211_h */
 
 /* END OF FILE */
diff --git a/src/panel/dora9211.c b/src/panel/dora9211.c
index ea52e95..295cf93 100644
--- a/src/panel/dora9211.c
+++ b/src/panel/dora9211.c
@@ -57,7 +57,8 @@ Dorado_Get_9211_Details(unsigned long flags, Pnl_PanelParams * pParam)
                 pParam->PanelChip = PNL_9211_A;
             else
                 pParam->PanelChip = PNL_UNKNOWN_CHIP;
-        } else {                       /* no 9211 present */
+        }
+        else {                  /* no 9211 present */
             pParam->PanelChip = PNL_UNKNOWN_CHIP;
         }
     }
@@ -75,22 +76,19 @@ Dorado_Get_9211_Details(unsigned long flags, Pnl_PanelParams * pParam)
         DPanelType = Dorado9211ReadReg(0x434);
         DPanelType = (DPanelType >> (DRD_LCDRESGPIO1 + 1));
         PanelTypeOrg = DPanelType >> 8;
-        Panel_2Byte = (unsigned char)PanelTypeOrg;
-        Panel_2Byte =
-            (Panel_2Byte >> (DRD_LCDRESGPIO2 - DRD_LCDRESGPIO1 - 1));
-        DPanelType = (DPanelType | ((unsigned int)Panel_2Byte << 8));
+        Panel_2Byte = (unsigned char) PanelTypeOrg;
+        Panel_2Byte = (Panel_2Byte >> (DRD_LCDRESGPIO2 - DRD_LCDRESGPIO1 - 1));
+        DPanelType = (DPanelType | ((unsigned int) Panel_2Byte << 8));
         DPanelType = DPanelType >> 1;
         PanelTypeOrg = DPanelType >> 8;
-        Panel_2Byte = (unsigned char)PanelTypeOrg;
-        Panel_2Byte =
-            (Panel_2Byte >> (DRD_LCDRESGPIO3 - DRD_LCDRESGPIO2 - 1));
-        DPanelType = (DPanelType | ((unsigned int)Panel_2Byte << 8));
+        Panel_2Byte = (unsigned char) PanelTypeOrg;
+        Panel_2Byte = (Panel_2Byte >> (DRD_LCDRESGPIO3 - DRD_LCDRESGPIO2 - 1));
+        DPanelType = (DPanelType | ((unsigned int) Panel_2Byte << 8));
         DPanelType = DPanelType >> 1;
         PanelTypeOrg = DPanelType >> 8;
-        Panel_2Byte = (unsigned char)PanelTypeOrg;
-        Panel_2Byte =
-            (Panel_2Byte >> (DRD_LCDRESGPIO4 - DRD_LCDRESGPIO3 - 1));
-        DPanelType = (DPanelType | ((unsigned int)Panel_2Byte << 8));
+        Panel_2Byte = (unsigned char) PanelTypeOrg;
+        Panel_2Byte = (Panel_2Byte >> (DRD_LCDRESGPIO4 - DRD_LCDRESGPIO3 - 1));
+        DPanelType = (DPanelType | ((unsigned int) Panel_2Byte << 8));
         DPanelType = DPanelType >> 5;
         DPanelType &= 0xf;
 
@@ -210,10 +208,10 @@ Dorado9211Init(Pnl_PanelStat * pstat)
             Dorado9211WriteReg(CS92xx_LCD_PAN_TIMING1, pMode->panel_timing1);
             Dorado9211WriteReg(CS92xx_LCD_PAN_TIMING2, pMode->panel_timing2);
             Dorado9211WriteReg(CS92xx_LCD_DITH_FR_CNTRL,
-                pMode->rev_C_dither_frc);
+                               pMode->rev_C_dither_frc);
             Dorado9211WriteReg(CS92xx_BLUE_LSFR_SEED, pMode->blue_lsfr_seed);
             Dorado9211WriteReg(CS92xx_RED_GREEN_LSFR_SEED,
-                pMode->red_green_lsfr_seed);
+                               pMode->red_green_lsfr_seed);
             DoradoProgramFRMload();
             Dorado9211WriteReg(CS92xx_LCD_MEM_CNTRL, pMode->memory_control);
             Dorado9211WriteReg(CS92xx_LCD_PWR_MAN, pMode->power_management);
@@ -235,8 +233,8 @@ Dorado9211Init(Pnl_PanelStat * pstat)
             orig_value &= 0xfff1ffff;
             WRITE_VID32(0X4, orig_value);
             return;
-        }                              /*end if() */
-    }                                  /*end for() */
+        }                       /*end if() */
+    }                           /*end for() */
 
 }
 
@@ -358,7 +356,8 @@ Dorado9211ReadReg(unsigned short index)
     for (i = 0; i < 12; i++) {
         if (index & 0x1) {
             Dorado9211SetDataOut();
-        } else {
+        }
+        else {
             Dorado9211ClearDataOut();
         }
         Dorado9211ToggleClock();
@@ -382,7 +381,7 @@ Dorado9211ReadReg(unsigned short index)
     for (i = 0; i < 32; i++) {
         Dorado9211ToggleClock();
         readbit = Dorado9211ReadDataIn();
-        data |= (((unsigned long)readbit) << i);
+        data |= (((unsigned long) readbit) << i);
     }
 
     Dorado9211ClearCS();
@@ -407,7 +406,8 @@ Dorado9211WriteReg(unsigned short index, unsigned long data)
     for (i = 0; i < 12; i++) {
         if (index & 0x1) {
             Dorado9211SetDataOut();
-        } else {
+        }
+        else {
             Dorado9211ClearDataOut();
         }
         Dorado9211ToggleClock();
@@ -420,7 +420,8 @@ Dorado9211WriteReg(unsigned short index, unsigned long data)
     for (i = 0; i < 32; i++) {
         if (data & 0x1) {
             Dorado9211SetDataOut();
-        } else {
+        }
+        else {
             Dorado9211ClearDataOut();
         }
         Dorado9211ToggleClock();
@@ -546,7 +547,7 @@ Dorado_Power_Up(void)
     Dorado9211WriteReg(CS92xx_LCD_PWR_MAN, 0x01000000);
     return;
 
-}                                      /* disable_Centaurus_Power */
+}                               /* disable_Centaurus_Power */
 
 /*****************************************************************************
  * void Dorado_Disable_Power((void);
@@ -560,7 +561,7 @@ Dorado_Power_Down(void)
     Dorado9211WriteReg(CS92xx_LCD_PWR_MAN, 0x0);
     return;
 
-}                                      /* disable_Centaurus_Power */
+}                               /* disable_Centaurus_Power */
 
 void
 Dorado_Save_Panel_State(void)
@@ -599,7 +600,7 @@ Dorado_Restore_Panel_State(void)
     Dorado9211WriteReg(CS92xx_LCD_DITH_FR_CNTRL, cs9211_regs.dither_frc_ctrl);
     Dorado9211WriteReg(CS92xx_BLUE_LSFR_SEED, cs9211_regs.blue_lsfr_seed);
     Dorado9211WriteReg(CS92xx_RED_GREEN_LSFR_SEED,
-        cs9211_regs.red_green_lsfr_seed);
+                       cs9211_regs.red_green_lsfr_seed);
 
     Dorado9211WriteReg(CS92xx_LCD_MEM_CNTRL, cs9211_regs.memory_control);
     /* Set the power register last. This will turn the panel on at the 9211 */
diff --git a/src/panel/dora9211.h b/src/panel/dora9211.h
index d38b503..fd3a406 100644
--- a/src/panel/dora9211.h
+++ b/src/panel/dora9211.h
@@ -40,13 +40,13 @@
 
 /* GPIO Pin Configuration Registers */
 
-#define DRD_GEODE_GPPIN_SEL	0x20   /* GPIO Pin Configuration Select        */
-#define DRD_GEODE_GPPIN_CFG	0x24   /* GPIO Pin Configuration Access        */
-#define DRD_GEODE_GPPIN_RESET	0x28   /* GPIO Pin Reset                                       */
+#define DRD_GEODE_GPPIN_SEL	0x20    /* GPIO Pin Configuration Select        */
+#define DRD_GEODE_GPPIN_CFG	0x24    /* GPIO Pin Configuration Access        */
+#define DRD_GEODE_GPPIN_RESET	0x28    /* GPIO Pin Reset                                       */
 
-#define DRD_GEODE_GPIO_BASE	0x6400 /* F0 GPIO, IO mapped                           */
-#define DRD_GEODE_GPDI0		0x04   /* GPIO Data In 0                                       */
-#define DRD_GEODE_GPDO0		0x00   /* GPIO Data Out 0                                      */
+#define DRD_GEODE_GPIO_BASE	0x6400  /* F0 GPIO, IO mapped                           */
+#define DRD_GEODE_GPDI0		0x04    /* GPIO Data In 0                                       */
+#define DRD_GEODE_GPDO0		0x00    /* GPIO Data Out 0                                      */
 
 /* Data Ports in */
 #define	DRD_CLOCKP9211IN	DRD_GEODE_GPIO_BASE + DRD_GEODE_GPDI0
@@ -61,11 +61,11 @@
 #define DRD_CSP9211OUT		DRD_GEODE_GPIO_BASE + DRD_GEODE_GPDO0
 
 /* Pin MASKS */
-#define	DRD_CLOCK9211	0x00000080     /* gpio 7, clock output to 9211         */
-#define	DRD_DATAIN9211	0x00040000     /* gpio 18, data output to 9211         */
-#define	DRD_DATAOUT9211	0x00000800     /* gpio 11, data input from 9211        */
-#define	DRD_CS9211	0x00000200     /* gpio 9, chip select output to 9211
-                                        * */
+#define	DRD_CLOCK9211	0x00000080      /* gpio 7, clock output to 9211         */
+#define	DRD_DATAIN9211	0x00040000      /* gpio 18, data output to 9211         */
+#define	DRD_DATAOUT9211	0x00000800      /* gpio 11, data input from 9211        */
+#define	DRD_CS9211	0x00000200      /* gpio 9, chip select output to 9211
+                                         * */
 
 /* Gpio CFG values to select in  */
 #define	DRD_CLOCK9211CFG	0x00000007      /* gpio 7                                                       */
@@ -97,4 +97,4 @@ void Dorado_Save_Panel_State(void);
 void Dorado_Restore_Panel_State(void);
 void Dorado9211Init(Pnl_PanelStat * pstat);
 
-#endif /* !_DORA9211_h */
+#endif                          /* !_DORA9211_h */
diff --git a/src/panel/drac9210.c b/src/panel/drac9210.c
index ce8b4a0..4eb0a98 100644
--- a/src/panel/drac9210.c
+++ b/src/panel/drac9210.c
@@ -32,12 +32,12 @@
 
 #include "drac9210.h"
 
-#define	CS9210			0x40   /* Chip select pin       */
+#define	CS9210			0x40    /* Chip select pin       */
 
 /* 9210 on Draco */
-#define CLOCK9210		0x04   /* Clock pin             */
-#define	DATAIN9210		0x20   /* Data from 9210        */
-#define	DATAOUT9210		0x80   /* Data to 9210          */
+#define CLOCK9210		0x04    /* Clock pin             */
+#define	DATAIN9210		0x20    /* Data from 9210        */
+#define	DATAOUT9210		0x80    /* Data to 9210          */
 
 static void DracoWriteData(unsigned char data);
 static void DracoReadData(unsigned char *data);
@@ -393,13 +393,13 @@ Draco9210Init(Pnl_PanelStat * pstat)
     Draco9210ToggleClock();
     Draco9210ClearCS();
 
-#if defined(_WIN32)                    /* For Windows   */
+#if defined(_WIN32)             /* For Windows   */
     for (i = 0; i < 10; i++) {
         _asm {
         out 0ED h, al}
     }
 
-#elif defined(linux)                   /* Linux                 */
+#elif defined(linux)            /* Linux                 */
 
 #endif
 
@@ -422,7 +422,8 @@ DracoWriteData(unsigned char data)
         databit = data & mask;
         if (data & mask) {
             Draco9210SetDataOut();
-        } else {
+        }
+        else {
             Draco9210ClearDataOut();
         }
         mask >>= 1;
@@ -449,7 +450,7 @@ DracoReadData(unsigned char *data)
     *data = tmp;
 }
 
-#if defined(_WIN32)                    /* For Windows */
+#if defined(_WIN32)             /* For Windows */
 
 void
 Draco9210GpioInit()
@@ -471,14 +472,11 @@ Draco9210SetCS()
         Point to PCI address register mov dx, 0 CF8h;
         55 XX GPIO data register mov eax, CX55x0_ID + 090 h out dx, eax;
         Point to PCI data register (CFCh)
-    mov dx, 0 CFCh
+mov dx, 0 CFCh
             in ax, dx
             and ah, 30 h
             mov ah, c92DataReg
-            or ah, CS9210 mov c92DataReg, ah out dx, ax popf}
-}
-
-void
+            or ah, CS9210 mov c92DataReg, ah out dx, ax popf}} void
 Draco9210ClearCS()
 {
     _asm {
@@ -487,13 +485,10 @@ Draco9210ClearCS()
         55 XX GPIO data register mov eax, CX55x0_ID + 090 h out dx, eax;
         Point to PCI data register (CFCh)
         mov dx, 0 CFCh;
-    Set CS LOW
+Set CS LOW
             in ax, dx
             mov ah, c92DataReg
-            and ah, NOT CS9210 mov c92DataReg, ah out dx, ax popf}
-}
-
-void
+            and ah, NOT CS9210 mov c92DataReg, ah out dx, ax popf}} void
 Draco9210SetDataOut()
 {
     _asm {
@@ -502,30 +497,26 @@ Draco9210SetDataOut()
         55 XX GPIO data register mov eax, CX55x0_ID + 090 h out dx, eax;
         Point to PCI data register (CFCh)
         mov dx, 0 CFCh;
-    Set DATA HIGH
+Set DATA HIGH
             in ax, dx
             mov ah, c92DataReg
-            or ah, DATAOUT9210 mov c92DataReg, ah out dx, ax popf}
-}
-
-void
+            or ah, DATAOUT9210 mov c92DataReg, ah out dx, ax popf}} void
 Draco9210ClearDataOut()
 {
     _asm {
         pushf;
         Point to PCI address register
-            mov dx, 0 CF8h mov eax, CX55x0_ID + 090 h;
+        mov dx, 0 CF8h mov eax, CX55x0_ID + 090 h;
+
         ;
         55 XX GPIO data register out dx, eax;
         Point to PCI data register (CFCh)
         mov dx, 0 CFCh;
-    Set Data LOW
+Set Data LOW
             in ax, dx
             mov ah, c92DataReg
-            and ah, NOT DATAOUT9210 mov c92DataReg, ah out dx, ax popf}
-}
-
-unsigned char
+            and ah, NOT DATAOUT9210 mov c92DataReg, ah out dx, ax popf}}
+    unsigned char
 Draco9210ReadDataIn()
 {
     unsigned char readdata;
@@ -538,8 +529,7 @@ Draco9210ReadDataIn()
         mov dx, 0F Ch in ax, dx;
         Preserve just Data IN bit and ah, DATAIN9210 mov al, ah cmp al, 0;
         Is it LOW ? je readDataLow;
-    must be HIGH mov al, 1 readDataLow:mov readdata, al popf}
-    return (readdata);
+    must be HIGH mov al, 1 readDataLow:mov readdata, al popf} return (readdata);
 }
 
 void
@@ -552,45 +542,49 @@ Draco9210ToggleClock()
         Point to PCI data register (CFCh)
         out dx, eax mov dx, 0 CFCh;
         SET CLOCK in ax, dx mov ah, c92DataReg or ah, CLOCK9210 mov c92DataReg, ah out dx, ax out 0ED h, al     /* IOPAUSE      */
-           ;
+        ;
         Point to PCI address register mov dx, 0 CF8h;
         55 XX GPIO data register mov eax, CX55x0_ID + 090 h out dx, eax;
         Point to PCI data register (CFCh)
         mov dx, 0 CFCh;
 
         ;
-    CLEAR CLOCK
+CLEAR CLOCK
             in ax, dx
             mov ah, c92DataReg
-            and ah, NOT CLOCK9210 mov c92DataReg, ah out dx, ax popf}
-}
-
-#elif defined(linux)                   /* Linux         */
+            and ah, NOT CLOCK9210 mov c92DataReg, ah out dx, ax popf}}
+#elif defined(linux)            /* Linux         */
 
 void
 Draco9210GpioInit()
 {
 }
+
 void
 Draco9210SetCS()
 {
 }
+
 void
 Draco9210ClearCS()
 {
 }
+
 void
 Draco9210SetDataOut()
 {
 }
+
 void
 Draco9210ClearDataOut()
 {
 }
+
 unsigned char
 Draco9210ReadDataIn()
 {
 }
+
 void
 Draco9210ToggleClock()
 {
diff --git a/src/panel/drac9210.h b/src/panel/drac9210.h
index 1939fd6..5248579 100644
--- a/src/panel/drac9210.h
+++ b/src/panel/drac9210.h
@@ -36,6 +36,6 @@
 #define _DRAC9210_h
 #define CX55x0_ID 	0x80009000
 static unsigned char c92DataReg = 0;
-#endif /* !_DRAC9210_h */
+#endif                          /* !_DRAC9210_h */
 
 /* END OF FILE */
diff --git a/src/panel/gx2_9211.c b/src/panel/gx2_9211.c
index 7d46b9c..b34a19d 100644
--- a/src/panel/gx2_9211.c
+++ b/src/panel/gx2_9211.c
@@ -34,13 +34,13 @@
 #include "gx2_9211.h"
 #include "pnl_defs.h"
 
-#if defined(_WIN32)                    /* windows */
+#if defined(_WIN32)             /* windows */
 #include "gfx_defs.h"
 
 extern DEV_STATUS gfx_msr_read(unsigned int device, unsigned int msrRegister,
-    Q_WORD * msrValue);
+                               Q_WORD * msrValue);
 extern DEV_STATUS gfx_msr_write(unsigned int device, unsigned int msrRegister,
-    Q_WORD * msrValue);
+                                Q_WORD * msrValue);
 #endif
 
 static unsigned long FPBaseAddr;
@@ -80,45 +80,45 @@ SetFPBaseAddr(unsigned long addr)
  ****************************************************************************/
 void
 protected_mode_access(unsigned long mode,
-    unsigned long width, unsigned long addr, char *pdata)
+                      unsigned long width, unsigned long addr, char *pdata)
 {
-    void *ptr = (void *)(FPBaseAddr + addr);
+    void *ptr = (void *) (FPBaseAddr + addr);
 
     /* type specific buffer pointers */
-    char *byte_data = (char *)pdata;
-    unsigned long *word_data = (unsigned long *)pdata;
-    unsigned long *dword_data = (unsigned long *)pdata;
+    char *byte_data = (char *) pdata;
+    unsigned long *word_data = (unsigned long *) pdata;
+    unsigned long *dword_data = (unsigned long *) pdata;
 
     if (mode == GX2_READ) {
         switch (width) {
         case FOUR_BYTES:
-            *(dword_data) = (unsigned long)(*(unsigned long *)ptr);
+            *(dword_data) = (unsigned long) (*(unsigned long *) ptr);
             break;
         case TWO_BYTES:
-            *(word_data) = (unsigned long)(*(unsigned long *)ptr);
+            *(word_data) = (unsigned long) (*(unsigned long *) ptr);
             break;
         default:
-            *(byte_data) = (char)(*(char *)ptr);
+            *(byte_data) = (char) (*(char *) ptr);
             break;
         }
-    } /* end  GX2_READ */
+    }                           /* end  GX2_READ */
     else if (mode == GX2_WRITE) {
         switch (width) {
         case FOUR_BYTES:
-            *(unsigned long *)ptr = *dword_data;
+            *(unsigned long *) ptr = *dword_data;
             break;
         case TWO_BYTES:
-            *(unsigned long *)ptr = *word_data;
+            *(unsigned long *) ptr = *word_data;
             break;
         default:
-            *(char *)ptr = *byte_data;
+            *(char *) ptr = *byte_data;
             break;
-        }                              /* end switch(mode) */
+        }                       /* end switch(mode) */
     }
     /* end case GX2_WRITE */
     return;
 
-}                                      /* End of protected_mode_access. */
+}                               /* End of protected_mode_access. */
 
 /*************************************************************************
  * void write_video_reg64_low( unsigned long offset, unsigned long value )
@@ -132,8 +132,8 @@ void
 write_video_reg64_low(unsigned long offset, unsigned long value)
 {
     protected_mode_access(GX2_WRITE, FOUR_BYTES,
-        FPBaseAddr + offset, (char *)&value);
-}                                      /*end write_video_reg64_low() */
+                          FPBaseAddr + offset, (char *) &value);
+}                               /*end write_video_reg64_low() */
 
 /*************************************************************************
  * unsigned long read_video_reg64_low( unsigned long offset )
@@ -149,9 +149,9 @@ read_video_reg64_low(unsigned long offset)
     unsigned long data;
 
     protected_mode_access(GX2_READ, FOUR_BYTES,
-        FPBaseAddr + offset, (char *)&data);
+                          FPBaseAddr + offset, (char *) &data);
     return (data);
-}                                      /*end read_video_reg64_low() */
+}                               /*end read_video_reg64_low() */
 
 /*****************************************************************************
  * void Redcloud_fp_reg(int mode, unsigned long address, unsigned long *data)
@@ -174,11 +174,12 @@ Redcloud_fp_reg(int mode, unsigned long address, unsigned long *data)
 {
     if (mode == GX2_READ) {
         *data = read_video_reg64_low(address);
-    } else {
+    }
+    else {
         write_video_reg64_low(address, *data);
     }
 
-}                                      /* End of Redcloud_fp_reg() */
+}                               /* End of Redcloud_fp_reg() */
 
 /*-------------------------------------------------------------------
  *
@@ -200,7 +201,8 @@ set_Redcloud_92xx_mode_params(int mode)
         msrValue.low &= ~GX2_VP_PAD_SELECT_MASK;
         if (pMode->panel_type == PNL_TFT || pMode->panel_type == PNL_TWOP) {
             msrValue.low = GX2_VP_PAD_SELECT_TFT;
-        } else {
+        }
+        else {
             msrValue.low = GX2_VP_PAD_SELECT_DSTN;
         }
         gfx_msr_write(RC_ID_DF, GX2_VP_MSR_PAD_SELECT, &msrValue);
@@ -208,17 +210,17 @@ set_Redcloud_92xx_mode_params(int mode)
 
     /* Turn the 92xx power off before setting any new parameters. */
     temp_data = pMode->power_management & ~GX2_FP_PM_PWR_ON;
-    Redcloud_fp_reg(GX2_WRITE, GX2_FP_PWR_MAN, (unsigned long *)&temp_data);
+    Redcloud_fp_reg(GX2_WRITE, GX2_FP_PWR_MAN, (unsigned long *) &temp_data);
 
     /* Set 9211 registers using the desired panel settings */
 
     Redcloud_fp_reg(GX2_WRITE, GX2_FP_PAN_TIMING1,
-        (unsigned long *)&pMode->panel_timing1);
+                    (unsigned long *) &pMode->panel_timing1);
 
     /* On Redcloud, bit 31 is now reserved. */
     temp_data = pMode->panel_timing2 & 0x7FFFFFFF;
     Redcloud_fp_reg(GX2_WRITE, GX2_FP_PAN_TIMING2,
-        (unsigned long *)&temp_data);
+                    (unsigned long *) &temp_data);
 
     /* On Redcloud TFT parts, set this to 0x70 so all 8 bits per color run 
      * thru fp crc but only non-TFT parts.  Otherwise, set it to be 0x50. 
@@ -226,30 +228,31 @@ set_Redcloud_92xx_mode_params(int mode)
      */
     if (pMode->panel_type == PNL_TFT || pMode->panel_type == PNL_TWOP) {
         temp_data = GX2_FP_CRC_PASS_THRU_MASK;
-    } else {
+    }
+    else {
         temp_data = pMode->rev_C_dither_frc;
     }
     Redcloud_fp_reg(GX2_WRITE, GX2_FP_DITH_FR_CNTRL,
-        (unsigned long *)&temp_data);
+                    (unsigned long *) &temp_data);
     Redcloud_fp_reg(GX2_WRITE, GX2_FP_BLFSR,
-        (unsigned long *)&pMode->blue_lsfr_seed);
+                    (unsigned long *) &pMode->blue_lsfr_seed);
     Redcloud_fp_reg(GX2_WRITE, GX2_FP_RLFSR,
-        (unsigned long *)&pMode->red_green_lsfr_seed);
+                    (unsigned long *) &pMode->red_green_lsfr_seed);
 
     /* Set the memory information, then the power register last. 
      * This will turn the panel on at the 9211.
      */
 
-    Redcloud_fp_reg(GX2_READ, GX2_FP_FBB, (unsigned long *)&base_data);
+    Redcloud_fp_reg(GX2_READ, GX2_FP_FBB, (unsigned long *) &base_data);
     if (base_data != 0x41780000) {
         base_data = 0x41780000;
-        Redcloud_fp_reg(GX2_WRITE, GX2_FP_FBB, (unsigned long *)&base_data);
+        Redcloud_fp_reg(GX2_WRITE, GX2_FP_FBB, (unsigned long *) &base_data);
     }
 
     Redcloud_fp_reg(GX2_WRITE, GX2_FP_PWR_MAN,
-        (unsigned long *)&pMode->power_management);
+                    (unsigned long *) &pMode->power_management);
 
-}                                      /*end set_92xx_mode_params() */
+}                               /*end set_92xx_mode_params() */
 
 /* -----------------------------------------------------------------------
  * SET_FLAT_PANEL_MODE
@@ -277,11 +280,11 @@ set_Redcloud_92xx_mode(Pnl_PanelStat * pstat)
             /* SET THE 92xx FOR THE SELECTED MODE */
             set_Redcloud_92xx_mode_params(mode);
             return TRUE;
-        }                              /* end if() */
-    }                                  /* end for() */
+        }                       /* end if() */
+    }                           /* end for() */
     return FALSE;
 
-}                                      /* end set_Centaurus_92xx_mode() */
+}                               /* end set_Centaurus_92xx_mode() */
 
 void
 Redcloud_9211init(Pnl_PanelStat * pstat)
diff --git a/src/panel/gx2_9211.h b/src/panel/gx2_9211.h
index 071b3fb..ef6372c 100644
--- a/src/panel/gx2_9211.h
+++ b/src/panel/gx2_9211.h
@@ -45,20 +45,20 @@
  */
 
 #define GX2_FP_LCD_OFFSET       0x00000400
-#define CS9211_REDCLOUD         0x0400 /* Moved 9211 Rev C3 up to next major
-                                        * no.                                                          */
-#define GX2_FP_PAN_TIMING1      0x0400 /* FP timings 1                                         */
-#define GX2_FP_PAN_TIMING2      0x0408 /* FP timings 2                                         */
-#define GX2_FP_PWR_MAN          0x0410 /* FP power management                          */
-#define GX2_FP_DITH_FR_CNTRL    0x0418 /* FP dither and frame rate             */
-#define GX2_FP_BLFSR            0x0420 /* Blue LFSR seed                                       */
-#define GX2_FP_RLFSR            0x0428 /* Red and Green LFSR seed                      */
-#define GX2_FP_FMI              0x0430 /* FRM Memory Index                             */
-#define GX2_FP_FMD              0x0438 /* FRM Memory Data                                      */
-#define GX2_FP_DCA              0x0448 /* Dither ram control and address       */
-#define GX2_FP_DMD              0x0450 /* Dither memory data                           */
-#define GX2_FP_PAN_CRC_SIG      0x0458 /* FP CRC signature                             */
-#define GX2_FP_FBB              0x0460 /* Frame Buffer Base Address            */
+#define CS9211_REDCLOUD         0x0400  /* Moved 9211 Rev C3 up to next major
+                                         * no.                                                          */
+#define GX2_FP_PAN_TIMING1      0x0400  /* FP timings 1                                         */
+#define GX2_FP_PAN_TIMING2      0x0408  /* FP timings 2                                         */
+#define GX2_FP_PWR_MAN          0x0410  /* FP power management                          */
+#define GX2_FP_DITH_FR_CNTRL    0x0418  /* FP dither and frame rate             */
+#define GX2_FP_BLFSR            0x0420  /* Blue LFSR seed                                       */
+#define GX2_FP_RLFSR            0x0428  /* Red and Green LFSR seed                      */
+#define GX2_FP_FMI              0x0430  /* FRM Memory Index                             */
+#define GX2_FP_FMD              0x0438  /* FRM Memory Data                                      */
+#define GX2_FP_DCA              0x0448  /* Dither ram control and address       */
+#define GX2_FP_DMD              0x0450  /* Dither memory data                           */
+#define GX2_FP_PAN_CRC_SIG      0x0458  /* FP CRC signature                             */
+#define GX2_FP_FBB              0x0460  /* Frame Buffer Base Address            */
 
 /* GX2_FP_PAN_TIMING2 bits */
 
@@ -107,7 +107,8 @@
 void SetFPBaseAddr(unsigned long);
 void Redcloud_9211init(Pnl_PanelStat *);
 void protected_mode_access(unsigned long mode,
-    unsigned long width, unsigned long addr, char *pdata);
+                           unsigned long width, unsigned long addr,
+                           char *pdata);
 void write_video_reg64_low(unsigned long offset, unsigned long value);
 unsigned long read_video_reg64_low(unsigned long offset);
 void Redcloud_fp_reg(int mode, unsigned long address, unsigned long *data);
diff --git a/src/panel/panel.c b/src/panel/panel.c
index ffd54c9..f7b55f0 100644
--- a/src/panel/panel.c
+++ b/src/panel/panel.c
@@ -30,7 +30,7 @@
  * SubModule:       Geode FlatPanel library
  * */
 
-#if defined(linux)                     /* Linux */
+#if defined(linux)              /* Linux */
 
 #ifdef __KERNEL__
 
@@ -43,8 +43,8 @@
 #include <linux/fs.h>
 #include <asm/mman.h>
 
-#endif /* __KERNEL__ */
-#elif defined(_WIN32)                  /* windows */
+#endif                          /* __KERNEL__ */
+#elif defined(_WIN32)           /* windows */
 
 #include <windows.h>
 
diff --git a/src/panel/panel.h b/src/panel/panel.h
index bc708df..93380f0 100644
--- a/src/panel/panel.h
+++ b/src/panel/panel.h
@@ -38,8 +38,7 @@
 #include "pnl_defs.h"
 
 #ifdef __cplusplus
-extern "C"
-{
+extern "C" {
 #endif
 
 /* CLOSE BRACKET FOR C++ COMPLILATION */
@@ -63,7 +62,7 @@ extern "C"
     void Pnl_GetPanelInfoFromBIOS(int *xres, int *yres, int *bpp, int *hz);
 /* from durango */
 
-#if defined(_WIN32)                    /* windows */
+#if defined(_WIN32)             /* windows */
     extern void gfx_delay_milliseconds(unsigned long milliseconds);
     extern unsigned long gfx_ind(unsigned short port);
     extern void gfx_outd(unsigned short port, unsigned long data);
@@ -74,7 +73,5 @@ extern "C"
 #ifdef __cplusplus
 }
 #endif
-
-#endif                                 /* !_panel_h */
-
+#endif                          /* !_panel_h */
 /* END OF FILE */
diff --git a/src/panel/platform.c b/src/panel/platform.c
index 46bb71b..3e5afe3 100644
--- a/src/panel/platform.c
+++ b/src/panel/platform.c
@@ -30,7 +30,6 @@
  * SubModule:       Geode FlatPanel library
  * */
 
-
 #define LINUX_ROM_SEGMENT 0x000F
 #define SEGMENT_LENGTH  0xFFFF
 #define PAGE_LENGTH     0x1000
@@ -38,12 +37,10 @@
 
 #define PLT_UNKNOWN     0xFFFF
 
-typedef struct
-{
+typedef struct {
     char sys_board_name[SYS_BOARD_NAME_LEN];
     SYS_BOARD sys_board;
-}
-SYS_BOARD_INFO;
+} SYS_BOARD_INFO;
 
 static SYS_BOARD_INFO Sys_info;
 
@@ -93,7 +90,8 @@ Strncmp(char *str1, char *str2, int len)
     for (i = 0; i < len; i++) {
         if (*(str1 + i) > *(str2 + i)) {
             return 1;
-        } else if (*(str1 + i) < *(str2 + i)) {
+        }
+        else if (*(str1 + i) < *(str2 + i)) {
             return -1;
         }
     }
@@ -110,7 +108,7 @@ Strcpy(char *dst, char *src)
     for (i = 0; src[i] != 0x0; i++) {
         dst[i] = src[i];
     }
-    dst[i] = 0x0;                      /* NULL termination */
+    dst[i] = 0x0;               /* NULL termination */
     return dst;
 }
 
@@ -121,7 +119,7 @@ Strlen(char *str)
 
     if (str == 0x0)
         return 0;
-    for (i = 0; str[i] != 0x0; i++) ;
+    for (i = 0; str[i] != 0x0; i++);
     return i;
 }
 
@@ -141,13 +139,13 @@ FindStringInSeg(unsigned int segment_address, char *string_ptr)
 {
     int string_length = Strlen(string_ptr);
     char *psegment_buf;
-    unsigned long mem_ptr = (unsigned long)segment_address << 16;
+    unsigned long mem_ptr = (unsigned long) segment_address << 16;
     unsigned int i;
 
     /* silence compiler */
-    (void)mem_ptr;
+    (void) mem_ptr;
 
-    psegment_buf = (char *)XpressROMPtr;
+    psegment_buf = (char *) XpressROMPtr;
 
     /* Now search for the first character of the string_ptr */
     for (i = 0; i < SEGMENT_LENGTH + 1; i++) {
@@ -166,7 +164,7 @@ FindStringInSeg(unsigned int segment_address, char *string_ptr)
     /* if we got this far we didn't find anything.  Return NULL. */
     return (0);
 
-}                                      /* end FindStringInSeg() */
+}                               /* end FindStringInSeg() */
 
 /**********************************************************************
 
@@ -185,7 +183,7 @@ FindStringInSeg(unsigned int segment_address, char *string_ptr)
  */
 static unsigned char
 get_sys_board_type(SYS_BOARD_INFO * sys_info,
-    SYS_BOARD_INFO * sys_board_array_base)
+                   SYS_BOARD_INFO * sys_board_array_base)
 {
     int index;
     char *xpress_rom_string_ptr = "XpressStart";
@@ -201,27 +199,28 @@ get_sys_board_type(SYS_BOARD_INFO * sys_info,
         sys_info->sys_board = PLT_UNKNOWN;
         Strcpy(sys_info->sys_board_name, "Unknown");
         return (FALSE);
-    } else {
+    }
+    else {
 
         /* we have Xpressrom, so look for a board */
         for (index = 0; index < Num_sys_board_type; index++) {
             if (!FindStringInSeg(segment, (sys_board_array_base +
-                        index)->sys_board_name)) {
+                                           index)->sys_board_name)) {
                 continue;
-            } else {
+            }
+            else {
 
                 /* a match!! */
-                sys_info->sys_board =
-                    (sys_board_array_base + index)->sys_board;
+                sys_info->sys_board = (sys_board_array_base + index)->sys_board;
                 Strcpy(sys_info->sys_board_name,
-                    (sys_board_array_base + index)->sys_board_name);
+                       (sys_board_array_base + index)->sys_board_name);
                 return (TRUE);
             }
-        }                              /* end for() */
-    }                                  /* end else */
+        }                       /* end for() */
+    }                           /* end else */
 
     /* if we are here we have failed */
     sys_info->sys_board = PLT_UNKNOWN;
     Strcpy(sys_info->sys_board_name, "Unknown");
     return (FALSE);
-}                                      /* end get_sys_board_type() */
+}                               /* end get_sys_board_type() */
diff --git a/src/panel/pnl_bios.c b/src/panel/pnl_bios.c
index 9e3c1fe..56b13b9 100644
--- a/src/panel/pnl_bios.c
+++ b/src/panel/pnl_bios.c
@@ -32,7 +32,7 @@
 
 #include "panel.h"
 
-#if defined(_WIN32)                    /* windows */
+#if defined(_WIN32)             /* windows */
 extern unsigned long gfx_cpu_version;
 extern void gfx_outw(unsigned short port, unsigned short data);
 extern unsigned short gfx_inw(unsigned short port);
@@ -47,63 +47,63 @@ extern unsigned short gfx_inw(unsigned short port);
 #define VR_INDEX                0xAC1C
 #define VR_DATA                 0xAC1E
 #define VR_UNLOCK               0xFC53
-#define VRC_VG                  0x0002 /* SoftVG Virtual Register Class    */
-#define VG_MEM_SIZE             0x0000 /* MemSize Virtual Register             */
+#define VRC_VG                  0x0002  /* SoftVG Virtual Register Class    */
+#define VG_MEM_SIZE             0x0000  /* MemSize Virtual Register             */
 #define FP_DETECT_MASK          0x8000
 
-#define VG_FP_TYPE      0x0002         /* Flat Panel Info Virtual Register */
+#define VG_FP_TYPE      0x0002  /* Flat Panel Info Virtual Register */
 
-#define FP_DEV_MASK     0x0003         /* Flat Panel type                                      */
-#define FP_TYPE_SSTN	0x0000         /* SSTN panel type value                        */
-#define FP_TYPE_DSTN	0x0001         /* DSTN panel type value                        */
-#define FP_TYPE_TFT		0x0002 /* TFT panel type value                         */
-#define FP_TYPE_LVDS	0x0003         /* LVDS panel type value                        */
+#define FP_DEV_MASK     0x0003  /* Flat Panel type                                      */
+#define FP_TYPE_SSTN	0x0000  /* SSTN panel type value                        */
+#define FP_TYPE_DSTN	0x0001  /* DSTN panel type value                        */
+#define FP_TYPE_TFT		0x0002  /* TFT panel type value                         */
+#define FP_TYPE_LVDS	0x0003  /* LVDS panel type value                        */
 
 #define FP_RESOLUTION_MASK      0x0038
-#define FP_RES_6X4		0x0000 /* 640x480 resolution value             */
-#define FP_RES_8X6		0x0008 /* 800x600 resolution value             */
-#define FP_RES_10X7		0x0010 /* 1024x768 resolution value            */
-#define FP_RES_11X8	0x0018         /* 1152x864 resolution value            */
-#define FP_RES_12X10	0x0020         /* 1280x1024 resolution value           */
-#define FP_RES_16X12	0x0028         /* 1600x1200 resolution value           */
+#define FP_RES_6X4		0x0000  /* 640x480 resolution value             */
+#define FP_RES_8X6		0x0008  /* 800x600 resolution value             */
+#define FP_RES_10X7		0x0010  /* 1024x768 resolution value            */
+#define FP_RES_11X8	0x0018  /* 1152x864 resolution value            */
+#define FP_RES_12X10	0x0020  /* 1280x1024 resolution value           */
+#define FP_RES_16X12	0x0028  /* 1600x1200 resolution value           */
 
 #define FP_WIDTH_MASK   0x01C0
-#define FP_WIDTH_8		0x0000 /* 8 bit data bus width                         */
-#define FP_WIDTH_9		0x0040 /* 9 bit data bus width                         */
-#define FP_WIDTH_12		0x0080 /* 12 bit data bus width                        */
-#define FP_WIDTH_18		0x00C0 /* 18 bit data bus width                        */
-#define FP_WIDTH_24		0x0100 /* 24 bit data bus width                        */
-#define FP_WIDTH_16		0x0140 /* 16 bit data bus width - 16 bit 
-                                        * Mono DSTN only                                       */
+#define FP_WIDTH_8		0x0000  /* 8 bit data bus width                         */
+#define FP_WIDTH_9		0x0040  /* 9 bit data bus width                         */
+#define FP_WIDTH_12		0x0080  /* 12 bit data bus width                        */
+#define FP_WIDTH_18		0x00C0  /* 18 bit data bus width                        */
+#define FP_WIDTH_24		0x0100  /* 24 bit data bus width                        */
+#define FP_WIDTH_16		0x0140  /* 16 bit data bus width - 16 bit 
+                                         * Mono DSTN only                                       */
 
 #define FP_COLOR_MASK   0x0200
-#define FP_COLOR_COLOR	0x0000         /* Color panel                                          */
-#define FP_COLOR_MONO	0x0200         /* Mono Panel                                           */
+#define FP_COLOR_COLOR	0x0000  /* Color panel                                          */
+#define FP_COLOR_MONO	0x0200  /* Mono Panel                                           */
 
 #define FP_PPC_MASK     0x0400
-#define FP_PPC_1PPC		0x0000 /* One pixel per clock                          */
-#define FP_PPC_2PPC		0x0400 /* Two pixels per clock                         */
+#define FP_PPC_1PPC		0x0000  /* One pixel per clock                          */
+#define FP_PPC_2PPC		0x0400  /* Two pixels per clock                         */
 
 #define FP_HPOL_MASK    0x0800
-#define	FP_H_POL_LGH	0x0000         /* HSync at panel, normally low, 
-                                        * active high                                          */
-#define FP_H_POL_HGL	0x0800         /* HSync at panel, normally high, 
-                                        * active low                                           */
+#define	FP_H_POL_LGH	0x0000  /* HSync at panel, normally low, 
+                                 * active high                                          */
+#define FP_H_POL_HGL	0x0800  /* HSync at panel, normally high, 
+                                 * active low                                           */
 
 #define FP_VPOL_MASK    0x1000
-#define FP_V_POL_LGH	0x0000         /* VSync at panel, normally low, 
-                                        * active high                                          */
-#define FP_V_POL_HGL	0x1000         /* VSync at panel, normally high, 
-                                        * active low                                           */
+#define FP_V_POL_LGH	0x0000  /* VSync at panel, normally low, 
+                                 * active high                                          */
+#define FP_V_POL_HGL	0x1000  /* VSync at panel, normally high, 
+                                 * active low                                           */
 
 #define FP_REF_MASK     0xE000
-#define FP_REF_60		0x0000 /* 60Hz refresh rate                            */
-#define FP_REF_70		0x2000 /* 70Hz refresh rate                            */
-#define FP_REF_72		0x4000 /* 72Hz refresh rate                            */
-#define FP_REF_75		0x6000 /* 75Hz refresh rate                            */
-#define FP_REF_85		0x8000 /* 85Hz refresh rate                            */
-#define FP_REF_90		0xA000 /* 90Hz refresh rate                            */
-#define FP_REF_100		0xC000 /* 100Hz refresh rate                           */
+#define FP_REF_60		0x0000  /* 60Hz refresh rate                            */
+#define FP_REF_70		0x2000  /* 70Hz refresh rate                            */
+#define FP_REF_72		0x4000  /* 72Hz refresh rate                            */
+#define FP_REF_75		0x6000  /* 75Hz refresh rate                            */
+#define FP_REF_85		0x8000  /* 85Hz refresh rate                            */
+#define FP_REF_90		0xA000  /* 90Hz refresh rate                            */
+#define FP_REF_100		0xC000  /* 100Hz refresh rate                           */
 
 /*-----------------------------------------------------------------
  * Pnl_IsPanelEnabledInBIOS
@@ -126,7 +126,8 @@ Pnl_IsPanelEnabledInBIOS(void)
         data = gfx_inw(VR_DATA);
         if (data & FP_DETECT_MASK)
             ret = 1;
-    } else {
+    }
+    else {
         unsigned short crtcindex, crtcdata;
 
         crtcindex = (gfx_inb(0x3CC) & 0x01) ? 0x3D4 : 0x3B4;
@@ -134,7 +135,7 @@ Pnl_IsPanelEnabledInBIOS(void)
 
         /* CHECK DisplayEnable Reg in SoftVGA */
 
-        gfx_outb(crtcindex, (unsigned char)SOFTVGA_DISPLAY_ENABLE);
+        gfx_outb(crtcindex, (unsigned char) SOFTVGA_DISPLAY_ENABLE);
         ret = gfx_inb(crtcdata);
     }
 
@@ -235,13 +236,14 @@ Pnl_GetPanelInfoFromBIOS(int *xres, int *yres, int *bpp, int *hz)
             break;
         }
 
-    } else {
+    }
+    else {
         crtcindex = (gfx_inb(0x3CC) & 0x01) ? 0x3D4 : 0x3B4;
         crtcdata = crtcindex + 1;
 
         /* CHECK FPResolution Reg in SoftVGA */
 
-        gfx_outb(crtcindex, (unsigned char)SOFTVGA_FPRESOLUTION);
+        gfx_outb(crtcindex, (unsigned char) SOFTVGA_FPRESOLUTION);
         ret = gfx_inb(crtcdata);
 
         switch (ret & 0x3) {
@@ -276,7 +278,7 @@ Pnl_GetPanelInfoFromBIOS(int *xres, int *yres, int *bpp, int *hz)
 
         /* CHECK FPClockFrequency Reg in SoftVGA */
 
-        gfx_outb(crtcindex, (unsigned char)SOFTVGA_FPCLOCKFREQUENCY);
+        gfx_outb(crtcindex, (unsigned char) SOFTVGA_FPCLOCKFREQUENCY);
         *hz = gfx_inb(crtcdata);
     }
 }
diff --git a/src/panel/pnl_defs.h b/src/panel/pnl_defs.h
index 447a944..083d5af 100644
--- a/src/panel/pnl_defs.h
+++ b/src/panel/pnl_defs.h
@@ -33,8 +33,7 @@
 #ifndef _pnl_defs_h
 #define _pnl_defs_h
 
-typedef enum
-{
+typedef enum {
     MARMOT_PLATFORM = 0,
     UNICORN_PLATFORM,
     CENTAURUS_PLATFORM,
@@ -45,8 +44,7 @@ typedef enum
     DRACO_PLATFORM,
     REDCLOUD_PLATFORM,
     OTHER_PLATFORM
-}
-SYS_BOARD;
+} SYS_BOARD;
 
 #define PNL_9210             0x01
 #define PNL_9211_A           0x02
@@ -70,26 +68,22 @@ SYS_BOARD;
 #define PNL_OVERRIDE_STAT    0x10
 #define PNL_OVERRIDE_ALL     0x1F
 
-typedef struct _Pnl_PanelStat_
-{
+typedef struct _Pnl_PanelStat_ {
     int Type;
     int XRes;
     int YRes;
     int Depth;
     int MonoColor;
-}
-Pnl_PanelStat;
+} Pnl_PanelStat;
 
-typedef struct _Pnl_Params_
-{
+typedef struct _Pnl_Params_ {
     unsigned long Flags;
     int PanelPresent;
     int Platform;
     int PanelChip;
     Pnl_PanelStat PanelStat;
-}
-Pnl_PanelParams, *PPnl_PanelParams;
+} Pnl_PanelParams, *PPnl_PanelParams;
 
-#endif /* _pnl_defs_h */
+#endif                          /* _pnl_defs_h */
 
 /* END OF FILE */
diff --git a/src/panel/pnl_init.c b/src/panel/pnl_init.c
index 39b932e..3c58014 100644
--- a/src/panel/pnl_init.c
+++ b/src/panel/pnl_init.c
@@ -221,7 +221,8 @@ Pnl_PowerUp(void)
         dcfg |= (CS5530_DCFG_FP_PWR_EN | CS5530_DCFG_FP_DATA_EN);
         /* Enable the flatpanel power and data */
         WRITE_VID32(CS5530_DISPLAY_CONFIG, dcfg);
-    } else if (hw_video == GFX_VID_SC1200) {
+    }
+    else if (hw_video == GFX_VID_SC1200) {
         /* READ DISPLAY CONFIG FROM SC1200 */
         dcfg = READ_VID32(SC1200_DISPLAY_CONFIG);
 
@@ -229,7 +230,8 @@ Pnl_PowerUp(void)
         dcfg |= (SC1200_DCFG_FP_PWR_EN | SC1200_DCFG_FP_DATA_EN);
         /* Enable the flatpanel power and data */
         WRITE_VID32(SC1200_DISPLAY_CONFIG, dcfg);
-    } else if (hw_video == GFX_VID_REDCLOUD) {
+    }
+    else if (hw_video == GFX_VID_REDCLOUD) {
         /* READ DISPLAY CONFIG FROM REDCLOUD */
         dcfg = READ_VID32(RCDF_DISPLAY_CONFIG);
 
@@ -287,7 +289,8 @@ Pnl_PowerDown(void)
         dcfg &= ~(CS5530_DCFG_FP_PWR_EN | CS5530_DCFG_FP_DATA_EN);
         /* Disable the flatpanel power and data */
         WRITE_VID32(CS5530_DISPLAY_CONFIG, dcfg);
-    } else if (hw_video == GFX_VID_SC1200) {
+    }
+    else if (hw_video == GFX_VID_SC1200) {
         /* READ DISPLAY CONFIG FROM SC1200 */
         dcfg = READ_VID32(SC1200_DISPLAY_CONFIG);
 
@@ -295,7 +298,8 @@ Pnl_PowerDown(void)
         dcfg &= ~(SC1200_DCFG_FP_PWR_EN | SC1200_DCFG_FP_DATA_EN);
         /* Disable the flatpanel power and data */
         WRITE_VID32(SC1200_DISPLAY_CONFIG, dcfg);
-    } else if (hw_video == GFX_VID_REDCLOUD) {
+    }
+    else if (hw_video == GFX_VID_REDCLOUD) {
         /* READ DISPLAY CONFIG FROM REDCLOUD */
         dcfg = READ_VID32(RCDF_DISPLAY_CONFIG);
 
@@ -488,16 +492,17 @@ Pnl_InitPanel(Pnl_PanelParams * pParam)
 {
     Pnl_PanelParams *pPtr;
 
-    if (pParam == 0x0)                 /* NULL  use the static table */
+    if (pParam == 0x0)          /* NULL  use the static table */
         pPtr = &sPanelParam;
     else
         pPtr = pParam;
 
     if (!pPtr->PanelPresent) {
-        return -1;                     /* error */
-    } else {
+        return -1;              /* error */
+    }
+    else {
         if ((pPtr->PanelChip < 0) || (pPtr->Platform < 0))
-            return -1;                 /* error */
+            return -1;          /* error */
 
 #if PLATFORM_DRACO
         /* check we are init. the right one */
@@ -526,6 +531,6 @@ Pnl_InitPanel(Pnl_PanelParams * pParam)
             Redcloud_9211init(&(pPtr->PanelStat));
         }
 #endif
-    }                                  /* else  end */
+    }                           /* else  end */
     return 1;
 }
diff --git a/src/z4l.c b/src/z4l.c
index a21e492..6388e00 100644
--- a/src/z4l.c
+++ b/src/z4l.c
@@ -132,22 +132,19 @@ static XF86ImageRec pixfmts[] = {
 
 #define NUM_PIXFMTS (sizeof(pixfmts)/sizeof(pixfmts[0]))
 
-typedef struct s_std_data
-{
+typedef struct s_std_data {
     int inp;
     v4l2_std_id std;
     unsigned int fmt;
 } t_std_data;
 
-typedef struct s_ovly_bfrs
-{
+typedef struct s_ovly_bfrs {
     void *start;
     unsigned long offset;
     size_t length;
 } t_ovly_bfrs;
 
-typedef struct
-{
+typedef struct {
     int fd;
     int run;
     int dir;
@@ -181,7 +178,7 @@ IoCtl(int fd, unsigned int fn, void *arg, int flag)
     errno = 0;
     ret = ioctl(fd, fn, arg);
     if (ret != 0 && flag != 0)
-	DBLOG(0, "ioctl(%08x)=%d\n", fn, ret);
+        DBLOG(0, "ioctl(%08x)=%d\n", fn, ret);
     return ret;
 }
 
@@ -192,10 +189,10 @@ z4l_ovly_unmap(Z4lPortPrivRec * pPriv)
 
     nbfrs = pPriv->nbfrs;
     for (i = 0; i < nbfrs; ++i) {
-	if (pPriv->bfrs[i].start != NULL) {
-	    munmap(pPriv->bfrs[i].start, pPriv->bfrs[i].length);
-	    pPriv->bfrs[i].start = NULL;
-	}
+        if (pPriv->bfrs[i].start != NULL) {
+            munmap(pPriv->bfrs[i].start, pPriv->bfrs[i].length);
+            pPriv->bfrs[i].start = NULL;
+        }
     }
     pPriv->nbfrs = -1;
     pPriv->bufsz = -1;
@@ -210,10 +207,10 @@ z4l_ovly_map(Z4lPortPrivRec * pPriv, int dir)
     struct v4l2_buffer bfr;
     struct v4l2_requestbuffers req;
     int type = dir >= 0 ?
-	V4L2_BUF_TYPE_VIDEO_CAPTURE : V4L2_BUF_TYPE_VIDEO_OVERLAY;
+        V4L2_BUF_TYPE_VIDEO_CAPTURE : V4L2_BUF_TYPE_VIDEO_OVERLAY;
     if (pPriv->run > 0) {
-	DBLOG(1, "busy\n");
-	return;
+        DBLOG(1, "busy\n");
+        return;
     }
     fd = pPriv->fd;
     memset(&req, 0, sizeof(req));
@@ -221,51 +218,51 @@ z4l_ovly_map(Z4lPortPrivRec * pPriv, int dir)
     req.memory = V4L2_MEMORY_MMAP;
     req.count = MAX_BUFFERS;
     if (ioctl(fd, VIDIOC_REQBUFS, &req) < 0)
-	goto xit;
+        goto xit;
     pPriv->nbfrs = req.count;
     if (pPriv->nbfrs <= 0) {
-	DBLOG(1, "no vidmem\n");
-	return;
+        DBLOG(1, "no vidmem\n");
+        return;
     }
     memset(&pPriv->bfrs, 0, sizeof(pPriv->bfrs));
 
     for (i = 0; i < pPriv->nbfrs; ++i) {
-	memset(&bfr, 0, sizeof(bfr));
-	bfr.type = type;
-	bfr.index = i;
-	if (ioctl(fd, VIDIOC_QUERYBUF, &bfr) < 0)
-	    goto xit;
-	offset = bfr.m.offset;
-	pPriv->bfrs[i].offset = offset;
-	pPriv->bfrs[i].length = bfr.length;
-	bsz = offset + bfr.length;
-	if (pPriv->bufsz < bsz)
-	    pPriv->bufsz = bsz;
+        memset(&bfr, 0, sizeof(bfr));
+        bfr.type = type;
+        bfr.index = i;
+        if (ioctl(fd, VIDIOC_QUERYBUF, &bfr) < 0)
+            goto xit;
+        offset = bfr.m.offset;
+        pPriv->bfrs[i].offset = offset;
+        pPriv->bfrs[i].length = bfr.length;
+        bsz = offset + bfr.length;
+        if (pPriv->bufsz < bsz)
+            pPriv->bufsz = bsz;
     }
 
     for (i = 0; i < pPriv->nbfrs; ++i) {
-	pPriv->bfrs[i].start = mmap(NULL, bfr.length, PROT_READ | PROT_WRITE,
-	    MAP_SHARED, fd, pPriv->bfrs[i].offset);
-	if (pPriv->bfrs[i].start == MAP_FAILED)
-	    goto xit;
+        pPriv->bfrs[i].start = mmap(NULL, bfr.length, PROT_READ | PROT_WRITE,
+                                    MAP_SHARED, fd, pPriv->bfrs[i].offset);
+        if (pPriv->bfrs[i].start == MAP_FAILED)
+            goto xit;
     }
 
     for (i = 0; i < pPriv->nbfrs; ++i) {
-	DBLOG(3, "bfr %d ofs %#lx adr %p sz %lu\n", i, pPriv->bfrs[i].offset,
-	    pPriv->bfrs[i].start, (unsigned long)pPriv->bfrs[i].length);
-	memset(pPriv->bfrs[i].start, 0x80, pPriv->bfrs[i].length);
+        DBLOG(3, "bfr %d ofs %#lx adr %p sz %lu\n", i, pPriv->bfrs[i].offset,
+              pPriv->bfrs[i].start, (unsigned long) pPriv->bfrs[i].length);
+        memset(pPriv->bfrs[i].start, 0x80, pPriv->bfrs[i].length);
     }
 
     pPriv->last = 0;
     while (pPriv->last < pPriv->nbfrs - 1) {
-	bfr.index = pPriv->last++;
-	bfr.type = type;
-	if (ioctl(fd, VIDIOC_QBUF, &bfr) < 0)
-	    goto xit;
+        bfr.index = pPriv->last++;
+        bfr.type = type;
+        if (ioctl(fd, VIDIOC_QBUF, &bfr) < 0)
+            goto xit;
     }
     return;
 
-  xit:
+ xit:
     z4l_ovly_unmap(pPriv);
 }
 
@@ -285,7 +282,7 @@ z4l_ovly_dqbuf(Z4lPortPrivRec * pPriv)
     tmo.tv_sec = 0;
     tmo.tv_usec = 0;
     if (select(fd + 1, &dqset, NULL, NULL, &tmo) <= 0)
-	return -1;
+        return -1;
 #endif
     memset(&bfr, 0, sizeof(bfr));
     bfr.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
@@ -301,15 +298,15 @@ z4l_open_device(Z4lPortPrivRec * pPriv)
     int enable;
 
     if (pPriv->fd < 0) {
-	pPriv->fd = open(&pPriv->dev_path[0], O_RDWR, 0);
-	DBLOG(1, "open(%s)=%d\n", &pPriv->dev_path[0], pPriv->fd);
-	enable = 1;
+        pPriv->fd = open(&pPriv->dev_path[0], O_RDWR, 0);
+        DBLOG(1, "open(%s)=%d\n", &pPriv->dev_path[0], pPriv->fd);
+        enable = 1;
 #ifdef NONBLK_IO
-	if (IoCtl(pPriv->fd, FIONBIO, &enable, 1) != 0) {
-	    DBLOG(1, "open cant enable nonblocking\n");
-	    close(pPriv->fd);
-	    pPriv->fd = -1;
-	}
+        if (IoCtl(pPriv->fd, FIONBIO, &enable, 1) != 0) {
+            DBLOG(1, "open cant enable nonblocking\n");
+            close(pPriv->fd);
+            pPriv->fd = -1;
+        }
 #endif
     }
     return pPriv->fd;
@@ -321,13 +318,13 @@ z4l_close_device(Z4lPortPrivRec * pPriv)
     int ret = 0;
 
     if (pPriv->fd >= 0) {
-	ret = close(pPriv->fd);
-	pPriv->fd = -1;
-	DBLOG(1, "close()=%d\n", ret);
+        ret = close(pPriv->fd);
+        pPriv->fd = -1;
+        DBLOG(1, "close()=%d\n", ret);
     }
     if (pPriv->run > 0) {
-	z4l_ovly_unmap(pPriv);
-	pPriv->run = -1;
+        z4l_ovly_unmap(pPriv);
+        pPriv->run = -1;
     }
 
     return ret;
@@ -339,8 +336,8 @@ z4l_ovly_reset(Z4lPortPrivRec * pPriv)
     int ret = 0;
 
     if (pPriv->run > 0) {
-	z4l_close_device(pPriv);
-	ret = z4l_open_device(pPriv);
+        z4l_close_device(pPriv);
+        ret = z4l_open_device(pPriv);
     }
 
     return ret;
@@ -353,28 +350,29 @@ z4l_fourcc_pixfmt(int fourcc)
 
     switch (fourcc) {
     case FOURCC_UYVY:
-	pixfmt = V4L2_PIX_FMT_UYVY;
-	break;
+        pixfmt = V4L2_PIX_FMT_UYVY;
+        break;
     case FOURCC_YV12:
-	pixfmt = V4L2_PIX_FMT_YVU420;
-	break;
+        pixfmt = V4L2_PIX_FMT_YVU420;
+        break;
     case FOURCC_Y800:
     case FOURCC_I420:
-	pixfmt = V4L2_PIX_FMT_YUV420;
-	break;
+        pixfmt = V4L2_PIX_FMT_YUV420;
+        break;
     case FOURCC_YUY2:
-	pixfmt = V4L2_PIX_FMT_YUYV;
-	break;
+        pixfmt = V4L2_PIX_FMT_YUYV;
+        break;
     }
 
     return pixfmt;
 }
+
 static void
 z4l_ovly_pixfmt(Z4lPortPrivRec * pPriv, unsigned int pixfmt)
 {
     struct v4l2_framebuffer fbuf;
 
-    DBLOG(1, "pixfmt %4.4s %4.4s\n", (char *)&pPriv->pixfmt, (char *)&pixfmt);
+    DBLOG(1, "pixfmt %4.4s %4.4s\n", (char *) &pPriv->pixfmt, (char *) &pixfmt);
     memset(&fbuf, 0, sizeof(fbuf));
     IoCtl(pPriv->fd, VIDIOC_G_FBUF, &fbuf, 1);
     fbuf.fmt.pixelformat = pixfmt;
@@ -400,8 +398,8 @@ z4l_ovly_bfr(Z4lPortPrivRec * pPriv, int width, int height)
 
 static void
 z4l_ovly_rect(Z4lPortPrivRec * pPriv,
-    int src_x, int src_y, int src_w, int src_h,
-    int drw_x, int drw_y, int drw_w, int drw_h)
+              int src_x, int src_y, int src_w, int src_h,
+              int drw_x, int drw_y, int drw_w, int drw_h)
 {
     int x, dx, w, y, dy, h;
     struct v4l2_format fmt;
@@ -416,66 +414,66 @@ z4l_ovly_rect(Z4lPortPrivRec * pPriv,
     pPriv->drw_h = drw_h;
 
     if ((drw_x -= z4l_x_offset) < 0) {
-	if ((w = pPriv->drw_w) <= 0)
-	    w = 1;
-	x = -drw_x;
-	dx = x * pPriv->src_w / w;
-	src_x = pPriv->src_x + dx;
-	src_w = pPriv->src_w - dx;
-	drw_w = pPriv->drw_w - x;
-	drw_x = 0;
+        if ((w = pPriv->drw_w) <= 0)
+            w = 1;
+        x = -drw_x;
+        dx = x * pPriv->src_w / w;
+        src_x = pPriv->src_x + dx;
+        src_w = pPriv->src_w - dx;
+        drw_w = pPriv->drw_w - x;
+        drw_x = 0;
     }
 
     if ((drw_y -= z4l_y_offset) < 0) {
-	if ((h = pPriv->drw_h) <= 0)
-	    h = 1;
-	y = -drw_y;
-	dy = y * pPriv->src_h / h;
-	src_y = pPriv->src_y + dy;
-	src_h = pPriv->src_h - dy;
-	drw_h = pPriv->drw_h - y;
-	drw_y = 0;
+        if ((h = pPriv->drw_h) <= 0)
+            h = 1;
+        y = -drw_y;
+        dy = y * pPriv->src_h / h;
+        src_y = pPriv->src_y + dy;
+        src_h = pPriv->src_h - dy;
+        drw_h = pPriv->drw_h - y;
+        drw_y = 0;
     }
 
     memset(&fmt, 0, sizeof(fmt));
     fmt.type = 0x100;
     IoCtl(pPriv->fd, VIDIOC_G_FMT, &fmt, 1);
     if (pPriv->src_is_set != 0) {
-	if (src_x != fmt.fmt.win.w.left || src_y != fmt.fmt.win.w.top ||
-	    src_w != fmt.fmt.win.w.width || src_h != fmt.fmt.win.w.height)
-	    pPriv->src_is_set = 0;
+        if (src_x != fmt.fmt.win.w.left || src_y != fmt.fmt.win.w.top ||
+            src_w != fmt.fmt.win.w.width || src_h != fmt.fmt.win.w.height)
+            pPriv->src_is_set = 0;
     }
     if (pPriv->src_is_set == 0) {
-	pPriv->src_is_set = 1;
-	fmt.fmt.win.w.left = src_x;
-	fmt.fmt.win.w.top = src_y;
-	fmt.fmt.win.w.width = src_w;
-	fmt.fmt.win.w.height = src_h;
-	IoCtl(pPriv->fd, VIDIOC_S_FMT, &fmt, 1);
-	DBLOG(3, "  set src %d,%d %dx%d\n", src_x, src_y, src_w, src_h);
+        pPriv->src_is_set = 1;
+        fmt.fmt.win.w.left = src_x;
+        fmt.fmt.win.w.top = src_y;
+        fmt.fmt.win.w.width = src_w;
+        fmt.fmt.win.w.height = src_h;
+        IoCtl(pPriv->fd, VIDIOC_S_FMT, &fmt, 1);
+        DBLOG(3, "  set src %d,%d %dx%d\n", src_x, src_y, src_w, src_h);
     }
     memset(&fmt, 0, sizeof(fmt));
     fmt.type = 0x101;
     IoCtl(pPriv->fd, VIDIOC_G_FMT, &fmt, 1);
     if (pPriv->drw_is_set != 0) {
-	if (drw_x != fmt.fmt.win.w.left || drw_y != fmt.fmt.win.w.top ||
-	    drw_w != fmt.fmt.win.w.width || drw_h != fmt.fmt.win.w.height)
-	    pPriv->drw_is_set = 0;
+        if (drw_x != fmt.fmt.win.w.left || drw_y != fmt.fmt.win.w.top ||
+            drw_w != fmt.fmt.win.w.width || drw_h != fmt.fmt.win.w.height)
+            pPriv->drw_is_set = 0;
     }
     if (pPriv->drw_is_set == 0) {
-	pPriv->drw_is_set = 1;
-	fmt.fmt.win.w.left = drw_x;
-	fmt.fmt.win.w.top = drw_y;
-	fmt.fmt.win.w.width = drw_w;
-	fmt.fmt.win.w.height = drw_h;
-	IoCtl(pPriv->fd, VIDIOC_S_FMT, &fmt, 1);
-	DBLOG(3, "  set drw %d,%d %dx%d\n", drw_x, drw_y, drw_w, drw_h);
+        pPriv->drw_is_set = 1;
+        fmt.fmt.win.w.left = drw_x;
+        fmt.fmt.win.w.top = drw_y;
+        fmt.fmt.win.w.width = drw_w;
+        fmt.fmt.win.w.height = drw_h;
+        IoCtl(pPriv->fd, VIDIOC_S_FMT, &fmt, 1);
+        DBLOG(3, "  set drw %d,%d %dx%d\n", drw_x, drw_y, drw_w, drw_h);
     }
 }
 
 static void
 z4l_ovly_pitch(unsigned int pixfmt, int w, int h, int *py_pitch,
-    int *puv_pitch, int *poffset1, int *poffset2, int *psize)
+               int *puv_pitch, int *poffset1, int *poffset2, int *psize)
 {
     int y_pitch, uv_pitch;
     int offset1, offset2;
@@ -484,22 +482,22 @@ z4l_ovly_pitch(unsigned int pixfmt, int w, int h, int *py_pitch,
     switch (pixfmt) {
     case V4L2_PIX_FMT_YVU420:
     case V4L2_PIX_FMT_YUV420:
-	is_420 = 1;
-	y_pitch = ((w + 1) / 2) * 2;
-	uv_pitch = (w + 1) / 2;
-	break;
+        is_420 = 1;
+        y_pitch = ((w + 1) / 2) * 2;
+        uv_pitch = (w + 1) / 2;
+        break;
     default:
-	is_420 = 0;
-	y_pitch = ((w + 1) / 2) * 4;
-	uv_pitch = 0;
-	break;
+        is_420 = 0;
+        y_pitch = ((w + 1) / 2) * 4;
+        uv_pitch = 0;
+        break;
     }
 
     offset1 = y_pitch * h;
     offset2 = uv_pitch * h;
 
     if (is_420 != 0)
-	offset2 /= 2;
+        offset2 /= 2;
 
     size = offset1 + 2 * offset2;
     *py_pitch = y_pitch;
@@ -517,10 +515,10 @@ z4l_ovly_set_colorkey(Z4lPortPrivRec * pPriv, int key)
     memset(&fmt, 0, sizeof(fmt));
     fmt.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
     if (IoCtl(pPriv->fd, VIDIOC_G_FMT, &fmt, 1) < 0)
-	return 0;
+        return 0;
     fmt.fmt.win.chromakey = key;
     if (IoCtl(pPriv->fd, VIDIOC_S_FMT, &fmt, 1) < 0)
-	return 0;
+        return 0;
     pPriv->colorkey = key;
 
     return 1;
@@ -534,7 +532,7 @@ z4l_ovly_get_colorkey(Z4lPortPrivRec * pPriv, int *key)
     memset(&fmt, 0, sizeof(fmt));
     fmt.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
     if (IoCtl(pPriv->fd, VIDIOC_G_FMT, &fmt, 1) < 0)
-	return 0;
+        return 0;
     *key = fmt.fmt.win.chromakey;
 
     return 1;
@@ -547,16 +545,16 @@ z4l_ovly_set_keymode(Z4lPortPrivRec * pPriv, int enable)
 
     memset(&fbuf, 0, sizeof(fbuf));
     if (IoCtl(pPriv->fd, VIDIOC_G_FBUF, &fbuf, 1) < 0)
-	return 0;
+        return 0;
 
     if (enable != 0)
-	fbuf.flags |= V4L2_FBUF_FLAG_CHROMAKEY;
+        fbuf.flags |= V4L2_FBUF_FLAG_CHROMAKEY;
     else
-	fbuf.flags &= ~V4L2_FBUF_FLAG_CHROMAKEY;
+        fbuf.flags &= ~V4L2_FBUF_FLAG_CHROMAKEY;
 
     fbuf.base = NULL;
     if (IoCtl(pPriv->fd, VIDIOC_S_FBUF, &fbuf, 1) < 0)
-	return 0;
+        return 0;
     pPriv->keymode = enable;
 
     return 1;
@@ -569,7 +567,7 @@ z4l_ovly_get_keymode(Z4lPortPrivRec * pPriv, int *enable)
 
     memset(&fbuf, 0, sizeof(fbuf));
     if (IoCtl(pPriv->fd, VIDIOC_G_FBUF, &fbuf, 1) < 0)
-	return 0;
+        return 0;
     *enable = (fbuf.flags & V4L2_FBUF_FLAG_CHROMAKEY) != 0 ? 1 : 0;
 
     return 1;
@@ -590,7 +588,7 @@ z4l_ovly_set_encoding(Z4lPortPrivRec * pPriv, int id)
     adpt = pPriv->adpt;
     DBLOG(1, "z4l_ovly_set_encoding(%d)\n", id);
     if (id < 0 || id >= adpt->nEncodings)
-	return 0;
+        return 0;
     enc = &adpt->pEncodings[id];
     cp = &enc->name[0];
     n = sizeof(int) - 1;
@@ -600,32 +598,32 @@ z4l_ovly_set_encoding(Z4lPortPrivRec * pPriv, int id)
     inp = sp->inp;
 
     DBLOG(1, " nm %s fmt %4.4s inp %d std %llx\n",
-	cp, (char *)&sp->fmt, sp->inp, sp->std);
+          cp, (char *) &sp->fmt, sp->inp, sp->std);
 
     if (IoCtl(pPriv->fd, VIDIOC_S_INPUT, &inp, 1) < 0)
-	return 0;
+        return 0;
 
     std = sp->std;
     if (IoCtl(pPriv->fd, VIDIOC_S_STD, &std, 1) < 0)
-	return 0;
+        return 0;
 
     memset(&fmt, 0, sizeof(fmt));
     fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
     if (IoCtl(pPriv->fd, VIDIOC_G_FMT, &fmt, 1) < 0)
-	return 0;
+        return 0;
 
     fmt.fmt.pix.pixelformat = sp->fmt;
     if (IoCtl(pPriv->fd, VIDIOC_S_FMT, &fmt, 1) < 0)
-	return 0;
+        return 0;
     memset(&fbuf, 0, sizeof(fbuf));
 
     if (IoCtl(pPriv->fd, VIDIOC_G_FBUF, &fbuf, 1) < 0)
-	return 0;
+        return 0;
 
     fbuf.fmt.pixelformat = sp->fmt;
     fbuf.base = NULL;
     if (IoCtl(pPriv->fd, VIDIOC_S_FBUF, &fbuf, 1) < 0)
-	return 0;
+        return 0;
     pPriv->pixfmt = sp->fmt;
     pPriv->enc = enc;
     pPriv->src_is_set = pPriv->drw_is_set = 0;
@@ -648,21 +646,21 @@ z4l_ovly_stop(Z4lPortPrivRec * pPriv)
     int type, enable, fd;
 
     if (pPriv->run < 0)
-	return;
+        return;
 
     fd = pPriv->fd;
     if (pPriv->dir > 0) {
-	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	ioctl(fd, VIDIOC_STREAMOFF, &type);
+        type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        ioctl(fd, VIDIOC_STREAMOFF, &type);
     }
 
     if (pPriv->dir <= 0) {
-	enable = 0;
-	ioctl(fd, VIDIOC_OVERLAY, &enable);
+        enable = 0;
+        ioctl(fd, VIDIOC_OVERLAY, &enable);
     }
 
     if (pPriv->dir != 0)
-	z4l_ovly_unmap(pPriv);
+        z4l_ovly_unmap(pPriv);
 
     pPriv->run = -1;
     z4l_close_device(pPriv);
@@ -674,16 +672,16 @@ z4l_ovly_start(Z4lPortPrivRec * pPriv, int dir)
     int enable;
 
     if (pPriv->run >= 0)
-	return;
+        return;
 
     if ((pPriv->dir = dir) != 0)
-	z4l_ovly_map(pPriv, dir);
+        z4l_ovly_map(pPriv, dir);
 
     enable = 1;
 
     if (IoCtl(pPriv->fd, VIDIOC_OVERLAY, &enable, 1) != 0) {
-	z4l_ovly_stop(pPriv);
-	return;
+        z4l_ovly_stop(pPriv);
+        return;
     }
 
     pPriv->run = 1;
@@ -696,39 +694,37 @@ z4l_region_equal(RegionPtr ap, RegionPtr bp)
     BoxPtr abox, bbox;
 
     if (ap == NULL && bp == NULL)
-	return 1;
+        return 1;
     if (ap == NULL || bp == NULL)
-	return 0;
+        return 0;
 
     if ((nboxes = REGION_NUM_RECTS(ap)) != REGION_NUM_RECTS(bp) ||
-	ap->extents.x1 != bp->extents.x1 ||
-	ap->extents.x2 != bp->extents.x2
-	|| ap->extents.y1 != bp->extents.y1
-	|| ap->extents.y2 != bp->extents.y2)
-	return 0;
+        ap->extents.x1 != bp->extents.x1 ||
+        ap->extents.x2 != bp->extents.x2
+        || ap->extents.y1 != bp->extents.y1 || ap->extents.y2 != bp->extents.y2)
+        return 0;
 
     abox = REGION_RECTS(ap);
     bbox = REGION_RECTS(bp);
 
     while (--nboxes >= 0) {
-	if (abox->x1 != bbox->x1 || abox->y1 != bbox->y1 ||
-	    abox->x2 != bbox->x2 || abox->y2 != bbox->y2)
-	    return 0;
-	++abox;
-	++bbox;
+        if (abox->x1 != bbox->x1 || abox->y1 != bbox->y1 ||
+            abox->x2 != bbox->x2 || abox->y2 != bbox->y2)
+            return 0;
+        ++abox;
+        ++bbox;
     }
 
     return 1;
 }
 
 static void
-z4l_setup_colorkey(Z4lPortPrivRec * pPriv, ScreenPtr pScrn,
-    RegionPtr clipBoxes)
+z4l_setup_colorkey(Z4lPortPrivRec * pPriv, ScreenPtr pScrn, RegionPtr clipBoxes)
 {
     if (pPriv->run > 0 && pPriv->dir <= 0 && pPriv->keymode != 0 &&
-	z4l_region_equal(&pPriv->clips, clipBoxes) == 0) {
-	xf86XVFillKeyHelper(pScrn, pPriv->colorkey, clipBoxes);
-	REGION_COPY(pScrn, &pPriv->clips, clipBoxes);
+        z4l_region_equal(&pPriv->clips, clipBoxes) == 0) {
+        xf86XVFillKeyHelper(pScrn, pPriv->colorkey, clipBoxes);
+        REGION_COPY(pScrn, &pPriv->clips, clipBoxes);
     }
 }
 
@@ -740,34 +736,34 @@ Z4lStopVideo(ScrnInfoPtr pScrni, pointer data, Bool exit)
     DBLOG(1, "Z4lStopVideo()\n");
 
     if (exit != 0)
-	z4l_ovly_stop(pPriv);
+        z4l_ovly_stop(pPriv);
     else
-	pPriv->src_is_set = pPriv->drw_is_set = 0;
+        pPriv->src_is_set = pPriv->drw_is_set = 0;
 
     REGION_EMPTY(pScrni->pScreen, &pPriv->clips);
 }
 
 static void
 Z4lQueryBestSize(ScrnInfoPtr pScrni, Bool motion,
-    short vid_w, short vid_h, short drw_w, short drw_h,
-    unsigned int *p_w, unsigned int *p_h, pointer data)
+                 short vid_w, short vid_h, short drw_w, short drw_h,
+                 unsigned int *p_w, unsigned int *p_h, pointer data)
 {
     if (drw_w > MAX_OVLY_WIDTH)
-	drw_w = MAX_OVLY_WIDTH;
+        drw_w = MAX_OVLY_WIDTH;
     if (drw_h > MAX_OVLY_HEIGHT)
-	drw_h = MAX_OVLY_HEIGHT;
+        drw_h = MAX_OVLY_HEIGHT;
 
     *p_w = drw_w;
     *p_h = drw_h;
     DBLOG(1, "Z4lQueryBestSize(%d, src %dx%d dst %dx%d)\n", motion, vid_w,
-	vid_h, drw_w, drw_h);
+          vid_h, drw_w, drw_h);
 }
 
 static int
 Z4lPutImage(ScrnInfoPtr pScrni, short src_x, short src_y, short drw_x,
-    short drw_y, short src_w, short src_h, short drw_w, short drw_h,
-    int id, unsigned char *buf, short width, short height,
-    Bool sync, RegionPtr clipBoxes, pointer data, DrawablePtr pDraw)
+            short drw_y, short src_w, short src_h, short drw_w, short drw_h,
+            int id, unsigned char *buf, short width, short height,
+            Bool sync, RegionPtr clipBoxes, pointer data, DrawablePtr pDraw)
 {
     int fd, size;
     int y_pitch, uv_pitch, offset1, offset2;
@@ -777,63 +773,64 @@ Z4lPutImage(ScrnInfoPtr pScrni, short src_x, short src_y, short drw_x,
     Z4lPortPrivRec *pPriv = (Z4lPortPrivRec *) data;
 
     if (pPriv->run > 0 && pPriv->dir >= 0)
-	return BadMatch;
+        return BadMatch;
     if (pPriv->fd < 0) {
-	z4l_open_device(pPriv);
-	if (pPriv->fd < 0)
-	    return BadValue;
+        z4l_open_device(pPriv);
+        if (pPriv->fd < 0)
+            return BadValue;
     }
 
     fd = pPriv->fd;
     if (pPriv->run < 0) {
-	DBLOG(2, "PutImg id %#x src %d,%d %dx%d drw %d,%d %dx%d bfr %p "
-	    "%dx%d data %p\n", id, src_x, src_y, src_w, src_h, drw_x,
-	    drw_y, drw_w, drw_h, buf, width, height, data);
-	pPriv->pixfmt = pPriv->height = -1;
-	pPriv->src_is_set = pPriv->drw_is_set = 0;
+        DBLOG(2, "PutImg id %#x src %d,%d %dx%d drw %d,%d %dx%d bfr %p "
+              "%dx%d data %p\n", id, src_x, src_y, src_w, src_h, drw_x,
+              drw_y, drw_w, drw_h, buf, width, height, data);
+        pPriv->pixfmt = pPriv->height = -1;
+        pPriv->src_is_set = pPriv->drw_is_set = 0;
     }
 
     pixfmt = z4l_fourcc_pixfmt(id);
     if (pixfmt != pPriv->pixfmt) {
-	z4l_ovly_reset(pPriv);
-	z4l_ovly_pixfmt(pPriv, pixfmt);
+        z4l_ovly_reset(pPriv);
+        z4l_ovly_pixfmt(pPriv, pixfmt);
     }
     if (pPriv->width != width || pPriv->height != height) {
-	z4l_ovly_reset(pPriv);
-	z4l_ovly_bfr(pPriv, width, height);
+        z4l_ovly_reset(pPriv);
+        z4l_ovly_bfr(pPriv, width, height);
     }
 
     if (pPriv->src_is_set == 0 || pPriv->drw_is_set == 0 ||
-	pPriv->src_x != src_x || pPriv->src_y != src_y ||
-	pPriv->src_w != src_w || pPriv->src_h != src_h ||
-	pPriv->drw_x != drw_x || pPriv->drw_y != drw_y ||
-	pPriv->drw_w != drw_w || pPriv->drw_h != drw_h)
-	z4l_ovly_rect(pPriv, src_x, src_y, src_w, src_h, drw_x, drw_y, drw_w,
-	    drw_h);
+        pPriv->src_x != src_x || pPriv->src_y != src_y ||
+        pPriv->src_w != src_w || pPriv->src_h != src_h ||
+        pPriv->drw_x != drw_x || pPriv->drw_y != drw_y ||
+        pPriv->drw_w != drw_w || pPriv->drw_h != drw_h)
+        z4l_ovly_rect(pPriv, src_x, src_y, src_w, src_h, drw_x, drw_y, drw_w,
+                      drw_h);
 
     if (pPriv->run < 0) {
-	z4l_ovly_start(pPriv, -1);
-	if (pPriv->run < 0)
-	    return BadValue;
+        z4l_ovly_start(pPriv, -1);
+        if (pPriv->run < 0)
+            return BadValue;
     }
 
     if (pPriv->last < 0 && (pPriv->last = z4l_ovly_dqbuf(pPriv)) < 0)
-	return BadAlloc;
+        return BadAlloc;
 
     z4l_ovly_pitch(pixfmt, width, height, &y_pitch, &uv_pitch,
-	&offset1, &offset2, &size);
+                   &offset1, &offset2, &size);
     src = buf;
-    dst = (unsigned char *)pPriv->bfrs[pPriv->last].start;
+    dst = (unsigned char *) pPriv->bfrs[pPriv->last].start;
     DBLOG(3, "cpy %4.4s src %p dst %p yp %d uvp %d o1 %d o2 %d sz %d\n",
-	(char *)&id, src, dst, y_pitch, uv_pitch, offset1, offset2, size);
+          (char *) &id, src, dst, y_pitch, uv_pitch, offset1, offset2, size);
 
     if (id == FOURCC_Y800) {
-	memcpy(dst, src, offset1);
-	src += offset1;
-	dst += offset1;
-	memset(dst, 0x80, 2 * offset2);
-    } else
-	memcpy(dst, src, size);
+        memcpy(dst, src, offset1);
+        src += offset1;
+        dst += offset1;
+        memset(dst, 0x80, 2 * offset2);
+    }
+    else
+        memcpy(dst, src, size);
 
     memset(&bfr, 0, sizeof(bfr));
     bfr.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
@@ -842,7 +839,7 @@ Z4lPutImage(ScrnInfoPtr pScrni, short src_x, short src_y, short drw_x,
     bfr.timestamp.tv_usec = 0;
     bfr.flags |= V4L2_BUF_FLAG_TIMECODE;
     if (IoCtl(fd, VIDIOC_QBUF, &bfr, 1) != 0)
-	return BadAccess;
+        return BadAccess;
 
     pPriv->last = z4l_ovly_dqbuf(pPriv);
     z4l_setup_colorkey(pPriv, pScrni->pScreen, clipBoxes);
@@ -852,7 +849,7 @@ Z4lPutImage(ScrnInfoPtr pScrni, short src_x, short src_y, short drw_x,
 
 static int
 Z4lQueryImageAttributes(ScrnInfoPtr pScrni, int id, unsigned short *width,
-    unsigned short *height, int *pitches, int *offsets)
+                        unsigned short *height, int *pitches, int *offsets)
 {
     int w, h, size;
     int y_pitch, uv_pitch, offset1, offset2;
@@ -861,70 +858,70 @@ Z4lQueryImageAttributes(ScrnInfoPtr pScrni, int id, unsigned short *width,
     w = *width;
     h = *height;
     if (w > MAX_OVLY_WIDTH)
-	w = MAX_OVLY_WIDTH;
+        w = MAX_OVLY_WIDTH;
     if (h > MAX_OVLY_HEIGHT)
-	h = MAX_OVLY_HEIGHT;
+        h = MAX_OVLY_HEIGHT;
 
     z4l_ovly_pitch(pixfmt, w, h, &y_pitch, &uv_pitch,
-	&offset1, &offset2, &size);
+                   &offset1, &offset2, &size);
 
     if (offsets != NULL)
-	offsets[0] = 0;
+        offsets[0] = 0;
     if (pitches != NULL)
-	pitches[0] = y_pitch;
+        pitches[0] = y_pitch;
 
     switch (pixfmt) {
     case V4L2_PIX_FMT_YVU420:
     case V4L2_PIX_FMT_YUV420:
-	if (offsets != NULL) {
-	    offsets[1] = offset1;
-	    offsets[2] = offset1 + offset2;
-	}
-	if (pitches != NULL)
-	    pitches[1] = pitches[2] = uv_pitch;
-	h = (h + 1) & ~1;
-	break;
+        if (offsets != NULL) {
+            offsets[1] = offset1;
+            offsets[2] = offset1 + offset2;
+        }
+        if (pitches != NULL)
+            pitches[1] = pitches[2] = uv_pitch;
+        h = (h + 1) & ~1;
+        break;
     }
 
     w = (w + 1) & ~1;
     *width = w;
     *height = h;
     DBLOG(1, "Z4lQueryImageAttributes(%4.4s) = %d, %dx%d %d/%d %d/%d\n",
-	(char *)&id, size, w, h, y_pitch, uv_pitch, offset1, offset2);
+          (char *) &id, size, w, h, y_pitch, uv_pitch, offset1, offset2);
 
     return size;
 }
 
 static int
 Z4lPutVideo(ScrnInfoPtr pScrni, short src_x, short src_y, short drw_x,
-    short drw_y, short src_w, short src_h, short drw_w, short drw_h,
-    RegionPtr clipBoxes, pointer data, DrawablePtr pDraw)
+            short drw_y, short src_w, short src_h, short drw_w, short drw_h,
+            RegionPtr clipBoxes, pointer data, DrawablePtr pDraw)
 {
     int id;
     Z4lPortPrivRec *pPriv = (Z4lPortPrivRec *) data;
 
     DBLOG(2, "PutVid src %d,%d %dx%d drw %d,%d %dx%d data %p\n",
-	src_x, src_y, src_w, src_h, drw_x, drw_y, drw_w, drw_h, data);
+          src_x, src_y, src_w, src_h, drw_x, drw_y, drw_w, drw_h, data);
 
     if (z4l_open_device(pPriv) >= 0) {
-	if (pPriv->run < 0) {
-	    DBLOG(2, "PutVid start\n");
-	    z4l_ovly_get_encoding(pPriv, &id);
-	    z4l_ovly_set_encoding(pPriv, id);
-	}
-	DBLOG(2, "PutVid priv %d,%d %dx%d drw %d,%d %dx%d\n",
-	    pPriv->src_x, pPriv->src_y, pPriv->src_w, pPriv->src_h,
-	    pPriv->drw_x, pPriv->drw_y, pPriv->drw_w, pPriv->drw_h);
-	if (pPriv->src_is_set == 0 || pPriv->drw_is_set == 0 ||
-	    pPriv->src_w != src_w || pPriv->src_h != src_h ||
-	    pPriv->drw_x != drw_x || pPriv->drw_y != drw_y ||
-	    pPriv->drw_w != drw_w || pPriv->drw_h != drw_h)
-	    z4l_ovly_rect(pPriv, src_x, src_y, src_w, src_h, drw_x, drw_y,
-		drw_w, drw_h);
-	if (pPriv->run < 0)
-	    z4l_ovly_start(pPriv, 0);
-
-	z4l_setup_colorkey(pPriv, pScrni->pScreen, clipBoxes);
+        if (pPriv->run < 0) {
+            DBLOG(2, "PutVid start\n");
+            z4l_ovly_get_encoding(pPriv, &id);
+            z4l_ovly_set_encoding(pPriv, id);
+        }
+        DBLOG(2, "PutVid priv %d,%d %dx%d drw %d,%d %dx%d\n",
+              pPriv->src_x, pPriv->src_y, pPriv->src_w, pPriv->src_h,
+              pPriv->drw_x, pPriv->drw_y, pPriv->drw_w, pPriv->drw_h);
+        if (pPriv->src_is_set == 0 || pPriv->drw_is_set == 0 ||
+            pPriv->src_w != src_w || pPriv->src_h != src_h ||
+            pPriv->drw_x != drw_x || pPriv->drw_y != drw_y ||
+            pPriv->drw_w != drw_w || pPriv->drw_h != drw_h)
+            z4l_ovly_rect(pPriv, src_x, src_y, src_w, src_h, drw_x, drw_y,
+                          drw_w, drw_h);
+        if (pPriv->run < 0)
+            z4l_ovly_start(pPriv, 0);
+
+        z4l_setup_colorkey(pPriv, pScrni->pScreen, clipBoxes);
     }
 
     return Success;
@@ -935,10 +932,10 @@ Z4lNewEncoding(XF86VideoEncodingPtr * encs, int *nencs)
 {
     XF86VideoEncodingPtr enc;
     XF86VideoEncodingPtr tencs =
-	(XF86VideoEncodingPtr) realloc(*encs, sizeof(*tencs) * (*nencs + 1));
+        (XF86VideoEncodingPtr) realloc(*encs, sizeof(*tencs) * (*nencs + 1));
 
     if (tencs == NULL)
-	return NULL;
+        return NULL;
 
     *encs = tencs;
     enc = &tencs[*nencs];
@@ -954,60 +951,61 @@ Z4lEncodingName(char *ename, int l, char *inp_name, char *std_name, char *fmt)
     int i, ch;
 
     while ((ch = *inp_name++) != 0) {
-	if (isalnum(ch) == 0)
-	    continue;
-	if (--l <= 0)
-	    goto xit;
-	*ename++ = ch;
+        if (isalnum(ch) == 0)
+            continue;
+        if (--l <= 0)
+            goto xit;
+        *ename++ = ch;
     }
 
     if (--l <= 0)
-	goto xit;
+        goto xit;
 
     *ename++ = '-';
 
     while ((ch = *std_name++) != 0) {
-	if (isalnum(ch) == 0)
-	    continue;
-	if (--l <= 0)
-	    goto xit;
-	*ename++ = ch;
+        if (isalnum(ch) == 0)
+            continue;
+        if (--l <= 0)
+            goto xit;
+        *ename++ = ch;
     }
 
     if (--l <= 0)
-	goto xit;
+        goto xit;
 
     *ename++ = '-';
     i = 4;
 
     while (--i >= 0 && (ch = *fmt++) != 0) {
-	if (isalnum(ch) == 0)
-	    continue;
-	if (--l <= 0)
-	    goto xit;
-	*ename++ = ch;
+        if (isalnum(ch) == 0)
+            continue;
+        if (--l <= 0)
+            goto xit;
+        *ename++ = ch;
     }
 
-  xit:
+ xit:
     *ename = 0;
 }
 
 static int
 Z4lAddEncoding(XF86VideoEncodingPtr enc, char *name, int id, int width,
-    int height, int numer, int denom, int inp, v4l2_std_id std,
-    unsigned int fmt)
+               int height, int numer, int denom, int inp, v4l2_std_id std,
+               unsigned int fmt)
 {
     int l, n;
     t_std_data *sp;
     char *cp;
+
     n = sizeof(int) - 1;
     l = strlen(&name[0]) + 1;
     l = (l + n) & ~n;
     n = l + sizeof(*sp);
-    cp = (char *)malloc(n);
+    cp = (char *) malloc(n);
 
     if (cp == NULL)
-	return 0;
+        return 0;
 
     sp = (t_std_data *) (cp + l);
     enc->id = id;
@@ -1030,10 +1028,10 @@ Z4lNewImage(XF86ImagePtr * imgs, int *nimgs)
 {
     XF86ImagePtr img;
     XF86ImagePtr timgs =
-	(XF86ImagePtr) realloc(*imgs, sizeof(*timgs) * (*nimgs + 1));
+        (XF86ImagePtr) realloc(*imgs, sizeof(*timgs) * (*nimgs + 1));
 
     if (timgs == NULL)
-	return NULL;
+        return NULL;
 
     *imgs = timgs;
     img = &timgs[*nimgs];
@@ -1047,7 +1045,7 @@ static int
 Z4lAddImage(XF86ImagePtr img, XF86ImagePtr ip)
 {
     *img = *ip;
-    DBLOG(1, "img %4.4s\n", (char *)&img->id);
+    DBLOG(1, "img %4.4s\n", (char *) &img->id);
     return 1;
 }
 
@@ -1056,10 +1054,10 @@ Z4lNewAttribute(XF86AttributePtr * attrs, int *nattrs)
 {
     XF86AttributePtr attr;
     XF86AttributePtr tattrs =
-	(XF86AttributePtr) realloc(*attrs, sizeof(*tattrs) * (*nattrs + 1));
+        (XF86AttributePtr) realloc(*attrs, sizeof(*tattrs) * (*nattrs + 1));
 
     if (tattrs == NULL)
-	return NULL;
+        return NULL;
 
     *attrs = tattrs;
     attr = &tattrs[*nattrs];
@@ -1076,22 +1074,22 @@ Z4lAttributeName(char *bp, int l, char *cp)
     char *atomNm = bp;
 
     if (l > 0) {
-	*bp++ = 'X';
-	--l;
+        *bp++ = 'X';
+        --l;
     }
     if (l > 0) {
-	*bp++ = 'V';
-	--l;
+        *bp++ = 'V';
+        --l;
     }
     if (l > 0) {
-	*bp++ = '_';
-	--l;
+        *bp++ = '_';
+        --l;
     }
 
     while (l > 0 && (ch = *cp++) != 0) {
-	if (isalnum(ch) == 0)
-	    continue;
-	*bp++ = toupper(ch);
+        if (isalnum(ch) == 0)
+            continue;
+        *bp++ = toupper(ch);
     }
 
     *bp = 0;
@@ -1099,13 +1097,12 @@ Z4lAttributeName(char *bp, int l, char *cp)
 }
 
 static int
-Z4lAddAttribute(XF86AttributePtr attr, char *name,
-    int min, int max, int flags)
+Z4lAddAttribute(XF86AttributePtr attr, char *name, int min, int max, int flags)
 {
-    char *cp = (char *)malloc(strlen((char *)&name[0]) + 1);
+    char *cp = (char *) malloc(strlen((char *) &name[0]) + 1);
 
     if (cp == NULL)
-	return 0;
+        return 0;
 
     attr->name = cp;
     strcpy(&attr->name[0], name);
@@ -1125,10 +1122,10 @@ Z4lNewAdaptor(XF86VideoAdaptorPtr ** adpts, int *nadpts, int nattrs)
     XF86VideoAdaptorPtr adpt, *tadpts;
 
     tadpts = (XF86VideoAdaptorPtr *) realloc(*adpts,
-	sizeof(*tadpts) * (*nadpts + 1));
+                                             sizeof(*tadpts) * (*nadpts + 1));
 
     if (tadpts == NULL)
-	return NULL;
+        return NULL;
 
     *adpts = tadpts;
     n = sizeof(*adpt) + sizeof(*pPriv) + 1 * sizeof(*adpt->pPortPrivates);
@@ -1136,12 +1133,12 @@ Z4lNewAdaptor(XF86VideoAdaptorPtr ** adpts, int *nadpts, int nattrs)
     adpt = (XF86VideoAdaptorPtr) malloc(n);
 
     if (adpt == NULL)
-	return NULL;
+        return NULL;
 
     memset(adpt, 0, n);
     tadpts[*nadpts] = adpt;
     ++*nadpts;
-    adpt->pPortPrivates = (DevUnion *) & adpt[1];
+    adpt->pPortPrivates = (DevUnion *) &adpt[1];
     pPriv = (Z4lPortPrivRec *) & adpt->pPortPrivates[1];
     adpt->pPortPrivates[0].ptr = (pointer) pPriv;
     pPriv->adpt = adpt;
@@ -1152,7 +1149,7 @@ Z4lNewAdaptor(XF86VideoAdaptorPtr ** adpts, int *nadpts, int nattrs)
 
 static int
 Z4lSetPortAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 value,
-    pointer data)
+                    pointer data)
 {
     Z4lPortPrivRec *pPriv = (Z4lPortPrivRec *) data;
     XF86VideoAdaptorPtr adpt;
@@ -1162,58 +1159,58 @@ Z4lSetPortAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 value,
     const char *name = NameForAtom(attribute);
     int old_fd = pPriv->fd;
 
-    DBLOG(1, "Z4lSetPortAttribute(%#lx,%d) '%s'\n", (unsigned long)attribute,
-	(int)value, name != NULL ? name : "_null_");
+    DBLOG(1, "Z4lSetPortAttribute(%#lx,%d) '%s'\n", (unsigned long) attribute,
+          (int) value, name != NULL ? name : "_null_");
 
     if (name == NULL)
-	return BadImplementation;
+        return BadImplementation;
     if (old_fd < 0 && z4l_open_device(pPriv) < 0)
-	return BadAccess;
+        return BadAccess;
 
     adpt = pPriv->adpt;
     attr = adpt->pAttributes;
     nattrs = adpt->nAttributes;
 
     for (i = 0; i < nattrs; ++i, ++attr)
-	if (strcmp(attr->name, name) == 0)
-	    break;
+        if (strcmp(attr->name, name) == 0)
+            break;
 
     if (i >= nattrs)
-	return BadMatch;
+        return BadMatch;
 
     attrId = pPriv->attrIds[i];
     val = value;
 
     switch (attrId) {
     case ATTR_ENCODING_ID:
-	z4l_ovly_set_encoding(pPriv, val);
-	break;
+        z4l_ovly_set_encoding(pPriv, val);
+        break;
     case ATTR_KEYMODE_ID:
-	z4l_ovly_set_keymode(pPriv, val);
-	REGION_EMPTY(pScrni->pScreen, &pPriv->clips);
-	z4l_setup_colorkey(pPriv, pScrni->pScreen, &pPriv->clips);
-	break;
+        z4l_ovly_set_keymode(pPriv, val);
+        REGION_EMPTY(pScrni->pScreen, &pPriv->clips);
+        z4l_setup_colorkey(pPriv, pScrni->pScreen, &pPriv->clips);
+        break;
     case ATTR_COLORKEY_ID:
-	z4l_ovly_set_colorkey(pPriv, val);
-	break;
+        z4l_ovly_set_colorkey(pPriv, val);
+        break;
     default:
-	memset(&ctrl, 0, sizeof(ctrl));
-	ctrl.id = attrId + V4L2_CID_BASE;
-	ctrl.value = val;
-	if (IoCtl(pPriv->fd, VIDIOC_S_CTRL, &ctrl, 1) != 0)
-	    return BadMatch;
-	break;
+        memset(&ctrl, 0, sizeof(ctrl));
+        ctrl.id = attrId + V4L2_CID_BASE;
+        ctrl.value = val;
+        if (IoCtl(pPriv->fd, VIDIOC_S_CTRL, &ctrl, 1) != 0)
+            return BadMatch;
+        break;
     }
 
     if (old_fd < 0)
-	z4l_close_device(pPriv);
+        z4l_close_device(pPriv);
 
     return Success;
 }
 
 static int
-Z4lGetPortAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 * value,
-    pointer data)
+Z4lGetPortAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 *value,
+                    pointer data)
 {
     Z4lPortPrivRec *pPriv = (Z4lPortPrivRec *) data;
     XF86VideoAdaptorPtr adpt;
@@ -1224,50 +1221,50 @@ Z4lGetPortAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 * value,
     int old_fd = pPriv->fd;
 
     DBLOG(1, "Z4lGetPortAttribute(%#lx) '%s'\n",
-	(unsigned long)attribute, name != NULL ? name : "_null_");
+          (unsigned long) attribute, name != NULL ? name : "_null_");
 
     if (name == NULL)
-	return BadImplementation;
+        return BadImplementation;
     if (old_fd < 0 && z4l_open_device(pPriv) < 0)
-	return BadAccess;
+        return BadAccess;
 
     adpt = pPriv->adpt;
     attr = adpt->pAttributes;
     nattrs = adpt->nAttributes;
 
     for (i = 0; i < nattrs; ++i, ++attr)
-	if (strcmp(attr->name, name) == 0)
-	    break;
+        if (strcmp(attr->name, name) == 0)
+            break;
 
     if (i >= nattrs)
-	return BadMatch;
+        return BadMatch;
 
     attrId = pPriv->attrIds[i];
     val = 0;
 
     switch (attrId) {
     case ATTR_ENCODING_ID:
-	z4l_ovly_get_encoding(pPriv, &val);
-	*value = val;
-	break;
+        z4l_ovly_get_encoding(pPriv, &val);
+        *value = val;
+        break;
     case ATTR_KEYMODE_ID:
-	z4l_ovly_get_keymode(pPriv, &val);
-	*value = val;
-	break;
+        z4l_ovly_get_keymode(pPriv, &val);
+        *value = val;
+        break;
     case ATTR_COLORKEY_ID:
-	z4l_ovly_get_colorkey(pPriv, &val);
-	break;
+        z4l_ovly_get_colorkey(pPriv, &val);
+        break;
     default:
-	memset(&ctrl, 0, sizeof(ctrl));
-	ctrl.id = attrId + V4L2_CID_BASE;
-	if (IoCtl(pPriv->fd, VIDIOC_G_CTRL, &ctrl, 1) != 0)
-	    return BadMatch;
-	val = ctrl.value;
-	break;
+        memset(&ctrl, 0, sizeof(ctrl));
+        ctrl.id = attrId + V4L2_CID_BASE;
+        if (IoCtl(pPriv->fd, VIDIOC_G_CTRL, &ctrl, 1) != 0)
+            return BadMatch;
+        val = ctrl.value;
+        break;
     }
 
     if (old_fd < 0)
-	z4l_close_device(pPriv);
+        z4l_close_device(pPriv);
 
     *value = val;
 
@@ -1290,14 +1287,15 @@ Z4lAdjustFrame(int scrnIndex, int x, int y, int flags)
 
     /* xv adjust does not handle putvideo case */
     for (i = 0; i < Z4l_nAdaptors; ++i) {
-	adpt = Z4l_pAdaptors[i];
-	pPriv = (Z4lPortPrivRec *) adpt->pPortPrivates[0].ptr;
-	if (pPriv->run > 0) {
-	    pPriv->drw_is_set = 0;
-	    z4l_ovly_rect(pPriv,
-		pPriv->src_x, pPriv->src_y, pPriv->src_w, pPriv->src_h,
-		pPriv->drw_x, pPriv->drw_y, pPriv->drw_w, pPriv->drw_h);
-	}
+        adpt = Z4l_pAdaptors[i];
+        pPriv = (Z4lPortPrivRec *) adpt->pPortPrivates[0].ptr;
+        if (pPriv->run > 0) {
+            pPriv->drw_is_set = 0;
+            z4l_ovly_rect(pPriv,
+                          pPriv->src_x, pPriv->src_y, pPriv->src_w,
+                          pPriv->src_h, pPriv->drw_x, pPriv->drw_y,
+                          pPriv->drw_w, pPriv->drw_h);
+        }
     }
 }
 
@@ -1328,8 +1326,8 @@ Z4lInit(ScrnInfoPtr pScrni, XF86VideoAdaptorPtr ** adaptors)
 
     DBLOG(1, "Init\n");
     if (oldAdjustFrame == NULL) {
-	oldAdjustFrame = pScrni->AdjustFrame;
-	pScrni->AdjustFrame = Z4lAdjustFrame;
+        oldAdjustFrame = pScrni->AdjustFrame;
+        pScrni->AdjustFrame = Z4lAdjustFrame;
     }
 
     fd = -1;
@@ -1348,254 +1346,255 @@ Z4lInit(ScrnInfoPtr pScrni, XF86VideoAdaptorPtr ** adaptors)
     has_video = has_image = has_colorkey = 0;
 
     for (dev = 0; z4l_dev_paths[dev] != NULL; ++dev) {
-	fd = open(z4l_dev_paths[dev], O_RDWR, 0);
-	if (fd < 0)
-	    continue;
-	DBLOG(1, "%s open ok\n", z4l_dev_paths[dev]);
-	msg = NULL;
-	enable = 1;
-	if (IoCtl(fd, VIDIOC_QUERYCAP, &capability, 1) < 0)
-	    msg = "bad querycap";
-	else if ((capability.capabilities & V4L2_CAP_VIDEO_OVERLAY) == 0)
-	    msg = "no overlay";
-	else if ((capability.capabilities & V4L2_CAP_STREAMING) == 0)
-	    msg = "no streaming";
+        fd = open(z4l_dev_paths[dev], O_RDWR, 0);
+        if (fd < 0)
+            continue;
+        DBLOG(1, "%s open ok\n", z4l_dev_paths[dev]);
+        msg = NULL;
+        enable = 1;
+        if (IoCtl(fd, VIDIOC_QUERYCAP, &capability, 1) < 0)
+            msg = "bad querycap";
+        else if ((capability.capabilities & V4L2_CAP_VIDEO_OVERLAY) == 0)
+            msg = "no overlay";
+        else if ((capability.capabilities & V4L2_CAP_STREAMING) == 0)
+            msg = "no streaming";
 #ifdef NONBLK_IO
-	else if (IoCtl(fd, FIONBIO, &enable, 1) != 0)
-	    msg = "cant enable non-blocking io";
+        else if (IoCtl(fd, FIONBIO, &enable, 1) != 0)
+            msg = "cant enable non-blocking io";
 #endif
-	if (msg == NULL) {
-	    memset(&format, 0, sizeof(format));
-	    format.type = 0x100;
-	    if (IoCtl(fd, VIDIOC_G_FMT, &format, 1) != 0)
-		msg = "no src/dst ovly fmt";
-	}
-	if (msg != NULL) {
-	    DBLOG(0, "%s %s\n", z4l_dev_paths[dev], msg);
-	    close(fd);
-	    continue;
-	}
-
-	memset(&cfmt, 0, sizeof(cfmt));
-	cfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	if (IoCtl(fd, VIDIOC_G_FMT, &cfmt, 1) < 0)
-	    goto fail;
-	if (IoCtl(fd, VIDIOC_G_STD, &cstd_id, 1) < 0)
-	    goto fail;
-	if (IoCtl(fd, VIDIOC_G_INPUT, &cinp, 1) < 0)
-	    goto fail;
-	cpixfmt = cfmt.fmt.pix.pixelformat;
-	cenc = 0;
-	for (inp = 0;; ++inp) {
-	    memset(&input, 0, sizeof(input));
-	    input.index = inp;
-	    if (IoCtl(fd, VIDIOC_ENUMINPUT, &input, 0) < 0)
-		break;
-	    id = inp;
-	    if (IoCtl(fd, VIDIOC_S_INPUT, &id, 1) < 0)
-		goto fail;
-	    for (std = 0;; ++std) {
-		memset(&standard, 0, sizeof(standard));
-		standard.index = std;
-		if (IoCtl(fd, VIDIOC_ENUMSTD, &standard, 0) < 0)
-		    break;
-		std_id = standard.id;
-		denom = standard.frameperiod.denominator;
-		numer = standard.frameperiod.numerator;
-		if (IoCtl(fd, VIDIOC_S_STD, &std_id, 1) < 0)
-		    continue;
-		memset(&format, 0, sizeof(format));
-		format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		if (IoCtl(fd, VIDIOC_G_FMT, &format, 1) < 0)
-		    continue;
-		width = format.fmt.pix.width;
-		height = format.fmt.pix.height;
-		for (fmt = 0;; ++fmt) {
-		    memset(&fmtdesc, 0, sizeof(fmtdesc));
-		    fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		    fmtdesc.index = fmt;
-		    if (IoCtl(fd, VIDIOC_ENUM_FMT, &fmtdesc, 0) < 0)
-			break;
-		    pixfmt = fmtdesc.pixelformat;
-		    ip = &pixfmts[0];
-		    for (i = sizeof(pixfmts) / sizeof(pixfmts[0]); --i >= 0;
-			++ip)
-			if (z4l_fourcc_pixfmt(ip->id) == pixfmt)
-			    break;
-
-		    if (i >= 0) {
-			id = nencs;
-			has_video = 1;
-			if ((enc = Z4lNewEncoding(&encs, &nencs)) == NULL)
-			    goto fail;
-			Z4lEncodingName(&enc_name[0], sizeof(enc_name),
-			    (char *)&input.name[0],
-			    (char *)&standard.name[0], (char *)&pixfmt);
-			if (Z4lAddEncoding(enc, &enc_name[0], id, width,
-				height, denom, numer, inp, std_id,
-				pixfmt) == 0)
-			    goto fail;
-			if (std_id == cstd_id && inp == cinp
-			    && pixfmt == cpixfmt)
-			    cenc = id;
-		    }
-		}
-	    }
-	}
-
-	if (IoCtl(fd, VIDIOC_S_INPUT, &cinp, 1) < 0)
-	    goto fail;
-	if (IoCtl(fd, VIDIOC_S_STD, &cstd_id, 1) < 0)
-	    goto fail;
-	if (IoCtl(fd, VIDIOC_S_FMT, &cfmt, 1) < 0)
-	    goto fail;
-
-	if (encs == NULL) {
-	    DBLOG(0, "no encodings\n");
-	    goto fail;
-	}
-
-	for (fmt = 0;; ++fmt) {
-	    memset(&fmtdesc, 0, sizeof(fmtdesc));
-	    fmtdesc.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
-	    fmtdesc.index = fmt;
-	    if (IoCtl(fd, VIDIOC_ENUM_FMT, &fmtdesc, 0) < 0)
-		break;
-	    pixfmt = fmtdesc.pixelformat;
-	    ip = &pixfmts[0];
-	    for (i = sizeof(pixfmts) / sizeof(pixfmts[0]); --i >= 0; ++ip)
-		if (z4l_fourcc_pixfmt(ip->id) == pixfmt)
-		    break;
-
-	    if (i >= 0) {
-		has_image = 1;
-		if ((img = Z4lNewImage(&imgs, &nimgs)) == NULL)
-		    goto fail;
-		if (Z4lAddImage(img, ip) == 0)
-		    goto fail;
-	    }
-	}
-
-	if (nimgs > 0) {
-	    id = nencs;
-	    if ((enc = Z4lNewEncoding(&encs, &nencs)) == NULL)
-		goto fail;
-	    if (Z4lAddEncoding(enc, "XV_IMAGE", id, MAX_OVLY_WIDTH,
-		    MAX_OVLY_HEIGHT, 0, 0, 0, 0, pixfmt) == 0)
-		goto fail;
-	}
-
-	ctl = 0;
-	for (ctl = 0; ctl < (V4L2_CID_LASTP1 - V4L2_CID_BASE); ++ctl) {
-	    memset(&queryctrl, 0, sizeof(queryctrl));
-	    queryctrl.id = V4L2_CID_BASE + ctl;
-	    if (IoCtl(fd, VIDIOC_QUERYCTRL, &queryctrl, 0) < 0)
-		continue;
-	    if (queryctrl.type != V4L2_CTRL_TYPE_INTEGER &&
-		queryctrl.type != V4L2_CTRL_TYPE_BOOLEAN)
-		continue;
-	    attrIds[nattrs] = ctl;
-	    if ((attr = Z4lNewAttribute(&attrs, &nattrs)) == NULL)
-		goto fail;
-	    Z4lAttributeName(&attr_name[0], sizeof(attr_name),
-		(char *)&queryctrl.name[0]);
-	    if (Z4lAddAttribute(attr, &attr_name[0],
-		    queryctrl.minimum, queryctrl.maximum,
-		    XvSettable | XvGettable) == 0)
-		goto fail;
-	}
-	attrIds[nattrs] = ATTR_ENCODING_ID;
-	if ((attr = Z4lNewAttribute(&attrs, &nattrs)) == NULL)
-	    goto fail;
-	Z4lAttributeName(&attr_name[0], sizeof(attr_name), ATTR_ENCODING);
-	if (Z4lAddAttribute(attr, &attr_name[0], 0, nencs - 1,
-		XvSettable | XvGettable) == 0)
-	    goto fail;
-	memset(&fbuf, 0, sizeof(fbuf));
-	if (IoCtl(fd, VIDIOC_G_FBUF, &fbuf, 1) < 0)
-	    goto fail;
-	opixfmt = fbuf.fmt.pixelformat;
-
-	if ((fbuf.capability & V4L2_FBUF_CAP_CHROMAKEY) != 0) {
-	    attrIds[nattrs] = ATTR_KEYMODE_ID;
-	    if ((attr = Z4lNewAttribute(&attrs, &nattrs)) == NULL)
-		goto fail;
-	    Z4lAttributeName(&attr_name[0], sizeof(attr_name), ATTR_KEYMODE);
-	    if (Z4lAddAttribute(attr, &attr_name[0], 0, 1,
-		    XvSettable | XvGettable) == 0)
-		goto fail;
-	    attrIds[nattrs] = ATTR_COLORKEY_ID;
-	    if ((attr = Z4lNewAttribute(&attrs, &nattrs)) == NULL)
-		goto fail;
-	    Z4lAttributeName(&attr_name[0], sizeof(attr_name), ATTR_COLORKEY);
-	    if (Z4lAddAttribute(attr, &attr_name[0], 0, 0xffffff,
-		    XvSettable | XvGettable) == 0)
-		goto fail;
-	    has_colorkey = 1;
-	}
-
-	dp = malloc(strlen((char *)&capability.card[0]) + 1);
-	if (dp == NULL)
-	    goto fail;
-	strcpy(dp, (char *)&capability.card[0]);
-	if ((adpt = Z4lNewAdaptor(&adpts, &nadpts, nattrs)) == NULL)
-	    goto fail;
-	adpt->type = XvWindowMask | XvInputMask;
-	if (has_video != 0)
-	    adpt->type |= XvVideoMask;
-	if (has_image != 0)
-	    adpt->type |= XvImageMask;
-	adpt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
-	adpt->name = dp;
-	adpt->type = XvInputMask | XvWindowMask | XvVideoMask | XvImageMask;
-	adpt->pEncodings = encs;
-	adpt->nEncodings = nencs;
-	adpt->pFormats = &Formats[0];
-	adpt->nFormats = sizeof(Formats) / sizeof(Formats[0]);
-	adpt->pAttributes = attrs;
-	adpt->nAttributes = nattrs;
-	attrs = NULL;
-	nattrs = 0;
-	adpt->pImages = imgs;
-	adpt->nImages = nimgs;
-	imgs = NULL;
-	nimgs = 0;
-	adpt->PutVideo = Z4lPutVideo;
-	adpt->StopVideo = Z4lStopVideo;
-	adpt->SetPortAttribute = Z4lSetPortAttribute;
-	adpt->GetPortAttribute = Z4lGetPortAttribute;
-	adpt->QueryBestSize = Z4lQueryBestSize;
-	adpt->PutImage = Z4lPutImage;
-	adpt->QueryImageAttributes = Z4lQueryImageAttributes;
-	pPriv = (Z4lPortPrivRec *) adpt->pPortPrivates[0].ptr;
-	pPriv->fd = fd;
-	pPriv->run = -1;
-	pPriv->dir = 0;
-	pPriv->nbfrs = -1;
-	pPriv->bufsz = -1;
-	pPriv->last = -1;
-	pPriv->pixfmt = opixfmt;
+        if (msg == NULL) {
+            memset(&format, 0, sizeof(format));
+            format.type = 0x100;
+            if (IoCtl(fd, VIDIOC_G_FMT, &format, 1) != 0)
+                msg = "no src/dst ovly fmt";
+        }
+        if (msg != NULL) {
+            DBLOG(0, "%s %s\n", z4l_dev_paths[dev], msg);
+            close(fd);
+            continue;
+        }
+
+        memset(&cfmt, 0, sizeof(cfmt));
+        cfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+        if (IoCtl(fd, VIDIOC_G_FMT, &cfmt, 1) < 0)
+            goto fail;
+        if (IoCtl(fd, VIDIOC_G_STD, &cstd_id, 1) < 0)
+            goto fail;
+        if (IoCtl(fd, VIDIOC_G_INPUT, &cinp, 1) < 0)
+            goto fail;
+        cpixfmt = cfmt.fmt.pix.pixelformat;
+        cenc = 0;
+        for (inp = 0;; ++inp) {
+            memset(&input, 0, sizeof(input));
+            input.index = inp;
+            if (IoCtl(fd, VIDIOC_ENUMINPUT, &input, 0) < 0)
+                break;
+            id = inp;
+            if (IoCtl(fd, VIDIOC_S_INPUT, &id, 1) < 0)
+                goto fail;
+            for (std = 0;; ++std) {
+                memset(&standard, 0, sizeof(standard));
+                standard.index = std;
+                if (IoCtl(fd, VIDIOC_ENUMSTD, &standard, 0) < 0)
+                    break;
+                std_id = standard.id;
+                denom = standard.frameperiod.denominator;
+                numer = standard.frameperiod.numerator;
+                if (IoCtl(fd, VIDIOC_S_STD, &std_id, 1) < 0)
+                    continue;
+                memset(&format, 0, sizeof(format));
+                format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+                if (IoCtl(fd, VIDIOC_G_FMT, &format, 1) < 0)
+                    continue;
+                width = format.fmt.pix.width;
+                height = format.fmt.pix.height;
+                for (fmt = 0;; ++fmt) {
+                    memset(&fmtdesc, 0, sizeof(fmtdesc));
+                    fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+                    fmtdesc.index = fmt;
+                    if (IoCtl(fd, VIDIOC_ENUM_FMT, &fmtdesc, 0) < 0)
+                        break;
+                    pixfmt = fmtdesc.pixelformat;
+                    ip = &pixfmts[0];
+                    for (i = sizeof(pixfmts) / sizeof(pixfmts[0]); --i >= 0;
+                         ++ip)
+                        if (z4l_fourcc_pixfmt(ip->id) == pixfmt)
+                            break;
+
+                    if (i >= 0) {
+                        id = nencs;
+                        has_video = 1;
+                        if ((enc = Z4lNewEncoding(&encs, &nencs)) == NULL)
+                            goto fail;
+                        Z4lEncodingName(&enc_name[0], sizeof(enc_name),
+                                        (char *) &input.name[0],
+                                        (char *) &standard.name[0],
+                                        (char *) &pixfmt);
+                        if (Z4lAddEncoding
+                            (enc, &enc_name[0], id, width, height, denom, numer,
+                             inp, std_id, pixfmt) == 0)
+                            goto fail;
+                        if (std_id == cstd_id && inp == cinp
+                            && pixfmt == cpixfmt)
+                            cenc = id;
+                    }
+                }
+            }
+        }
+
+        if (IoCtl(fd, VIDIOC_S_INPUT, &cinp, 1) < 0)
+            goto fail;
+        if (IoCtl(fd, VIDIOC_S_STD, &cstd_id, 1) < 0)
+            goto fail;
+        if (IoCtl(fd, VIDIOC_S_FMT, &cfmt, 1) < 0)
+            goto fail;
+
+        if (encs == NULL) {
+            DBLOG(0, "no encodings\n");
+            goto fail;
+        }
+
+        for (fmt = 0;; ++fmt) {
+            memset(&fmtdesc, 0, sizeof(fmtdesc));
+            fmtdesc.type = V4L2_BUF_TYPE_VIDEO_OVERLAY;
+            fmtdesc.index = fmt;
+            if (IoCtl(fd, VIDIOC_ENUM_FMT, &fmtdesc, 0) < 0)
+                break;
+            pixfmt = fmtdesc.pixelformat;
+            ip = &pixfmts[0];
+            for (i = sizeof(pixfmts) / sizeof(pixfmts[0]); --i >= 0; ++ip)
+                if (z4l_fourcc_pixfmt(ip->id) == pixfmt)
+                    break;
+
+            if (i >= 0) {
+                has_image = 1;
+                if ((img = Z4lNewImage(&imgs, &nimgs)) == NULL)
+                    goto fail;
+                if (Z4lAddImage(img, ip) == 0)
+                    goto fail;
+            }
+        }
+
+        if (nimgs > 0) {
+            id = nencs;
+            if ((enc = Z4lNewEncoding(&encs, &nencs)) == NULL)
+                goto fail;
+            if (Z4lAddEncoding(enc, "XV_IMAGE", id, MAX_OVLY_WIDTH,
+                               MAX_OVLY_HEIGHT, 0, 0, 0, 0, pixfmt) == 0)
+                goto fail;
+        }
+
+        ctl = 0;
+        for (ctl = 0; ctl < (V4L2_CID_LASTP1 - V4L2_CID_BASE); ++ctl) {
+            memset(&queryctrl, 0, sizeof(queryctrl));
+            queryctrl.id = V4L2_CID_BASE + ctl;
+            if (IoCtl(fd, VIDIOC_QUERYCTRL, &queryctrl, 0) < 0)
+                continue;
+            if (queryctrl.type != V4L2_CTRL_TYPE_INTEGER &&
+                queryctrl.type != V4L2_CTRL_TYPE_BOOLEAN)
+                continue;
+            attrIds[nattrs] = ctl;
+            if ((attr = Z4lNewAttribute(&attrs, &nattrs)) == NULL)
+                goto fail;
+            Z4lAttributeName(&attr_name[0], sizeof(attr_name),
+                             (char *) &queryctrl.name[0]);
+            if (Z4lAddAttribute(attr, &attr_name[0],
+                                queryctrl.minimum, queryctrl.maximum,
+                                XvSettable | XvGettable) == 0)
+                goto fail;
+        }
+        attrIds[nattrs] = ATTR_ENCODING_ID;
+        if ((attr = Z4lNewAttribute(&attrs, &nattrs)) == NULL)
+            goto fail;
+        Z4lAttributeName(&attr_name[0], sizeof(attr_name), ATTR_ENCODING);
+        if (Z4lAddAttribute(attr, &attr_name[0], 0, nencs - 1,
+                            XvSettable | XvGettable) == 0)
+            goto fail;
+        memset(&fbuf, 0, sizeof(fbuf));
+        if (IoCtl(fd, VIDIOC_G_FBUF, &fbuf, 1) < 0)
+            goto fail;
+        opixfmt = fbuf.fmt.pixelformat;
+
+        if ((fbuf.capability & V4L2_FBUF_CAP_CHROMAKEY) != 0) {
+            attrIds[nattrs] = ATTR_KEYMODE_ID;
+            if ((attr = Z4lNewAttribute(&attrs, &nattrs)) == NULL)
+                goto fail;
+            Z4lAttributeName(&attr_name[0], sizeof(attr_name), ATTR_KEYMODE);
+            if (Z4lAddAttribute(attr, &attr_name[0], 0, 1,
+                                XvSettable | XvGettable) == 0)
+                goto fail;
+            attrIds[nattrs] = ATTR_COLORKEY_ID;
+            if ((attr = Z4lNewAttribute(&attrs, &nattrs)) == NULL)
+                goto fail;
+            Z4lAttributeName(&attr_name[0], sizeof(attr_name), ATTR_COLORKEY);
+            if (Z4lAddAttribute(attr, &attr_name[0], 0, 0xffffff,
+                                XvSettable | XvGettable) == 0)
+                goto fail;
+            has_colorkey = 1;
+        }
+
+        dp = malloc(strlen((char *) &capability.card[0]) + 1);
+        if (dp == NULL)
+            goto fail;
+        strcpy(dp, (char *) &capability.card[0]);
+        if ((adpt = Z4lNewAdaptor(&adpts, &nadpts, nattrs)) == NULL)
+            goto fail;
+        adpt->type = XvWindowMask | XvInputMask;
+        if (has_video != 0)
+            adpt->type |= XvVideoMask;
+        if (has_image != 0)
+            adpt->type |= XvImageMask;
+        adpt->flags = VIDEO_OVERLAID_IMAGES | VIDEO_CLIP_TO_VIEWPORT;
+        adpt->name = dp;
+        adpt->type = XvInputMask | XvWindowMask | XvVideoMask | XvImageMask;
+        adpt->pEncodings = encs;
+        adpt->nEncodings = nencs;
+        adpt->pFormats = &Formats[0];
+        adpt->nFormats = sizeof(Formats) / sizeof(Formats[0]);
+        adpt->pAttributes = attrs;
+        adpt->nAttributes = nattrs;
+        attrs = NULL;
+        nattrs = 0;
+        adpt->pImages = imgs;
+        adpt->nImages = nimgs;
+        imgs = NULL;
+        nimgs = 0;
+        adpt->PutVideo = Z4lPutVideo;
+        adpt->StopVideo = Z4lStopVideo;
+        adpt->SetPortAttribute = Z4lSetPortAttribute;
+        adpt->GetPortAttribute = Z4lGetPortAttribute;
+        adpt->QueryBestSize = Z4lQueryBestSize;
+        adpt->PutImage = Z4lPutImage;
+        adpt->QueryImageAttributes = Z4lQueryImageAttributes;
+        pPriv = (Z4lPortPrivRec *) adpt->pPortPrivates[0].ptr;
+        pPriv->fd = fd;
+        pPriv->run = -1;
+        pPriv->dir = 0;
+        pPriv->nbfrs = -1;
+        pPriv->bufsz = -1;
+        pPriv->last = -1;
+        pPriv->pixfmt = opixfmt;
 #if defined(REGION_NULL)
-	REGION_NULL(pScrni->pScreen, &pPriv->clips);
+        REGION_NULL(pScrni->pScreen, &pPriv->clips);
 #else
-	REGION_INIT(pScrni->pScreen, &pPriv->clips, NullBox, 0);
+        REGION_INIT(pScrni->pScreen, &pPriv->clips, NullBox, 0);
 #endif
-	strncpy(&pPriv->dev_path[0], z4l_dev_paths[dev],
-	    sizeof(pPriv->dev_path));
-	pPriv->enc = &encs[cenc];
-	for (i = 0; i < adpt->nAttributes; ++i)
-	    pPriv->attrIds[i] = attrIds[i];
-	DBLOG(1, "adpt %s\n", dp);
-	if (has_colorkey != 0) {
-	    z4l_ovly_set_colorkey(pPriv, DEFAULT_COLORKEY);
-	    z4l_ovly_set_keymode(pPriv, DEFAULT_KEYMODE);
-	}
-	close(fd);
-	pPriv->fd = -1;
-	adpt = NULL;
-	cenc = 0;
-	encs = NULL;
-	nencs = 0;
+        strncpy(&pPriv->dev_path[0], z4l_dev_paths[dev],
+                sizeof(pPriv->dev_path));
+        pPriv->enc = &encs[cenc];
+        for (i = 0; i < adpt->nAttributes; ++i)
+            pPriv->attrIds[i] = attrIds[i];
+        DBLOG(1, "adpt %s\n", dp);
+        if (has_colorkey != 0) {
+            z4l_ovly_set_colorkey(pPriv, DEFAULT_COLORKEY);
+            z4l_ovly_set_keymode(pPriv, DEFAULT_KEYMODE);
+        }
+        close(fd);
+        pPriv->fd = -1;
+        adpt = NULL;
+        cenc = 0;
+        encs = NULL;
+        nencs = 0;
     }
 
     DBLOG(0, "init done, %d device(s) found\n", nadpts);
@@ -1605,52 +1604,52 @@ Z4lInit(ScrnInfoPtr pScrni, XF86VideoAdaptorPtr ** adaptors)
 
     return nadpts;
 
-  fail:
+ fail:
     if (attrs != NULL) {
-	for (i = 0; i < nattrs; ++i)
-	    if (attrs[i].name != NULL)
-		free(attrs[i].name);
-	free(attrs);
+        for (i = 0; i < nattrs; ++i)
+            if (attrs[i].name != NULL)
+                free(attrs[i].name);
+        free(attrs);
     }
 
     if (encs != NULL) {
-	for (i = 0; i < nencs; ++i) {
-	    if (encs[i].name != NULL)
-		free(encs[i].name);
-	}
-	free(encs);
+        for (i = 0; i < nencs; ++i) {
+            if (encs[i].name != NULL)
+                free(encs[i].name);
+        }
+        free(encs);
     }
 
     if (imgs != NULL)
-	free(imgs);
+        free(imgs);
 
     if (adpts != NULL) {
-	for (i = 0; i < nadpts; ++i) {
-	    if ((adpt = adpts[i]) != NULL) {
-		if (adpt->name != NULL)
-		    free(adpt->name);
-		if ((attrs = adpt->pAttributes) != NULL) {
-		    for (i = 0; i < adpt->nAttributes; ++i)
-			if (attrs[i].name != NULL)
-			    free(attrs[i].name);
-		    free(attrs);
-		}
-		if ((encs = adpt->pEncodings) != NULL) {
-		    for (i = 0; i < adpt->nEncodings; ++i, ++enc)
-			if (encs[i].name != NULL)
-			    free(encs[i].name);
-		    free(encs);
-		}
-		if ((imgs = adpt->pImages) != NULL)
-		    free(imgs);
-		free(adpt);
-	    }
-	}
-	free(adpts);
+        for (i = 0; i < nadpts; ++i) {
+            if ((adpt = adpts[i]) != NULL) {
+                if (adpt->name != NULL)
+                    free(adpt->name);
+                if ((attrs = adpt->pAttributes) != NULL) {
+                    for (i = 0; i < adpt->nAttributes; ++i)
+                        if (attrs[i].name != NULL)
+                            free(attrs[i].name);
+                    free(attrs);
+                }
+                if ((encs = adpt->pEncodings) != NULL) {
+                    for (i = 0; i < adpt->nEncodings; ++i, ++enc)
+                        if (encs[i].name != NULL)
+                            free(encs[i].name);
+                    free(encs);
+                }
+                if ((imgs = adpt->pImages) != NULL)
+                    free(imgs);
+                free(adpt);
+            }
+        }
+        free(adpts);
     }
 
     if (fd >= 0)
-	close(fd);
+        close(fd);
 
     return 0;
 }
@@ -1660,7 +1659,7 @@ Z4lProbe(DriverPtr drv, int flags)
 {
     DBLOG(1, "Probe\n");
     if (flags & PROBE_DETECT)
-	return TRUE;
+        return TRUE;
 
     xf86XVRegisterGenericAdaptorDriver(Z4lInit);
     drv->refCount++;
@@ -1711,21 +1710,21 @@ z4lSetup(pointer module, pointer opts, int *errmaj, int *errmin)
     static Bool setupDone = FALSE;
 
     if (setupDone != FALSE) {
-	if (errmaj != NULL)
-	    *errmaj = LDR_ONCEONLY;
-	return NULL;
+        if (errmaj != NULL)
+            *errmaj = LDR_ONCEONLY;
+        return NULL;
     }
 
     setupDone = TRUE;
     LoaderGetOS(&osname, NULL, NULL, NULL);
 
     if (osname == NULL || strcmp(osname, "linux") != 0) {
-	if (errmaj)
-	    *errmaj = LDR_BADOS;
-	if (errmin)
-	    *errmin = 0;
+        if (errmaj)
+            *errmaj = LDR_BADOS;
+        if (errmin)
+            *errmin = 0;
 
-	return NULL;
+        return NULL;
     }
 
     xf86AddDriver(&Z4l, module, 0);
@@ -1734,4 +1733,4 @@ z4lSetup(pointer module, pointer opts, int *errmaj, int *errmin)
 }
 
 #endif
-#endif /* !XvExtension */
+#endif                          /* !XvExtension */
--
cgit v0.9.0.2-2-gbebe
From dc0dbd41745f99dcd9ca3fda05acf5a5f11a6960 Mon Sep 17 00:00:00 2001
From: Mart Raudsepp <leio@gentoo.org>
Date: Wed, 25 Jul 2012 01:44:18 +0000
Subject: Fix an unused variable warning in geode_driver.c

geode_driver.c:372:9: warning: variable 'cpu_detected' set but not used [-Wunused-but-set-variable]
Was used only in a DEBUGMSG, which has since been made not do anything ever, so just kill
it completely, as the debug message wasn't useful anyway.
---
diff --git a/src/geode_driver.c b/src/geode_driver.c
index a8cc944..b27bfd5 100644
--- a/src/geode_driver.c
+++ b/src/geode_driver.c
@@ -369,7 +369,6 @@ AmdPciProbe(DriverPtr driver,
             int entity_num, struct pci_device *device, intptr_t match_data)
 {
     ScrnInfoPtr scrn = NULL;
-    int cpu_detected;
 
     ErrorF("AmdPciProbe: Probing for supported devices!\n");
 
@@ -385,13 +384,11 @@ AmdPciProbe(DriverPtr driver,
         switch (device->device_id) {
 #ifdef HAVE_LX
         case PCI_CHIP_GEODELX:
-            cpu_detected = LX;
             LXSetupChipsetFPtr(scrn);
             break;
 #endif
 #ifdef HAVE_GX
         case PCI_CHIP_GEODEGX:
-            cpu_detected = GX;
             GXSetupChipsetFPtr(scrn);
             break;
 #endif
@@ -399,9 +396,6 @@ AmdPciProbe(DriverPtr driver,
             ErrorF("AmdPciProbe: unknown device ID\n");
             return FALSE;
         }
-
-        DEBUGMSG(1, (0, X_INFO, "AmdPciProbe: CPUDetected %d!\n",
-                     cpu_detected));
     }
     return scrn != NULL;
 }
--
cgit v0.9.0.2-2-gbebe
From cb0e67bbc019b170194b3b51e2a47fca8d3aeac1 Mon Sep 17 00:00:00 2001
From: Mart Raudsepp <leio@gentoo.org>
Date: Wed, 25 Jul 2012 04:23:35 +0000
Subject: lx_exa: Fix EXA minor version checks

The old version of just checking for EXA_MINOR_VERSION >= 2 would
stop working if ever EXA gets a new major version, as minor would be
reset to 0, and start unexpectedly working again when minor gets bumped
gradually up to 2 again.
Other drivers also assume that a new major would still have the vfunc we use.
---
diff --git a/src/lx_exa.c b/src/lx_exa.c
index 57fd8e1..1f01717 100644
--- a/src/lx_exa.c
+++ b/src/lx_exa.c
@@ -1503,7 +1503,7 @@ lx_upload_to_screen(PixmapPtr pxDst, int x, int y, int w, int h,
 }
 #endif
 
-#if EXA_VERSION_MINOR >= 2
+#if EXA_VERSION_MAJOR > 2 || (EXA_VERSION_MAJOR == 2 && EXA_VERSION_MINOR >= 2)
 
 static Bool
 lx_exa_pixmap_is_offscreen(PixmapPtr pPixmap)
@@ -1551,7 +1551,7 @@ LXExaInit(ScreenPtr pScreen)
     pExa->DoneComposite = lx_done;
     //pExa->UploadToScreen =  lx_upload_to_screen;
 
-#if EXA_VERSION_MINOR >= 2
+#if EXA_VERSION_MAJOR > 2 || (EXA_VERSION_MAJOR == 2 && EXA_VERSION_MINOR >= 2)
     pExa->PixmapIsOffscreen = lx_exa_pixmap_is_offscreen;
 #endif
 
--
cgit v0.9.0.2-2-gbebe
From 68646c3119a69a8391a49f2d565672d73829e2c9 Mon Sep 17 00:00:00 2001
From: Maarten Lankhorst <maarten.lankhorst@canonical.com>
Date: Sat, 21 Jul 2012 10:36:17 +0000
Subject: Allow building on Xservers without XAA

---
diff --git a/configure.ac b/configure.ac
index 2c810a2..7d9ead7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -78,6 +78,24 @@ AC_ARG_ENABLE(ztv,
 	    [ztv=$enableval],
 	    [ztv=auto])
 
+AC_ARG_ENABLE(xaa,
+              AS_HELP_STRING([--enable-xaa],
+                             [Enable legacy X Acceleration Architecture (XAA) [default=auto]]),
+              [XAA="$enableval"],
+              [XAA=auto])
+if test "x$XAA" != xno; then
+        save_CFLAGS=$CFLAGS
+        save_CPPFLAGS=$CPPFLAGS
+        CFLAGS=$XORG_CFLAGS
+        CPPFLAGS="$XORG_CFLAGS"
+        AC_CHECK_HEADERS([xaa.h], XAA=yes, XAA=no)
+        CFLAGS=$save_CFLAGS
+        CPPFLAGS=$save_CPPFLAGS
+fi
+AC_MSG_CHECKING([whether to include XAA support])
+AM_CONDITIONAL(XAA, test "x$XAA" = xyes)
+AC_MSG_RESULT([$XAA])
+
 # Check for Video4Linux Version 2 (V4L2) availability
 AC_CHECK_HEADERS([linux/videodev2.h],[v4l2=yes],[v4l2=no])
 if test "x$ztv" != "xno" ; then
diff --git a/src/geode.h b/src/geode.h
index 4a86b38..0165c81 100644
--- a/src/geode.h
+++ b/src/geode.h
@@ -30,7 +30,9 @@
 #include "geode_pcirename.h"
 #include "config.h"
 
+#ifdef HAVE_XAA_H
 #include "xaa.h"
+#endif
 #include "exa.h"
 #include "xf86Cursor.h"
 
@@ -51,6 +53,12 @@
 #undef XF86EXA
 #endif
 
+#ifdef HAVE_XAA_H
+#define XF86XAA 1
+#else
+#undef XF86XAA
+#endif
+
 #define CFB 0
 #define INT10_SUPPORT 1
 
@@ -71,7 +79,7 @@
 
 #define GFX_CPU_GEODELX   4
 
-#ifdef HAVE_GX
+#if defined(HAVE_GX) && XF86XAA
 #define GX_FILL_RECT_SUPPORT 1
 #define GX_BRES_LINE_SUPPORT 1
 #define GX_DASH_LINE_SUPPORT 0  /* does not do dashed lines */
@@ -84,10 +92,10 @@
 #define GX_USE_OFFSCRN_MEM 0
 #define GX_ONE_LINE_AT_A_TIME 1
 #define GX_WRITE_PIXMAP_SUPPORT 1
+#endif
 
 #define GFX(func) gfx_##func
 #define GFX2(func) gfx2_##func
-#endif
 
 #define GEODEPTR(p) ((GeodeRec *)((p)->driverPrivate))
 
@@ -299,7 +307,9 @@ typedef struct _geodeRec {
     int NoOfImgBuffers;
     unsigned char **AccelColorExpandBuffers;
     int NoOfColorExpandLines;
+#if XF86XAA
     XAAInfoRecPtr AccelInfoRec;
+#endif
 
     /* Save state */
     unsigned long FBCompressionOffset;
diff --git a/src/gx_accel.c b/src/gx_accel.c
index 58aa833..c368649 100644
--- a/src/gx_accel.c
+++ b/src/gx_accel.c
@@ -39,7 +39,9 @@
 
 #include "vgaHW.h"
 #include "xf86.h"
+#ifdef HAVE_XAA_H
 #include "xaalocal.h"
+#endif
 #include "xf86fbman.h"
 #include "miline.h"
 #include "xaarop.h"
@@ -128,7 +130,9 @@ static GDashLine gdln;
 static unsigned int gu2_xshift, gu2_yshift;
 static unsigned int gu2_pitch;
 
+#if XF86XAA
 static XAAInfoRecPtr localRecPtr;
+#endif
 
 /* pat  0xF0 */
 /* src  0xCC */
@@ -1964,6 +1968,8 @@ GXAccelInit(ScreenPtr pScrn)
     }
 #endif
 
+#if XF86XAA
+
     /* Getting the pointer for acceleration Inforecord */
     pGeode->AccelInfoRec = localRecPtr = XAACreateInfoRec();
     if (!pGeode->AccelInfoRec)
@@ -2076,6 +2082,9 @@ GXAccelInit(ScreenPtr pScrn)
 #endif
 
     return (XAAInit(pScrn, localRecPtr));
+#else /* XF86XAA */
+    return FALSE;
+#endif
 }
 
 /* END OF FILE */
diff --git a/src/gx_driver.c b/src/gx_driver.c
index f6ac4c6..96b3dc3 100644
--- a/src/gx_driver.c
+++ b/src/gx_driver.c
@@ -258,6 +258,7 @@ GXAllocateMemory(ScreenPtr pScrn, ScrnInfoPtr pScrni, int rotate)
 
         if (!pGeode->useEXA) {
 
+#if XF86XAA
             if (!xf86FBManagerRunning(pScrn)) {
 
                 unsigned int offset = fboffset;
@@ -296,6 +297,7 @@ GXAllocateMemory(ScreenPtr pScrn, ScrnInfoPtr pScrni, int rotate)
             else
                 xf86DrvMsg(pScrni->scrnIndex, X_INFO,
                            "XAA offscreen memory has already been allocated.\n");
+#endif
         }
     }
     return ret;
@@ -972,8 +974,10 @@ GXCloseScreen(int scrnIndex, ScreenPtr pScrn)
     if (pScrni->vtSema)
         GXLeaveGraphics(pScrni);
 
+#ifdef XF86XAA
     if (pGeode->AccelInfoRec)
         XAADestroyInfoRec(pGeode->AccelInfoRec);
+#endif
 
     if (pGeode->AccelImageWriteBuffers) {
         free(pGeode->AccelImageWriteBuffers[0]);
diff --git a/src/gx_rotate.c b/src/gx_rotate.c
index 9eb39e7..2a86b30 100644
--- a/src/gx_rotate.c
+++ b/src/gx_rotate.c
@@ -158,7 +158,7 @@ GXRotate(ScrnInfoPtr pScrni, DisplayModePtr mode)
                                                    pScrni->fbOffset));
 
     /* Don't use XAA pixmap cache or offscreen pixmaps when rotated */
-
+#if XF86XAA
     if (pGeode->AccelInfoRec) {
         if (pGeode->rotation == RR_Rotate_0) {
             pGeode->AccelInfoRec->Flags =
@@ -174,6 +174,7 @@ GXRotate(ScrnInfoPtr pScrni, DisplayModePtr mode)
             pGeode->AccelInfoRec->maxOffPixHeight = 1;
         }
     }
+#endif
 
     return TRUE;
 
diff --git a/src/gx_video.c b/src/gx_video.c
index fef7764..b687b11 100644
--- a/src/gx_video.c
+++ b/src/gx_video.c
@@ -54,8 +54,10 @@
 #include "geode.h"
 #include "xf86xv.h"
 #include <X11/extensions/Xv.h>
+#ifdef HAVE_XAA_H
 #include "xaa.h"
 #include "xaalocal.h"
+#endif
 #include "dixstruct.h"
 #include "fourcc.h"
 #include "geode_fourcc.h"
--
cgit v0.9.0.2-2-gbebe
From a83fcb6f84995dc50b8adffc27e264a663fbd606 Mon Sep 17 00:00:00 2001
From: Maarten Lankhorst <maarten.lankhorst@canonical.com>
Date: Sat, 21 Jul 2012 10:36:51 +0000
Subject: Initial stab at converting geode to new X1.13 API

Preparing to compile geode on X 1.13
All compiler errors are gone as far as I can tell,
but I lack the hardware to verify it works as well.
---
diff --git a/src/compat-api.h b/src/compat-api.h
new file mode 100644
index 0000000..e296829
--- a/dev/null
+++ b/src/compat-api.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2012 Red Hat, Inc.
+ * Copyright 2012 Canonical Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *   Dave Airlie <airlied@redhat.com>
+ *   Maarten Lankhorst <maarten.lankhorst@canonical.com>
+ */
+
+/* this file provides API compat between server post 1.13 and pre it,
+   it should be reused inside as many drivers as possible */
+#ifndef COMPAT_API_H
+#define COMPAT_API_H
+
+#ifndef GLYPH_HAS_GLYPH_PICTURE_ACCESSOR
+#define GetGlyphPicture(g, s) GlyphPicture((g))[(s)->myNum]
+#define SetGlyphPicture(g, s, p) GlyphPicture((g))[(s)->myNum] = p
+#endif
+
+#ifndef XF86_HAS_SCRN_CONV
+#define xf86ScreenToScrn(s) xf86Screens[(s)->myNum]
+#define xf86ScrnToScreen(s) screenInfo.screens[(s)->scrnIndex]
+#endif
+
+#ifndef XF86_SCRN_INTERFACE
+
+#define DDC_CALL(pScrni) (pScrni->scrnIndex)
+
+#define SCRN_ARG_TYPE int
+#define SCRN_INFO_PTR(arg1) ScrnInfoPtr pScrni = xf86Screens[(arg1)]
+
+#define SCREEN_ARG_TYPE int
+#define SCREEN_PTR(arg1) ScreenPtr pScrn = screenInfo.screens[(arg1)]
+
+#define SCREEN_INIT_ARGS_DECL int index, ScreenPtr pScrn, int argc, char **argv
+
+#define BLOCKHANDLER_ARGS_DECL int arg, pointer blockData, pointer pTimeout, pointer pReadmask
+#define BLOCKHANDLER_ARGS arg, blockData, pTimeout, pReadmask
+
+#define CLOSE_SCREEN_ARGS_DECL int scrnIndex, ScreenPtr pScrn
+#define CLOSE_SCREEN_ARGS scrnIndex, pScrn
+
+#define ADJUST_FRAME_ARGS_DECL int arg, int x, int y, int flags
+#define ADJUST_FRAME_ARGS(x, y) pScrni->scrnIndex, (x), (y), 0
+
+#define SWITCH_MODE_ARGS_DECL int arg, DisplayModePtr pMode, int flags
+
+#define FREE_SCREEN_ARGS_DECL int arg, int flags
+#define FREE_SCREEN_ARGS(x) (x)->scrnIndex, 0
+
+#define VT_FUNC_ARGS_DECL int arg, int flags
+#define VT_FUNC_ARGS(flags) pScrni->scrnIndex, (flags)
+
+#define XF86_ENABLEDISABLEFB_ARG(pScrni, x) ((pScrni)->scrnIndex), (x)
+
+#define POINTER_MOVED_ARGS_DECL int arg, int x, int y
+#define POINTER_MOVED_ARGS(x, y) pScrni->scrnIndex, (x), (y)
+
+#define VALID_MODE_ARGS_DECL int arg, DisplayModePtr pMode, Bool Verbose, int flags
+
+#else /*XF86_SCRN_INTERFACE)*/
+
+#define DDC_CALL(pScrni) (pScrni)
+
+#define SCRN_ARG_TYPE ScrnInfoPtr
+#define SCRN_INFO_PTR(arg1) ScrnInfoPtr pScrni = (arg1)
+
+#define SCREEN_ARG_TYPE ScreenPtr
+#define SCREEN_PTR(arg1) ScreenPtr pScrn = (arg1)
+
+#define SCREEN_INIT_ARGS_DECL ScreenPtr pScrn, int argc, char **argv
+
+#define BLOCKHANDLER_ARGS_DECL ScreenPtr arg, pointer pTimeout, pointer pReadmask
+#define BLOCKHANDLER_ARGS arg, pTimeout, pReadmask
+
+#define CLOSE_SCREEN_ARGS_DECL ScreenPtr pScrn
+#define CLOSE_SCREEN_ARGS pScrn
+
+#define ADJUST_FRAME_ARGS_DECL ScrnInfoPtr arg, int x, int y
+#define ADJUST_FRAME_ARGS(x, y) pScrni, (x), (y)
+
+#define SWITCH_MODE_ARGS_DECL ScrnInfoPtr arg, DisplayModePtr pMode
+
+#define FREE_SCREEN_ARGS_DECL ScrnInfoPtr arg
+#define FREE_SCREEN_ARGS(x) (x)
+
+#define VT_FUNC_ARGS_DECL ScrnInfoPtr arg
+#define VT_FUNC_ARGS(flags) pScrni
+
+#define XF86_ENABLEDISABLEFB_ARG(pScrni, x) (pScrni), (x)
+
+#define POINTER_MOVED_ARGS_DECL ScrnInfoPtr arg, int x, int y
+#define POINTER_MOVED_ARGS(x, y) pScrni, (x), (y)
+
+#define VALID_MODE_ARGS_DECL ScrnInfoPtr arg, DisplayModePtr pMode, Bool Verbose, int flags
+
+#endif
+
+#endif
diff --git a/src/geode.h b/src/geode.h
index 0165c81..b733805 100644
--- a/src/geode.h
+++ b/src/geode.h
@@ -43,6 +43,8 @@
 
 #include "xf86xv.h"
 
+#include "compat-api.h"
+
 /* We only support EXA version >=2 */
 
 #if (EXA_VERSION_MAJOR >= 2)
@@ -248,7 +250,7 @@ typedef struct _geodeRec {
 
     /* Hooks */
 
-    void (*PointerMoved) (int index, int x, int y);
+    void (*PointerMoved) (POINTER_MOVED_ARGS_DECL);
     CloseScreenProcPtr CloseScreen;
     Bool (*CreateScreenResources) (ScreenPtr);
 
@@ -405,8 +407,8 @@ xf86MonPtr GeodeDoDDC(ScrnInfoPtr pScrni, int index);
 Bool GeodeI2CInit(ScrnInfoPtr pScrni, I2CBusPtr * ptr, char *name);
 
 int GeodeGetFPGeometry(const char *str, int *width, int *height);
-void GeodePointerMoved(int index, int x, int y);
-void GeodeFreeScreen(int scrnIndex, int flags);
+void GeodePointerMoved(POINTER_MOVED_ARGS_DECL);
+void GeodeFreeScreen(FREE_SCREEN_ARGS_DECL);
 int GeodeCalculatePitchBytes(unsigned int width, unsigned int bpp);
 void GXSetupChipsetFPtr(ScrnInfoPtr pScrn);
 
@@ -458,7 +460,7 @@ void LXSetupOutput(ScrnInfoPtr);
 DisplayModePtr LXGetLegacyPanelMode(ScrnInfoPtr pScrni);
 DisplayModePtr LXGetManualPanelMode(char *modestr);
 
-void LXAdjustFrame(int scrnIndex, int x, int y, int flags);
+void LXAdjustFrame(ADJUST_FRAME_ARGS_DECL);
 
 /* lx_display.c */
 void LXSetupCrtc(ScrnInfoPtr pScrni);
diff --git a/src/geode_ddc.c b/src/geode_ddc.c
index 8f1c605..7b8277d 100644
--- a/src/geode_ddc.c
+++ b/src/geode_ddc.c
@@ -173,7 +173,7 @@ GeodeGetDDC(ScrnInfoPtr pScrni)
     if (!GeodeI2CInit(pScrni, &bus, "CS5536 DDC BUS"))
         return NULL;
 
-    mon = xf86DoEDID_DDC2(pScrni->scrnIndex, bus);
+    mon = xf86DoEDID_DDC2(DDC_CALL(pScrni), bus);
 
 #if (XORG_VERSION_CURRENT >= XORG_VERSION_NUMERIC(1,4,99,0,0))
     if (mon)
diff --git a/src/gx_accel.c b/src/gx_accel.c
index c368649..764e0db 100644
--- a/src/gx_accel.c
+++ b/src/gx_accel.c
@@ -1904,7 +1904,7 @@ amd_gx_exa_Composite(PixmapPtr pxDst, int srcX, int srcY, int maskX,
 Bool
 GXAccelInit(ScreenPtr pScrn)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
 #if XF86EXA
diff --git a/src/gx_cursor.c b/src/gx_cursor.c
index de706fc..5a8f335 100644
--- a/src/gx_cursor.c
+++ b/src/gx_cursor.c
@@ -67,7 +67,7 @@ extern void GXSetVideoPosition(int x, int y, int width, int height,
 Bool
 GXHWCursorInit(ScreenPtr pScrn)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     xf86CursorInfoPtr infoPtr;
 
diff --git a/src/gx_driver.c b/src/gx_driver.c
index 96b3dc3..5268f29 100644
--- a/src/gx_driver.c
+++ b/src/gx_driver.c
@@ -306,7 +306,7 @@ GXAllocateMemory(ScreenPtr pScrn, ScrnInfoPtr pScrni, int rotate)
 static Bool
 GXSaveScreen(ScreenPtr pScrn, int mode)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodePtr pGeode = GEODEPTR(pScrni);
 
     if (pGeode->useVGA && !pScrni->vtSema)
@@ -784,9 +784,9 @@ GXSetDvLineSize(unsigned int pitch)
 /* XXX - this is nothing like the original function - not sure exactly what the purpose is for this quite yet */
 
 static void
-GXAdjustFrame(int scrnIndex, int x, int y, int flags)
+GXAdjustFrame(ADJUST_FRAME_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     unsigned long offset;
 
@@ -868,16 +868,16 @@ GXSetVideoMode(ScrnInfoPtr pScrni, DisplayModePtr pMode)
         pGeode->HWCursor = FALSE;
     }
 
-    GXAdjustFrame(pScrni->scrnIndex, pScrni->frameX0, pScrni->frameY0, 0);
+    GXAdjustFrame(ADJUST_FRAME_ARGS(pScrni->frameX0, pScrni->frameY0));
     gx_enable_dac_power();
 
     return TRUE;
 }
 
 static Bool
-GXSwitchMode(int index, DisplayModePtr pMode, int flags)
+GXSwitchMode(SWITCH_MODE_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[index];
+    SCRN_INFO_PTR(arg);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     int ret = TRUE;
     int rotate;
@@ -966,9 +966,9 @@ GXLeaveGraphics(ScrnInfoPtr pScrni)
 }
 
 static Bool
-GXCloseScreen(int scrnIndex, ScreenPtr pScrn)
+GXCloseScreen(CLOSE_SCREEN_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[scrnIndex];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pScrni->vtSema)
@@ -1004,7 +1004,7 @@ GXCloseScreen(int scrnIndex, ScreenPtr pScrn)
     pScrn->CloseScreen = pGeode->CloseScreen;
 
     if (pScrn->CloseScreen)
-        return (*pScrn->CloseScreen) (scrnIndex, pScrn);
+        return (*pScrn->CloseScreen) (CLOSE_SCREEN_ARGS);
 
     return TRUE;
 }
@@ -1199,7 +1199,7 @@ GXDPMSSet(ScrnInfoPtr pScrni, int mode, int flags)
 static Bool
 GXCreateScreenResources(ScreenPtr pScreen)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScreen);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     pScreen->CreateScreenResources = pGeode->CreateScreenResources;
@@ -1235,9 +1235,9 @@ GXCreateScreenResources(ScreenPtr pScreen)
 }
 
 static Bool
-GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
+GXScreenInit(SCREEN_INIT_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[scrnIndex];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     XF86ModReqInfo shadowReq;
     int maj, min, ret, rotate;
@@ -1259,7 +1259,7 @@ GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
         if (pGeode->useEXA) {
 
             if (!(pGeode->pExa = exaDriverAlloc())) {
-                xf86DrvMsg(scrnIndex, X_ERROR,
+                xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
                            "Couldn't allocate the EXA structure.\n");
                 pGeode->NoAccel = TRUE;
             }
@@ -1360,7 +1360,7 @@ GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
 
     if (pGeode->tryHWCursor) {
         if (!GXHWCursorInit(pScrn))
-            xf86DrvMsg(scrnIndex, X_ERROR,
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
                        "Hardware cursor initialization failed.\n");
     }
 
@@ -1434,9 +1434,9 @@ GXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
 }
 
 static int
-GXValidMode(int scrnIndex, DisplayModePtr pMode, Bool Verbose, int flags)
+GXValidMode(VALID_MODE_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     int p;
     int custom = 0;
@@ -1485,19 +1485,20 @@ GXValidMode(int scrnIndex, DisplayModePtr pMode, Bool Verbose, int flags)
 /* XXX - Way more to do here */
 
 static Bool
-GXEnterVT(int scrnIndex, int flags)
+GXEnterVT(VT_FUNC_ARGS_DECL)
 {
-    return GXEnterGraphics(NULL, xf86Screens[scrnIndex]);
+    SCRN_INFO_PTR(arg);
+    return GXEnterGraphics(NULL, pScrni);
 }
 
 static void
-GXLeaveVT(int scrnIndex, int flags)
+GXLeaveVT(VT_FUNC_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     pGeode->PrevDisplayOffset = gfx_get_display_offset();
-    GXLeaveGraphics(xf86Screens[scrnIndex]);
+    GXLeaveGraphics(pScrni);
 }
 
 void
@@ -1520,9 +1521,9 @@ GXSetupChipsetFPtr(ScrnInfoPtr pScrn)
  * ============================== */
 
 void
-GeodePointerMoved(int index, int x, int y)
+GeodePointerMoved(POINTER_MOVED_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[index];
+    SCRN_INFO_PTR(arg);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     int newX = x, newY = y;
@@ -1544,7 +1545,7 @@ GeodePointerMoved(int index, int x, int y)
         break;
     }
 
-    (*pGeode->PointerMoved) (index, newX, newY);
+    (*pGeode->PointerMoved) (POINTER_MOVED_ARGS(newX, newY));
 }
 
 int
@@ -1566,19 +1567,20 @@ GeodeFreeRec(ScrnInfoPtr pScrni)
 }
 
 void
-GeodeFreeScreen(int scrnIndex, int flags)
+GeodeFreeScreen(FREE_SCREEN_ARGS_DECL)
 {
-    GeodeRec *pGeode = GEODEPTR(xf86Screens[scrnIndex]);
+    SCRN_INFO_PTR(arg);
+    GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pGeode == NULL)
         return;
 
     if (pGeode->useVGA) {
         if (xf86LoaderCheckSymbol("vgaHWFreeHWRec"))
-            vgaHWFreeHWRec(xf86Screens[scrnIndex]);
+            vgaHWFreeHWRec(pScrni);
     }
 
-    GeodeFreeRec(xf86Screens[scrnIndex]);
+    GeodeFreeRec(pScrni);
 }
 
 int
diff --git a/src/gx_randr.c b/src/gx_randr.c
index 2176019..5b83094 100644
--- a/src/gx_randr.c
+++ b/src/gx_randr.c
@@ -181,7 +181,7 @@ GXRandRSetMode(ScreenPtr pScreen,
 #endif
 
     if (pRoot)
-        (*pScrni->EnableDisableFBAccess) (pScreen->myNum, FALSE);
+        (*pScrni->EnableDisableFBAccess) (XF86_ENABLEDISABLEFB_ARG(pScrni, FALSE));
 
     if (useVirtual) {
         pScrni->virtualX = pRandr->virtualX;
@@ -236,7 +236,7 @@ GXRandRSetMode(ScreenPtr pScreen,
     xf86SetViewport(pScreen, 0, 0);
 
     if (pRoot)
-        (*pScrni->EnableDisableFBAccess) (pScreen->myNum, TRUE);
+        (*pScrni->EnableDisableFBAccess) (XF86_ENABLEDISABLEFB_ARG(pScrni, TRUE));
 
     return ret;
 }
diff --git a/src/gx_rotate.c b/src/gx_rotate.c
index 2a86b30..3f7c911 100644
--- a/src/gx_rotate.c
+++ b/src/gx_rotate.c
@@ -35,7 +35,7 @@ static void *
 GXWindowLinear(ScreenPtr pScreen, CARD32 row, CARD32 offset, int mode,
                CARD32 *size, void *closure)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScreen);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     *size = pGeode->displayPitch;
@@ -47,7 +47,7 @@ GXWindowLinear(ScreenPtr pScreen, CARD32 row, CARD32 offset, int mode,
 static void
 GXUpdate(ScreenPtr pScreen, shadowBufPtr pBuf)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScreen);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     int rotate = pGeode->rotation;
 
diff --git a/src/gx_video.c b/src/gx_video.c
index b687b11..0d3e1c5 100644
--- a/src/gx_video.c
+++ b/src/gx_video.c
@@ -105,7 +105,7 @@ static int GXPutImage(ScrnInfoPtr, short, short, short, short, short, short,
                       short, short, int, unsigned char *, short, short, Bool,
                       RegionPtr, pointer, DrawablePtr pDraw);
 
-static void GXBlockHandler(int, pointer, pointer, pointer);
+static void GXBlockHandler(BLOCKHANDLER_ARGS_DECL);
 void GXSetVideoPosition(int x, int y, int width, int height,
                         short src_w, short src_h, short drw_w,
                         short drw_h, int id, int offset, ScrnInfoPtr pScrni);
@@ -164,7 +164,7 @@ void
 GXInitVideo(ScreenPtr pScrn)
 {
     GeodeRec *pGeode;
-    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
 
     pGeode = GEODEPTR(pScrni);
 
@@ -371,7 +371,7 @@ GXResetVideo(ScrnInfoPtr pScrni)
 static XF86VideoAdaptorPtr
 GXSetupImageVideo(ScreenPtr pScrn)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     XF86VideoAdaptorPtr adapt;
     GeodePortPrivRec *pPriv;
@@ -690,7 +690,7 @@ GXCopyData422(unsigned char *src, unsigned char *dst,
 static void
 GXVideoSave(ScreenPtr pScreen, ExaOffscreenArea * area)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScreen);
     GeodePortPrivRec *pPriv = GET_PORT_PRIVATE(pScrni);
 
     if (area == pPriv->area)
@@ -701,7 +701,7 @@ GXVideoSave(ScreenPtr pScreen, ExaOffscreenArea * area)
 static int
 GXAllocateMemory(ScrnInfoPtr pScrni, void **memp, int numlines)
 {
-    ScreenPtr pScrn = screenInfo.screens[pScrni->scrnIndex];
+    ScreenPtr pScrn = xf86ScrnToScreen(pScrni);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     //long displayWidth = pGeode->Pitch / ((pScrni->bitsPerPixel + 7) / 8);
@@ -1320,15 +1320,15 @@ GeodeQueryImageAttributes(ScrnInfoPtr pScrni,
 }
 
 static void
-GXBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
+GXBlockHandler(BLOCKHANDLER_ARGS_DECL)
 {
-    ScreenPtr pScrn = screenInfo.screens[i];
-    ScrnInfoPtr pScrni = xf86Screens[i];
+    SCREEN_PTR(arg);
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     GeodePortPrivRec *pPriv = GET_PORT_PRIVATE(pScrni);
 
     pScrn->BlockHandler = pGeode->BlockHandler;
-    (*pScrn->BlockHandler) (i, blockData, pTimeout, pReadmask);
+    (*pScrn->BlockHandler) (BLOCKHANDLER_ARGS);
     pScrn->BlockHandler = GXBlockHandler;
 
     if (pPriv->videoStatus & TIMER_MASK) {
diff --git a/src/lx_driver.c b/src/lx_driver.c
index 44ab2a4..6d7f37f 100644
--- a/src/lx_driver.c
+++ b/src/lx_driver.c
@@ -76,7 +76,7 @@ unsigned char *XpressROMPtr;
 static Bool
 LXSaveScreen(ScreenPtr pScrn, int mode)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodePtr pGeode = GEODEPTR(pScrni);
 
     if (pGeode->useVGA && !pScrni->vtSema)
@@ -630,9 +630,9 @@ LXUnmapMem(ScrnInfoPtr pScrni)
 /* These should be correctly accounted for rotation */
 
 void
-LXAdjustFrame(int scrnIndex, int x, int y, int flags)
+LXAdjustFrame(ADJUST_FRAME_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     unsigned long offset;
@@ -644,9 +644,9 @@ LXAdjustFrame(int scrnIndex, int x, int y, int flags)
 }
 
 static Bool
-LXSwitchMode(int index, DisplayModePtr pMode, int flags)
+LXSwitchMode(SWITCH_MODE_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[index];
+    SCRN_INFO_PTR(arg);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     /* Set the new mode */
@@ -693,9 +693,9 @@ LXLeaveGraphics(ScrnInfoPtr pScrni)
 }
 
 static Bool
-LXCloseScreen(int scrnIndex, ScreenPtr pScrn)
+LXCloseScreen(CLOSE_SCREEN_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[scrnIndex];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     if (pScrni->vtSema)
@@ -719,7 +719,7 @@ LXCloseScreen(int scrnIndex, ScreenPtr pScrn)
     pScrn->CloseScreen = pGeode->CloseScreen;
 
     if (pScrn->CloseScreen)
-        return (*pScrn->CloseScreen) (scrnIndex, pScrn);
+        return (*pScrn->CloseScreen) (CLOSE_SCREEN_ARGS);
 
     return TRUE;
 }
@@ -815,9 +815,9 @@ LXLoadPalette(ScrnInfoPtr pScrni,
 }
 
 static Bool
-LXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
+LXScreenInit(SCREEN_INIT_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[scrnIndex];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     int ret;
     unsigned int dwidth;
@@ -850,7 +850,7 @@ LXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
             pGeode->pExa->maxY = LX_MAX_HEIGHT - 1;
         }
         else {
-            xf86DrvMsg(scrnIndex, X_ERROR,
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
                        "Couldn't allocate the EXA structure.\n");
             pGeode->NoAccel = TRUE;
         }
@@ -942,7 +942,7 @@ LXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
 
     if (pGeode->tryHWCursor) {
         if (!LXCursorInit(pScrn))
-            xf86DrvMsg(scrnIndex, X_ERROR,
+            xf86DrvMsg(pScrni->scrnIndex, X_ERROR,
                        "Hardware cursor initialization failed.\n");
     }
 
@@ -973,7 +973,7 @@ LXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
     pScrn->SaveScreen = LXSaveScreen;
 
     if (!xf86CrtcScreenInit(pScrn)) {
-        xf86DrvMsg(scrnIndex, X_ERROR, "CRTCScreenInit failed.\n");
+        xf86DrvMsg(pScrni->scrnIndex, X_ERROR, "CRTCScreenInit failed.\n");
         return FALSE;
     }
 
@@ -986,21 +986,22 @@ LXScreenInit(int scrnIndex, ScreenPtr pScrn, int argc, char **argv)
 }
 
 static int
-LXValidMode(int scrnIndex, DisplayModePtr pMode, Bool Verbose, int flags)
+LXValidMode(VALID_MODE_ARGS_DECL)
 {
     return MODE_OK;
 }
 
 static Bool
-LXEnterVT(int scrnIndex, int flags)
+LXEnterVT(VT_FUNC_ARGS_DECL)
 {
-    return LXEnterGraphics(NULL, xf86Screens[scrnIndex]);
+    SCRN_INFO_PTR(arg);
+    return LXEnterGraphics(NULL, pScrni);
 }
 
 static void
-LXLeaveVT(int scrnIndex, int flags)
+LXLeaveVT(VT_FUNC_ARGS_DECL)
 {
-    ScrnInfoPtr pScrni = xf86Screens[scrnIndex];
+    SCRN_INFO_PTR(arg);
     GeodeRec *pGeode = GEODEPTR(pScrni);
 
     pGeode->PrevDisplayOffset = vg_get_display_offset();
diff --git a/src/lx_exa.c b/src/lx_exa.c
index 1f01717..bcff23e 100644
--- a/src/lx_exa.c
+++ b/src/lx_exa.c
@@ -461,7 +461,9 @@ struct blend_ops_t {
     }
 };
 
+#ifndef ARRAY_SIZE
 #define ARRAY_SIZE(a) (sizeof((a)) / (sizeof(*(a))))
+#endif
 
 static const struct exa_format_t *
 lx_get_format(PicturePtr p)
@@ -1508,7 +1510,7 @@ lx_upload_to_screen(PixmapPtr pxDst, int x, int y, int w, int h,
 static Bool
 lx_exa_pixmap_is_offscreen(PixmapPtr pPixmap)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pPixmap->drawable.pScreen->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pPixmap->drawable.pScreen);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     void *start = (void *) (pGeode->FBBase);
     void *end =
@@ -1527,7 +1529,7 @@ lx_exa_pixmap_is_offscreen(PixmapPtr pPixmap)
 Bool
 LXExaInit(ScreenPtr pScreen)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScreen->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScreen);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     ExaDriverPtr pExa = pGeode->pExa;
 
diff --git a/src/lx_video.c b/src/lx_video.c
index cf1c380..5dbe224 100644
--- a/src/lx_video.c
+++ b/src/lx_video.c
@@ -61,7 +61,9 @@
 #define TIMER_MASK      (OFF_TIMER | FREE_TIMER)
 
 #define MAKE_ATOM(a) MakeAtom(a, sizeof(a) - 1, TRUE)
+#ifndef ARRAY_SIZE
 #define ARRAY_SIZE(a) (sizeof((a)) / (sizeof(*(a))))
+#endif
 
 /* Local function prototypes */
 static void LXStopVideo(ScrnInfoPtr pScrni, pointer data, Bool exit);
@@ -638,15 +640,15 @@ LXResetVideo(ScrnInfoPtr pScrni)
 }
 
 static void
-LXVidBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
+LXVidBlockHandler(BLOCKHANDLER_ARGS_DECL)
 {
-    ScreenPtr pScrn = screenInfo.screens[i];
-    ScrnInfoPtr pScrni = xf86Screens[i];
+    SCREEN_PTR(arg);
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     GeodePortPrivRec *pPriv = GET_PORT_PRIVATE(pScrni);
 
     pScrn->BlockHandler = pGeode->BlockHandler;
-    (*pScrn->BlockHandler) (i, blockData, pTimeout, pReadmask);
+    (*pScrn->BlockHandler) (BLOCKHANDLER_ARGS);
     pScrn->BlockHandler = LXVidBlockHandler;
 
     if (pPriv->videoStatus & TIMER_MASK) {
@@ -684,7 +686,7 @@ LXVidBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask)
 static XF86VideoAdaptorPtr
 LXSetupImageVideo(ScreenPtr pScrn)
 {
-    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     GeodeRec *pGeode = GEODEPTR(pScrni);
     XF86VideoAdaptorPtr adapt;
     GeodePortPrivRec *pPriv;
@@ -946,7 +948,7 @@ void
 LXInitVideo(ScreenPtr pScrn)
 {
     GeodeRec *pGeode;
-    ScrnInfoPtr pScrni = xf86Screens[pScrn->myNum];
+    ScrnInfoPtr pScrni = xf86ScreenToScrn(pScrn);
     XF86VideoAdaptorPtr *adaptors, *newAdaptors = NULL;
     XF86VideoAdaptorPtr newAdaptor = NULL;
     int num_adaptors;
diff --git a/src/z4l.c b/src/z4l.c
index 6388e00..eccefe8 100644
--- a/src/z4l.c
+++ b/src/z4l.c
@@ -47,6 +47,8 @@
 #include "xf86xv.h"
 #include "fourcc.h"
 
+#include "compat-api.h"
+
 #define __s64 __s_64
 typedef long long __s64;
 
@@ -1271,19 +1273,20 @@ Z4lGetPortAttribute(ScrnInfoPtr pScrni, Atom attribute, INT32 *value,
     return Success;
 }
 
-static void (*oldAdjustFrame) (int scrnIndex, int x, int y, int flags) = NULL;
+static void (*oldAdjustFrame) (ADJUST_FRAME_ARGS_DECL) = NULL;
 
 static void
-Z4lAdjustFrame(int scrnIndex, int x, int y, int flags)
+Z4lAdjustFrame(ADJUST_FRAME_ARGS_DECL)
 {
+    SCRN_INFO_PTR(arg);
     int i;
     XF86VideoAdaptorPtr adpt;
     Z4lPortPrivRec *pPriv;
 
-    DBLOG(3, "Z4lAdjustFrame(%d,%d,%d)\n", x, y, flags);
+    DBLOG(3, "Z4lAdjustFrame(%d,%d)\n", x, y);
     z4l_x_offset = x;
     z4l_y_offset = y;
-    oldAdjustFrame(scrnIndex, x, y, flags);
+    oldAdjustFrame(ADJUST_FRAME_ARGS(x, y));
 
     /* xv adjust does not handle putvideo case */
     for (i = 0; i < Z4l_nAdaptors; ++i) {
--
cgit v0.9.0.2-2-gbebe
From 86a879a1ec9771c45b0bffb18f7fd13854b1e84a Mon Sep 17 00:00:00 2001
From: Mart Raudsepp <leio@gentoo.org>
Date: Thu, 26 Jul 2012 07:28:22 +0000
Subject: configure: Make the new XAA checks work, and other improvements

commit 68646c31 added XAA checks were too early, when XORG_CFLAGS isn't
declared yet, so it got never enabled. Move the block after xorg-server
pkg-config checks, which declare XORG_CFLAGS.
Change configure to fail if --enable-xaa is explicitly requested, but
XAA headers are not found.
Other tweaks for more autoconf-ism.

Signed-off-by: Mart Raudsepp <leio@gentoo.org>
---
diff --git a/configure.ac b/configure.ac
index 7d9ead7..94740e7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -78,24 +78,6 @@ AC_ARG_ENABLE(ztv,
 	    [ztv=$enableval],
 	    [ztv=auto])
 
-AC_ARG_ENABLE(xaa,
-              AS_HELP_STRING([--enable-xaa],
-                             [Enable legacy X Acceleration Architecture (XAA) [default=auto]]),
-              [XAA="$enableval"],
-              [XAA=auto])
-if test "x$XAA" != xno; then
-        save_CFLAGS=$CFLAGS
-        save_CPPFLAGS=$CPPFLAGS
-        CFLAGS=$XORG_CFLAGS
-        CPPFLAGS="$XORG_CFLAGS"
-        AC_CHECK_HEADERS([xaa.h], XAA=yes, XAA=no)
-        CFLAGS=$save_CFLAGS
-        CPPFLAGS=$save_CPPFLAGS
-fi
-AC_MSG_CHECKING([whether to include XAA support])
-AM_CONDITIONAL(XAA, test "x$XAA" = xyes)
-AC_MSG_RESULT([$XAA])
-
 # Check for Video4Linux Version 2 (V4L2) availability
 AC_CHECK_HEADERS([linux/videodev2.h],[v4l2=yes],[v4l2=no])
 if test "x$ztv" != "xno" ; then
@@ -146,6 +128,33 @@ PKG_CHECK_MODULES(XEXT, [xextproto >= 7.0.99.1],
                   HAVE_XEXTPROTO_71="yes"; AC_DEFINE(HAVE_XEXTPROTO_71, 1, [xextproto 7.1 available]),
                   HAVE_XEXTPROTO_71="no")
 
+# Define a configure option to enable/disable XAA support;
+# handles unavailability of XAA since xserver-1.13
+AC_ARG_ENABLE(xaa,
+    AS_HELP_STRING([--enable-xaa],
+                   [Enable legacy X Acceleration Architecture (XAA) [default=auto]]))
+
+AS_IF([test "x$enable_xaa" != "xno"],
+    [
+        save_CFLAGS=$CFLAGS
+        save_CPPFLAGS=$CPPFLAGS
+        CFLAGS=$XORG_CFLAGS
+        CPPFLAGS="$XORG_CFLAGS"
+        AC_CHECK_HEADERS([xaa.h], have_XAA=yes, have_XAA=no)
+        CFLAGS=$save_CFLAGS
+        CPPFLAGS=$save_CPPFLAGS
+])
+
+AC_MSG_CHECKING([whether to include XAA support])
+
+AS_IF([test "x$have_XAA" = "xyes"],
+    [AC_MSG_RESULT([yes])],
+    [AS_IF([test "x$enable_xaa" = "xyes"],
+        [AC_MSG_ERROR([XAA requested but not found (perhaps building against xserver-1.13 or newer?)])],
+        [AC_MSG_RESULT([no])
+    ])
+])
+
 # Checks for libpciaccess support.
 SAVE_CPPFLAGS="$CPPFLAGS"
 CPPFLAGS="$CPPFLAGS $XORG_CFLAGS"
--
cgit v0.9.0.2-2-gbebe
From 0e64b1252c51e380f72f6ff0bdb6836a6e27071d Mon Sep 17 00:00:00 2001
From: Martin-Éric Racine <martin-eric.racine@iki.fi>
Date: Thu, 09 Aug 2012 15:59:03 +0000
Subject: src/Makefile.am: added missing compat-api.h to geode_drv_la_SOURCES

---
diff --git a/src/Makefile.am b/src/Makefile.am
index 1f3dfcb..6c02386 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -40,6 +40,7 @@ geode_drv_la_LDFLAGS = -module -avoid-version
 geode_drv_ladir = $(moduledir)/drivers
 
 geode_drv_la_SOURCES =		\
+	compat-api.h		\
 	cimarron.c		\
 	cim_dev.h		\
 	durango.c		\
--
cgit v0.9.0.2-2-gbebe
From 4a20e8ac285cfe8a033f771ac8df25f873db9908 Mon Sep 17 00:00:00 2001
From: Martin-Éric Racine <martin-eric.racine@iki.fi>
Date: Wed, 29 Aug 2012 09:53:00 +0000
Subject: NEWS: add information about releases since 2.11.9

...and flip the location of the recent src/Makefile.am addition.
---
diff --git a/NEWS b/NEWS
index 1b50f88..fee3a0d 100644
--- a/NEWS
+++ b/NEWS
@@ -1,3 +1,43 @@
+Geode 2.11.13 (2011-12-26)
+==========================
+This release mainly features a complete overhaul of the building scripts plus
+a cleanup of deprecated macros. The key benefit is that this Geode driver can
+finally build on FreeBSD and on other platforms not offering V4L2 support and
+that it can also build on a 64-bit host using its 32-bit personality.
+
+Support for the Video Input Port (VIP) feature of the Geode LX found in 'ztv'
+is now documented and the source code saw the removal of deprecated Linux 2.4
+backward compatibility code. Compiling is skipped on platforms without V4L2.
+
+Configuration for laptops featuring WXGA resolutions is finally documented.
+
+Setting the GEODE_TRACE_FALL macro now enables composite operation tracing on
+this driver. This can be used to profile the performance during development.
+
+Fixes to keep this driver compilable on recent X servers are also included.
+
+VALIDATION PLATFORMS
+* Debian/stable (X server 1.7.7) on Artec DBE61 and Hercules EC-800.
+* Ubuntu/Precise (X server 1.10.4) on FIC ION603A.
+
+Geode 2.11.12 (2011-02-13)
+==========================
+This release drops the "linux/videodev.h" include in z4l.c because
+V4L1 support was dropped as of Linux kernel 2.6.38, and it fixes 
+packed overlay offscreen allocations.
+
+Geode 2.11.10 (2010-11-09)
+==========================
+This release migrates deprecated xalloc/xrealloc/xfree/xcalloc calls
+to malloc/realloc/free/calloc, fixes several DCON-specific issues, 
+improves mode validation and adds support for one WXGA resolution.
+
+Geode 2.11.11 (2010-12-27)
+==========================
+This release restores code compatibility down to X server 1.4, it fixes
+compilation under 1.9.99 and newer, and it improves handling of gamma
+correction in video vs graphics
+
 Geode 2.11.9 (2010-08-23)
 =========================
 We are pleased to announce this maintenance release of xf86-video-geode.
diff --git a/src/Makefile.am b/src/Makefile.am
index 6c02386..ad21034 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -40,9 +40,9 @@ geode_drv_la_LDFLAGS = -module -avoid-version
 geode_drv_ladir = $(moduledir)/drivers
 
 geode_drv_la_SOURCES =		\
-	compat-api.h		\
 	cimarron.c		\
 	cim_dev.h		\
+	compat-api.h		\
 	durango.c		\
 	geode_blend.h		\
 	geode_common.c		\
--
cgit v0.9.0.2-2-gbebe
From 5f7797cadeaf8a28612b9d0c394f8507eb687c34 Mon Sep 17 00:00:00 2001
From: Mart Raudsepp <leio@gentoo.org>
Date: Tue, 18 Sep 2012 05:41:53 +0000
Subject: lx_exa: Fix crash with solid fills on PictOpAdd operations

lx_check_composite has many special checks for PictOpAdd to return
successfully early, but these were done even earlier than the check
for solid fills. This resulted in lx_prepare_composite assuming
the source pixmap exists, which is not the case with solid fills.
Move the solid fill fallback checks before the others, so we are
guaranteed to always have a source pixmap in PrepareComposite and
Composite and don't crash trying to access a NULL pointer.

Also move up the mask check to do less checks in the PictOpAdd logic.
---
diff --git a/src/lx_exa.c b/src/lx_exa.c
index bcff23e..b341c51 100644
--- a/src/lx_exa.c
+++ b/src/lx_exa.c
@@ -547,28 +547,33 @@ lx_check_composite(int op, PicturePtr pSrc, PicturePtr pMsk, PicturePtr pDst)
     if (op > PictOpAdd)
         GEODE_FALLBACK(("Operation %d is not supported\n", op));
 
+    /* XXX - don't know if we can do any hwaccel on solid fills or gradient types */
+    if (pSrc->pSourcePict || (pMsk && pMsk->pSourcePict))
+        GEODE_FALLBACK(("Solid fills or gradient types are not supported\n"));
+
+    if (pMsk && op == PictOpAdd)
+        GEODE_FALLBACK(("PictOpAdd with mask is not supported\n"));
+
     /* FIXME: Meet this conditions from the debug for PictOpAdd.
      * Any Other possibilities? Add a judge for the future supplement */
     if (op == PictOpAdd && pSrc->format == PICT_a8r8g8b8 &&
-        pDst->format == PICT_a8 && !pMsk)
+        pDst->format == PICT_a8)
         return TRUE;
 
     if (op == PictOpAdd && pSrc->format == PICT_x8r8g8b8 &&
-        pDst->format == PICT_a8 && !pMsk)
+        pDst->format == PICT_a8)
         return TRUE;
 
     if (op == PictOpAdd && pSrc->format == PICT_r5g6b5 &&
-        pDst->format == PICT_a8 && !pMsk)
+        pDst->format == PICT_a8)
         return TRUE;
 
     if (usesPasses(op)) {
+        /* FIXME: Slightly misleading fallback msg when !pMsk */
         if (pGeode->exaBfrOffset == 0 || !pMsk)
             GEODE_FALLBACK(("Multipass operation requires off-screen buffer\n"));
     }
 
-    if (pMsk && op == PictOpAdd)
-        GEODE_FALLBACK(("PictOpAdd with mask is not supported\n"));
-
     /* Check that the filter matches what we support */
 
     switch (pSrc->filter) {
@@ -585,10 +590,6 @@ lx_check_composite(int op, PicturePtr pSrc, PicturePtr pMsk, PicturePtr pDst)
     if (pMsk && pMsk->transform)
         GEODE_FALLBACK(("Mask transforms are not supported\n"));
 
-    /* XXX - don't know if we can do any hwaccel on solid fills or gradient types */
-    if (pSrc->pSourcePict || (pMsk && pMsk->pSourcePict))
-        GEODE_FALLBACK(("Solid fills or gradient types are not supported\n"));
-
     /* Keep an eye out for source rotation transforms - those we can
      * do something about */
 
--
cgit v0.9.0.2-2-gbebe
From 65d9954ef61b7e22252d38cc81db710a8ec0b22b Mon Sep 17 00:00:00 2001
From: Mart Raudsepp <leio@gentoo.org>
Date: Tue, 18 Sep 2012 05:43:51 +0000
Subject: lx_exa: Downgrade src/dst format warnings to fallbacks to not spam the log

We don't support 10bit wide color channels, BGRA and other types, which mainly
cause these fallbacks. The ErrorF's were unwarranted, these are just fallbacks
as any other, so don't output these warnings without GEODE_TRACE_FALL.
---
diff --git a/src/lx_exa.c b/src/lx_exa.c
index b341c51..c7b7bdd 100644
--- a/src/lx_exa.c
+++ b/src/lx_exa.c
@@ -630,15 +630,11 @@ lx_check_composite(int op, PicturePtr pSrc, PicturePtr pMsk, PicturePtr pDst)
 
     /* Get the formats for the source and destination */
 
-    if ((srcFmt = lx_get_format(pSrc)) == NULL) {
-        ErrorF("EXA: Invalid source format %x\n", pSrc->format);
-        return FALSE;
-    }
+    if ((srcFmt = lx_get_format(pSrc)) == NULL)
+        GEODE_FALLBACK(("Unsupported source format %x\n", pSrc->format));
 
-    if ((dstFmt = lx_get_format(pDst)) == NULL) {
-        ErrorF("EXA: Invalid destination format %x\n", pDst->format);
-        return FALSE;
-    }
+    if ((dstFmt = lx_get_format(pDst)) == NULL)
+        GEODE_FALLBACK(("Unsupported destination format %x\n", pDst->format));
 
     /* Make sure operations that need alpha bits have them */
     /* If a mask is enabled, the alpha will come from there */
--
cgit v0.9.0.2-2-gbebe
From 5cfd7591b2f6ccb57d698738faa3fa800088f972 Mon Sep 17 00:00:00 2001
From: Martin-Éric Racine <martin-eric.racine@iki.fi>
Date: Tue, 02 Oct 2012 15:05:55 +0000
Subject: Clarified the copyright and license of src/geode_msr.c src/geode_blend.h

Debian's 'licensecheck' tool showed these two files to have unspecified
copyright and license. Git log clarifies that these had been created by
Jordan Crouse when he was still at AMD, so their stock copyright notice
was copied as-is from other files in src/
---
diff --git a/src/geode_blend.h b/src/geode_blend.h
index 6748ec0..51dff1b 100644
--- a/src/geode_blend.h
+++ b/src/geode_blend.h
@@ -1,3 +1,29 @@
+/*
+ * Copyright (c) 2007 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Neither the name of the Advanced Micro Devices, Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ */
+
 #ifndef AMD_BLEND_H_
 #define AMD_BLEND_H_
 
diff --git a/src/geode_msr.c b/src/geode_msr.c
index d3a72c4..b7c56d9 100644
--- a/src/geode_msr.c
+++ b/src/geode_msr.c
@@ -1,3 +1,29 @@
+/*
+ * Copyright (c) 2008 Advanced Micro Devices, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Neither the name of the Advanced Micro Devices, Inc. nor the names of its
+ * contributors may be used to endorse or promote products derived from this
+ * software without specific prior written permission.
+ */
+
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
--
cgit v0.9.0.2-2-gbebe
