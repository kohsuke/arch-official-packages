--- fcpcmcia_cs.c~	2010-08-04 13:02:02.150001261 +0200
+++ fcpcmcia_cs.c	2010-08-04 13:02:02.176667927 +0200
@@ -121,33 +121,6 @@
 
 static void cs_detach(struct pcmcia_device *p_dev);
 
-
-/*
-   A linked list of "instances" of the skeleton device.  Each actual
-   PCMCIA card corresponds to one device instance, and is described
-   by one struct pcmcia_device structure (defined in ds.h).
-
-   You may not want to use a linked list for this -- for example, the
-   memory card driver uses an array of struct pcmcia_device pointers, where minor
-   device numbers are used to derive the corresponding array index.
-*/
-
-
-/*
-   A driver needs to provide a dev_node_t structure for each device
-   on a card.  In some cases, there is only one device per card (for
-   example, ethernet cards, modems).  In other cases, there may be
-   many actual or logical devices (SCSI adapters, memory cards with
-   multiple partitions).  The dev_node_t structures need to be kept
-   in a linked list starting at the 'dev' field of a struct pcmcia_device
-   structure.  We allocate them in the card's private data structure,
-   because they generally can't be allocated dynamically.
-*/
-   
-typedef struct local_info_t {
-    dev_node_t	node;
-} local_info_t;
-
 /*======================================================================
 
     cs_attach() creates an "instance" of the driver, allocating
@@ -162,7 +135,6 @@
 
 static int cs_probe(struct pcmcia_device *p_dev)
 {
-    local_info_t *local;
 #if defined (PCMCIA_IRQ_INFO2)
     int i;
 #endif
@@ -194,11 +166,6 @@
     p_dev->conf.ConfigIndex = 1;
     p_dev->conf.Present = PRESENT_OPTION;
 
-    /* Allocate space for private device-specific data */
-    local = kzalloc(sizeof(local_info_t), GFP_KERNEL);
-    if (!local)
-        goto err_kfree;
-    p_dev->priv = local;
     return cs_config(p_dev);
 
  err_kfree:
@@ -249,10 +216,8 @@
 
 static int cs_config(struct pcmcia_device *link)
 {
-    local_info_t *dev;
     int i;
     char devname[128];
-    dev = link->priv;
 
     devname[0] = 0;
     if (link->prod_id[1])
@@ -283,14 +248,6 @@
 
     } while (0);
 
-    /* At this point, the dev_node_t structure(s) should be
-       initialized and arranged in a linked list at link->dev. */
-
-    strcpy(dev->node.dev_name, "A1");
-    dev->node.major = 64;
-    dev->node.minor = 0;
-
-    link->dev_node = &dev->node;
     /* If any step failed, release any partially configured state */
     if (i != 0) {
         ERROR("Failed to setup controller, releasing link...\n");
@@ -309,7 +266,7 @@
 	cs_release(link);
 	return -ENODEV;
     }
-    dev->node.minor = i;
+    link->priv = (void *) (unsigned long) i;
 
     NOTE(
 	"Card driver for '%s' has been set up: i/o %x, irq %d\n", 
--- fcpcmcia_cs.c~	2010-08-04 13:13:33.610000837 +0200
+++ fcpcmcia_cs.c	2010-08-04 13:13:33.633334616 +0200
@@ -165,8 +165,6 @@
 
     return cs_config(p_dev);
 
- err_kfree:
-    return -ENOMEM;
 } /* cs_attach */
 
 /*======================================================================
