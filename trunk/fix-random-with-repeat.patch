--- amarok-2.2.1/src/playlist/navigators/RandomTrackNavigator.cpp~	2009-11-11 22:09:13.000000000 +0100
+++ amarok-2.2.1/src/playlist/navigators/RandomTrackNavigator.cpp	2009-11-20 13:24:12.310019258 +0100
@@ -33,13 +33,15 @@
 Playlist::RandomTrackNavigator::RandomTrackNavigator()
 {
     m_model = Playlist::ModelStack::instance()->top();
+
+    reset();
+
     connect( model(), SIGNAL( insertedIds( const QList<quint64>& ) ),
              this, SLOT( recvInsertedIds( const QList<quint64>& ) ) );
     connect( model(), SIGNAL( removedIds( const QList<quint64>& ) ),
              this, SLOT( recvRemovedIds( const QList<quint64>& ) ) );
-    connect( model(), SIGNAL( layoutChanged() ), this, SLOT( modelLayoutChanged() ) );
-
-    reset();
+    connect( model(), SIGNAL( activeTrackChanged( const quint64 ) ),
+             this, SLOT( recvActiveTrackChanged( const quint64 ) ) );
 }
 
 void
@@ -51,12 +53,6 @@
         {
             m_unplayedRows.append( t );
         }
-        else
-        {
-            // insert a new, but played, track at a random position
-            int pos = KRandom::random() % m_playedRows.size();
-            m_playedRows.insert( pos, t );
-        }
     }
 
     std::random_shuffle( m_unplayedRows.begin(), m_unplayedRows.end() );
@@ -75,7 +71,11 @@
 void
 Playlist::RandomTrackNavigator::recvActiveTrackChanged( const quint64 id )
 {
-    if ( m_unplayedRows.contains( id ) )
+    if( m_replayedRows.contains( id ) )
+    {
+        m_playedRows.prepend( m_replayedRows.takeAt( m_replayedRows.indexOf( id ) ) );
+    }
+    else if( m_unplayedRows.contains( id ) )
     {
         m_playedRows.prepend( m_unplayedRows.takeAt( m_unplayedRows.indexOf( id ) ) );
     }
@@ -86,7 +86,7 @@
 {
     if( !m_queue.isEmpty() )
         return m_queue.takeFirst();
-    if( m_unplayedRows.isEmpty() && m_playedRows.isEmpty() )
+    if( m_model->tracks().isEmpty() )
         return 0;
     else if( m_unplayedRows.isEmpty() && !m_repeatPlaylist )
         return 0;
@@ -94,8 +94,8 @@
     {
         if ( m_unplayedRows.isEmpty() )
         {
-            m_unplayedRows = m_playedRows;
-            m_playedRows.clear();
+            // reset when playlist finishes
+            reset();
         }
 
         quint64 requestedTrack = 0;
@@ -106,14 +106,22 @@
             // remove the id from the unplayed rows list
             m_unplayedRows.removeAll( requestedTrack );
         }
-        else if ( !m_unplayedRows.isEmpty() )
+        else if ( !m_replayedRows.isEmpty() )
+        {
+            requestedTrack = m_replayedRows.takeFirst();
+        }
+        else if (!m_unplayedRows.isEmpty() )
+        {
             requestedTrack = m_unplayedRows.takeFirst();
+        }
 
         if ( requestedTrack == m_model->activeId())
         {
             m_playedRows.prepend( requestedTrack );
-            if ( !m_unplayedRows.isEmpty() )
-                requestedTrack = m_unplayedRows.takeFirst();
+            if ( !m_replayedRows.isEmpty() )
+                requestedTrack = m_replayedRows.takeFirst();
+            else if ( !m_unplayedRows.isEmpty() )
+                 requestedTrack = m_unplayedRows.takeFirst();
         }
 
         m_playedRows.prepend( requestedTrack );
@@ -133,6 +141,7 @@
         if ( m_playedRows.isEmpty() )
         {
             m_playedRows = m_unplayedRows;
+            m_replayedRows.clear();
             m_unplayedRows.clear();
         }
 
@@ -140,12 +149,12 @@
 
         if ( requestedTrack == m_model->activeId())
         {
-            m_unplayedRows.prepend( requestedTrack );
+            m_replayedRows.prepend( requestedTrack );
             if ( !m_playedRows.isEmpty() )
                 requestedTrack = m_playedRows.takeFirst();
         }
 
-        m_unplayedRows.prepend( requestedTrack );
+        m_replayedRows.prepend( requestedTrack );
         return requestedTrack;
     }
 }
@@ -155,26 +164,15 @@
     DEBUG_BLOCK
 
     m_unplayedRows.clear();
+    m_replayedRows.clear();
     m_playedRows.clear();
 
     const int max = m_model->rowCount();
     for ( int i = 0; i < max; i++ )
     {
-        if (( m_model->stateOfRow( i ) == Item::Unplayed ) || ( m_model->stateOfRow( i ) == Item::NewlyAdded ) )
-        {
-            m_unplayedRows.append( m_model->idAt( i ) );
-        }
-        else
-        {
-            m_playedRows.append( m_model->idAt( i ) );
-        }
+        // everything is unplayed upon reset
+        m_unplayedRows.append( m_model->idAt( i ) );
     }
 
     std::random_shuffle( m_unplayedRows.begin(), m_unplayedRows.end() );
-    std::random_shuffle( m_playedRows.begin(), m_playedRows.end() );
-}
-
-void Playlist::RandomTrackNavigator::modelLayoutChanged()
-{
-    reset();
 }
--- amarok-2.2.1/src/playlist/navigators/RandomTrackNavigator.h~	2009-11-11 22:09:13.000000000 +0100
+++ amarok-2.2.1/src/playlist/navigators/RandomTrackNavigator.h	2009-11-20 13:26:06.773339397 +0100
@@ -44,11 +44,10 @@
         void recvRemovedIds( const QList<quint64>& );
         void recvActiveTrackChanged( const quint64 );
 
-        void modelLayoutChanged();
-
     private:
         QList<quint64> m_playedRows;
         QList<quint64> m_unplayedRows;
+        QList<quint64> m_replayedRows;
 
     };
 }
--- a/src/playlist/PlaylistActions.cpp
+++ b/src/playlist/PlaylistActions.cpp
@@ -272,17 +272,8 @@
 
     m_navigator = 0;
 
-    if ( Amarok::repeatEnabled() )
+    if ( Amarok::randomEnabled() ) // random track navigators need to deal with repeat
     {
-        if ( Amarok::repeatTrack() )
-            m_navigator = new RepeatTrackNavigator();
-        else if ( Amarok::repeatAlbum() )
-            m_navigator = new RepeatAlbumNavigator();
-        else
-            m_navigator = new StandardTrackNavigator(); // this navigator handles playlist repeat
-    }
-    else if ( Amarok::randomEnabled() )
-    {
         if ( Amarok::randomTracks() )
         {
             if( Amarok::favorNone() )
@@ -295,12 +286,21 @@
         else
             m_navigator = new StandardTrackNavigator(); // crap -- something went wrong
     }
+    else if ( Amarok::repeatEnabled() )
+    {
+        if ( Amarok::repeatTrack() )
+            m_navigator = new RepeatTrackNavigator();
+        else if ( Amarok::repeatAlbum() )
+            m_navigator = new RepeatAlbumNavigator();
+        else
+            m_navigator = new StandardTrackNavigator(); // this navigator handles playlist repeat
+    }
     else
+    {
         m_navigator = new StandardTrackNavigator();
+    }
 
-
     m_navigator->queueIds( currentQueue );
-
 }
 
 void
