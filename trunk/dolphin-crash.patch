Index: branches/KDE/4.5/kdelibs/kio/kfile/kloadfilemetadatathread.cpp
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kfile/kloadfilemetadatathread.cpp	(revision 1157301)
+++ branches/KDE/4.5/kdelibs/kio/kfile/kloadfilemetadatathread.cpp	(revision 1157302)
@@ -118,8 +118,14 @@
             }
 
             if (variants.isEmpty()) {
-                // the file has not been indexed, query the meta data
+                // The file has not been indexed, query the meta data
                 // directly from the file
+                
+                // TODO: KFileMetaInfo (or one of it's used components) is not reentrant.
+                // As temporary workaround the access is protected by a mutex.
+                static QMutex metaInfoMutex;
+                metaInfoMutex.lock();
+                
                 const QString path = urls.first().toLocalFile();
                 KFileMetaInfo metaInfo(path, QString(), KFileMetaInfo::Fastest);
                 const QHash<QString, KFileMetaInfoItem> metaInfoItems = metaInfo.items();
@@ -128,6 +134,8 @@
                     const Nepomuk::Variant value(metaInfoItem.value());
                     data.insert(uriString, formatValue(value));
                 }
+                
+                metaInfoMutex.unlock();
             }
         }

Index: branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfo_p.h
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfo_p.h	(revision 1158287)
+++ branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfo_p.h	(revision 1158288)
@@ -1,66 +0,0 @@
-/* This file is part of the KDE libraries
-
-   Copyright (c) 2007 Jos van den Oever <jos@vandenoever.info>
-
-   This library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Library General Public
-   License (LGPL) as published by the Free Software Foundation; either
-   version 2 of the License, or (at your option) any later version.
-
-   This library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
-*/
-#ifndef KFILEMETAINFO_P_H
-#define KFILEMETAINFO_P_H
-
-#include "kfilewriteplugin.h"
-#include "predicateproperties.h"
-#include "kfilemetainfoitem.h"
-#include "kfilemetainfo.h"
-#include <QHash>
-
-namespace Strigi {
-    class StreamAnalyzer;
-}
-
-class KFileWriterProvider {
-private:
-    QHash<QString, QHash<QString, KFileWritePlugin*> > loadedWriters;
-public:
-    KFileWritePlugin* loadPlugin(const QString& key);
-    QHash<QString, KFileWritePlugin*> plugins;
-    ~KFileWriterProvider();
-    static KFileWriterProvider* self();
-};
-
-class PredicatePropertyProvider {
-private:
-    class Private;
-    Private* p;
-public:
-    PredicatePropertyProvider();
-    ~PredicatePropertyProvider();
-    static PredicatePropertyProvider* self();
-    Strigi::StreamAnalyzer& indexer();
-    static PredicateProperties getPredicateProperties(const QString& key);
-};
-
-class KFileMetaInfoItemPrivate : public QSharedData {
-public:
-    KFileMetaInfoItemPrivate() : writer(0) {}
-    static const QVariant null;
-    PredicateProperties pp;
-    QVariant value;
-    KFileWritePlugin* writer;
-    bool embedded;
-    bool modified;
-};
-
-#endif
Index: branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfo.cpp
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfo.cpp	(revision 1158287)
+++ branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfo.cpp	(revision 1158288)
@@ -2,6 +2,7 @@
 
    Copyright (c) 2001,2002 Carsten Pfeiffer <pfeiffer@kde.org>
                  2007 Jos van den Oever <jos@vandenoever.info>
+                 2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -18,7 +19,12 @@
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
 */
-#include "kfilemetainfo_p.h"
+
+#include "kfilemetainfo.h"
+#include "kfilemetainfoitem.h"
+#include "kfilemetainfoitem_p.h"
+#include "kfilewriteplugin.h"
+#include "kfilewriteplugin_p.h"
 #include <strigi/bufferedstream.h>
 #include <strigi/analyzerconfiguration.h>
 #include <strigi/indexwriter.h>
@@ -33,56 +39,83 @@
 using namespace std;
 using namespace Strigi;
 
-class KFileMetaInfoGroupPrivate : public QSharedData {
+class KFileMetaInfoGroupPrivate : public QSharedData
+{
 public:
     QString name;
 };
-KFileMetaInfoGroup::~KFileMetaInfoGroup() {
+
+KFileMetaInfoGroup::~KFileMetaInfoGroup()
+{
 }
-KFileMetaInfoGroup::KFileMetaInfoGroup(KFileMetaInfoGroup const& g) {
-    p = g.p;
+
+KFileMetaInfoGroup::KFileMetaInfoGroup ( KFileMetaInfoGroup const& g )
+{
+    d = g.d;
 }
 
-QDataStream& operator >>(QDataStream& s, KFileMetaInfo& ) {
+QDataStream& operator >> ( QDataStream& s, KFileMetaInfo& )
+{
     return s;
 }
-QDataStream& operator <<(QDataStream& s, const KFileMetaInfo&) {
+
+QDataStream& operator << ( QDataStream& s, const KFileMetaInfo& )
+{
     return s;
 }
 
 /**
  * @brief Wrap a QIODevice in a Strigi stream.
  **/
-class QIODeviceInputStream : public BufferedInputStream {
+class QIODeviceInputStream : public BufferedInputStream
+{
 private:
     QIODevice& in;
-    int32_t fillBuffer(char* start, int32_t space);
+    const qint64 m_maxRead;
+    qint64 m_read;
+    int32_t fillBuffer ( char* start, int32_t space );
 public:
-    QIODeviceInputStream(QIODevice& i);
+    QIODeviceInputStream ( QIODevice& i, qint64 max );
 };
 
 int32_t
-QIODeviceInputStream::fillBuffer(char* start, int32_t space) {
-    if (!in.isOpen() || !in.isReadable()) return -1;
+QIODeviceInputStream::fillBuffer ( char* start, int32_t space )
+{
+    if ( !in.isOpen() || !in.isReadable() )
+        return -1;
+
+    // we force a max stream read length according to the config since some Strigi
+    // plugins simply ignore the value which will lead to frozen client apps
+    qint64 max = m_maxRead;
+    if(max < 0)
+        max = space;
+    else
+        max = qMin(qint64(space), qMax(max-m_read,qint64(0)));
+    
     // read into the buffer
-    int32_t nwritten = in.read(start, space);
+    int32_t nwritten = in.read ( start, max );
+    
     // check the file stream status
-    if (nwritten < 0) {
+    if ( nwritten < 0 ) {
         m_error = "Could not read from QIODevice.";
         in.close();
         return -1;
     }
-    if (nwritten == 0 || in.atEnd()) {
+    if ( nwritten == 0 || in.atEnd() ) {
         in.close();
     }
+    m_read += nwritten;
     return nwritten;
 }
 
-QIODeviceInputStream::QIODeviceInputStream(QIODevice &i) :in(i)
+QIODeviceInputStream::QIODeviceInputStream ( QIODevice& i, qint64 max )
+    : in ( i ),
+      m_maxRead(max),
+      m_read(0)
 {
     // determine if we have a character device, which will likely never eof and thereby
     // potentially cause an infinite loop.
-    if(i.isSequential()) {
+    if ( i.isSequential() ) {
         in.close(); // cause fillBuffer to return -1
     }
 }
@@ -91,240 +124,293 @@
  * @brief KMetaInfoWriter handles the data returned by the Strigi analyzers and
  * store it in a KFileMetaInfo.
  **/
-class KMetaInfoWriter : public IndexWriter {
+class KMetaInfoWriter : public IndexWriter
+{
 public:
     // irrelevant for KFileMetaInfo
-    void startAnalysis(const AnalysisResult*) {
+    void startAnalysis ( const AnalysisResult* ) {
     }
+
     // irrelevant for KFileMetaInfo
     // we do not store text as metainfo
-    void addText(const AnalysisResult*, const char* /*s*/, int32_t /*n*/) {
+
+    void addText ( const AnalysisResult*, const char* /*s*/, int32_t /*n*/ ) {
     }
-    void addValue(const AnalysisResult* idx, const RegisteredField* field,
-            const string& value) {
-        if (idx->writerData()) {
-            QString val = QString::fromUtf8(value.c_str(), value.size());
-            addValue(idx, field, val);
+
+    void addValue ( const AnalysisResult* idx, const RegisteredField* field,
+                    const string& value ) {
+        if ( idx->writerData() ) {
+            QString val = QString::fromUtf8 ( value.c_str(), value.size() );
+            addValue ( idx, field, val );
         }
     }
-    void addValue(const AnalysisResult* idx, const RegisteredField* field,
-        const unsigned char* data, uint32_t size) {
-        if (idx->writerData()) {
-            QByteArray d((const char*)data, size);
-            addValue(idx, field, QVariant(d));
+
+    void addValue ( const AnalysisResult* idx, const RegisteredField* field,
+                    const unsigned char* data, uint32_t size ) {
+        if ( idx->writerData() ) {
+            QByteArray d ( ( const char* ) data, size );
+            addValue ( idx, field, QVariant ( d ) );
         }
     }
-    void addValue(const AnalysisResult* idx, const RegisteredField* field,
-            uint32_t value) {
-        if (idx->writerData()) {
-            addValue(idx, field, QVariant((quint32)value));
+
+    void addValue ( const AnalysisResult* idx, const RegisteredField* field,
+                    uint32_t value ) {
+        if ( idx->writerData() ) {
+            addValue ( idx, field, QVariant ( ( quint32 ) value ) );
         }
     }
-    void addValue(const AnalysisResult* idx, const RegisteredField* field,
-            int32_t value) {
-        if (idx->writerData()) {
-            addValue(idx, field, QVariant((qint32)value));
+
+    void addValue ( const AnalysisResult* idx, const RegisteredField* field,
+                    int32_t value ) {
+        if ( idx->writerData() ) {
+            addValue ( idx, field, QVariant ( ( qint32 ) value ) );
         }
     }
-    void addValue(const AnalysisResult* idx, const RegisteredField* field,
-            double value) {
-        if (idx->writerData()) {
-            addValue(idx, field, QVariant(value));
+
+    void addValue ( const AnalysisResult* idx, const RegisteredField* field,
+                    double value ) {
+        if ( idx->writerData() ) {
+            addValue ( idx, field, QVariant ( value ) );
         }
     }
-    void addValue(const AnalysisResult* idx,
-            const RegisteredField* field, const QVariant& value) {
+
+    void addValue ( const AnalysisResult* idx,
+                    const RegisteredField* field, const QVariant& value ) {
         QHash<QString, KFileMetaInfoItem>* info
-            = static_cast<QHash<QString, KFileMetaInfoItem>*>(
-            idx->writerData());
-        if (info) {
-            string name(field->key());
-            QString key = QString::fromUtf8(name.c_str(), name.size());
-            QHash<QString, KFileMetaInfoItem>::iterator i = info->find(key);
-            if (i == info->end()) {
-                // retrieve the info describing this field
-                PredicateProperties pp(key);
-                info->insert(key, KFileMetaInfoItem(pp, value, 0, true));
-            } else {
-                i.value().addValue(value);
+        = static_cast<QHash<QString, KFileMetaInfoItem>*> (
+              idx->writerData() );
+        if ( info ) {
+            string name ( field->key() );
+            QString key = QString::fromUtf8 ( name.c_str(), name.size() );
+            QHash<QString, KFileMetaInfoItem>::iterator i = info->find ( key );
+            if ( i == info->end() ) {
+                info->insert ( key, KFileMetaInfoItem ( key, value, 0, true ) );
             }
+            else {
+                i.value().addValue ( value );
+            }
         }
     }
-    void addValue(const Strigi::AnalysisResult* ar,
-            const RegisteredField* field, const std::string& name,
-            const std::string& value) {
-        if (ar->writerData()) {
+
+    void addValue ( const Strigi::AnalysisResult* ar,
+                    const RegisteredField* field, const std::string& name,
+                    const std::string& value ) {
+        if ( ar->writerData() ) {
             QVariantMap m;
-            m.insert(name.c_str(), value.c_str());
-            addValue(ar, field, m);
+            m.insert ( name.c_str(), value.c_str() );
+            addValue ( ar, field, m );
         }
     }
+
     /* irrelevant for KFileMetaInfo: These triples does not convey information
      * about this file, so we ignore it
      */
-    void addTriplet(const std::string& /*subject*/,
-        const std::string& /*predicate*/, const std::string& /*object*/) {
+    void addTriplet ( const std::string& /*subject*/,
+                      const std::string& /*predicate*/, const std::string& /*object*/ ) {
     }
+
     // irrelevant for KFileMetaInfo
-    void finishAnalysis(const AnalysisResult*) {}
+    void finishAnalysis ( const AnalysisResult* ) {}
+
     // irrelevant for KFileMetaInfo
-    void deleteEntries(const vector<string>&) {}
+    void deleteEntries ( const vector<string>& ) {}
+
     // irrelevant for KFileMetaInfo
     void deleteAllEntries() {}
 };
-class KFileMetaInfoPrivate : public QSharedData {
+
+
+class KFileMetaInfoPrivate : public QSharedData
+{
 public:
     QHash<QString, KFileMetaInfoItem> items;
-    KUrl kurl;
-
-    //Private() :QSharedData() {qDebug() <<"ok: " << this;}
-    void init(QIODevice& stream, const KUrl& url, time_t mtime, KFileMetaInfo::WhatFlags w=KFileMetaInfo::Everything);
-    void initWriters(const KUrl& /*file*/);
-    void operator=(const KFileMetaInfoPrivate& k) {
+    KUrl m_url;
+    
+    void init ( QIODevice& stream, const KUrl& url, time_t mtime, KFileMetaInfo::WhatFlags w = KFileMetaInfo::Everything );
+    void initWriters ( const KUrl& /*file*/ );
+    void operator= ( const KFileMetaInfoPrivate& k ) {
         items = k.items;
-        kurl = k.kurl;
     }
 };
 static const KFileMetaInfoItem nullitem;
 
-//used to override 64k limit of PredicatePropertyProvider's indexer.
-//this is important for getting gettext po files statistics, for example
-class ComprehensiveAnalysisConfiguration : public Strigi::AnalyzerConfiguration {
-     int64_t maximalStreamReadLength(const Strigi::AnalysisResult& ar) {return (ar.depth() == 0) ?-1:0;} 
+class KFileMetaInfoAnalysisConfiguration : public Strigi::AnalyzerConfiguration
+{
+public:
+    KFileMetaInfoAnalysisConfiguration( KFileMetaInfo::WhatFlags indexDetail )
+    : m_indexDetail(indexDetail) {
+    }
+    
+    int64_t maximalStreamReadLength ( const Strigi::AnalysisResult& ar ) {
+        if(ar.depth() > 0)
+            return 0; // ignore all data that has a depth > 0, i.e. files in archives
+        else if(m_indexDetail == KFileMetaInfo::Everything)
+            return -1;
+        else 
+            return 65536; // do not read the whole file - this is used for on-the-fly analysis
+    }
+
+private:
+    KFileMetaInfo::WhatFlags m_indexDetail;
 };
 
-//const KFileMetaInfoItem KFileMetaInfoPrivate::null;
-void
-KFileMetaInfoPrivate::init(QIODevice& stream, const KUrl& url, time_t mtime, KFileMetaInfo::WhatFlags w) {
+void KFileMetaInfoPrivate::init ( QIODevice& stream, const KUrl& url, time_t mtime, KFileMetaInfo::WhatFlags w )
+{
+    m_url = url;
+    
     // get data from Strigi
-    kurl = url;
-    ComprehensiveAnalysisConfiguration c;
-    StreamAnalyzer comprehensiveIndexer(c);
-    StreamAnalyzer& indexer = (w==KFileMetaInfo::Everything)?comprehensiveIndexer:PredicatePropertyProvider::self()->indexer();
+    KFileMetaInfoAnalysisConfiguration c( w );
+    StreamAnalyzer indexer ( c );
     KMetaInfoWriter writer;
-    QIODeviceInputStream strigiStream(stream);
-    kDebug(7033) << url;
-    AnalysisResult idx(url.toLocalFile().toUtf8().constData(), mtime, writer, indexer);
+    kDebug ( 7033 ) << url;
+    AnalysisResult idx ( url.toLocalFile().toUtf8().constData(), mtime, writer, indexer );
+    idx.setWriterData ( &items );
 
-    idx.setWriterData(&items);
-    indexer.analyze(idx, &strigiStream);
+    QIODeviceInputStream strigiStream ( stream, c.maximalStreamReadLength(idx) );
+    indexer.analyze ( idx, &strigiStream );
 
     // TODO: get data from Nepomuk
 }
-void
-KFileMetaInfoPrivate::initWriters(const KUrl& file) {
+
+void KFileMetaInfoPrivate::initWriters ( const KUrl& file )
+{
     QStringList mimetypes;
     QHash<QString, KFileMetaInfoItem>::iterator i;
-    for (i = items.begin(); i != items.end(); ++i) {
+    for ( i = items.begin(); i != items.end(); ++i ) {
         KFileWritePlugin *w =
-            KFileWriterProvider::self()->loadPlugin(i.key());
-        if (w && w->canWrite(file, i.key())) {
-            i.value().p->writer = w;
+            KFileWriterProvider::self()->loadPlugin ( i.key() );
+        if ( w && w->canWrite ( file, i.key() ) ) {
+            i.value().d->writer = w;
         }
     }
 }
-KFileMetaInfo::KFileMetaInfo(const QString& path, const QString& /*mimetype*/,
-                             KFileMetaInfo::WhatFlags w)
-    : p(new KFileMetaInfoPrivate())
+
+KFileMetaInfo::KFileMetaInfo ( const QString& path, const QString& /*mimetype*/,
+                               KFileMetaInfo::WhatFlags w )
+        : d ( new KFileMetaInfoPrivate() )
 {
-    QFileInfo fileinfo(path);
-    QFile file(path);
+    QFileInfo fileinfo ( path );
+    QFile file ( path );
     // only open the file if it is a filetype Qt understands
     // if e.g. the path points to a pipe, it is not opened
-    if ((fileinfo.isFile() || fileinfo.isDir() || fileinfo.isSymLink())
-            && file.open(QIODevice::ReadOnly)) {
-        KUrl u(path);
-        p->init(file, u, fileinfo.lastModified().toTime_t(), w);
-        if (fileinfo.isWritable()) {
-            p->initWriters(u);
+    if ( ( fileinfo.isFile() || fileinfo.isDir() || fileinfo.isSymLink() )
+            && file.open ( QIODevice::ReadOnly ) ) {
+        KUrl u ( path );
+        d->init ( file, u, fileinfo.lastModified().toTime_t(), w );
+        if ( fileinfo.isWritable() ) {
+            d->initWriters ( u );
         }
     }
 }
-KFileMetaInfo::KFileMetaInfo(const KUrl& url)
-    : p(new KFileMetaInfoPrivate())
+
+KFileMetaInfo::KFileMetaInfo ( const KUrl& url )
+        : d ( new KFileMetaInfoPrivate() )
 {
-    QFileInfo fileinfo(url.toLocalFile());
-    QFile file(url.toLocalFile());
-    if (file.open(QIODevice::ReadOnly)) {
-        p->init(file, url, fileinfo.lastModified().toTime_t());
-        if (fileinfo.isWritable()) {
-            p->initWriters(url);
+    QFileInfo fileinfo ( url.toLocalFile() );
+    QFile file ( url.toLocalFile() );
+    if ( file.open ( QIODevice::ReadOnly ) ) {
+        d->init ( file, url, fileinfo.lastModified().toTime_t() );
+        if ( fileinfo.isWritable() ) {
+            d->initWriters ( url );
         }
     }
 }
-KFileMetaInfo::KFileMetaInfo() :p(new KFileMetaInfoPrivate()) {
+
+KFileMetaInfo::KFileMetaInfo() : d ( new KFileMetaInfoPrivate() )
+{
 }
-KFileMetaInfo::KFileMetaInfo(const KFileMetaInfo& k) :p(k.p) {
+
+KFileMetaInfo::KFileMetaInfo ( const KFileMetaInfo& k ) : d ( k.d )
+{
 }
-const KFileMetaInfo&
-KFileMetaInfo::operator=(KFileMetaInfo const& kfmi) {
-    p = kfmi.p;
+
+const KFileMetaInfo& KFileMetaInfo::operator= ( KFileMetaInfo const & kfmi )
+{
+    d = kfmi.d;
     return kfmi;
 }
-KFileMetaInfo::~KFileMetaInfo() {
+
+KFileMetaInfo::~KFileMetaInfo()
+{
 }
-bool
-KFileMetaInfo::applyChanges() {
 
+bool KFileMetaInfo::applyChanges()
+{
     // go through all editable fields and group them by writer
     QHash<KFileWritePlugin*, QVariantMap> data;
     QHash<QString, KFileMetaInfoItem>::const_iterator i;
-    for (i = p->items.constBegin(); i != p->items.constEnd(); ++i) {
-        if (i.value().isModified() && i.value().p->writer) {
-            data[i.value().p->writer][i.key()] = i.value().value();
+    for ( i = d->items.constBegin(); i != d->items.constEnd(); ++i ) {
+        if ( i.value().isModified() && i.value().d->writer ) {
+            data[i.value().d->writer][i.key() ] = i.value().value();
         }
     }
 
     // call the writers on the data they can write
     bool ok = true;
     QHash<KFileWritePlugin*, QVariantMap>::const_iterator j;
-    for (j = data.constBegin(); j != data.constEnd(); ++j) {
-        ok &= j.key()->write(p->kurl, j.value());
+    for ( j = data.constBegin(); j != data.constEnd(); ++j ) {
+        ok &= j.key()->write ( d->m_url, j.value() );
     }
     return ok;
 }
-const KUrl&
-KFileMetaInfo::url() const {
-    return p->kurl;
+
+const KUrl& KFileMetaInfo::url() const
+{
+    return d->m_url;
 }
-const QHash<QString, KFileMetaInfoItem>&
-KFileMetaInfo::items() const {
-    return p->items;
+
+const QHash<QString, KFileMetaInfoItem>& KFileMetaInfo::items() const
+{
+    return d->items;
 }
-const KFileMetaInfoItem&
-KFileMetaInfo::item(const QString& key) const {
-    QHash<QString, KFileMetaInfoItem>::const_iterator i = p->items.constFind(key);
-    return (i == p->items.constEnd()) ?nullitem :i.value();
+
+const KFileMetaInfoItem& KFileMetaInfo::item ( const QString& key ) const
+{
+    QHash<QString, KFileMetaInfoItem>::const_iterator i = d->items.constFind ( key );
+    return ( i == d->items.constEnd() ) ? nullitem : i.value();
 }
-QStringList
-KFileMetaInfo::keys() const {
-    return p->items.keys();
+
+QStringList KFileMetaInfo::keys() const
+{
+    return d->items.keys();
 }
-KFileMetaInfoItem&
-KFileMetaInfo::item(const QString& key) {
-    return p->items[key];
+
+KFileMetaInfoItem& KFileMetaInfo::item ( const QString& key )
+{
+    return d->items[key];
 }
-bool
-KFileMetaInfo::isValid() const {
-    return !p->kurl.isEmpty();
+
+bool KFileMetaInfo::isValid() const
+{
+    return !d->m_url.isEmpty();
 }
-QStringList KFileMetaInfo::preferredKeys() const { return QStringList(); }
-QStringList KFileMetaInfo::supportedKeys() const { return QStringList(); }
 
-KFileMetaInfoGroupList
-KFileMetaInfo::preferredGroups() const {
+QStringList KFileMetaInfo::preferredKeys() const
+{
+    return QStringList();
+}
+
+QStringList KFileMetaInfo::supportedKeys() const
+{
+    return QStringList();
+}
+
+KFileMetaInfoGroupList KFileMetaInfo::preferredGroups() const
+{
     return KFileMetaInfoGroupList();
 }
-KFileMetaInfoGroupList
-KFileMetaInfo::supportedGroups() const {
+
+KFileMetaInfoGroupList KFileMetaInfo::supportedGroups() const
+{
     return KFileMetaInfoGroupList();
 }
-KFileMetaInfoItemList
-KFileMetaInfoGroup::items() const {
+
+KFileMetaInfoItemList KFileMetaInfoGroup::items() const
+{
     return KFileMetaInfoItemList();
 }
-const QString&
-KFileMetaInfoGroup::name() const {
-    return p->name;
+
+const QString& KFileMetaInfoGroup::name() const
+{
+    return d->name;
 }
-
Index: branches/KDE/4.5/kdelibs/kio/kio/predicateproperties.h
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/predicateproperties.h	(revision 1158287)
+++ branches/KDE/4.5/kdelibs/kio/kio/predicateproperties.h	(revision 1158288)
@@ -30,8 +30,10 @@
  * It is identified by URI and it defines the type of the relationship.
  * For file metadata, a predicate can be seen as a fieldname.
  * It has a data type, a description, a short id, a cardinality
+ *
+ * @deprecated use Nepomuk::Types::Property instead
  **/
-class KIO_EXPORT PredicateProperties {
+class KDE_DEPRECATED KIO_EXPORT PredicateProperties {
 friend class PredicatePropertyProvider;
 public:
     PredicateProperties(const QString& predicate = QString());
@@ -96,7 +98,7 @@
     bool isValid() const;
 private:
     class Private;
-    QSharedDataPointer<Private> p;
+    QSharedDataPointer<Private> d;
 };
 
 #endif
Index: branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfoitem.cpp
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfoitem.cpp	(revision 1158287)
+++ branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfoitem.cpp	(revision 1158288)
@@ -1,7 +1,8 @@
 /* This file is part of the KDE libraries
 
    Copyright (c) 2007 Jos van den Oever <jos@vandenoever.info>
-
+                 2010 Sebastian Trueg <trueg@kde.org>
+                 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License (LGPL) as published by the Free Software Foundation; either
@@ -18,64 +19,63 @@
    Boston, MA 02110-1301, USA.
 */
 
-#include "kfilemetainfo_p.h"
-#include <QDebug>
+#include "kfilemetainfoitem.h"
+#include "kfilemetainfoitem_p.h"
 
-const QVariant KFileMetaInfoItemPrivate::null;
 
-KFileMetaInfoItem::KFileMetaInfoItem() :p(new KFileMetaInfoItemPrivate()) {
+KFileMetaInfoItem::KFileMetaInfoItem() : d(new KFileMetaInfoItemPrivate()) {
 }
 
-KFileMetaInfoItem::KFileMetaInfoItem(const KFileMetaInfoItem& item) :p(item.p) {
+KFileMetaInfoItem::KFileMetaInfoItem(const KFileMetaInfoItem& item) : d(item.d) {
 }
-KFileMetaInfoItem::KFileMetaInfoItem(const PredicateProperties& pp,
-            const QVariant& v, KFileWritePlugin* w, bool e)
-        :p(new KFileMetaInfoItemPrivate()) {
-    p->pp = pp;
-    p->value = v;
-    p->writer = w;
-    p->embedded = e;
-    p->modified = false;
+KFileMetaInfoItem::KFileMetaInfoItem(const QString& pp,
+                                     const QVariant& v, KFileWritePlugin* w, bool e)
+    : d(new KFileMetaInfoItemPrivate()) {
+    d->pp = pp;
+    d->value = v;
+    d->writer = w;
+    d->embedded = e;
+    d->modified = false;
 }
 KFileMetaInfoItem::~KFileMetaInfoItem() {
 }
 const KFileMetaInfoItem&
 KFileMetaInfoItem::operator=(const KFileMetaInfoItem& item) {
-    p = item.p;
+    d = item.d;
     return item;
 }
 const QString&
 KFileMetaInfoItem::name() const {
-    return p->pp.name();
+    return d->pp.name();
 }
 const QVariant&
 KFileMetaInfoItem::value() const {
-    return p->value;
+    return d->value;
 }
 bool
 KFileMetaInfoItem::setValue(const QVariant& value) {
-    bool changed = p->value != value;
-    p->value = value;
-    p->modified |= changed;
+    bool changed = d->value != value;
+    d->value = value;
+    d->modified |= changed;
     return changed;
 }
 bool
 KFileMetaInfoItem::addValue(const QVariant& value) {
-    QVariant& v = p->value;
+    QVariant& v = d->value;
     if (v.type() == QVariant::List) {
         QVariantList vl = v.toList();
         vl.append(value);
-        p->value = vl;
+        d->value = vl;
     }
     return false;
 }
 bool
 KFileMetaInfoItem::isModified() const {
-    return p->modified;
+    return d->modified;
 }
 bool
 KFileMetaInfoItem::isRemoved() const {
-    return p->modified && p->value.isNull();
+    return d->modified && d->value.isNull();
 }
 bool
 KFileMetaInfoItem::isValid() const {
@@ -88,11 +88,11 @@
 }
 const PredicateProperties&
 KFileMetaInfoItem::properties() const {
-    return p->pp;
+    return d->pp;
 }
 bool
 KFileMetaInfoItem::isEditable() const {
-    return p->writer != NULL;
+    return d->writer != 0;
 }
 QString
 KFileMetaInfoItem::suffix() const {
Index: branches/KDE/4.5/kdelibs/kio/kio/kfilewriteplugin.cpp
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/kfilewriteplugin.cpp	(revision 1158287)
+++ branches/KDE/4.5/kdelibs/kio/kio/kfilewriteplugin.cpp	(revision 1158288)
@@ -17,7 +17,9 @@
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
 */
-#include "kfilemetainfo_p.h"
+
+#include "kfilewriteplugin.h"
+#include "kfilewriteplugin_p.h"
 #include "kglobal.h"
 #include "kservicetypetrader.h"
 #include <QHash>
Index: branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfo.h
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfo.h	(revision 1158287)
+++ branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfo.h	(revision 1158288)
@@ -40,7 +40,7 @@
     const QString& name() const;
     const QStringList& keys() const;
 private:
-    QSharedDataPointer<KFileMetaInfoGroupPrivate> p;
+    QSharedDataPointer<KFileMetaInfoGroupPrivate> d;
 };
 
 typedef QList<KFileMetaInfoGroup> KFileMetaInfoGroupList;
@@ -153,7 +153,7 @@
     const KUrl& url() const;
 
 private:
-    QSharedDataPointer<KFileMetaInfoPrivate> p;
+    QSharedDataPointer<KFileMetaInfoPrivate> d;
 };
 
 Q_DECLARE_OPERATORS_FOR_FLAGS(KFileMetaInfo::WhatFlags)
Index: branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfoitem_p.h
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfoitem_p.h	(revision 0)
+++ branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfoitem_p.h	(revision 1158288)
@@ -0,0 +1,43 @@
+/* This file is part of the KDE libraries
+
+   Copyright (c) 2007 Jos van den Oever <jos@vandenoever.info>
+                 2010 Sebastian Trueg <trueg@kde.org>
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License (LGPL) as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+#ifndef KFILEMETAINFOITEM_P_H
+#define KFILEMETAINFOITEM_P_H
+
+#include "kurl.h"
+#include "predicateproperties.h"
+
+#include <QtCore/QHash>
+#include <QtCore/QSharedData>
+
+class KFileWritePlugin;
+
+class KFileMetaInfoItemPrivate : public QSharedData {
+public:
+    KFileMetaInfoItemPrivate() : writer(0) {}
+    PredicateProperties pp;
+    KUrl propertyUri;
+    QVariant value;
+    KFileWritePlugin* writer;
+    bool embedded;
+    bool modified;
+};
+
+#endif
Index: branches/KDE/4.5/kdelibs/kio/kio/kfilewriteplugin_p.h
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/kfilewriteplugin_p.h	(revision 0)
+++ branches/KDE/4.5/kdelibs/kio/kio/kfilewriteplugin_p.h	(revision 1158288)
@@ -0,0 +1,39 @@
+/* This file is part of the KDE libraries
+ * 
+ *   Copyright (c) 2007 Jos van den Oever <jos@vandenoever.info>
+ *                 2010 Sebastian Trueg <trueg@kde.org>
+ * 
+ *   This library is free software; you can redistribute it and/or
+ *   modify it under the terms of the GNU Library General Public
+ *   License (LGPL) as published by the Free Software Foundation; either
+ *   version 2 of the License, or (at your option) any later version.
+ * 
+ *   This library is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *   Library General Public License for more details.
+ * 
+ *   You should have received a copy of the GNU Library General Public License
+ *   along with this library; see the file COPYING.LIB.  If not, write to
+ *   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *   Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KFILEWRITE_PLUGIN_P_H
+#define KFILEWRITE_PLUGIN_P_H
+
+#include <QtCore/QHash>
+
+class KFileWritePlugin;
+
+class KFileWriterProvider {
+private:
+    QHash<QString, QHash<QString, KFileWritePlugin*> > loadedWriters;
+public:
+    KFileWritePlugin* loadPlugin(const QString& key);
+    QHash<QString, KFileWritePlugin*> plugins;
+    ~KFileWriterProvider();
+    static KFileWriterProvider* self();
+};
+
+#endif
Index: branches/KDE/4.5/kdelibs/kio/kio/predicateproperties.cpp
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/predicateproperties.cpp	(revision 1158287)
+++ branches/KDE/4.5/kdelibs/kio/kio/predicateproperties.cpp	(revision 1158288)
@@ -17,12 +17,15 @@
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
 */
-#include "kfilemetainfo_p.h"
-#include "kglobal.h"
+
+#include "predicateproperties.h"
+
 #include <strigi/streamanalyzer.h>
 #include <strigi/analysisresult.h>
 #include <strigi/analyzerconfiguration.h>
-#include <QDebug>
+
+#include <QtCore/QStringList>
+
 using namespace Strigi;
 using namespace std;
 
@@ -43,24 +46,24 @@
 
 PredicateProperties::PredicateProperties(const QString& predicate) {
     if (!predicate.isEmpty()) {
-        p = new Private();
-        p->key = predicate;
+        d = new Private();
+        d->key = predicate;
     }
 }
 PredicateProperties::PredicateProperties(const PredicateProperties& pp)
-        :p(pp.p) {
+        : d(pp.d) {
 }
 PredicateProperties::~PredicateProperties() {
 }
 const PredicateProperties&
 PredicateProperties::operator=(const PredicateProperties& pp) {
-    p = pp.p;
+    d = pp.d;
     return pp;
 }
 const QString&
 PredicateProperties::name() const {
-    if (p == 0) return Private::nullString;
-    return (p->name.isEmpty()) ?p->key :p->name;
+    if ( d == 0) return Private::nullString;
+    return ( d->name.isEmpty()) ? d->key : d->name;
 }
 
 const QStringList&
@@ -80,11 +83,11 @@
 
 uint
 PredicateProperties::attributes() const {
-    return (p) ?p->attributes :0;
+    return ( d) ? d->attributes :0;
 }
 QVariant::Type
 PredicateProperties::type() const {
-    return (p) ?p->type :QVariant::Invalid;
+    return ( d) ? d->type :QVariant::Invalid;
 }
 QValidator*
 PredicateProperties::createValidator() const {
@@ -92,52 +95,9 @@
 }
 const PredicateProperties&
 PredicateProperties::parent() const {
-    return (p) ?p->parent :Private::nullPP;
+    return ( d) ? d->parent :Private::nullPP;
 }
 bool
 PredicateProperties::isValid() const {
-    return p;
+    return d;
 }
-
-/// PredicatePropertyProvider
-
-K_GLOBAL_STATIC(PredicatePropertyProvider, staticPredicatePropertyProvider)
-
-PredicatePropertyProvider*
-PredicatePropertyProvider::self() {
-    return staticPredicatePropertyProvider;
-}
-PredicateProperties
-PredicatePropertyProvider::getPredicateProperties(const QString& key) {
-    PredicateProperties p(key);
-    return p;
-}
-
-class ShallowAnalysisConfiguration : public Strigi::AnalyzerConfiguration { 
-     /** Limit the amount of data we will read from a stream. 
-       * This is a suggestion to analyzers which they should follow. 
-       * Only index real files. We do not look at subfiles. 
-       * This setting is needed because by default all subfiles are examined. 
-       **/ 
-     int64_t maximalStreamReadLength(const Strigi::AnalysisResult& ar) { 
-         // 64k should be enough 
-         return (ar.depth() == 0) ?65536 :0; 
-     } 
-}; 
-
-class PredicatePropertyProvider::Private {
-public:
-    ShallowAnalysisConfiguration config;
-    StreamAnalyzer indexer;
-    Private() :indexer(config) {}
-};
-PredicatePropertyProvider::PredicatePropertyProvider() {
-    p = new PredicatePropertyProvider::Private();
-}
-PredicatePropertyProvider::~PredicatePropertyProvider() {
-    delete p;
-}
-StreamAnalyzer&
-PredicatePropertyProvider::indexer() {
-    return p->indexer;
-}
Index: branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfoitem.h
===================================================================
--- branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfoitem.h	(revision 1158287)
+++ branches/KDE/4.5/kdelibs/kio/kio/kfilemetainfoitem.h	(revision 1158288)
@@ -2,6 +2,7 @@
 
    Copyright (c) 2001,2002 Carsten Pfeiffer <pfeiffer@kde.org>
                  2007 Jos van den Oever <jos@vandenoever.info>
+                 2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -27,6 +28,7 @@
 class KFileWritePlugin;
 class QVariant;
 class PredicateProperties;
+class KUrl;
 
 class KFileMetaInfoItemPrivate;
 class KIO_EXPORT KFileMetaInfoItem {
@@ -55,7 +57,7 @@
      **/
     bool isEditable() const;
     /**
-     * @brief Has this value been removed, e.g with setValue(QVarian())
+     * @brief Has this value been removed, e.g with setValue(QVariant())
      **/
     bool isRemoved() const;
     /**
@@ -84,11 +86,12 @@
     bool isValid() const;
     /**
      * @brief Retrieve the properties of this field type.
+     *
+     * @deprecated
      **/
-    const PredicateProperties& properties() const;
+    KDE_DEPRECATED const PredicateProperties& properties() const;
     /**
      * Localized name of the predicate.
-     * Convenience function for properties().name();
      **/
     const QString& name() const;
     /**
@@ -106,9 +109,9 @@
      */
     QString prefix() const;
 private:
-    QSharedDataPointer<KFileMetaInfoItemPrivate> p;
+    QSharedDataPointer<KFileMetaInfoItemPrivate> d;
 
-    KFileMetaInfoItem(const PredicateProperties& p,
+    KFileMetaInfoItem(const QString& p,
         const QVariant& v, KFileWritePlugin* w, bool e);
 };
 
